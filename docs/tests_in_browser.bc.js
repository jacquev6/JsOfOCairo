//# 1 "tests_in_browser.bc.runtime.js"
// Generated by js_of_ocaml 3.2.1
(function(a){"use strict";var
bP=" : flags Open_text and Open_binary are not compatible",K=254,f=255,cb=224,ca="}",cp="Invalid_argument",Z=65536,b4=",",aB='"',e=16777215,b$=1027,a6=16711680,a7=250,am=1024,aD=65599,b3="jsError",b2=864e5,co=512,b1="End_of_file",ae=65280,bO="lexing: empty token",b0="Failure",b_="Marshal.data_size: bad object",bZ=",\n",a2="\n",a9="]",bN="Stack_overflow",b="",p=128,a5="^",cn="0000",bY="Bigarray.blit: dimension mismatch",cm=1026,x="0",w=248,bM="Not_found",cj="Sys_blocked_io",ck="fd ",cl="p",F=1023,b9="Match_failure",aZ=2224400062,bL="static/",bX="Division_by_zero",al=1e3,a1=1900,bW="Sys_error",aC=".",ak="+",o=65535,ci="Marshal.to_buffer: buffer overflow",bU=1073741823,bV=": ",ch=251,bT=57343,a4=127,O="int_of_string",bS="Illegal seek",J=" ",a8="e",bI="Undefined_recursive_module",bJ=0.001,bK="\\u",b8=")",cg=" : flags Open_rdonly and Open_wronly are not compatible",_=256,cf="([^/]*)",aA=":",P="-",n=4294967296,b7="nan",a0=240,bR=2048,b6=56320,ce=" : file already exists",bH=32752,b5="Assert_failure",t="/",bQ="0x",cd="Out_of_memory",z=32768,cc="index out of bounds",a3="null";"use strict";var
br=0;function
aa(a){return a.l}function
k(a,b){switch(a.t&6){default:if(b>=a.c.length)return 0;case
0:return a.c.charCodeAt(b);case
4:return a.c[b]}}function
cL(a,b){var
c=a[1]+b[1],d=a[2]+b[2]+(c>>24),g=a[3]+b[3]+(d>>24);return[f,c&e,d&e,g&o]}var
ah=Math.pow(2,-24);function
cQ(a,b){var
c=a[1]*b[1],d=(c*ah|0)+a[2]*b[1]+a[1]*b[2],g=(d*ah|0)+a[3]*b[1]+a[2]*b[2]+a[1]*b[3];return[f,c&e,d&e,g&o]}function
Q(a){var
b=-a[1],c=-a[2]+(b>>24),d=-a[3]+(c>>24);return[f,b&e,c&e,d&o]}function
ar(a){return[f,a&e,a>>24&e,a>>31&o]}function
au(d){var
c=d.length,b=new
Array(c);for(var
a=0;a<c;a++)b[a]=d[a];return b}function
cR(a,b){var
c=a[1]-b[1],d=a[2]-b[2]+(c>>24),g=a[3]-b[3]+(d>>24);return[f,c&e,d&e,g&o]}function
aL(a,b){if(a[3]>b[3])return 1;if(a[3]<b[3])return-1;if(a[2]>b[2])return 1;if(a[2]<b[2])return-1;if(a[1]>b[1])return 1;if(a[1]<b[1])return-1;return 0}function
bk(a){a[3]=a[3]<<1|a[2]>>23;a[2]=(a[2]<<1|a[1]>>23)&e;a[1]=a[1]<<1&e}function
cP(a){a[1]=(a[1]>>>1|a[2]<<23)&e;a[2]=(a[2]>>>1|a[3]<<23)&e;a[3]=a[3]>>>1}function
as(e,g){var
c=0,b=au(e),a=au(g),d=[f,0,0,0];while(aL(b,a)>0){c++;bk(a)}while(c>=0){c--;bk(d);if(aL(b,a)>=0){d[1]++;b=cR(b,a)}cP(a)}return[0,d,b]}function
aM(a,b){return aL(a,b)<0}function
bs(c){var
a=0,e=aa(c),b=10,d=1;if(e>0)switch(k(c,a)){case
45:a++;d=-1;break;case
43:a++;d=1;break}if(a+1<e&&k(c,a)==48)switch(k(c,a+1)){case
120:case
88:b=16;a+=2;break;case
111:case
79:b=8;a+=2;break;case
98:case
66:b=2;a+=2;break}return[a,d,b]}function
bt(b,a){throw[0,b,a]}function
ac(c,a){if(a.repeat)return a.repeat(c);var
d=b,e=0;if(c==0)return d;for(;;){if(c&1)d+=a;c>>=1;if(c==0)return d;a+=a;e++;if(e==9)a.slice(0,1)}}function
aj(d,e,c){var
b=new
Array(c);for(var
a=0;a<c;a++)b[a]=d[e+a];return b}function
aX(c,d,a){var
e=String.fromCharCode;if(d==0&&a<=4096&&a==c.length)return e.apply(null,c);var
f=b;for(;0<a;d+=am,a-=am)f+=e.apply(null,aj(c,d,Math.min(a,am)));return f}function
l(a){if(a.t==2)a.c+=ac(a.l-a.c.length,"\0");else
a.c=aX(a.c,0,a.c.length);a.t=0}function
bm(a){if(a.length<24){for(var
b=0;b<a.length;b++)if(a.charCodeAt(b)>a4)return false;return true}else
return!/[^\x00-\x7f]/.test(a)}function
c8(f){for(var
k=b,d=b,h,g,i,a,c=0,j=f.length;c<j;c++){g=f.charCodeAt(c);if(g<p){for(var
e=c+1;e<j&&(g=f.charCodeAt(e))<p;e++);if(e-c>co){d.substr(0,1);k+=d;d=b;k+=f.slice(c,e)}else
d+=f.slice(c,e);if(e==j)break;c=e}a=1;if(++c<j&&((i=f.charCodeAt(c))&-64)==p){h=i+(g<<6);if(g<cb){a=h-12416;if(a<p)a=1}else{a=2;if(++c<j&&((i=f.charCodeAt(c))&-64)==p){h=i+(h<<6);if(g<a0){a=h-925824;if(a<bR||a>=55295&&a<57344)a=2}else{a=3;if(++c<j&&((i=f.charCodeAt(c))&-64)==p&&g<245){a=i-63447168+(h<<6);if(a<Z||a>1114111)a=3}}}}}if(a<4){c-=a;d+="\ufffd"}else
if(a>o)d+=String.fromCharCode(55232+(a>>10),b6+(a&F));else
d+=String.fromCharCode(a);if(d.length>am){d.substr(0,1);k+=d;d=b}}return k+d}function
c6(a){switch(a.t){case
9:return a.c;default:l(a);case
0:if(bm(a.c)){a.t=9;return a.c}a.t=8;case
8:return c8(a.c)}}function
q(c,a,b){this.t=c;this.c=a;this.l=b}q.prototype.toString=function(){return c6(this)};function
h(a){return new
q(0,a,a.length)}function
aW(b,a){bt(b,h(a))}var
g=[0];function
d(a){aW(g.Failure,a)}function
av(a){if(a>=48&&a<=57)return a-48;if(a>=65&&a<=90)return a-55;if(a>=97&&a<=122)return a-87;return-1}function
ft(i){var
h=bs(i),g=h[0],m=h[1],j=h[2],l=ar(j),n=as([f,e,268435455,o],l)[1],c=k(i,g),a=av(c);if(a<0||a>=j)d(O);var
b=ar(a);for(;;){g++;c=k(i,g);if(c==95)continue;a=av(c);if(a<0||a>=j)break;if(aM(n,b))d(O);a=ar(a);b=cL(cQ(l,b),a);if(aM(b,a))d(O)}if(g!=aa(i))d(O);if(h[2]==10&&aM([f,0,0,z],b))d(O);if(m<0)b=Q(b);return b}function
aI(a){return(a[3]|a[2]|a[1])==0}function
cS(a){return a[1]|a[2]<<24}function
cO(a){return a[3]<<16<0}function
R(a){if((a.t&6)!=0)l(a);return a.c}function
i(a){aW(g.Invalid_argument,a)}function
aT(d){d=R(d);var
e=d.length;if(e>31)i("format_int: format too long");var
a={justify:ak,signstyle:P,filler:J,alternate:false,base:0,signedconv:false,width:0,uppercase:false,sign:1,prec:-1,conv:"f"};for(var
c=0;c<e;c++){var
b=d.charAt(c);switch(b){case"-":a.justify=P;break;case"+":case" ":a.signstyle=b;break;case"0":a.filler=x;break;case"#":a.alternate=true;break;case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":a.width=0;while(b=d.charCodeAt(c)-48,b>=0&&b<=9){a.width=a.width*10+b;c++}c--;break;case".":a.prec=0;c++;while(b=d.charCodeAt(c)-48,b>=0&&b<=9){a.prec=a.prec*10+b;c++}c--;case"d":case"i":a.signedconv=true;case"u":a.base=10;break;case"x":a.base=16;break;case"X":a.base=16;a.uppercase=true;break;case"o":a.base=8;break;case"e":case"f":case"g":a.signedconv=true;a.conv=b;break;case"E":case"F":case"G":a.signedconv=true;a.uppercase=true;a.conv=b.toLowerCase();break}}return a}function
aG(a,f){if(a.uppercase)f=f.toUpperCase();var
e=f.length;if(a.signedconv&&(a.sign<0||a.signstyle!=P))e++;if(a.alternate){if(a.base==8)e+=1;if(a.base==16)e+=2}var
c=b;if(a.justify==ak&&a.filler==J)for(var
d=e;d<a.width;d++)c+=J;if(a.signedconv)if(a.sign<0)c+=P;else
if(a.signstyle!=P)c+=a.signstyle;if(a.alternate&&a.base==8)c+=x;if(a.alternate&&a.base==16)c+=bQ;if(a.justify==ak&&a.filler==x)for(var
d=e;d<a.width;d++)c+=x;c+=f;if(a.justify==P)for(var
d=e;d<a.width;d++)c+=J;return h(c)}function
fp(h,d){var
a=aT(h);if(a.signedconv&&cO(d)){a.sign=-1;d=Q(d)}var
c=b,i=ar(a.base),g="0123456789abcdef";do{var
f=as(d,i);d=f[1];c=g.charAt(cS(f[2]))+c}while(!aI(d));if(a.prec>=0){a.filler=J;var
e=a.prec-c.length;if(e>0)c=ac(e,x)+c}return aG(a,c)}function
eK(a){var
c=Math.exp(a),b=c-1;return Math.abs(a)>1?b:b==0?a:a*b/Math.log(c)}if(a.process&&a.process.cwd)var
X=a.process.cwd().replace(/\\/g,t);else
var
X="/static";if(X.slice(-1)!==t)X+=t;function
aO(a){a=a
instanceof
q?a.toString():a;if(a.charCodeAt(0)!=47)a=X+a;var
e=a.split(t),c=[];for(var
d=0;d<e.length;d++)switch(e[d]){case"..":if(c.length>1)c.pop();break;case".":break;case"":if(c.length==0)c.push(b);break;default:c.push(e[d]);break}c.orig=a;return c}function
s(a){aW(g.Sys_error,a)}function
aw(a){a=a
instanceof
q?a.toString():a;s(a+": No such file or directory")}function
ad(a){return new
q(4,a,a.length)}function
v(){i(cc)}function
ag(a,b){switch(a.t&6){default:if(b>=a.c.length)return 0;case
0:return a.c.charCodeAt(b);case
4:return a.c[b]}}function
be(b,a){if(a>>>0>=b.l)v();return ag(b,a)}function
B(a){if(a<0)i("Bytes.create");return new
q(a?2:9,b,a)}function
aQ(a){return a.l}function
ap(c){if(a.Uint8Array)var
d=new(a.Uint8Array)(c.l);else
var
d=new
Array(c.l);var
f=c.c,e=f.length,b=0;for(;b<e;b++)d[b]=f.charCodeAt(b);for(e=c.l;b<e;b++)d[b]=0;c.c=d;c.t=4;return d}function
V(d,e,b,f,c){if(c==0)return 0;if(f==0&&(c>=b.l||b.t==2&&c>=b.c.length)){b.c=d.t==4?aX(d.c,e,c):e==0&&d.c.length==c?d.c:d.c.substr(e,c);b.t=b.c.length==b.l?0:2}else
if(b.t==2&&f==b.c.length){b.c+=d.t==4?aX(d.c,e,c):e==0&&d.c.length==c?d.c:d.c.substr(e,c);b.t=b.c.length==b.l?0:2}else{if(b.t!=4)ap(b);var
g=d.c,h=b.c;if(d.t==4)if(f<=e)for(var
a=0;a<c;a++)h[f+a]=g[e+a];else
for(var
a=c-1;a>=0;a--)h[f+a]=g[e+a];else{var
i=Math.min(c,g.length-e);for(var
a=0;a<i;a++)h[f+a]=g.charCodeAt(e+a);for(;a<c;a++)h[f+a]=0}}return 0}function
ba(){}function
r(a){this.data=a}r.prototype=new
ba();r.prototype.truncate=function(a){var
b=this.data;this.data=B(a|0);V(b,0,this.data,0,a)};r.prototype.length=function(){return aQ(this.data)};r.prototype.write=function(b,d,g,a){var
c=this.length();if(b+a>=c){var
e=B(b+a),f=this.data;this.data=e;V(f,0,this.data,0,c)}V(d,g,this.data,b,a);return 0};r.prototype.read=function(c,a,d,b){var
e=this.length();V(this.data,c,a,d,b);return 0};r.prototype.read_one=function(a){return be(this.data,a)};r.prototype.close=function(){};r.prototype.constructor=r;function
u(b,a){this.content={};this.root=b;this.lookupFun=a}u.prototype.nm=function(a){return this.root+a};u.prototype.lookup=function(a){if(!this.content[a]&&this.lookupFun){var
b=this.lookupFun(h(this.root),h(a));if(b!=0)this.content[a]=new
r(b[1])}};u.prototype.exists=function(a){if(a==b)return 1;var
d=a+t,e=new
RegExp(a5+d);for(var
c
in
this.content)if(c.match(e))return 1;this.lookup(a);return this.content[a]?1:0};u.prototype.readdir=function(d){var
g=d==b?b:d+t,h=new
RegExp(a5+g+cf),e={},c=[];for(var
f
in
this.content){var
a=f.match(h);if(a&&!e[a[1]]){e[a[1]]=true;c.push(a[1])}}return c};u.prototype.is_dir=function(a){var
e=a==b?b:a+t,f=new
RegExp(a5+e+cf),g=[];for(var
d
in
this.content){var
c=d.match(f);if(c)return 1}return 0};u.prototype.unlink=function(a){var
b=this.content[a]?true:false;delete
this.content[a];return b};u.prototype.open=function(a,b){if(b.rdonly&&b.wronly)s(this.nm(a)+cg);if(b.text&&b.binary)s(this.nm(a)+bP);this.lookup(a);if(this.content[a]){if(this.is_dir(a))s(this.nm(a)+" : is a directory");if(b.create&&b.excl)s(this.nm(a)+ce);var
c=this.content[a];if(b.truncate)c.truncate();return c}else
if(b.create){this.content[a]=new
r(B(0));return this.content[a]}else
aw(this.nm(a))};u.prototype.register=function(b,a){if(this.content[b])s(this.nm(b)+ce);if(a
instanceof
q)this.content[b]=new
r(a);else
if(a
instanceof
Array)this.content[b]=new
r(ad(a));else
if(a.toString){var
c=h(a.toString());this.content[b]=new
r(c)}};u.prototype.constructor=u;function
an(a){if(a.t!=4)ap(a);return a.c}function
bg(a,c,b){b&=f;if(a.t!=4){if(c==a.c.length){a.c+=String.fromCharCode(b);if(c+1==a.l)a.t=0;return 0}ap(a)}a.c[c]=b;return 0}function
bf(b,a,c){if(a>>>0>=b.l)v();return bg(b,a,c)}var
a$=a.Buffer;function
H(a){this.fs=require("fs");this.fd=a}H.prototype=new
ba();H.prototype.truncate=function(a){this.fs.ftruncateSync(this.fd,a|0)};H.prototype.length=function(){return this.fs.fstatSync(this.fd).size};H.prototype.write=function(g,c,d,f){var
b=an(c);if(!(b
instanceof
a.Uint8Array))b=new(a.Uint8Array)(b);var
e=new
a$(b);this.fs.writeSync(this.fd,e,d,f,g);return 0};H.prototype.read=function(h,e,d,g){var
b=an(e);if(!(b
instanceof
a.Uint8Array))b=new(a.Uint8Array)(b);var
f=new
a$(b);this.fs.readSync(this.fd,f,d,g,h);for(var
c=0;c<g;c++)bf(e,d+c,f[d+c]);return 0};H.prototype.read_one=function(d){var
c=new(a.Uint8Array)(1),b=new
a$(c);this.fs.readSync(this.fd,b,0,1,d);return b[0]};H.prototype.close=function(){this.fs.closeSync(this.fd)};H.prototype.constructor=H;function
G(a){this.fs=require("fs");this.root=a}G.prototype.nm=function(a){return this.root+a};G.prototype.exists=function(a){return this.fs.existsSync(this.nm(a))?1:0};G.prototype.readdir=function(a){return this.fs.readdirSync(this.nm(a))};G.prototype.is_dir=function(a){return this.fs.statSync(this.nm(a)).isDirectory()?1:0};G.prototype.unlink=function(a){var
b=this.fs.existsSync(this.nm(a))?1:0;this.fs.unlinkSync(this.nm(a));return b};G.prototype.open=function(f,c){var
a=require("constants"),b=0;for(var
e
in
c)switch(e){case"rdonly":b|=a.O_RDONLY;break;case"wronly":b|=a.O_WRONLY;break;case"append":b|=a.O_WRONLY|a.O_APPEND;break;case"create":b|=a.O_CREAT;break;case"truncate":b|=a.O_TRUNC;break;case"excl":b|=a.O_EXCL;break;case"binary":b|=a.O_BINARY;break;case"text":b|=a.O_TEXT;break;case"nonblock":b|=a.O_NONBLOCK;break}var
d=this.fs.openSync(this.nm(f),b);return new
H(d)};G.prototype.rename=function(b,a){this.fs.renameSync(this.nm(b),this.nm(a))};G.prototype.constructor=G;var
ab=X.match(/[^\/]*\//)[0];function
dg(){return typeof
a.process!=="undefined"&&typeof
a.process.versions!=="undefined"&&typeof
a.process.versions.node!=="undefined"}var
E=[];if(dg())E.push({path:ab,device:new
G(ab)});else
E.push({path:ab,device:new
u(ab)});E.push({path:ab+bL,device:new
u(ab+bL)});function
I(b){var
f=aO(b),b=f.join(t),e=b+t,c;for(var
d=0;d<E.length;d++){var
a=E[d];if(e.search(a.path)==0&&(!c||c.path.length<a.path.length))c={path:a.path,device:a.device,rest:b.substring(a.path.length,b.length)}}return c}function
hG(c){var
a=I(c),b=a.device.is_dir(a.rest);return b?1:0}function
dk(c,d){var
a=c[d],b=0;if(a&4294901760){b+=16;a>>>=16}if(a&ae){b+=8;a>>>=8}if(a&a0){b+=4;a>>>=4}if(a&12){b+=2;a>>>=2}if(a&2){b+=1;a>>>=1}if(a&1)b+=1;return 32-b}function
c2(b,a){if(a>>>0>=b.l)v();return k(b,a)}function
af(a,b,c){return a.set1(b,c)}function
cs(f,e,b,c,d){for(var
a=0;a<d;a++)af(b,c+a,c2(f,e+a));return 0}var
ea=cs;function
gk(a,d){var
a=a+1|0,b=new
Array(a);b[0]=0;for(var
c=1;c<a;c++)b[c]=d;return b}function
de(c,d,f,e){var
b=e==1?0:1;for(var
a=0;a<f;a++){c[d+a]-=b;if(c[d+a]>=0){b=0;break}else{c[d+a]+=n;b=1}}return b==1?0:1}function
bG(c,d,g,h,i,e,f){var
b=f==1?0:1;for(var
a=0;a<e;a++){c[d+a]-=h[i+a]+b;if(c[d+a]>=0)b=0;else{c[d+a]+=n;b=1}}return de(c,d+e,g-e,b==1?0:1)}function
ay(b){var
c=a;if(c.process&&c.process.stdout&&c.process.stdout.write)c.process.stderr.write(b);else{if(b.charCodeAt(b.length-1)==10)b=b.substr(0,b.length-1);var
d=c.console;d&&d.error&&d.error(b)}}function
c9(f){for(var
g=b,c=g,a,i,d=0,h=f.length;d<h;d++){a=f.charCodeAt(d);if(a<p){for(var
e=d+1;e<h&&(a=f.charCodeAt(e))<p;e++);if(e-d>co){c.substr(0,1);g+=c;c=b;g+=f.slice(d,e)}else
c+=f.slice(d,e);if(e==h)break;d=e}if(a<bR){c+=String.fromCharCode(192|a>>6);c+=String.fromCharCode(p|a&63)}else
if(a<55296||a>=bT)c+=String.fromCharCode(cb|a>>12,p|a>>6&63,p|a&63);else
if(a>=56319||d+1==h||(i=f.charCodeAt(d+1))<b6||i>bT)c+="\xef\xbf\xbd";else{d++;a=(a<<10)+i-56613888;c+=String.fromCharCode(a0|a>>18,p|a>>12&63,p|a>>6&63,p|a&63)}if(c.length>am){c.substr(0,1);g+=c;c=b}}return g+c}function
Y(a){var
b=9;if(!bm(a))b=8,a=c9(a);return new
q(b,a,a.length)}function
aU(a){throw a}function
c0(){aU(g.Not_found)}function
hF(d){var
b=a,c=d.toString();if(b.process&&b.process.env&&b.process.env[c]!=undefined)return Y(b.process.env[c]);c0()}function
bF(b,d,i,c,e,f){if(f==0){c[e]=0;return 0}var
g=0;for(var
a=i-1;a>=0;a--){var
h=b[d+a];b[d+a]=h>>>f|g;if(b[d+a]<0)b[d+a]+=n;g=h<<32-f}c[e]=g;if(c[e]<0)c[e]+=n;return 0}var
h2=Math.log2&&Math.log2(1.12355820928894744e+307)==1020;function
bB(a){if(h2)return Math.floor(Math.log2(a));var
b=0;if(a==0)return-Infinity;if(a>=1)while(a>=2){a/=2;b++}else
while(a<1){a*=2;b--}return b}function
bj(a){if(!isFinite(a)){if(isNaN(a))return[f,1,0,bH];return a>0?[f,0,0,bH]:[f,0,0,65520]}var
g=a==0&&1/a==-Infinity?z:a>=0?0:z;if(g)a=-a;var
b=bB(a)+F;if(b<=0){b=0;a/=Math.pow(2,-cm)}else{a/=Math.pow(2,b-b$);if(a<16){a*=2;b-=1}if(b==0)a/=2}var
d=Math.pow(2,24),c=a|0;a=(a-c)*d;var
e=a|0;a=(a-e)*d;var
h=a|0;c=c&15|g|b<<4;return[f,h,e,c]}function
aK(a){return[a[3]>>8,a[3]&f,a[2]>>16,a[2]>>8&f,a[2]&f,a[1]>>16,a[1]>>8&f,a[1]&f]}var
ai=function(){function
h(){this.chunk=[]}h.prototype={chunk_idx:20,block_len:0,obj_counter:0,size_32:0,size_64:0,write:function(b,c){for(var
a=b-8;a>=0;a-=8)this.chunk[this.chunk_idx++]=c>>a&f},write_code:function(c,b,d){this.chunk[this.chunk_idx++]=b;for(var
a=c-8;a>=0;a-=8)this.chunk[this.chunk_idx++]=d>>a&f},finalize:function(){this.block_len=this.chunk_idx-20;this.chunk_idx=0;this.write(32,aZ);this.write(32,this.block_len);this.write(32,this.obj_counter);this.write(32,this.size_32);this.write(32,this.size_64);return this.chunk}};return function(a){var
b=new
h(),g=[];function
e(a){if(a
instanceof
Array&&a[0]===(a[0]|0)){if(a[0]==f){b.write(8,18);for(var
c=0;c<3;c++)b.write(8,"_j\0".charCodeAt(c));var
h=aK(a);for(var
c=0;c<8;c++)b.write(8,h[c]);b.size_32+=4;b.size_64+=3;return}if(a[0]==ch)d("output_value: abstract value (Abstract)");if(a[0]<16&&a.length-1<8)b.write(8,p+a[0]+(a.length-1<<4));else
b.write_code(32,8,a.length-1<<10|a[0]);b.size_32+=a.length;b.size_64+=a.length;if(a.length>1)g.push(a,1)}else
if(a
instanceof
q){var
e=aa(a);if(e<32)b.write(8,32+e);else
if(e<_)b.write_code(8,9,e);else
b.write_code(32,10,e);for(var
c=0;c<e;c++)b.write(8,k(a,c));b.size_32+=1+((e+4)/4|0);b.size_64+=1+((e+8)/8|0)}else
if(a!=(a|0)){var
i=typeof
a;d("output_value: abstract value ("+i+b8)}else
if(a>=0&&a<64)b.write(8,64+a);else
if(a>=-(1<<7)&&a<1<<7)b.write_code(8,0,a);else
if(a>=-(1<<15)&&a<1<<15)b.write_code(16,1,a);else
b.write_code(32,2,a)}e(a);while(g.length>0){var
c=g.pop(),a=g.pop();if(c+1<a.length)g.push(a,c+1);e(a[c])}b.finalize();return b.chunk}}();function
aF(b){var
d=b.length,c=1;for(var
a=0;a<d;a++){if(b[a]<0)i("Bigarray.create: negative dimension");c=c*b[a]}return c}var
ao;function
cw(){if(!ao){var
b=a;ao=[[b.Float32Array,b.Float64Array,b.Int8Array,b.Uint8Array,b.Int16Array,b.Uint16Array,b.Int32Array,b.Int32Array,b.Int32Array,b.Int32Array,b.Float32Array,b.Float64Array,b.Uint8Array],[0,0,0,0,0,0,0,1,0,0,2,2,0]]}}function
N(a){return aj(a,1,a.length-1)}function
L(){i(cc)}function
U(b,h,d,m,j,g){var
c=g.length,t=aF(g);function
E(b){var
d=0;if(c!=b.length)i("Bigarray.get/set: bad number of dimensions");for(var
a=0;a<c;a++){if(b[a]<0||b[a]>=g[a])L();d=d*g[a]+b[a]}return d}function
F(b){var
d=0;if(c!=b.length)i("Bigarray.get/set: wrong number of indices");for(var
a=c-1;a>=0;a--){if(b[a]<1||b[a]>g[a])L();d=d*g[a]+(b[a]-1)}return d}var
k=j==0?E:F,a=g[0];function
D(a){var
c=k(a),d=b[c];return d}function
C(g){var
d=k(g),c=b[d],a=h[d];return[f,c&e,c>>>24&f|(a&o)<<8,a>>>16&o]}function
B(d){var
a=k(d),e=b[a],c=h[a];return[K,e,c]}var
n=d==1?C:d==2?B:D;function
z(c){if(c<0||c>=a)L();return b[c]}function
A(c){if(c<1||c>a)L();return b[c-1]}function
y(a){return n([a])}var
x=d==0?j==0?z:A:y;function
s(a,c){b[a]=c}function
r(c,a){b[c]=a[1]|(a[2]&f)<<24;h[c]=a[2]>>>8&o|a[3]<<16}function
q(a,c){b[a]=c[1];h[a]=c[2]}function
P(a,c){var
b=k(a);return s(b,c)}function
O(a,b){return r(k(a),b)}function
N(a,b){return q(k(a),b)}var
p=d==1?O:d==2?N:P;function
J(c,d){if(c<0||c>=a)L();b[c]=d}function
M(c,d){if(c<1||c>a)L();b[c-1]=d}function
I(a,b){p([a],b)}var
H=d==0?j==0?J:M:I;function
l(a){if(a<0||a>=c)i("Bigarray.dim");return g[a]}function
w(c){if(d==0)for(var
a=0;a<b.length;a++)s(a,c);if(d==1)for(var
a=0;a<b.length;a++)r(a,c);if(d==2)for(var
a=0;a<b.length;a++)q(a,c)}function
u(a){if(c!=a.num_dims)i(bY);for(var
e=0;e<c;e++)if(g[e]!=a.nth_dim(e))i(bY);b.set(a.data);if(d!=0)h.set(a.data2)}function
R(f,k){var
l,e=1;if(j==0){for(var
a=1;a<c;a++)e=e*g[a];l=0}else{for(var
a=0;a<c-1;a++)e=e*g[a];l=c-1;f=f-1}if(f<0||k<0||f+k>g[l])i("Bigarray.sub: bad sub-array");var
o=b.subarray(f*e,(f+k)*e),p=d==0?null:h.subarray(f*e,(f+k)*e),n=[];for(var
a=0;a<c;a++)n[a]=g[a];n[l]=k;return U(o,p,d,m,j,n)}function
Q(o){var
e=o.length,f=[],n=[],l;if(e>=c)i("Bigarray.slice: too many indices");if(j==0){for(var
a=0;a<e;a++)f[a]=o[a];for(;a<c;a++)f[a]=0;l=k(f);n=g.slice(e)}else{for(var
a=0;a<e;a++)f[c-e+a]=o[a];for(var
a=0;a<c-e;a++)f[a]=1;l=k(f);n=g.slice(0,e)}var
p=aF(n),q=b.subarray(l,l+p),r=d==0?null:h.subarray(l,l+p);return U(q,r,d,m,j,n)}function
G(g){var
c=[],f=g.length;if(f<1)i("Bigarray.reshape: bad number of dimensions");var
e=1;for(var
a=0;a<f;a++){c[a]=g[a];if(c[a]<0)i("Bigarray.reshape: negative dimension");e=e*c[a]}if(e!=t)i("Bigarray.reshape: size mismatch");return U(b,h,d,m,j,c)}function
v(d,g){if(j!=d.layout)return d.layout-j;if(c!=d.num_dims)return d.num_dims-c;for(var
a=0;a<c;a++)if(l(a)!=d.nth_dim(a))return l(a)<d.nth_dim(a)?-1:1;switch(m){case
0:case
1:case
10:case
11:var
e,f;for(var
a=0;a<b.length;a++){e=b[a];f=d.data[a];if(e<f)return-1;if(e>f)return 1;if(e!=f)if(e!=f){if(!g)return NaN;if(e==e)return 1;if(f==f)return-1}if(h){e=h[a];f=d.data2[a];if(e<f)return-1;if(e>f)return 1;if(e!=f)if(e!=f){if(!g)return NaN;if(e==e)return 1;if(f==f)return-1}}}break;case
2:case
3:case
4:case
5:case
6:case
8:case
9:case
12:for(var
a=0;a<b.length;a++){if(b[a]<d.data[a])return-1;if(b[a]>d.data[a])return 1}break;case
7:for(var
a=0;a<b.length;a++){if(h[a]<d.data2[a])return-1;if(h[a]>d.data2[a])return 1;if(b[a]<d.data[a])return-1;if(b[a]>d.data[a])return 1}break}return 0}return{data:b,data2:h,data_type:d,num_dims:c,nth_dim:l,kind:m,layout:j,size:t,sub:R,slice:Q,blit:u,fill:w,reshape:G,get:n,get1:x,set:p,set1:H,compare:v}}function
cv(a,j,h){cw();var
e=N(h),f=aF(e),b=ao[0][a];if(!b)i("Bigarray.create: unsupported kind");var
g=new
b(f),d=ao[1][a],c=null;if(d!=0)c=new
b(f);return U(g,c,d,a,j,e)}function
cr(b,a){return cv(12,0,[0,a])}function
dx(d,e){var
b=ai(d),c=cr(0,b.length);for(var
a=0;a<b.length;a++)af(c,a,b[a]);return c}function
hM(e,c){var
a=I(e),b=I(c);if(a.device!=b.device)d("caml_sys_rename: cannot move file between two filesystem");if(!a.device.rename)d("caml_sys_rename: no implemented");a.device.rename(a.rest,b.rest)}function
g3(a){a=a
instanceof
q?a.toString():a;s(a+": Not a directory")}function
hK(e){var
d=I(e),b=d.device.readdir(d.rest),c=new
Array(b.length+1);c[0]=0;for(var
a=0;a<b.length;a++)c[a+1]=h(b[a]);return c}var
c=new
Array();function
gF(b,d){var
a=c[b];if(a.refill!=null)s(bS);a.offset=d;return 0}function
bn(e){var
a=c[e];if(!a.opened)s("Cannot flush a closed channel");if(!a.buffer||a.buffer==b)return 0;if(a.fd&&g.fds[a.fd]&&g.fds[a.fd].output){var
d=g.fds[a.fd].output;switch(d.length){case
2:d(e,a.buffer);break;default:d(a.buffer)}}a.buffer=b;return 0}function
cY(h,e,i,g){var
a=c[h];if(!a.opened)s("Cannot output to a closed channel");var
d;if(i==0&&aQ(e)==g)d=e;else{d=B(g);V(e,i,d,0,g)}var
b=R(d),f=b.lastIndexOf(a2);if(f<0)a.buffer+=b;else{a.buffer+=b.substr(0,f+1);bn(h);a.buffer+=b.substr(f+1)}return 0}function
aR(b,a,d,c){return cY(b,a,d,c)}function
gy(b,a){var
c=h(String.fromCharCode(a));aR(b,c,0,1);return 0}function
aS(a){var
c=a.refill(),b=aQ(c);if(b==0)a.refill=null;a.file.write(a.file.length(),c,0,b);return b}function
bo(b){var
a=c[b];if(a.refill==null)return;if(a.file.length()!=a.offset)return;aS(a)}function
aV(){aU(g.End_of_file)}function
gs(b){var
a=c[b];bo(b);if(a.offset>=a.file.length())aV();var
d=a.file.read_one(a.offset);a.offset++;return d}function
hy(){return 0}function
gT(a){return+(a
instanceof
Array)}function
cN(a){var
c=(a[3]&32767)>>4;if(c==2047)return(a[1]|a[2]|a[3]&15)==0?a[3]&z?-Infinity:Infinity:NaN;var
d=Math.pow(2,-24),b=(a[1]*d+a[2])*d+(a[3]&15);if(c>0){b+=16;b*=Math.pow(2,c-b$)}else
b*=Math.pow(2,-cm);if(a[3]&z)b=-b;return b}function
aq(a){return[f,a[7]|a[6]<<8|a[5]<<16,a[4]|a[3]<<8|a[2]<<16,a[1]|a[0]<<8]}function
$(a){return cN(aq(a))}function
gh(a){return Math.LOG10E*Math.log(a)}var
bv=0;function
gq(a){bv=a;return 0}function
em(a){if(isFinite(a)){if(Math.abs(a)>=2.22507385850720138e-308)return 0;if(a!=0)return 1;return 2}return isNaN(a)?4:3}function
f3(a){var
a=a.toString();if(!a.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))ay('caml_js_var: "'+a+'" is not a valid JavaScript variable. continuing ..');return eval(a)}function
gu(d){var
b=c[d];bo(d);var
a=b.offset,e=b.file.length();if(a>=e)return 0;while(true){if(a>=e)return-(a-b.offset);if(b.file.read_one(a)==10)return a-b.offset+1;a++}}function
bw(e,f){var
a=c[e],d=h(f),b=aa(d);a.file.write(a.offset,d,0,b);a.offset+=b;return 0}function
e1(){return 0}var
M=2;function
ev(b,a){a[M]=b[M];return 0}function
fB(a){return+(a>31&&a<a4)}function
cy(a,b){a.t&6&&l(a);b.t&6&&l(b);return a.c<=b.c?1:0}function
d5(a,b){var
c=a.get1(b),d=a.get1(b+1)<<8,e=a.get1(b+2)<<16,g=a.get1(b+3),h=a.get1(b+4)<<8,i=a.get1(b+5)<<16,j=a.get1(b+6),k=a.get1(b+7)<<8;return[f,c|d|e,g|h|i,j|k]}function
cM(a,b){var
c=a[3]<<16,d=b[3]<<16;if(c>d)return 1;if(c<d)return-1;if(a[2]>b[2])return 1;if(a[2]<b[2])return-1;if(a[1]>b[1])return 1;if(a[1]<b[1])return-1;return 0}function
cT(a,b){if(a<b)return-1;if(a==b)return 0;return 1}function
c1(a,b){a.t&6&&l(a);b.t&6&&l(b);return a.c<b.c?-1:a.c>b.c?1:0}function
W(a,b,h){var
d=[];for(;;){if(!(h&&a===b))if(a
instanceof
q)if(b
instanceof
q){if(a!==b){var
c=c1(a,b);if(c!=0)return c}}else
return 1;else
if(a
instanceof
Array&&a[0]===(a[0]|0)){var
e=a[0];if(e===K)e=0;if(e===a7){a=a[1];continue}else
if(b
instanceof
Array&&b[0]===(b[0]|0)){var
f=b[0];if(f===K)f=0;if(f===a7){b=b[1];continue}else
if(e!=f)return e<f?-1:1;else
switch(e){case
248:var
c=cT(a[2],b[2]);if(c!=0)return c;break;case
251:i("equal: abstract value");case
255:var
c=cM(a,b);if(c!=0)return c;break;default:if(a.length!=b.length)return a.length<b.length?-1:1;if(a.length>1)d.push(a,b,1)}}else
return 1}else
if(b
instanceof
q||b
instanceof
Array&&b[0]===(b[0]|0))return-1;else
if(typeof
a!="number"&&a&&a.compare){var
j=a.compare(b,h);if(j!=0)return j}else
if(typeof
a=="function")i("compare: functional value");else{if(a<b)return-1;if(a>b)return 1;if(a!=b){if(!h)return NaN;if(a==a)return 1;if(b==b)return-1}}if(d.length==0)return 0;var
g=d.pop();b=d.pop();a=d.pop();if(g+1<a.length)d.push(a,b,g+1);a=a[g];b=b[g]}}function
eI(a,b){return+(W(a,b,false)==0)}function
dX(a,b){return a.num_dims}function
m(a,b){return a.get1(b)}function
bc(c,f,g,d,e){for(var
a=0;a<e;a++){var
b=m(c,f+a);bf(g,d+a,b)}return 0}function
bh(c,b){var
a=I(c);if(!a.device.register)d("cannot register file");a.device.register(a.rest,b);return 0}function
cE(){var
c=a.caml_fs_tmp;if(c)for(var
b=0;b<c.length;b++)bh(c[b].name,c[b].content);a.caml_create_file=bh;return 0}if(!Math.imul)Math.imul=function(b,a){a|=0;return((b>>16)*a<<16)+(b&o)*a|0};var
at=Math.imul;function
D(b,a){a=at(a,3432918353|0);a=a<<15|a>>>32-15;a=at(a,461845907);b^=a;b=b<<13|b>>>32-13;return(b+(b<<2)|0)+(3864292196|0)|0}function
bi(d,b){var
e=b.length,a,c;for(a=0;a+4<=e;a+=4){c=b[a]|b[a+1]<<8|b[a+2]<<16|b[a+3]<<24;d=D(d,c)}c=0;switch(e&3){case
3:c=b[a+2]<<16;case
2:c|=b[a+1]<<8;case
1:c|=b[a];d=D(d,c)}d^=e;return d}function
bu(a){return a}var
bq={};function
bp(a){return bq[a]}function
hT(b){if(b
instanceof
Array)return b;if(a.RangeError&&b
instanceof
a.RangeError&&b.message&&b.message.match(/maximum call stack/i))return bu(g.Stack_overflow);if(a.InternalError&&b
instanceof
a.InternalError&&b.message&&b.message.match(/too much recursion/i))return bu(g.Stack_overflow);if(b
instanceof
a.Error&&bp(b3))return[0,bp(b3),b];return[0,g.Failure,Y(String(b))]}function
eN(){return 0}function
hJ(){var
a=new
Date()^4294967295*Math.random();return[0,a]}function
gg(c){var
b=0;for(var
a=c.length-1;a>=0;a--){var
d=c[a];b=[0,d,b]}return b}function
dQ(a,b,c){return a.get([b,c])}function
hc(){return 0}function
ie(a){return a}function
dn(){return new
Date().getTime()/al}function
d6(a,b,c){a.set1(b,c&f);a.set1(b+1,c>>>8&f);return 0}function
dl(c,e){var
d=c.length,b=new
Array(d+1),a=0;for(;a<d;a++)b[a]=c[a];b[a]=e;return b}function
A(b,a){if(b.fun)return A(b.fun,a);var
c=b.length,d=a.length,e=c-d;if(e==0)return b.apply(null,a);else
if(e<0)return A(b.apply(null,aj(a,0,c)),aj(a,c,d-c));else
return function(c){return A(b,dl(a,c))}}function
cU(a){return function(){return arguments.length>0?A(a,arguments):A(a,[undefined])}}function
f4(a){return function(){return cU(a)(arguments)}}function
hr(b){var
a=I(b);if(a.device.exists(a.rest)){X=a.rest?a.path+a.rest+t:a.path;return 0}else
aw(b)}function
eX(){return[K,0,0,0]}function
bD(c,d,b){for(var
a=b-1;a>=0;a--)if(c[d+a]!=0)return a+1;return 1}function
dc(b,d,h,c,e,i){var
f=bD(b,d,h),g=bD(c,e,i);if(f>g)return 1;if(f<g)return-1;for(var
a=h-1;a>=0;a--){if(b[d+a]>c[e+a])return 1;if(b[d+a]<c[e+a])return-1}return 0}function
dm(c,d,b){for(var
a=0;a<b;a++)c[d+a]=0;return 0}function
fD(b,a){delete
b[a];return 0}function
gf(){var
b=0;for(var
a=0;a<E.length;a++){var
c=b;b=[0,h(E[a].path),c]}return b}function
fz(g){var
i=bs(g),c=i[0],j=i[1],e=i[2],h=aa(g),l=-1>>>0,f=c<h?k(g,c):0,b=av(f);if(b<0||b>=e)d(O);var
a=b;for(c++;c<h;c++){f=k(g,c);if(f==95)continue;b=av(f);if(b<0||b>=e)break;a=e*a+b;if(a>l)d(O)}if(c!=h)d(O);a=j*a;if(e==10&&(a|0)!=a)d(O);return a|0}var
gl={PREFIX_SMALL_BLOCK:p,PREFIX_SMALL_INT:64,PREFIX_SMALL_STRING:32,CODE_INT8:0,CODE_INT16:1,CODE_INT32:2,CODE_INT64:3,CODE_SHARED8:4,CODE_SHARED16:5,CODE_SHARED32:6,CODE_BLOCK32:8,CODE_BLOCK64:19,CODE_STRING8:9,CODE_STRING32:10,CODE_DOUBLE_BIG:11,CODE_DOUBLE_LITTLE:12,CODE_DOUBLE_ARRAY8_BIG:13,CODE_DOUBLE_ARRAY8_LITTLE:14,CODE_DOUBLE_ARRAY32_BIG:15,CODE_DOUBLE_ARRAY32_LITTLE:7,CODE_CODEPOINTER:16,CODE_INFIXPOINTER:17,CODE_CUSTOM:18};function
fE(a,b){return+(a==b)}function
cJ(d,b){var
e=b.length,a,c;for(a=0;a+4<=e;a+=4){c=b.charCodeAt(a)|b.charCodeAt(a+1)<<8|b.charCodeAt(a+2)<<16|b.charCodeAt(a+3)<<24;d=D(d,c)}c=0;switch(e&3){case
3:c=b.charCodeAt(a+2)<<16;case
2:c|=b.charCodeAt(a+1)<<8;case
1:c|=b.charCodeAt(a);d=D(d,c)}d^=e;return d}function
e$(a,b){return+(W(a,b,false)>0)}function
dJ(b,a){a.blit(b);return 0}function
aH(c,i){var
q=c.read32u(),o=c.read32u(),l=c.read32u(),r=c.read32u(),s=c.read32u(),m=[],e=l>0?[]:null,k=0;function
h(){var
l=c.read8u();if(l>=64)if(l>=p){var
q=l&15,o=l>>4&7,a=[q];if(o==0)return a;if(e)e[k++]=a;m.push(a,o);return a}else
return l&63;else
if(l>=32){var
j=l&31,a=c.readstr(j);if(e)e[k++]=a;return a}else
switch(l){case
0:return c.read8s();case
1:return c.read16s();case
2:return c.read32s();case
3:d("input_value: integer too large");break;case
4:var
n=c.read8u();return e[k-n];case
5:var
n=c.read16u();return e[k-n];case
6:var
n=c.read32u();return e[k-n];case
8:var
s=c.read32u(),q=s&f,o=s>>10,a=[q];if(o==0)return a;if(e)e[k++]=a;m.push(a,o);return a;case
19:d("input_value: data block too large");break;case
9:var
j=c.read8u(),a=c.readstr(j);if(e)e[k++]=a;return a;case
10:var
j=c.read32u(),a=c.readstr(j);if(e)e[k++]=a;return a;case
12:var
h=new
Array(8);for(var
g=0;g<8;g++)h[7-g]=c.read8u();var
a=$(h);if(e)e[k++]=a;return a;case
11:var
h=new
Array(8);for(var
g=0;g<8;g++)h[g]=c.read8u();var
a=$(h);if(e)e[k++]=a;return a;case
14:var
j=c.read8u(),a=new
Array(j+1);a[0]=K;var
h=new
Array(8);if(e)e[k++]=a;for(var
g=1;g<=j;g++){for(var
i=0;i<8;i++)h[7-i]=c.read8u();a[g]=$(h)}return a;case
13:var
j=c.read8u(),a=new
Array(j+1);a[0]=K;var
h=new
Array(8);if(e)e[k++]=a;for(var
g=1;g<=j;g++){for(var
i=0;i<8;i++)h[i]=c.read8u();a[g]=$(h)}return a;case
7:var
j=c.read32u(),a=new
Array(j+1);a[0]=K;if(e)e[k++]=a;var
h=new
Array(8);for(var
g=1;g<=j;g++){for(var
i=0;i<8;i++)h[7-i]=c.read8u();a[g]=$(h)}return a;case
15:var
j=c.read32u(),a=new
Array(j+1);a[0]=K;var
h=new
Array(8);for(var
g=1;g<=j;g++){for(var
i=0;i<8;i++)h[i]=c.read8u();a[g]=$(h)}return a;case
16:case
17:d("input_value: code pointer");break;case
18:var
r,t=b;while((r=c.read8u())!=0)t+=String.fromCharCode(r);switch(t){case"_j":var
h=new
Array(8);for(var
i=0;i<8;i++)h[i]=c.read8u();var
a=aq(h);if(e)e[k++]=a;return a;case"_i":var
a=c.read32s();if(e)e[k++]=a;return a;case"_n":switch(c.read8u()){case
1:var
a=c.read32s();if(e)e[k++]=a;return a;case
2:d("input_value: native integer value too large");default:d("input_value: ill-formed native integer")}default:d("input_value: unknown custom block identifier")}default:d("input_value: ill-formed message")}}var
n=h();while(m.length>0){var
j=m.pop(),a=m.pop(),g=a.length;if(g<j)m.push(a,j);a[g]=h()}if(typeof
i!="number")i[0]=c.i;return n}function
bA(e,b,a){var
d=e*Z+(b>>>16),f=Math.floor(d/a)*Z,g=d%a*Z,c=g+(b&o);return[f+Math.floor(c/a),c%a]}function
df(h,k,i,l,d,e,c,g,j){var
b=d[e+c-1];for(var
a=c-2;a>=0;a--){var
f=bA(b,d[e+a],g[j]);h[k+a]=f[0];b=f[1]}i[l]=b;return 0}function
bE(b,d,i,c,e,f){if(f==0){c[e]=0;return 0}var
g=0;for(var
a=0;a<i;a++){var
h=b[d+a];b[d+a]=h<<f|g;if(b[d+a]<0)b[d+a]+=n;g=h>>>32-f}c[e]=g;if(c[e]<0)c[e]+=n;return 0}function
dd(c){var
b=[-1,-1];for(var
a=2;a<c+2;a++)b[a]=-1;return b}function
dh(c,d,f,e){var
b=e;for(var
a=0;a<f;a++){c[d+a]+=b;if(c[d+a]<n){b=0;break}else{c[d+a]-=n;b=1}}return b}function
bb(c,d,g,h,i,e,f){var
b=f;for(var
a=0;a<e;a++){c[d+a]+=h[i+a]+b;if(c[d+a]<n)b=0;else{c[d+a]-=n;b=1}}return dh(c,d+e,g-e,b)}function
bC(c,d,g,h,i,e,k,l){var
b=0,f=k[l];for(var
a=0;a<e;a++){c[d+a]+=h[i+a]*(f&o)+b;var
j=h[i+a]*(f>>>16);b=Math.floor(j/Z);c[d+a]+=j%Z*Z;b+=Math.floor(c[d+a]/n);c[d+a]%=n}return e<g&&b?bb(c,d+e,g-e,[b],0,1,0):b}function
hW(b,c,j,e,f,a){if(a==1){df(b,c+1,b,c,b,c,j,e,f);return 0}var
h=dk(e,f+a-1);bE(e,f,a,[0],0,h);bE(b,c,j,[0],0,h);var
k=e[f+a-1]+1,i=dd(a+1);for(var
d=j-1;d>=a;d--){var
g=k==n?b[c+d]:bA(b[c+d],b[c+d-1],k)[0];dm(i,0,a+1);bC(i,0,a+1,e,f,a,[g],0);bG(b,c+d-a,a+1,i,0,a+1,1);while(b[c+d]!=0||dc(b,c+d-a,a,e,f,a)>=0){g=g+1;bG(b,c+d-a,a+1,e,f,a,1)}b[c+d]=g}bF(b,c,a,[0],0,h);bF(e,f,a,[0],0,h);return 0}function
d2(a,b){return a.slice(N(b))}function
ax(){aU(g.Division_by_zero)}function
fo(b,a){if(aI(a))ax();var
d=b[3]^a[3];if(b[3]&z)b=Q(b);if(a[3]&z)a=Q(a);var
c=as(b,a)[1];if(d&z)c=Q(c);return c}function
hY(a,b){return a[b]<n/4}function
du(c,d,a,b){while(b>0){if(m(c,a)==d)return a;a++;b--}return-1}function
fP(c){var
b,a=document.createElement(cl);a.innerHTML=c;b=a.textContent||a.innerText;a=null;return b}function
aJ(a){if(a<0)a=Math.ceil(a);return[f,a&e,Math.floor(a*ah)&e,Math.floor(a*ah*ah)&o]}function
go(b){var
a=c[b];return aJ(a.file.length())}function
dZ(a,b,c,d){return a.set([b,c],d)}function
S(c,b,a){return bg(c,b,a)}function
dD(b,c){function
f(a){bt(g.Undefined_recursive_module,b)}function
e(b,c,a){if(typeof
b==="number")switch(b){case
0:c[a]={fun:f};break;case
1:c[a]=[246,f];break;default:c[a]=[]}else
switch(b[0]){case
0:c[a]=[0];for(var
d=1;d<b[1].length;d++)e(b[1][d],c[a],d);break;default:c[a]=b[1]}}var
a=[];e(c,a,0);return a[0]}function
fG(a){return eval(a.toString())}function
ec(a,b){a.t&6&&l(a);b.t&6&&l(b);return a.c<b.c?-1:a.c>b.c?1:0}function
cW(c,b){function
a(b,a){return ag(b,a)<<24|ag(b,a+1)<<16|ag(b,a+2)<<8|ag(b,a+3)}if(a(c,b)!=(aZ|0))d(b_);return a(c,b+4)}function
aE(b,a){this.s=R(b);this.i=a}aE.prototype={read8u:function(){return this.s.charCodeAt(this.i++)},read8s:function(){return this.s.charCodeAt(this.i++)<<24>>24},read16u:function(){var
b=this.s,a=this.i;this.i=a+2;return b.charCodeAt(a)<<8|b.charCodeAt(a+1)},read16s:function(){var
b=this.s,a=this.i;this.i=a+2;return b.charCodeAt(a)<<24>>16|b.charCodeAt(a+1)},read32u:function(){var
b=this.s,a=this.i;this.i=a+4;return(b.charCodeAt(a)<<24|b.charCodeAt(a+1)<<16|b.charCodeAt(a+2)<<8|b.charCodeAt(a+3))>>>0},read32s:function(){var
b=this.s,a=this.i;this.i=a+4;return b.charCodeAt(a)<<24|b.charCodeAt(a+1)<<16|b.charCodeAt(a+2)<<8|b.charCodeAt(a+3)},readstr:function(b){var
a=this.i;this.i=a+b;return h(this.s.substring(a,a+b))}};function
cK(c,a){var
b=new
aE(c,typeof
a=="number"?a:a[0]);return aH(b,a)}function
fg(f){var
a=c[f],b=B(8);a.file.read(a.offset,b,0,8);var
d=cW(b,0)+20,b=B(d);a.file.read(a.offset,b,0,d);var
e=[0],g=cK(b,e);a.offset=a.offset+e[0];return g}function
dU(a){return a.kind}function
fM(b,a){switch(a.length){case
1:return b();case
2:return b(a[1]);case
3:return b(a[1],a[2]);case
4:return b(a[1],a[2],a[3]);case
5:return b(a[1],a[2],a[3],a[4]);case
6:return b(a[1],a[2],a[3],a[4],a[5]);case
7:return b(a[1],a[2],a[3],a[4],a[5],a[6]);case
8:return b(a[1],a[2],a[3],a[4],a[5],a[6],a[7])}return b.apply(null,N(a))}function
dv(f,e,c,g,h){var
b=ai(g);if(b.length>c)d(ci);for(var
a=0;a<b.length;a++)af(f,a+e,b[a]);return b.length}function
fW(a){return a()}function
hA(c){var
b=a;if(b.quit)b.quit(c);if(b.process&&b.process.exit)b.process.exit(c);i("Function 'exit' not implemented")}function
gr(e,g,f,b){var
a=c[e],d=a.file.length()-a.offset;if(d==0&&a.refill!=null)d=aS(a);if(d<b)b=d;a.file.read(a.offset,g,f,b);a.offset+=b;return b}function
dY(a,b){return a.reshape(N(b))}function
fj(d){var
b=new(a.Float32Array)(1);b[0]=d;var
c=new(a.Int32Array)(b.buffer);return c[0]|0}function
hU(a,c,b,d){if(a[c]>b[d])return 1;if(a[c]<b[d])return-1;return 0}function
fb(b,a){return bi(b,a.data)}function
hb(a){a[2]=br++;return a}function
g8(){return 0}function
e8(){return g}function
h$(d){var
a=new
Date(d*al),c=new
Date(Date.UTC(a.getUTCFullYear(),0,1)),b=Math.floor((a-c)/b2);return[0,a.getUTCSeconds(),a.getUTCMinutes(),a.getUTCHours(),a.getUTCDate(),a.getUTCMonth(),a.getUTCFullYear()-a1,a.getUTCDay(),b,false|0]}function
d4(a,b){var
c=a.get1(b),d=a.get1(b+1)<<8;return c|d}function
fx(b,a){a=a&63;if(a==0)return b;if(a<24)return[f,(b[1]>>a|b[2]<<24-a)&e,(b[2]>>a|b[3]<<24-a)&e,b[3]>>a];if(a<48)return[f,(b[2]>>a-24|b[3]<<48-a)&e,b[3]>>a-24,0];return[f,b[3]>>a-48,0,0]}function
hs(){return[0,h("js_of_ocaml")]}function
hD(){return[0,h("Unix"),32,0]}function
en(a,b){return W(a,b,true)}function
ic(){return Math.floor(dn())}function
gx(){var
b=0;for(var
a=0;a<c.length;a++)if(c[a]&&c[a].opened&&c[a].out)b=[0,c[a].fd,b];return b}var
dq=bc;function
eU(){return br++}function
bl(a){return(a[3]<<16)*Math.pow(2,32)+a[2]*Math.pow(2,24)+a[1]}function
dz(c){var
b=new(a.Uint8Array)(c);return U(b,null,0,12,0,[b.length])}function
dt(a){if(a.data2!=null)i("bigstring_destroy: unsupported kind");if(a.hasOwnProperty("__is_deallocated"))i("bigstring_destroy: bigstring is already deallocated");var
c=new(a.data.__proto__.constructor)(0),b=U(c,null,a.data_type,a.kind,a.layout,[0]);b.__is_deallocated=true;Object.assign(a,b);return 0}function
g4(){return 0}function
bd(a,b){var
c=a.get1(b),d=a.get1(b+1)<<8,e=a.get1(b+2)<<16,f=a.get1(b+3)<<24;return c|d|e|f}function
dA(a){return a.data.buffer}function
gN(b,a){if(a==0)ax();return b%a}function
gS(d,c){var
b=new
Array(c+1);b[0]=d;for(var
a=1;a<=c;a++)b[a]=0;return b}function
dT(){return 0}function
h4(a,b,c,d){a[b]^=c[d];if(a[b]<0)a[b]+=n;return 0}function
eO(){return 0}function
dS(a,b){return a.get(N(b))}function
a_(a,b){this.s=a;this.i=b}a_.prototype={read8u:function(){return m(this.s,this.i++)},read8s:function(){return m(this.s,this.i++)<<24>>24},read16u:function(){var
b=this.s,a=this.i;this.i=a+2;return m(b,a)<<8|m(b,a+1)},read16s:function(){var
b=this.s,a=this.i;this.i=a+2;return m(b,a)<<24>>16|m(b,a+1)},read32u:function(){var
b=this.s,a=this.i;this.i=a+4;return(m(b,a)<<24|m(b,a+1)<<16|m(b,a+2)<<8|m(b,a+3))>>>0},read32s:function(){var
b=this.s,a=this.i;this.i=a+4;return m(b,a)<<24|m(b,a+1)<<16|m(b,a+2)<<8|m(b,a+3)},readstr:function(b){var
d=this.i,c=new
Array(b);for(var
a=0;a<b;a++)c[a]=m(this.s,d+a);this.i=d+b;return ad(c)}};function
e6(){return 0}function
az(c,e){var
d=c.length,b=new
Array(d+1);b[0]=e;for(var
a=1;a<=d;a++)b[a]=c[a-1];return b}function
fY(a){return az(a,0)}function
gP(a,b){var
c=aO(a),a=c.join(t)+t;E.push({path:a,device:new
u(a,b)});return 0}function
c5(a){delete
g.fds[a];return 0}function
eS(i,c){var
a,e=aT(i),d=e.prec<0?6:e.prec;if(c<0||c==0&&1/c==-Infinity){e.sign=-1;c=-c}if(isNaN(c)){a=b7;e.filler=J}else
if(!isFinite(c)){a="inf";e.filler=J}else
switch(e.conv){case"e":var
a=c.toExponential(d),b=a.length;if(a.charAt(b-3)==a8)a=a.slice(0,b-1)+x+a.slice(b-1);break;case"f":a=c.toFixed(d);break;case"g":d=d?d:1;a=c.toExponential(d-1);var
h=a.indexOf(a8),g=+a.slice(h+1);if(g<-4||c>=1e+21||c.toFixed(0).length>d){var
b=h-1;while(a.charAt(b)==x)b--;if(a.charAt(b)==aC)b--;a=a.slice(0,b+1)+a.slice(h);b=a.length;if(a.charAt(b-3)==a8)a=a.slice(0,b-1)+x+a.slice(b-1);break}else{var
f=d;if(g<0){f-=g+1;a=c.toFixed(f)}else
while(a=c.toFixed(f),a.length>d+1)f--;if(f){var
b=a.length-1;while(a.charAt(b)==x)b--;if(a.charAt(b)==aC)b--;a=a.slice(0,b+1)}}break}return aG(e,a)}function
cC(c,b,e){if(b>>>0>=c.l+7)v();var
d=aK(e);for(var
a=0;a<8;a++)S(c,b+7-a,d[a]);return 0}function
cA(b,a,c){if(a>>>0>=b.l+1)v();var
e=f&c>>8,d=f&c;S(b,a+0,d);S(b,a+1,e);return 0}function
ho(c,a,b){return cA(c,a,b)}function
fn(a){return[f,(a[3]&ae)>>8|(a[3]&f)<<8|a[2]&a6,(a[2]&ae)>>8|(a[2]&f)<<8|a[1]&a6,(a[1]&ae)>>8|(a[1]&f)<<8]}function
eu(b,a){if(a==0)ax();return b/a|0}function
cD(a,d,c,e){if(c>0)if(d==0&&(c>=a.l||a.t==2&&c>=a.c.length))if(e==0){a.c=b;a.t=2}else{a.c=ac(c,String.fromCharCode(e));a.t=c==a.l?0:2}else{if(a.t!=4)ap(a);for(c+=d;d<c;d++)a.c[d]=e}return 0}var
eL=cD;function
c4(a,b){a.t&6&&l(a);b.t&6&&l(b);return a.c<b.c?1:0}function
hk(a,b){return c4(b,a)}function
e0(){return 0}function
eB(a){return a[M]===undefined?0:[0,au(a[M])]}function
j(b){b=R(b);var
d=b.length/2,c=new
Array(d);for(var
a=0;a<d;a++)c[a]=(b.charCodeAt(2*a)|b.charCodeAt(2*a+1)<<8)<<16>>16;return c}function
gd(b,v,a){var
p=2,q=3,t=5,e=6,i=7,h=8,l=9,o=1,n=2,s=3,u=4,r=5;if(!b.lex_default){b.lex_base=j(b[o]);b.lex_backtrk=j(b[n]);b.lex_check=j(b[r]);b.lex_trans=j(b[u]);b.lex_default=j(b[s])}var
f,c=v,m=an(a[p]);if(c>=0){a[i]=a[t]=a[e];a[h]=-1}else
c=-c-1;for(;;){var
g=b.lex_base[c];if(g<0)return-g-1;var
k=b.lex_backtrk[c];if(k>=0){a[i]=a[e];a[h]=k}if(a[e]>=a[q])if(a[l]==0)return-c-1;else
f=_;else{f=m[a[e]];a[e]++}c=b.lex_check[g+f]==c?b.lex_trans[g+f]:b.lex_default[c];if(c<0){a[e]=a[i];if(a[h]==-1)d(bO);else
return a[h]}else
if(f==_)a[l]=0}}function
hC(){var
b=a,g="a.out",c=[];if(b.process&&b.process.argv&&b.process.argv.length>1){var
d=b.process.argv;g=d[1];c=aj(d,2,d.length-2)}var
h=Y(g),f=[0,h];for(var
e=0;e<c.length;e++)f.push(Y(c[e]));return[0,h,f]}function
fZ(a){return+a}function
hB(b){var
a=I(b);return a.device.exists(a.rest)}var
C=3;function
by(b,a){if(a<0||C+a>=b.length)i("Weak.get_key");return b[C+a]===undefined?0:b[C+a]}function
db(c,b){if(b<0||C+b>=c.length)i("Weak.get_copy");var
a=by(c,b);if(a===0)return a;var
d=a[1];if(d
instanceof
Array)return[0,au(d)];return a}var
eD=db;function
ep(){d("caml_convert_raw_backtrace_slot")}function
g5(){return 0}function
dI(e,f,d){var
a=new
Array(d+1);a[0]=0;for(var
b=1,c=f+1;b<=d;b++,c++)a[b]=e[c];return a}function
gc(a,b){return+(W(a,b,false)<0)}function
ed(a,b){if(a===b)return 1;a.t&6&&l(a);b.t&6&&l(b);return a.c==b.c?1:0}function
hw(){return 0}function
y(c,b,a){g[c+1]=b;if(a)g[a]=b}function
er(a){return(Math.exp(a)+Math.exp(-a))/2}function
dj(f,i,c,g,j,d,h,k,e){var
b=0;for(var
a=0;a<e;a++)b+=bC(f,i+a,c-a,g,j,d,h,k+a);return b}function
h_(c,d,b,f,g,e){var
a=0;a+=bb(c,d,b,c,d,b,0);a+=dj(c,d,b,f,g,e,f,g,e);return a}function
c$(b,a){return b[C+a]!==undefined&&b[C+a]!==0?1:0}var
ey=c$;function
cF(a){a^=a>>>16;a=at(a,2246822507|0);a^=a>>>13;a=at(a,3266489909|0);a^=a>>>16;return a}function
d8(a,b,c){a.set1(b,c[1]&f);a.set1(b+1,c[1]>>8&f);a.set1(b+2,c[1]>>16);a.set1(b+3,c[2]&f);a.set1(b+4,c[2]>>8&f);a.set1(b+5,c[2]>>16);a.set1(b+6,c[3]&f);a.set1(b+7,c[3]>>8);return 0}function
ge(d,a,c,g){for(;;){var
b=d.charCodeAt(a);a++;if(b==f)return;var
e=d.charCodeAt(a);a++;c[b+1]=e==f?g:c[e+1]}}function
cV(d,a,c){for(;;){var
b=d.charCodeAt(a);a++;if(b==f)return;var
e=d.charCodeAt(a);a++;c[b+1]=e==f?-1:c[e+1]}}function
gQ(a,F,b){var
v=2,w=3,C=5,f=6,k=7,i=8,p=9,l=10,t=1,r=2,A=3,D=4,x=5,u=6,s=7,B=8,E=9,y=10,z=11;if(!a.lex_default){a.lex_base=j(a[t]);a.lex_backtrk=j(a[r]);a.lex_check=j(a[x]);a.lex_trans=j(a[D]);a.lex_default=j(a[A])}if(!a.lex_default_code){a.lex_base_code=j(a[u]);a.lex_backtrk_code=j(a[s]);a.lex_check_code=j(a[y]);a.lex_trans_code=j(a[E]);a.lex_default_code=j(a[B])}if(a.lex_code==null)a.lex_code=R(a[z]);var
e,c=F,q=an(b[v]);if(c>=0){b[k]=b[C]=b[f];b[i]=-1}else
c=-c-1;for(;;){var
h=a.lex_base[c];if(h<0){var
g=a.lex_base_code[c];cV(a.lex_code,g,b[l]);return-h-1}var
n=a.lex_backtrk[c];if(n>=0){var
g=a.lex_backtrk_code[c];cV(a.lex_code,g,b[l]);b[k]=b[f];b[i]=n}if(b[f]>=b[w])if(b[p]==0)return-c-1;else
e=_;else{e=q[b[f]];b[f]++}var
m=c;c=a.lex_check[h+e]==c?a.lex_trans[h+e]:a.lex_default[c];if(c<0){b[f]=b[k];if(b[i]==-1)d(bO);else
return b[i]}else{var
o=a.lex_base_code[m],g;g=a.lex_check_code[o+e]==m?a.lex_trans_code[o+e]:a.lex_default_code[m];if(g>0)ge(a.lex_code,g,b[l],b[f]);if(e==_)b[p]=0}}}function
fK(a){return a}function
eR(a){var
a=a+1|0,b=new
Array(a);b[0]=K;for(var
c=1;c<a;c++)b[c]=0;return b}function
e4(){return[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}function
gb(a,b){return+(W(a,b,false)<=0)}function
gI(a,b){c[a].offset=bl(b);return 0}function
e3(a){return 0}function
fN(b,a){return b[a]}var
aP=[];function
e9(i,h,d){var
b=i[1],g=aP[d];if(g===null)for(var
f=aP.length;f<d;f++)aP[f]=0;else
if(b[g]===h)return b[g-1];var
a=3,e=b[1]*2+1,c;while(a<e){c=a+e>>1|1;if(h<b[c+1])e=c-2;else
a=c}aP[d]=a+1;return h==b[a+1]?b[a]:0}function
fO(){var
c=a.console?a.console:{},d=["log","debug","info","warn","error","assert","dir","dirxml","trace","group","groupCollapsed","groupEnd","time","timeEnd"];function
e(){}for(var
b=0;b<d.length;b++)if(!c[d[b]])c[d[b]]=e;return c}function
di(b){var
c=a;if(c.process&&c.process.stdout&&c.process.stdout.write)c.process.stdout.write(b);else{if(b.charCodeAt(b.length-1)==10)b=b.substr(0,b.length-1);var
d=c.console;d&&d.log&&d.log(b)}}function
aY(c,e,d,a){if(g.fds===undefined)g.fds=new
Array();a=a?a:{};var
b={};b.file=d;b.offset=a.append?d.length():0;b.flags=a;b.output=e;g.fds[c]=b;if(!g.fd_last_idx||c>g.fd_last_idx)g.fd_last_idx=c;return c}function
hI(c,b,h){var
a={};while(b){switch(b[1]){case
0:a.rdonly=1;break;case
1:a.wronly=1;break;case
2:a.append=1;break;case
3:a.create=1;break;case
4:a.truncate=1;break;case
5:a.excl=1;break;case
6:a.binary=1;break;case
7:a.text=1;break;case
8:a.nonblock=1;break}b=b[2]}if(a.rdonly&&a.wronly)s(c.toString()+cg);if(a.text&&a.binary)s(c.toString()+bP);var
d=I(c),e=d.device.open(d.rest,a),f=g.fd_last_idx?g.fd_last_idx:0;return aY(f+1,bw,e,a)}aY(0,bw,new
r(B(0)));aY(1,di,new
r(B(0)));aY(2,ay,new
r(B(0)));function
gv(d){var
b=g.fds[d];if(b.flags.wronly)s(ck+d+" is writeonly");var
a={file:b.file,offset:b.offset,fd:d,opened:true,out:false,refill:null};c[a.fd]=a;return a.fd}function
eW(){return 0}function
gX(b,a){switch(a.length){case
0:return new
b();case
1:return new
b(a[0]);case
2:return new
b(a[0],a[1]);case
3:return new
b(a[0],a[1],a[2]);case
4:return new
b(a[0],a[1],a[2],a[3]);case
5:return new
b(a[0],a[1],a[2],a[3],a[4]);case
6:return new
b(a[0],a[1],a[2],a[3],a[4],a[5]);case
7:return new
b(a[0],a[1],a[2],a[3],a[4],a[5],a[6])}function
c(){return b.apply(this,a)}c.prototype=b.prototype;return new
c()}var
eC=by;function
hV(b,c,d){for(var
a=0;a<d;a++)b[c+a]=n-1-b[c+a]}var
aN={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};function
fQ(a){if(!aN.all.test(a))return a;return a.replace(aN.amp,"&amp;").replace(aN.lt,"&lt;").replace(aN.quot,"&quot;")}function
gp(b){var
a=c[b];bn(b);a.opened=false;a.file.close();c5(a.fd);return 0}function
id(){}function
eJ(b,c){if(!b.js_error||c||b[0]==w)b.js_error=new(a.Error)("Js exception containing backtrace");return b}function
hH(a){return 0}function
dN(a){return a.nth_dim(1)}function
h0(a,b){return a[b]==0}function
f7(a){return function(){return A(a,[this,arguments])}}function
ia(){return 0}function
hd(a){return(Math.exp(a)-Math.exp(-a))/2}function
fX(b,a,c){b[a]=c;return 0}function
ga(b,a){a|=0;if(a>F){a-=F;b*=Math.pow(2,F);if(a>F){a-=F;b*=Math.pow(2,F)}}if(a<-F){a+=F;b*=Math.pow(2,-F)}b*=Math.pow(2,a);return b}function
f5(b,e){return function(){var
d=arguments.length;if(d==b)return A(e,arguments);var
c=new
Array(b);for(var
a=0;a<d&&a<b;a++)c[a]=arguments[a];return A(e,c)}}function
dG(b,a){if(a<0||a>=b.length-1)L();return b[a+1]}function
e5(){return[0]}function
fs(a,b){if(aI(b))ax();var
d=a[3];if(a[3]&z)a=Q(a);if(b[3]&z)b=Q(b);var
c=as(a,b)[2];if(d&z)c=Q(c);return c}function
h1(a,b,c,d){a[b]&=c[d];if(a[b]<0)a[b]+=n;return 0}function
es(c,b){if(a.caml_create_file)a.caml_create_file(c,b);else{if(!a.caml_fs_tmp)a.caml_fs_tmp=[];a.caml_fs_tmp.push({name:c,content:b})}return 0}function
gU(b,a){b[0]=a;return 0}function
dB(c,a){var
b=new
a_(c,typeof
a=="number"?a:a[0]);return aH(b,a)}function
fk(a){return(a&f)<<24|(a&ae)<<8|(a&a6)>>>8|(a&4278190080)>>>24}function
hf(){d("Spacetime profiling only works for native code")}function
ig(){}function
gG(b,d){var
a=c[b];if(a.refill!=null)s(bS);a.offset=bl(d);return 0}function
d0(a,b,c,d,e){return a.set([b,c,d],e)}function
fR(b,a){return b
instanceof
a}function
cG(a,e){var
b=bj(e),d=b[1]|b[2]<<24,c=b[2]>>>8|b[3]<<16;a=D(a,d);a=D(a,c);return a}function
gR(a,b){return+(W(a,b,false)!=0)}function
fv(b,a){a=a&63;if(a==0)return b;if(a<24)return[f,b[1]<<a&e,(b[2]<<a|b[1]>>24-a)&e,(b[3]<<a|b[2]>>24-a)&o];if(a<48)return[f,0,b[1]<<a-24&e,(b[2]<<a-24|b[1]>>48-a)&o];return[f,0,0,b[1]<<a-48&o]}function
f6(a){return function(){return A(a,az(arguments,this))}}function
hu(){return 32}var
d_=bc;function
fA(){return 1}function
hq(c,a,b){return cC(c,a,b)}function
h6(a,b){return a[b]}function
h9(a,b,c){a[b]=c;if(a[b]<0)a[b]+=n;return 0}function
dM(a){return a.nth_dim(0)}function
fS(a,c,b){return a[c.toString()].apply(a,N(b))}function
cx(g,b,c,f,a,e){d("caml_ba_map_file not implemented")}function
dW(a,b){return cx(a[0],a[1],a[2],a[3],a[4],a[5])}function
dp(g){var
a=new
Date(g*al),d=new
Date(a.getFullYear(),0,1),b=Math.floor((a-d)/b2),c=new
Date(a.getFullYear(),0,1),e=new
Date(a.getFullYear(),6,1),f=Math.max(c.getTimezoneOffset(),e.getTimezoneOffset());return[0,a.getSeconds(),a.getMinutes(),a.getHours(),a.getDate(),a.getMonth(),a.getFullYear()-a1,a.getDay(),b,a.getTimezoneOffset()<f|0]}function
da(a){if(a<0)i("Weak.create");var
b=[ch,"caml_ephe_list_head"];b.length=C+a;return b}var
ez=da;function
f0(a){return h(a)}function
hP(a){var
b=Math.exp(a),c=Math.exp(-a);return(b-c)/(b+c)}var
T=a.JSON;if(typeof
T!=="object")T={};(function(){"use strict";var
l=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,n=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,i=/(?:^|:|,)(?:\s*\[)+/g,e=/[\\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,d=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;function
a(a){return a<10?x+a:a}function
g(){return this.valueOf()}if(typeof
Date.prototype.toJSON!=="function"){Date.prototype.toJSON=function(){return isFinite(this.valueOf())?this.getUTCFullYear()+P+a(this.getUTCMonth()+1)+P+a(this.getUTCDate())+"T"+a(this.getUTCHours())+aA+a(this.getUTCMinutes())+aA+a(this.getUTCSeconds())+"Z":null};Boolean.prototype.toJSON=g;Number.prototype.toJSON=g;String.prototype.toJSON=g}var
c,j,h,f;function
m(a){e.lastIndex=0;return e.test(a)?aB+a.replace(e,function(a){var
b=h[a];return typeof
b==="string"?b:bK+(cn+a.charCodeAt(0).toString(16)).slice(-4)})+aB:aB+a+aB}function
k(l,n){var
b,g,e,h,i=c,d,a=n[l];if(a&&typeof
a==="object"&&typeof
a.toJSON==="function")a=a.toJSON(l);if(typeof
f==="function")a=f.call(n,l,a);switch(typeof
a){case"string":return m(a);case"number":return isFinite(a)?String(a):a3;case"boolean":case"null":return String(a);case"object":if(!a)return a3;c+=j;d=[];if(Object.prototype.toString.apply(a)==="[object Array]"){h=a.length;for(b=0;b<h;b+=1)d[b]=k(b,a)||a3;e=d.length===0?"[]":c?"[\n"+c+d.join(bZ+c)+a2+i+a9:"["+d.join(b4)+a9;c=i;return e}if(f&&typeof
f==="object"){h=f.length;for(b=0;b<h;b+=1)if(typeof
f[b]==="string"){g=f[b];e=k(g,a);if(e)d.push(m(g)+(c?bV:aA)+e)}}else
for(g
in
a)if(Object.prototype.hasOwnProperty.call(a,g)){e=k(g,a);if(e)d.push(m(g)+(c?bV:aA)+e)}e=d.length===0?"{}":c?"{\n"+c+d.join(bZ+c)+a2+i+ca:"{"+d.join(b4)+ca;c=i;return e}}if(typeof
T.stringify!=="function"){h={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"};T.stringify=function(g,a,d){var
e;c=b;j=b;if(typeof
d==="number")for(e=0;e<d;e+=1)j+=J;else
if(typeof
d==="string")j=d;f=a;if(a&&typeof
a!=="function"&&(typeof
a!=="object"||typeof
a.length!=="number"))throw new
Error("JSON.stringify");return k(b,{"":g})}}if(typeof
T.parse!=="function")T.parse=function(a,f){var
c;function
g(d,e){var
b,c,a=d[e];if(a&&typeof
a==="object")for(b
in
a)if(Object.prototype.hasOwnProperty.call(a,b)){c=g(a,b);if(c!==undefined)a[b]=c;else
delete
a[b]}return f.call(d,e,a)}a=String(a);d.lastIndex=0;if(d.test(a))a=a.replace(d,function(a){return bK+(cn+a.charCodeAt(0).toString(16)).slice(-4)});if(l.test(a.replace(o,"@").replace(n,a9).replace(i,b))){c=eval("("+a+b8);return typeof
f==="function"?g({"":c},b):c}throw new
SyntaxError("JSON.parse")}}());function
f_(){return T}function
hQ(a){var
b=1;while(a&&a.joo_tramp){a=a.joo_tramp.apply(null,a.joo_args);b++}return a}function
ib(a){var
c=new
Date(a[6]+a1,a[5],a[4],a[3],a[2],a[1]),b=Math.floor(c.getTime()/al),d=dp(b);return[0,b,d]}function
eg(d,c){if(c>>>0>=d.l+7)v();var
b=new
Array(8);for(var
a=0;a<8;a++)b[7-a]=k(d,c+a);return aq(b)}function
bz(b,a,c){if(a<0||C+a>=b.length)i("Weak.set");b[C+a]=c;return 0}function
hL(a){var
b=I(a),c=b.device.unlink(b.rest);if(c==0)aw(a);return 0}function
hS(c){var
d=aO(c),c=d.join(t)+t,b=-1;for(var
a=0;a<E.length;a++)if(E[a].path==c)b=a;if(b>-1)E.splice(b,1);return 0}function
hh(b,a){if(a>>>0>=b.l+3)v();var
c=k(b,a),d=k(b,a+1),e=k(b,a+2),f=k(b,a+3);return f<<24|e<<16|d<<8|c}function
fe(a,b){var
a=Math.abs(a),b=Math.abs(b),c=Math.max(a,b),d=Math.min(a,b)/(c?c:1);return c*Math.sqrt(1+d*d)}function
fl(d){var
b=new(a.Int32Array)(1);b[0]=d;var
c=new(a.Float32Array)(b.buffer);return c[0]}function
gB(a){return aJ(c[a].offset)}function
fC(b,c,a){return b.apply(c,N(a))}function
g9(a){return 0}function
hn(b,a,c){if(a>>>0>=b.l)v();return S(b,a,c)}function
hv(){return 2147483647/4|0}function
eH(b,a){return bz(b,a,0)}function
gC(a){return c[a].offset}function
he(a){return 0}function
bx(a,b){if(a===b)return 1;a.t&6&&l(a);b.t&6&&l(b);return a.c==b.c?1:0}function
ej(a,b){return 1-bx(a,b)}function
fU(b){var
c={};for(var
a=1;a<b.length;a++){var
d=b[a];c[d[1].toString()]=d[2]}return c}function
g$(a){return h(b)}function
cu(d,b,e,c,f){if(c<=b)for(var
a=1;a<=f;a++)e[c+a]=d[b+a];else
for(var
a=f;a>=1;a--)e[c+a]=d[b+a];return 0}function
c_(a,c,b,d,e){cu(a,C+c-1,b,C+d-1,e);return 0}function
cz(a,b){a.t&6&&l(a);b.t&6&&l(b);return a.c<b.c?1:0}function
e2(){return[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}function
gt(e){var
a=c[e],b=a.file;while(a.offset+3>=b.length()){var
f=aS(a);if(f==0)aV()}var
d=a.offset,g=b.read_one(d)<<24|b.read_one(d+1)<<16|b.read_one(d+2)<<8|b.read_one(d+3);a.offset+=4;return g}function
eb(a){return(a&f)<<8|(a&ae)>>8}function
gJ(e,b){var
d=c[e],a=g.fds[d.fd];a.flags.text=!b;a.flags.binary=b;return 0}function
eM(){return 0}function
h5(a,b){return a[b]}function
hE(){return h(X)}function
eQ(a){var
c;a=R(a);c=+a;if(a.length>0&&c===c)return c;a=a.replace(/_/g,b);c=+a;if(a.length>0&&c===c||/^[+-]?nan$/i.test(a))return c;var
e=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(a);if(e){var
f=e[3].replace(/0+$/,b),h=parseInt(e[1]+e[2]+f,16),g=(e[4]|0)-4*f.length;c=h*Math.pow(2,g);return c}if(/^\+?inf(inity)?$/i.test(a))return Infinity;if(/^-inf(inity)?$/i.test(a))return-Infinity;d("float_of_string")}function
hg(b,a){if(a>>>0>=b.l+1)v();var
c=k(b,a),d=k(b,a+1);return d<<8|c}function
ht(){return 0}function
eG(a,b){a[M]=undefined;return 0}function
cZ(a,b){return ad(ai(a))}function
gY(b,c,d){var
a=cZ(c);aR(b,a,0,aa(a));return 0}function
hN(b){var
b=b.toString();a.console.log(b);if(typeof
require!="undefined"&&require("child_process")&&require("child_process").execSync)try{require("child_process").execSync(b);return 0}catch(a){return 1}else
return a4}function
dR(a,b,c,d){return a.get([b,c,d])}var
ew=c_;function
fF(a){if(a.js_error)return a.js_error;return null}function
el(a,b){if(b>>>0>=a.length-1)L();return a}function
ek(a){return a}function
hX(){return 0}function
cH(b,a){var
d=a[1]|a[2]<<24,c=a[2]>>>8|a[3]<<16;b=D(b,c^d);return b}function
cI(a,b){switch(b.t&6){default:l(b);case
0:a=cJ(a,b.c);break;case
2:a=bi(a,b.c)}return a}var
cq=_;function
fa(j,k,m,l){var
f,g,h,d,c,b,a,e,i;d=k;if(d<0||d>cq)d=cq;c=j;b=m;f=[l];g=0;h=1;while(g<h&&c>0){a=f[g++];if(a
instanceof
Array&&a[0]===(a[0]|0))switch(a[0]){case
248:b=D(b,a[2]);c--;break;case
250:f[--g]=a[1];break;case
255:b=cH(b,a);c--;break;default:var
n=a.length-1<<10|a[0];b=D(b,n);for(e=1,i=a.length;e<i;e++){if(h>=d)break;f[h++]=a[e]}break}else
if(a
instanceof
q){b=cI(b,a);c--}else
if(a===(a|0)){b=D(b,a+a+1);c--}else
if(a===+a){b=cG(b,a);c--}else
if(a&&a.hash&&typeof
a.hash==="function")b=D(b,a.hash())}b=cF(b);return b&bU}function
dy(e,f,g,h,d){for(var
a=0;a<d;a++){var
b=m(e,f+a),c=m(g,h+a);if(b<c)return-1;if(b>c)return 1}return 0}function
gV(a){return a
instanceof
Array?a[0]:a
instanceof
q?252:al}function
fH(){return typeof
module!=="undefined"&&module&&module.exports?module.exports:a}function
eV(a){if(a==0||!isFinite(a))return[0,a,0];var
c=a<0;if(c)a=-a;var
b=bB(a)+1;a*=Math.pow(2,-b);if(a<0.5){a*=2;b-=1}if(c)a=-a;return[0,a,b]}function
ef(b,a){if(a>>>0>=b.l+3)v();var
c=k(b,a),d=k(b,a+1),e=k(b,a+2),f=k(b,a+3);return f<<24|e<<16|d<<8|c}function
dr(f,e,b,c,d){for(var
a=0;a<d;a++)af(b,c+a,be(f,e+a));return 0}function
eq(a,b){if(b==0)b=1/b;a=Math.abs(a);return b<0?-a:a}function
d1(a,b,c){return a.set(N(b),c)}function
eF(c,a,b){return bz(c,a,[0,b])}function
gD(a){return aJ(c[a].offset)}function
hi(d,c){if(c>>>0>=d.l+7)v();var
b=new
Array(8);for(var
a=0;a<8;a++)b[7-a]=k(d,c+a);return aq(b)}function
c3(a,b){a.t&6&&l(a);b.t&6&&l(b);return a.c<=b.c?1:0}function
hj(a,b){return c3(b,a)}function
gA(a){return c[a].offset}function
fm(a,b){return[f,a[1]&b[1],a[2]&b[2],a[3]&b[3]]}function
hz(){return 32}function
dK(a,d){if(a.layout==d)return a;var
c=[];for(var
b=0;b<a.num_dims;b++)c[b]=a.nth_dim(b);return U(a.data,a.data2,a.data_type,a.kind,d,c)}function
fh(c,a){var
b=new
aE(c,typeof
a=="number"?a:a[0]);return aH(b,a)}function
fT(b,a){switch(a.length){case
1:return new
b();case
2:return new
b(a[1]);case
3:return new
b(a[1],a[2]);case
4:return new
b(a[1],a[2],a[3]);case
5:return new
b(a[1],a[2],a[3],a[4]);case
6:return new
b(a[1],a[2],a[3],a[4],a[5]);case
7:return new
b(a[1],a[2],a[3],a[4],a[5],a[6]);case
8:return new
b(a[1],a[2],a[3],a[4],a[5],a[6],a[7])}function
c(){return b.apply(this,N(a))}c.prototype=b.prototype;return new
c()}function
eT(e,c){if(R(e)=="%d")return h(b+c);var
a=aT(e);if(c<0)if(a.signedconv){a.sign=-1;c=-c}else
c>>>=0;var
d=c.toString(a.base);if(a.prec>=0){a.filler=J;var
f=a.prec-d.length;if(f>0)d=ac(f,x)+d}return aG(a,d)}function
fL(a){return a.toString()}function
gW(b,a){if(a<=0||a+1>b.length)i("Obj.truncate");if(b.length!=a+1)b.length=a+1;return 0}function
d3(a,c,b){return a.sub(c,b)}function
hZ(a,b){return a[b]&1==1}function
eY(){return 0}function
fr(a){return a[3]==o&&(a[1]&a[2])==e}function
cB(b,a,c){if(a>>>0>=b.l+3)v();var
h=f&c>>24,g=f&c>>16,e=f&c>>8,d=f&c;S(b,a+0,d);S(b,a+1,e);S(b,a+2,g);S(b,a+3,h);return 0}function
gw(e){var
d=g.fds[e];if(d.flags.rdonly)s(ck+e+" is readonly");var
a={file:d.file,offset:d.offset,fd:e,opened:true,out:true,buffer:b};c[a.fd]=a;return a.fd}function
ha(a){return h(b)}function
dF(a){var
c=[0];while(a!==0){var
d=a[1];for(var
b=1;b<d.length;b++)c.push(d[b]);a=a[2]}return c}function
d7(a,b,c){a.set1(b,c&f);a.set1(b+1,c>>>8&f);a.set1(b+2,c>>>16&f);a.set1(b+3,c>>>24&f);return 0}function
hx(){return 1}function
eE(b,a){b[M]=a;return 0}function
dw(b,a){if(bd(b,a)!=(aZ|0))d(b_);return bd(b,a+4)}function
gj(a){var
a=a+1|0,b=new
Array(a);b[0]=K;for(var
c=1;c<a;c++)b[c]=0;return b}function
gH(a,b){c[a].offset=b;return 0}function
e_(a,b){return+(W(a,b,false)>=0)}function
f2(a){return typeof
a}function
f9(a){return function(){a.apply(null,az(arguments,this))}}function
dO(a){return a.nth_dim(2)}function
e7(){return[0]}function
ex(a){return a[M]===undefined?0:1}function
gi(a){var
b=1+a,c=b-1;return c==0?a:a*Math.log(b)/c}function
ee(b,a){if(a>>>0>=b.l+1)v();var
c=k(b,a),d=k(b,a+1);return d<<8|c}function
fu(a,b){return[f,a[1]|b[1],a[2]|b[2],a[3]|b[3]]}function
fJ(a){return!!a}function
gK(){return 0}function
f$(a){return[a7,a]}function
h3(a,b,c,d){a[b]|=c[d];if(a[b]<0)a[b]+=n;return 0}function
et(a){if(a<0)i("String.create");return new
q(a?2:9,b,a)}function
fV(){var
c=a.navigator?a.navigator.userAgent:b;return c.indexOf("MSIE")!=-1&&c.indexOf("Opera")!=0}function
dV(a){return a.layout}var
cX=function(){function
m(a,b){return a+b|0}function
a(d,a,c,f,b,e){a=m(m(a,d),m(f,e));return m(a<<b|a>>>32-b,c)}function
h(c,b,d,e,h,f,g){return a(b&d|~b&e,c,b,h,f,g)}function
i(d,b,e,c,h,f,g){return a(b&c|e&~c,d,b,h,f,g)}function
j(c,b,d,e,h,f,g){return a(b^d^e,c,b,h,f,g)}function
k(c,b,d,e,h,f,g){return a(d^(b|~e),c,b,h,f,g)}function
n(g,o){var
e=o;g[e>>2]|=p<<8*(e&3);for(e=(e&~3)+8;(e&63)<60;e+=4)g[(e>>2)-1]=0;g[(e>>2)-1]=o<<3;g[e>>2]=o>>29&536870911;var
l=[1732584193,4023233417,2562383102,271733878];for(e=0;e<g.length;e+=16){var
a=l[0],b=l[1],c=l[2],d=l[3];a=h(a,b,c,d,g[e+0],7,3614090360);d=h(d,a,b,c,g[e+1],12,3905402710);c=h(c,d,a,b,g[e+2],17,606105819);b=h(b,c,d,a,g[e+3],22,3250441966);a=h(a,b,c,d,g[e+4],7,4118548399);d=h(d,a,b,c,g[e+5],12,1200080426);c=h(c,d,a,b,g[e+6],17,2821735955);b=h(b,c,d,a,g[e+7],22,4249261313);a=h(a,b,c,d,g[e+8],7,1770035416);d=h(d,a,b,c,g[e+9],12,2336552879);c=h(c,d,a,b,g[e+10],17,4294925233);b=h(b,c,d,a,g[e+11],22,2304563134);a=h(a,b,c,d,g[e+12],7,1804603682);d=h(d,a,b,c,g[e+13],12,4254626195);c=h(c,d,a,b,g[e+14],17,2792965006);b=h(b,c,d,a,g[e+15],22,1236535329);a=i(a,b,c,d,g[e+1],5,4129170786);d=i(d,a,b,c,g[e+6],9,3225465664);c=i(c,d,a,b,g[e+11],14,643717713);b=i(b,c,d,a,g[e+0],20,3921069994);a=i(a,b,c,d,g[e+5],5,3593408605);d=i(d,a,b,c,g[e+10],9,38016083);c=i(c,d,a,b,g[e+15],14,3634488961);b=i(b,c,d,a,g[e+4],20,3889429448);a=i(a,b,c,d,g[e+9],5,568446438);d=i(d,a,b,c,g[e+14],9,3275163606);c=i(c,d,a,b,g[e+3],14,4107603335);b=i(b,c,d,a,g[e+8],20,1163531501);a=i(a,b,c,d,g[e+13],5,2850285829);d=i(d,a,b,c,g[e+2],9,4243563512);c=i(c,d,a,b,g[e+7],14,1735328473);b=i(b,c,d,a,g[e+12],20,2368359562);a=j(a,b,c,d,g[e+5],4,4294588738);d=j(d,a,b,c,g[e+8],11,2272392833);c=j(c,d,a,b,g[e+11],16,1839030562);b=j(b,c,d,a,g[e+14],23,4259657740);a=j(a,b,c,d,g[e+1],4,2763975236);d=j(d,a,b,c,g[e+4],11,1272893353);c=j(c,d,a,b,g[e+7],16,4139469664);b=j(b,c,d,a,g[e+10],23,3200236656);a=j(a,b,c,d,g[e+13],4,681279174);d=j(d,a,b,c,g[e+0],11,3936430074);c=j(c,d,a,b,g[e+3],16,3572445317);b=j(b,c,d,a,g[e+6],23,76029189);a=j(a,b,c,d,g[e+9],4,3654602809);d=j(d,a,b,c,g[e+12],11,3873151461);c=j(c,d,a,b,g[e+15],16,530742520);b=j(b,c,d,a,g[e+2],23,3299628645);a=k(a,b,c,d,g[e+0],6,4096336452);d=k(d,a,b,c,g[e+7],10,1126891415);c=k(c,d,a,b,g[e+14],15,2878612391);b=k(b,c,d,a,g[e+5],21,4237533241);a=k(a,b,c,d,g[e+12],6,1700485571);d=k(d,a,b,c,g[e+3],10,2399980690);c=k(c,d,a,b,g[e+10],15,4293915773);b=k(b,c,d,a,g[e+1],21,2240044497);a=k(a,b,c,d,g[e+8],6,1873313359);d=k(d,a,b,c,g[e+15],10,4264355552);c=k(c,d,a,b,g[e+6],15,2734768916);b=k(b,c,d,a,g[e+13],21,1309151649);a=k(a,b,c,d,g[e+4],6,4149444226);d=k(d,a,b,c,g[e+11],10,3174756917);c=k(c,d,a,b,g[e+2],15,718787259);b=k(b,c,d,a,g[e+9],21,3951481745);l[0]=m(a,l[0]);l[1]=m(b,l[1]);l[2]=m(c,l[2]);l[3]=m(d,l[3])}var
q=new
Array(16);for(var
e=0;e<4;e++)for(var
n=0;n<4;n++)q[e*4+n]=l[e]>>8*n&f;return q}return function(h,g,f){var
e=[];switch(h.t&6){default:l(h);case
0:var
d=h.c;for(var
a=0;a<f;a+=4){var
b=a+g;e[a>>2]=d.charCodeAt(b)|d.charCodeAt(b+1)<<8|d.charCodeAt(b+2)<<16|d.charCodeAt(b+3)<<24}for(;a<f;a++)e[a>>2]|=d.charCodeAt(a+g)<<8*(a&3);break;case
4:var
c=h.c;for(var
a=0;a<f;a+=4){var
b=a+g;e[a>>2]=c[b]|c[b+1]<<8|c[b+2]<<16|c[b+3]<<24}for(;a<f;a++)e[a>>2]|=c[a+g]<<8*(a&3)}return ad(n(e,f))}}();function
gm(f,a){var
b=c[f],e=b.file.length();if(a<0)a=e-b.offset;if(b.offset+a>e)aV();var
d=B(a);b.file.read(b.offset,d,0,a);return cX(d,0,a)}function
fw(b,a){a=a&63;if(a==0)return b;var
d=b[3]<<16>>16;if(a<24)return[f,(b[1]>>a|b[2]<<24-a)&e,(b[2]>>a|d<<24-a)&e,b[3]<<16>>a>>>16];var
c=b[3]<<16>>31;if(a<48)return[f,(b[2]>>a-24|b[3]<<48-a)&e,b[3]<<16>>a-24>>16&e,c&o];return[f,b[3]<<16>>a-32&e,c&e,c&o]}function
eo(){return[0]}function
dH(b,a,c){if(a<0||a>=b.length-1)L();b[a+1]=c;return 0}function
eh(a,b){return cy(b,a)}function
c7(c,a){if(typeof
a==="function"){c.fun=a;return 0}if(a.fun){c.fun=a.fun;return 0}var
b=a.length;while(b--)c[b]=a[b];return 0}function
ct(b,c,d){if(typeof
b==="number")switch(b){case
0:c.fun=d;break;case
1:default:c7(c,d)}else
switch(b[0]){case
0:for(var
a=1;a<b[1].length;a++)ct(b[1][a],c[a],d[a]);break}return 0}function
h8(a,b,c){a[b]=c;if(a[b]<0)a[b]+=n;return 0}function
eA(a){return a[M]===undefined?0:[0,a[M]]}function
hR(b,a){return{joo_tramp:b,joo_args:a}}function
gz(c,a){var
b=[a>>24&f,a>>16&f,a>>8&f,a&f],d=ad(b);aR(c,d,0,4);return 0}var
ff=new
Date()*bJ;function
hO(){return new
Date()*bJ-ff}function
gn(b){var
a=c[b];return a.file.length()}function
dE(c,d){var
g=c.length,h=d.length,f=g+h-1,b=new
Array(f);b[0]=0;var
a=1,e=1;for(;a<g;a++)b[a]=c[a];for(;a<f;a++,e++)b[a]=d[e];return b}function
g6(){i("Printexc.get_raw_backtrace_slot: index out of bounds")}function
hm(a){return a}function
gM(a,b){c[a].refill=b;return 0}function
fq(a){return a[3]==z&&(a[1]|a[2])==0}function
fd(a,d,l){if(!isFinite(a)){if(isNaN(a))return Y(b7);return Y(a>0?"infinity":"-infinity")}var
j=a==0&&1/a==-Infinity?1:a>=0?0:1;if(j)a=-a;var
e=0;if(a==0);else
if(a<1)while(a<1&&e>-1022){a*=2;e--}else
while(a>=2){a/=2;e++}var
k=e<0?b:ak,f=b;if(j)f=P;else
switch(l){case
43:f=ak;break;case
32:f=J;break;default:break}if(d>=0&&d<13){var
h=Math.pow(2,d*4);a=Math.round(a*h)/h}var
c=a.toString(16);if(d>=0){var
i=c.indexOf(aC);if(i<0)c+=aC+ac(d,x);else{var
g=i+1+d;if(c.length<g)c+=ac(g-c.length,x);else
c=c.substr(0,g)}}return Y(f+bQ+c+cl+k+e.toString(10))}function
fI(a){ay("caml_js_expr: fallback to runtime evaluation");return eval(a.toString())}function
f8(c,e){return function(){var
d=arguments.length;if(d==c)return A(e,az(arguments,this));var
b=new
Array(c+1);b[0]=this;for(var
a=1;a<d&&a<=c;a++)b[a]=arguments[a];return A(e,b)}}function
gE(a){return bv}function
d9(){return 0}function
fi(){return 0}function
dP(a,b){a.fill(b);return 0}function
eZ(){return[0,0,0,0,0,0,0,0,0]}function
g0(a,b){return ad(ai(a))}function
gO(a){if(isFinite(a)){var
d=1/a<0;a=Math.abs(a);var
b=Math.floor(a),c=a-b;if(d){b=-b;c=-c}return[0,c,b]}if(isNaN(a))return[0,NaN,NaN];return[0,1/a,a]}function
fc(d,g,a){var
b=0;function
f(a){g--;if(d<0||g<0)return;if(a
instanceof
Array&&a[0]===(a[0]|0))switch(a[0]){case
248:d--;b=b*aD+a[2]|0;break;case
250:g++;f(a);break;case
255:d--;b=b*aD+a[1]+(a[2]<<24)|0;break;default:d--;b=b*19+a[0]|0;for(var
c=a.length-1;c>0;c--)f(a[c])}else
if(a
instanceof
q){d--;switch(a.t&6){default:l(a);case
0:for(var
i=a.c,e=a.l,c=0;c<e;c++)b=b*19+i.charCodeAt(c)|0;break;case
2:for(var
h=a.c,e=a.l,c=0;c<e;c++)b=b*19+h[c]|0}}else
if(a===(a|0)){d--;b=b*aD+a|0}else
if(a===+a){d--;var
j=aK(bj(a));for(var
c=7;c>=0;c--)b=b*19+j[c]|0}else
if(a&&a.hash&&typeof
a.hash==="function")b=b*aD+a.hash()|0}f(a);return b&bU}function
eP(a,b){if(a===b)return 0;if(a<b)return-1;if(a>b)return 1;if(a===a)return 1;if(b===b)return-1;return 0}function
hp(c,a,b){return cB(c,a,b)}function
g1(b,a,g,m){var
w=_,v=6,ab=7,P=8,Q=9,E=10,J=0,s=1,H=2,I=3,G=4,F=5,p=1,D=2,C=3,q=4,A=5,M=6,f=7,u=8,O=9,N=10,x=11,K=12,L=13,z=14,B=15,y=16,aa=2,$=3,W=4,V=5,S=6,T=7,Y=8,X=9,U=10,r=11,Z=12,R=13;if(!b.dgoto){b.defred=j(b[S]);b.sindex=j(b[Y]);b.check=j(b[R]);b.rindex=j(b[X]);b.table=j(b[Z]);b.len=j(b[V]);b.lhs=j(b[W]);b.gindex=j(b[U]);b.dgoto=j(b[T])}var
l=0,k,e,d,o,c=a[z],h=a[B],i=a[y];exit:for(;;)switch(g){case
0:h=0;i=0;case
6:k=b.defred[h];if(k!=0){g=E;break}if(a[f]>=0){g=ab;break}l=J;break exit;case
1:if(m
instanceof
Array){a[f]=b[$][m[0]+1];a[u]=m[1]}else{a[f]=b[aa][m+1];a[u]=0}case
7:e=b.sindex[h];d=e+a[f];if(e!=0&&d>=0&&d<=b[r]&&b.check[d]==a[f]){g=P;break}e=b.rindex[h];d=e+a[f];if(e!=0&&d>=0&&d<=b[r]&&b.check[d]==a[f]){k=b.table[d];g=E;break}if(i<=0){l=F;break exit}case
5:if(i<3){i=3;for(;;){o=a[p][c+1];e=b.sindex[o];d=e+w;if(e!=0&&d>=0&&d<=b[r]&&b.check[d]==w){g=Q;break}else{if(c<=a[M])return s;c--}}}else{if(a[f]==0)return s;a[f]=-1;g=v;break}case
8:a[f]=-1;if(i>0)i--;case
9:h=b.table[d];c++;if(c>=a[A]){l=H;break exit}case
2:a[p][c+1]=h;a[D][c+1]=a[u];a[C][c+1]=a[O];a[q][c+1]=a[N];g=v;break;case
10:var
n=b.len[k];a[x]=c;a[L]=k;a[K]=n;c=c-n+1;n=b.lhs[k];o=a[p][c];e=b.gindex[n];d=e+o;h=e!=0&&d>=0&&d<=b[r]&&b.check[d]==o?b.table[d]:b.dgoto[n];if(c>=a[A]){l=I;break exit}case
3:l=G;break exit;case
4:a[p][c+1]=h;a[D][c+1]=m;var
t=a[x];a[q][c+1]=a[q][t+1];if(c>t)a[C][c+1]=a[q][t+1];g=v;break;default:return s}a[z]=c;a[B]=h;a[y]=i;return l}function
h7(b){var
d=b.length,c=new
Array(d);for(var
a=0;a<d;a++)c[a]=b[a];return c}function
gZ(e,c,b,f,g){var
a=ai(f);if(a.length>b)d(ci);V(a,0,e,c,a.length);return 0}function
g2(a){ay("caml_pure_js_expr: fallback to runtime evaluation");return eval(a.toString())}function
d$(d,a,e,b,c){return V(d,a,e,b,c)}function
dC(c,e,d,f,b){for(var
a=0;a<b;a++)c[e+a]=d[f+a];return 0}function
ds(e,b,f,c,d){for(var
a=0;a<d;a++)af(f,c+a,m(e,b+a));return 0}function
hl(a,b){return 1-bx(a,b)}function
fy(a,b){return[f,a[1]^b[1],a[2]^b[2],a[3]^b[3]]}function
ei(a,b){return cz(b,a)}function
g7(e){var
a=I(e);if(a.device.exists(a.rest)){var
c=a.device.open(a.rest,{rdonly:1}),d=c.length(),b=B(d);c.read(0,b,0,d);return b}aw(e)}function
gL(b,d){var
a=c[b];g.fds[a.fd].output=d;return 0}function
f1(a){return a}function
g_(a,b){bq[R(a)]=b;return 0}function
dL(a,b){return a.nth_dim(b)}a.jsoo_runtime={caml_ephe_check_data:ex,caml_ephe_unset_data:eG,caml_ephe_set_data:eE,caml_ephe_get_data_copy:eB,caml_ephe_get_data:eA,caml_ephe_blit_data:ev,caml_ephe_unset_key:eH,caml_ephe_set_key:eF,caml_ephe_check_key:ey,caml_ephe_get_key_copy:eD,caml_ephe_get_key:eC,caml_ephe_blit_key:ew,caml_ephe_create:ez,caml_weak_blit:c_,caml_weak_check:c$,caml_weak_get_copy:db,caml_weak_get:by,caml_weak_set:bz,caml_weak_create:da,caml_ephe_data_offset:M,caml_ephe_key_offset:C,caml_hash_mix_bigstring:fb,bigstring_marshal_blit_stub:dv,bigstring_marshal_stub:dx,bigstring_unmarshal_stub:dB,bigstring_marshal_data_size_stub:dw,bigstring_of_array_buffer:dz,bigstring_to_array_buffer:dA,bigstring_find:du,bigstring_memcmp_stub:dy,bigstring_blit_stub:ds,caml_blit_string_to_bigstring:ea,bigstring_blit_bytes_bigstring_stub:dr,bigstring_blit_string_bigstring_stub:cs,caml_blit_bigstring_to_string:d_,bigstring_blit_bigstring_string_stub:dq,bigstring_blit_bigstring_bytes_stub:bc,bigstring_destroy_stub:dt,bigstring_alloc:cr,caml_json:f_,JSON:T,caml_gc_get:eZ,caml_gc_set:e3,caml_gc_stat:e4,caml_gc_quick_stat:e2,caml_gc_counters:eX,caml_gc_compaction:eW,caml_gc_full_major:eY,caml_gc_major:e0,caml_gc_minor:e1,caml_CamlinternalMod_update_mod:ct,caml_CamlinternalMod_init_mod:dD,caml_js_export_var:fH,caml_js_object:fU,caml_pure_js_expr:g2,caml_js_expr:fI,caml_js_eval_string:fG,caml_js_to_byte_string:f0,caml_js_equals:fE,caml_js_wrap_meth_callback_unsafe:f9,caml_js_wrap_meth_callback_strict:f8,caml_js_wrap_meth_callback_arguments:f7,caml_js_wrap_meth_callback:f6,caml_js_wrap_callback_strict:f5,caml_js_wrap_callback_arguments:f4,caml_js_wrap_callback:cU,caml_ojs_new_arr:gX,caml_js_new:fT,caml_js_meth_call:fS,caml_js_fun_call:fM,caml_js_call:fC,caml_js_var:f3,caml_js_to_array:fY,caml_js_from_array:N,caml_js_from_string:fL,caml_js_to_float:f1,caml_js_from_float:fK,caml_js_to_bool:fZ,caml_js_from_bool:fJ,js_print_stderr:ay,js_print_stdout:di,caml_trampoline_return:hR,caml_trampoline:hQ,caml_js_get_console:fO,caml_js_html_entities:fP,caml_js_html_escape:fQ,caml_js_on_ie:fV,caml_js_typeof:f2,caml_js_instanceof:fR,caml_js_delete:fD,caml_js_get:fN,caml_js_set:fX,caml_js_pure_expr:fW,MlNodeFile:H,MlNodeDevice:G,fs_node_supported:dg,MlFakeFile:r,MlFakeDevice:u,caml_read_file_content:g7,caml_create_file:bh,caml_fs_init:cE,caml_create_file_extern:es,caml_ba_map_file_bytecode:dW,caml_ba_map_file:cx,caml_sys_rename:hM,caml_sys_is_directory:hG,caml_sys_remove:hL,caml_sys_read_directory:hK,caml_sys_file_exists:hB,caml_raise_not_a_dir:g3,caml_raise_no_such_file:aw,caml_sys_chdir:hr,caml_sys_getcwd:hE,caml_unmount:hS,caml_mount_autoload:gP,resolve_fs_device:I,caml_list_mount_point:gf,jsoo_mount_point:E,caml_make_path:aO,MlFile:ba,caml_root:ab,caml_current_dir:X,caml_ml_output_int:gz,caml_ml_pos_out_64:gD,caml_ml_pos_out:gC,caml_ml_seek_out_64:gI,caml_ml_seek_out:gH,caml_output_value:gY,caml_ml_output_char:gy,caml_ml_output:aR,caml_ml_output_bytes:cY,caml_ml_flush:bn,caml_ml_input_scan_line:gu,caml_ml_pos_in_64:gB,caml_ml_pos_in:gA,caml_ml_seek_in_64:gG,caml_ml_seek_in:gF,caml_ml_input_int:gt,caml_ml_input_char:gs,caml_input_value:fg,caml_ml_input:gr,caml_ml_may_refill_input:bo,caml_ml_refill_input:aS,caml_ml_set_channel_refill:gM,caml_ml_set_channel_output:gL,caml_ml_channel_size_64:go,caml_ml_channel_size:gn,caml_ml_close_channel:gp,caml_ml_set_binary_mode:gJ,caml_ml_open_descriptor_in:gv,caml_ml_open_descriptor_out:gw,caml_ml_out_channels_list:gx,caml_ml_channels:c,caml_ml_set_channel_name:gK,caml_sys_open:hI,caml_std_output:bw,caml_sys_close:c5,caml_is_js:fA,caml_spacetime_only_works_for_native_code:hf,caml_register_channel_for_spacetime:g9,caml_spacetime_enabled:he,caml_sys_isatty:hH,caml_runtime_parameters:g$,caml_runtime_variant:ha,caml_ml_runtime_warnings_enabled:gE,caml_ml_enable_runtime_warnings:gq,caml_runtime_warnings:bv,caml_list_of_js_array:gg,caml_int64_bswap:fn,caml_int32_bswap:fk,caml_bswap16:eb,caml_convert_raw_backtrace_slot:ep,caml_install_signal_handler:fi,caml_fresh_oo_id:eU,caml_set_oo_id:hb,caml_oo_last_id:br,unix_inet_addr_of_string:ia,caml_sys_get_argv:hC,caml_sys_exit:hA,caml_sys_getenv:hF,caml_get_current_callstack:e5,caml_raw_backtrace_slot:g6,caml_raw_backtrace_next_slot:g5,caml_raw_backtrace_length:g4,caml_convert_raw_backtrace:eo,caml_record_backtrace:g8,caml_get_exception_raw_backtrace:e7,caml_get_exception_backtrace:e6,caml_backtrace_status:d9,caml_final_release:eO,caml_final_register_called_without_value:eN,caml_final_register:eM,caml_get_public_method:e9,caml_array_blit:cu,caml_array_concat:dF,caml_array_append:dE,caml_array_sub:dI,caml_sys_system_command:hN,caml_sys_const_ostype_win32:hy,caml_sys_const_ostype_unix:hx,caml_sys_const_ostype_cygwin:hw,caml_sys_const_max_wosize:hv,caml_sys_const_int_size:hu,caml_sys_const_word_size:hz,caml_sys_const_big_endian:ht,caml_sys_random_seed:hJ,caml_sys_const_backend_type:hs,caml_sys_get_config:hD,caml_sys_time:hO,caml_hash:fa,caml_hash_mix_string:cI,caml_hash_mix_string_arr:bi,caml_hash_mix_string_str:cJ,caml_hash_mix_int64:cH,caml_hash_mix_float:cG,caml_hash_mix_final:cF,caml_hash_mix_int:D,caml_hash_univ_param:fc,caml_format_float:eS,caml_format_int:eT,caml_finish_formatting:aG,caml_parse_format:aT,caml_is_printable:fB,caml_float_of_string:eQ,caml_int_of_string:fz,caml_parse_digit:av,caml_parse_sign_and_base:bs,caml_lessthan:gc,caml_lessequal:gb,caml_greaterthan:e$,caml_greaterequal:e_,caml_notequal:gR,caml_equal:eI,caml_int_compare:cT,caml_compare:en,caml_compare_val:W,caml_floatarray_create:eR,caml_make_float_vect:gj,caml_make_vect:gk,caml_check_bound:el,caml_array_get:dG,caml_array_set:dH,caml_mod:gN,caml_div:eu,caml_mul:at,caml_lazy_make_forward:f$,caml_obj_truncate:gW,caml_obj_dup:au,caml_obj_block:gS,caml_obj_set_tag:gU,caml_obj_tag:gV,caml_obj_is_block:gT,caml_update_dummy:c7,caml_array_bound_error:L,caml_raise_not_found:c0,caml_raise_zero_divide:ax,caml_raise_end_of_file:aV,caml_invalid_argument:i,caml_js_error_of_exception:fF,caml_exn_with_js_backtrace:eJ,caml_wrap_exception:hT,caml_failwith:d,caml_raise_sys_error:s,caml_raise_with_string:aW,caml_raise_with_arg:bt,caml_return_exn_constant:bu,caml_raise_constant:aU,caml_get_global_data:e8,caml_register_global:y,caml_global_data:g,caml_named_value:bp,caml_register_named_value:g_,caml_named_values:bq,caml_call_gen:A,raw_array_append_one:dl,raw_array_cons:az,raw_array_copy:h7,raw_array_sub:aj,win_handle_fd:ie,win_cleanup:id,win_startup:ig,unix_mktime:ib,unix_localtime:dp,unix_gmtime:h$,unix_time:ic,unix_gettimeofday:dn,caml_ba_reshape:dY,caml_ba_slice:d2,caml_ba_sub:d3,caml_ba_fill:dP,caml_ba_blit:dJ,caml_ba_set_3:d0,caml_ba_set_2:dZ,caml_ba_set_1:af,caml_ba_uint8_set64:d8,caml_ba_uint8_set32:d7,caml_ba_uint8_set16:d6,caml_ba_set_generic:d1,caml_ba_get_3:dR,caml_ba_get_2:dQ,caml_ba_get_1:m,caml_ba_uint8_get64:d5,caml_ba_uint8_get32:bd,caml_ba_uint8_get16:d4,caml_ba_get_generic:dS,caml_ba_dim_3:dO,caml_ba_dim_2:dN,caml_ba_dim_1:dM,caml_ba_dim:dL,caml_ba_num_dims:dX,caml_ba_layout:dV,caml_ba_kind:dU,caml_ba_change_layout:dK,caml_ba_create:cv,caml_ba_create_from:U,caml_ba_views:ao,caml_ba_get_size:aF,caml_ba_init_views:cw,caml_ba_init:dT,caml_set_parser_trace:hc,caml_parse_engine:g1,caml_new_lex_engine:gQ,caml_lex_engine:gd,caml_lex_array:j,caml_output_value_to_buffer:gZ,caml_output_value_to_bytes:g0,caml_output_value_to_string:cZ,caml_output_val:ai,caml_marshal_data_size:cW,caml_input_value_from_reader:aH,caml_input_value_from_bytes:fh,caml_input_value_from_string:cK,caml_float_of_bytes:$,BigStringReader:a_,MlBytesReader:aE,caml_marshal_constants:gl,caml_md5_string:cX,caml_md5_chan:gm,caml_int64_to_bytes:aK,caml_int64_of_bytes:aq,caml_int64_of_string:ft,caml_int64_format:fp,caml_int64_of_float:aJ,caml_int64_to_float:bl,caml_int64_to_int32:cS,caml_int64_of_int32:ar,caml_int64_mod:fs,caml_int64_div:fo,caml_int64_udivmod:as,caml_int64_lsr1:cP,caml_int64_lsl1:bk,caml_int64_shift_right:fw,caml_int64_shift_right_unsigned:fx,caml_int64_shift_left:fv,caml_int64_xor:fy,caml_int64_or:fu,caml_int64_and:fm,caml_int64_is_minus_one:fr,caml_int64_is_min_int:fq,caml_int64_is_negative:cO,caml_int64_is_zero:aI,caml_int64_mul:cQ,caml_int64_sub:cR,caml_int64_add:cL,caml_int64_neg:Q,caml_int64_compare:cM,caml_int64_ult:aM,caml_int64_ucompare:aL,caml_int64_offset:ah,caml_tanh_float:hP,caml_sinh_float:hd,caml_cosh_float:er,caml_log10_float:gh,caml_hypot_float:fe,caml_log1p_float:gi,caml_expm1_float:eK,caml_copysign_float:eq,caml_float_compare:eP,caml_frexp_float:eV,caml_ldexp_float:ga,caml_modf_float:gO,caml_classify_float:em,caml_int32_float_of_bits:fl,caml_int64_float_of_bits:cN,caml_hexstring_of_float:fd,caml_int32_bits_of_float:fj,caml_int64_bits_of_float:bj,jsoo_floor_log2:bB,caml_bytes_of_string:ek,caml_string_of_bytes:hm,caml_ml_bytes_length:aQ,caml_ml_string_length:aa,caml_blit_string:d$,caml_blit_bytes:V,caml_fill_string:eL,caml_fill_bytes:cD,caml_bytes_greaterthan:ei,caml_string_greaterthan:hk,caml_bytes_greaterequal:eh,caml_string_greaterequal:hj,caml_bytes_lessthan:cz,caml_string_lessthan:c4,caml_bytes_lessequal:cy,caml_string_lessequal:c3,caml_bytes_notequal:ej,caml_string_notequal:hl,caml_bytes_equal:ed,caml_string_equal:bx,caml_bytes_compare:ec,caml_string_compare:c1,caml_string_of_array:ad,caml_new_string:h,caml_create_bytes:B,caml_create_string:et,caml_js_to_string:Y,caml_jsbytes_of_string:R,caml_array_of_string:an,caml_convert_string_to_array:ap,caml_convert_string_to_bytes:l,MlBytes:q,caml_bytes_set:bf,caml_string_set64:hq,caml_bytes_set64:cC,caml_string_set32:hp,caml_bytes_set32:cB,caml_string_set16:ho,caml_bytes_set16:cA,caml_string_set:hn,caml_bytes_get:be,caml_bytes_get64:eg,caml_string_get64:hi,caml_bytes_get32:ef,caml_string_get32:hh,caml_bytes_get16:ee,caml_string_get16:hg,caml_string_get:c2,caml_string_bound_error:v,caml_string_unsafe_set:S,caml_bytes_unsafe_set:bg,caml_bytes_unsafe_get:ag,caml_string_unsafe_get:k,caml_to_js_string:c6,caml_is_ascii:bm,caml_utf16_of_utf8:c8,caml_utf8_of_utf16:c9,caml_subarray_to_string:aX,caml_str_repeat:ac,lxor_digit_nat:h4,lor_digit_nat:h3,land_digit_nat:h1,compare_nat:dc,compare_digits_nat:hU,shift_right_nat:bF,div_nat:hW,div_digit_nat:df,div_helper:bA,shift_left_nat:bE,square_nat:h_,mult_nat:dj,mult_digit_nat:bC,sub_nat:bG,decr_nat:de,complement_nat:hV,add_nat:bb,incr_nat:dh,is_digit_odd:hZ,is_digit_zero:h0,is_digit_int:hY,num_leading_zero_bits_in_digit:dk,num_digits_nat:bD,nth_digit_nat_native:h6,set_digit_nat_native:h9,nth_digit_nat:h5,set_digit_nat:h8,blit_nat:dC,set_to_zero_nat:dm,create_nat:dd,initialize_nat:hX};cE();y(0,[w,h(cd),0],cd);y(1,[w,h(bW),-1],bW);y(2,[w,h(b0),-2],b0);y(3,[w,h(cp),-3],cp);y(4,[w,h(b1),-4],b1);y(5,[w,h(bX),-5],bX);y(6,[w,h(bM),-6],bM);y(7,[w,h(b9),-7],b9);y(8,[w,h(bN),-8],bN);y(9,[w,h(cj),-9],cj);y(10,[w,h(b5),-10],b5);y(11,[w,h(bI),-11],bI);return}(function(){return this}()));

//# 1 "../.js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_sub=runtime.caml_array_sub,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_of_string=runtime.caml_bytes_of_string,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtrace=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_input_int=runtime.caml_ml_input_int,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_output_int=runtime.caml_ml_output_int,
     caml_ml_pos_in=runtime.caml_ml_pos_in,
     caml_ml_pos_out=runtime.caml_ml_pos_out,
     caml_ml_seek_in=runtime.caml_ml_seek_in,
     caml_ml_seek_out=runtime.caml_ml_seek_out,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_set_tag=runtime.caml_obj_set_tag,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_obj_truncate=runtime.caml_obj_truncate,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_spacetime_enabled=runtime.caml_spacetime_enabled,
     caml_spacetime_only_works_for_native_code=
      runtime.caml_spacetime_only_works_for_native_code,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_bytes=runtime.caml_string_of_bytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_weak_blit=runtime.caml_weak_blit,
     caml_weak_check=runtime.caml_weak_check,
     caml_weak_create=runtime.caml_weak_create,
     caml_weak_get=runtime.caml_weak_get,
     caml_weak_get_copy=runtime.caml_weak_get_copy,
     caml_weak_set=runtime.caml_weak_set,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_new_string("%,"),
     cst_really_input=caml_new_string("really_input"),
     cst_input=caml_new_string("input"),
     cst_output_substring=caml_new_string("output_substring"),
     cst_output=caml_new_string("output"),
     cst_12g=caml_new_string("%.12g"),
     cst=caml_new_string("."),
     cst_false$1=caml_new_string("false"),
     cst_true$1=caml_new_string("true"),
     cst_false$0=caml_new_string("false"),
     cst_true$0=caml_new_string("true"),
     cst_bool_of_string=caml_new_string("bool_of_string"),
     cst_true=caml_new_string("true"),
     cst_false=caml_new_string("false"),
     cst_char_of_int=caml_new_string("char_of_int"),
     cst_Stdlib_Pervasives_Exit=caml_new_string("Stdlib.Pervasives.Exit"),
     cst$1=caml_new_string("\\\\"),
     cst$2=caml_new_string("\\'"),
     cst_b=caml_new_string("\\b"),
     cst_t=caml_new_string("\\t"),
     cst_n=caml_new_string("\\n"),
     cst_r=caml_new_string("\\r"),
     cst_Char_chr=caml_new_string("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_new_string(" is not a latin1 character"),
     cst_04X=caml_new_string("%04X"),
     cst_U=caml_new_string("U+"),
     cst_is_not_an_Unicode_scalar_value=
      caml_new_string(" is not an Unicode scalar value"),
     cst_X=caml_new_string("%X"),
     err_no_pred=caml_new_string("U+0000 has no predecessor"),
     err_no_succ=caml_new_string("U+10FFFF has no successor"),
     cst_Stdlib_Sys_Break=caml_new_string("Stdlib.Sys.Break"),
     ocaml_version=caml_new_string("4.07.1"),
     cst_List_map2=caml_new_string("List.map2"),
     cst_List_iter2=caml_new_string("List.iter2"),
     cst_List_fold_left2=caml_new_string("List.fold_left2"),
     cst_List_fold_right2=caml_new_string("List.fold_right2"),
     cst_List_for_all2=caml_new_string("List.for_all2"),
     cst_List_exists2=caml_new_string("List.exists2"),
     cst_List_combine=caml_new_string("List.combine"),
     cst_List_rev_map2=caml_new_string("List.rev_map2"),
     cst_List_init=caml_new_string("List.init"),
     cst_List_nth$0=caml_new_string("List.nth"),
     cst_nth=caml_new_string("nth"),
     cst_List_nth=caml_new_string("List.nth"),
     cst_tl=caml_new_string("tl"),
     cst_hd=caml_new_string("hd"),
     cst_Bytes_of_seq_cannot_grow_bytes=
      caml_new_string("Bytes.of_seq: cannot grow bytes"),
     cst_String_rcontains_from_Bytes_rcontains_from=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_new_string("Bytes.concat"),
     cst_String_blit_Bytes_blit_string=
      caml_new_string("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_new_string("Bytes.blit"),
     cst_String_fill_Bytes_fill=caml_new_string("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_new_string("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_new_string("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Bytes_rcontains_from$0=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from$0=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt$0=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from$0=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt$0=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from$0=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst$4=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_String_concat=caml_new_string("String.concat"),
     cst_Sort_array=caml_new_string("Sort.array"),
     cst_Marshal_from_bytes=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_new_string("Marshal.data_size"),
     cst_Marshal_to_buffer_substring_out_of_bounds=
      caml_new_string("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_extension_constructor$0=
      caml_new_string("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_new_string("Obj.extension_constructor"),
     cst_Array_map2_arrays_must_have_the_same_length=
      caml_new_string("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_have_the_same_length=
      caml_new_string("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_new_string("Array.blit"),
     cst_Array_fill=caml_new_string("Array.fill"),
     cst_Array_sub=caml_new_string("Array.sub"),
     cst_Array_init=caml_new_string("Array.init"),
     cst_Stdlib_Array_Bottom=caml_new_string("Stdlib.Array.Bottom"),
     cst_d=caml_new_string("%d"),
     cst_d$0=caml_new_string("%d"),
     zero$0=[255,0,0,0],
     one$0=[255,1,0,0],
     minus_one$0=[255,16777215,16777215,65535],
     min_int$1=[255,0,0,32768],
     max_int$1=[255,16777215,16777215,32767],
     cst_d$1=caml_new_string("%d"),
     cst_Lexing_lex_refill_cannot_grow_buffer=
      caml_new_string("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_new_string(""),0,0,-1],
     zero_pos=[0,caml_new_string(""),1,0,0],
     cst_syntax_error=caml_new_string("syntax error"),
     cst_Stdlib_Parsing_YYexit=caml_new_string("Stdlib.Parsing.YYexit"),
     cst_Stdlib_Parsing_Parse_error=
      caml_new_string("Stdlib.Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_new_string("Set.remove_min_elt"),
     cst_Set_bal=caml_new_string("Set.bal"),
     cst_Set_bal$0=caml_new_string("Set.bal"),
     cst_Set_bal$1=caml_new_string("Set.bal"),
     cst_Set_bal$2=caml_new_string("Set.bal"),
     cst_Map_remove_min_elt=caml_new_string("Map.remove_min_elt"),
     cst_Map_bal=caml_new_string("Map.bal"),
     cst_Map_bal$0=caml_new_string("Map.bal"),
     cst_Map_bal$1=caml_new_string("Map.bal"),
     cst_Map_bal$2=caml_new_string("Map.bal"),
     cst_Stdlib_Stack_Empty=caml_new_string("Stdlib.Stack.Empty"),
     cst_Stdlib_Queue_Empty=caml_new_string("Stdlib.Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_new_string("CamlinternalLazy.Undefined"),
     cst_count=caml_new_string("{count = "),
     cst_data=caml_new_string("; data = "),
     cst$5=caml_new_string("}"),
     cst_Sempty=caml_new_string("Sempty"),
     cst_Scons=caml_new_string("Scons ("),
     cst$6=caml_new_string(", "),
     cst$7=caml_new_string(")"),
     cst_Sapp=caml_new_string("Sapp ("),
     cst$8=caml_new_string(", "),
     cst$9=caml_new_string(")"),
     cst_Slazy=caml_new_string("Slazy"),
     cst_Sgen=caml_new_string("Sgen"),
     cst_Sbuffio=caml_new_string("Sbuffio"),
     cst_Stdlib_Stream_Failure=caml_new_string("Stdlib.Stream.Failure"),
     cst_Stdlib_Stream_Error=caml_new_string("Stdlib.Stream.Error"),
     cst_Buffer_truncate=caml_new_string("Buffer.truncate"),
     cst_Buffer_add_channel=caml_new_string("Buffer.add_channel"),
     cst_Buffer_add_substring_add_subbytes=
      caml_new_string("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buffer=
      caml_new_string("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_new_string("Buffer.nth"),
     cst_Buffer_blit=caml_new_string("Buffer.blit"),
     cst_Buffer_sub=caml_new_string("Buffer.sub"),
     cst_c=caml_new_string("%c"),
     cst_s=caml_new_string("%s"),
     cst_i=caml_new_string("%i"),
     cst_li=caml_new_string("%li"),
     cst_ni=caml_new_string("%ni"),
     cst_Li=caml_new_string("%Li"),
     cst_f=caml_new_string("%f"),
     cst_B=caml_new_string("%B"),
     cst$20=caml_new_string("%{"),
     cst$21=caml_new_string("%}"),
     cst$22=caml_new_string("%("),
     cst$23=caml_new_string("%)"),
     cst_a=caml_new_string("%a"),
     cst_t$0=caml_new_string("%t"),
     cst$24=caml_new_string("%?"),
     cst_r$0=caml_new_string("%r"),
     cst_r$1=caml_new_string("%_r"),
     cst_u$0=caml_new_string("%u"),
     cst_Printf_bad_conversion=caml_new_string("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=caml_new_string("Printf: bad conversion %_"),
     cst$28=caml_new_string("@{"),
     cst$29=caml_new_string("@["),
     cst$30=caml_new_string("@{"),
     cst$31=caml_new_string("@["),
     cst$32=caml_new_string("@{"),
     cst$33=caml_new_string("@["),
     cst_0=caml_new_string("0"),
     cst_padding=caml_new_string("padding"),
     cst_precision=caml_new_string("precision"),
     cst$38=caml_new_string("'*'"),
     cst$36=caml_new_string("'-'"),
     cst_0$2=caml_new_string("'0'"),
     cst$37=caml_new_string("'*'"),
     cst_0$0=caml_new_string("0"),
     cst_0$1=caml_new_string("0"),
     cst_precision$0=caml_new_string("precision"),
     cst_precision$1=caml_new_string("precision"),
     cst$39=caml_new_string("'+'"),
     cst$40=caml_new_string("'#'"),
     cst$41=caml_new_string("' '"),
     cst_padding$0=caml_new_string("`padding'"),
     cst_precision$2=caml_new_string("`precision'"),
     cst$42=caml_new_string("'+'"),
     cst$43=caml_new_string("'_'"),
     sub_format=[0,0,caml_new_string("")],
     formatting_lit=[0,caml_new_string("@;"),1,0],
     cst_digit=caml_new_string("digit"),
     cst_character=caml_new_string("character ')'"),
     cst_character$0=caml_new_string("character '}'"),
     cst$47=caml_new_string("'#'"),
     cst$46=caml_new_string("'+'"),
     cst$45=caml_new_string("'+'"),
     cst$44=caml_new_string("' '"),
     cst$50=caml_new_string("'+'"),
     cst$49=caml_new_string("'+'"),
     cst$48=caml_new_string("' '"),
     cst_non_zero_widths_are_unsupported_for_c_conversions=
      caml_new_string("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=caml_new_string("unexpected end of format"),
     cst$34=caml_new_string(""),
     cst$35=caml_new_string(""),
     cst_b$0=caml_new_string("b"),
     cst_h=caml_new_string("h"),
     cst_hov=caml_new_string("hov"),
     cst_hv=caml_new_string("hv"),
     cst_v=caml_new_string("v"),
     cst_nan=caml_new_string("nan"),
     cst$27=caml_new_string("."),
     cst_neg_infinity=caml_new_string("neg_infinity"),
     cst_infinity=caml_new_string("infinity"),
     cst_12g$0=caml_new_string("%.12g"),
     cst_nd=caml_new_string("%nd"),
     cst_nd$0=caml_new_string("%+nd"),
     cst_nd$1=caml_new_string("% nd"),
     cst_ni$0=caml_new_string("%ni"),
     cst_ni$1=caml_new_string("%+ni"),
     cst_ni$2=caml_new_string("% ni"),
     cst_nx=caml_new_string("%nx"),
     cst_nx$0=caml_new_string("%#nx"),
     cst_nX=caml_new_string("%nX"),
     cst_nX$0=caml_new_string("%#nX"),
     cst_no=caml_new_string("%no"),
     cst_no$0=caml_new_string("%#no"),
     cst_nu=caml_new_string("%nu"),
     cst_ld=caml_new_string("%ld"),
     cst_ld$0=caml_new_string("%+ld"),
     cst_ld$1=caml_new_string("% ld"),
     cst_li$0=caml_new_string("%li"),
     cst_li$1=caml_new_string("%+li"),
     cst_li$2=caml_new_string("% li"),
     cst_lx=caml_new_string("%lx"),
     cst_lx$0=caml_new_string("%#lx"),
     cst_lX=caml_new_string("%lX"),
     cst_lX$0=caml_new_string("%#lX"),
     cst_lo=caml_new_string("%lo"),
     cst_lo$0=caml_new_string("%#lo"),
     cst_lu=caml_new_string("%lu"),
     cst_Ld=caml_new_string("%Ld"),
     cst_Ld$0=caml_new_string("%+Ld"),
     cst_Ld$1=caml_new_string("% Ld"),
     cst_Li$0=caml_new_string("%Li"),
     cst_Li$1=caml_new_string("%+Li"),
     cst_Li$2=caml_new_string("% Li"),
     cst_Lx=caml_new_string("%Lx"),
     cst_Lx$0=caml_new_string("%#Lx"),
     cst_LX=caml_new_string("%LX"),
     cst_LX$0=caml_new_string("%#LX"),
     cst_Lo=caml_new_string("%Lo"),
     cst_Lo$0=caml_new_string("%#Lo"),
     cst_Lu=caml_new_string("%Lu"),
     cst_d$2=caml_new_string("%d"),
     cst_d$3=caml_new_string("%+d"),
     cst_d$4=caml_new_string("% d"),
     cst_i$0=caml_new_string("%i"),
     cst_i$1=caml_new_string("%+i"),
     cst_i$2=caml_new_string("% i"),
     cst_x=caml_new_string("%x"),
     cst_x$0=caml_new_string("%#x"),
     cst_X$0=caml_new_string("%X"),
     cst_X$1=caml_new_string("%#X"),
     cst_o=caml_new_string("%o"),
     cst_o$0=caml_new_string("%#o"),
     cst_u=caml_new_string("%u"),
     cst$25=caml_new_string("%!"),
     cst$26=caml_new_string("@{"),
     cst_0c=caml_new_string("0c"),
     cst$19=caml_new_string("%%"),
     cst$11=caml_new_string("@]"),
     cst$12=caml_new_string("@}"),
     cst$13=caml_new_string("@?"),
     cst$14=caml_new_string("@\n"),
     cst$15=caml_new_string("@."),
     cst$16=caml_new_string("@@"),
     cst$17=caml_new_string("@%"),
     cst$18=caml_new_string("@"),
     cst$10=caml_new_string(".*"),
     cst_CamlinternalFormat_Type_mismatch=
      caml_new_string("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_new_string(""),
     cst$59=caml_new_string("\n"),
     cst_a_boolean=caml_new_string("a boolean"),
     cst_an_integer=caml_new_string("an integer"),
     cst_an_integer$0=caml_new_string("an integer"),
     cst_a_float=caml_new_string("a float"),
     cst_a_float$0=caml_new_string("a float"),
     cst$55=caml_new_string(""),
     cst$56=caml_new_string(" "),
     cst$57=caml_new_string(""),
     cst_one_of=caml_new_string("one of: "),
     cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic=
      caml_new_string
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_new_string("no argument"),
     cst$54=caml_new_string("(?)"),
     cst_help$3=caml_new_string("--help"),
     cst_help$4=caml_new_string("-help"),
     cst_help$2=caml_new_string("-help"),
     cst_Display_this_list_of_options=
      caml_new_string(" Display this list of options"),
     cst_help=caml_new_string("-help"),
     cst_help$1=caml_new_string("--help"),
     cst_Display_this_list_of_options$0=
      caml_new_string(" Display this list of options"),
     cst_help$0=caml_new_string("--help"),
     cst$51=caml_new_string("}"),
     cst$52=caml_new_string("|"),
     cst$53=caml_new_string("{"),
     cst_none=caml_new_string("<none>"),
     cst_Stdlib_Arg_Bad=caml_new_string("Stdlib.Arg.Bad"),
     cst_Stdlib_Arg_Help=caml_new_string("Stdlib.Arg.Help"),
     cst_Stdlib_Arg_Stop=caml_new_string("Stdlib.Arg.Stop"),
     cst$61=caml_new_string(""),
     cst_Program_not_linked_with_g_cannot_print_stack_backtrace=
      caml_new_string
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_new_string("Raised at"),
     cst_Re_raised_at=caml_new_string("Re-raised at"),
     cst_Raised_by_primitive_operation_at=
      caml_new_string("Raised by primitive operation at"),
     cst_Called_from=caml_new_string("Called from"),
     cst_inlined=caml_new_string(" (inlined)"),
     cst$64=caml_new_string(""),
     partial=[4,0,0,0,0],
     cst_Out_of_memory=caml_new_string("Out of memory"),
     cst_Stack_overflow=caml_new_string("Stack overflow"),
     cst_Pattern_matching_failed=caml_new_string("Pattern matching failed"),
     cst_Assertion_failed=caml_new_string("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_new_string("Undefined recursive module"),
     cst$62=caml_new_string(""),
     cst$63=caml_new_string(""),
     cst$60=caml_new_string("_"),
     locfmt=
      [0,
       [11,
        caml_new_string('File "'),
        [2,
         0,
         [11,
          caml_new_string('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", characters "),
            [4,0,0,0,[12,45,[4,0,0,0,[11,caml_new_string(": "),[2,0,0]]]]]]]]]],
       caml_new_string('File "%s", line %d, characters %d-%d: %s')],
     cst_Digest_from_hex$0=caml_new_string("Digest.from_hex"),
     cst_Digest_from_hex=caml_new_string("Digest.from_hex"),
     cst_Digest_to_hex=caml_new_string("Digest.to_hex"),
     cst_Digest_substring=caml_new_string("Digest.substring"),
     cst_Random_int64=caml_new_string("Random.int64"),
     cst_Random_int32=caml_new_string("Random.int32"),
     cst_Random_int=caml_new_string("Random.int"),
     cst_x$1=caml_new_string("x"),
     cst_OCAMLRUNPARAM=caml_new_string("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_new_string("CAMLRUNPARAM"),
     cst$65=caml_new_string(""),
     cst_Weak_Make_hash_bucket_cannot_grow_more=
      caml_new_string("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_new_string("Weak.fill"),
     cst$71=caml_new_string("."),
     cst$69=caml_new_string(">"),
     cst$70=caml_new_string("</"),
     cst$67=caml_new_string(">"),
     cst$68=caml_new_string("<"),
     cst$66=caml_new_string("\n"),
     cst_Stdlib_Format_Empty_queue=
      caml_new_string("Stdlib.Format.Empty_queue"),
     cst_end_of_input_not_found=caml_new_string("end of input not found"),
     cst_scanf_bad_conversion_a=caml_new_string('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=caml_new_string('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_new_string("scanf: missing reader"),
     cst_scanf_bad_conversion_custom_converter=
      caml_new_string('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=caml_new_string('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=caml_new_string('scanf: bad conversion "%*"'),
     cst$75=caml_new_string('"'),
     cst$76=caml_new_string('"'),
     cst$74=caml_new_string('"'),
     cst_in_format=caml_new_string(' in format "'),
     cst_an=caml_new_string("an"),
     cst_x$2=caml_new_string("x"),
     cst_nfinity=caml_new_string("nfinity"),
     cst_digits=caml_new_string("digits"),
     cst_decimal_digits=caml_new_string("decimal digits"),
     cst_0b=caml_new_string("0b"),
     cst_0o=caml_new_string("0o"),
     cst_0u=caml_new_string("0u"),
     cst_0x=caml_new_string("0x"),
     cst_false$2=caml_new_string("false"),
     cst_true$2=caml_new_string("true"),
     cst_not_a_valid_float_in_hexadecimal_notation=
      caml_new_string("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_found_in_float_token=
      caml_new_string("no dot or exponent part found in float token"),
     cst$73=caml_new_string("-"),
     cst_unnamed_function=caml_new_string("unnamed function"),
     cst_unnamed_character_string=caml_new_string("unnamed character string"),
     cst_unnamed_Pervasives_input_channel=
      caml_new_string("unnamed Pervasives input channel"),
     cst$72=caml_new_string("-"),
     cst_Stdlib_Scanf_Scan_failure=
      caml_new_string("Stdlib.Scanf.Scan_failure"),
     cst_binary=caml_new_string("binary"),
     cst_octal=caml_new_string("octal"),
     cst_hexadecimal=caml_new_string("hexadecimal"),
     cst_a_Char=caml_new_string("a Char"),
     cst_a_String=caml_new_string("a String"),
     cst$77=caml_new_string(""),
     cst$78=caml_new_string(""),
     cst$79=caml_new_string(""),
     cst$80=caml_new_string(""),
     cst$81=caml_new_string(""),
     cst$83=caml_new_string(""),
     cst$82=caml_new_string(""),
     cst_Illegal_character=caml_new_string("Illegal character "),
     cst_Filename_chop_extension=caml_new_string("Filename.chop_extension"),
     cst$94=caml_new_string(""),
     cst_Filename_chop_suffix=caml_new_string("Filename.chop_suffix"),
     cst$93=caml_new_string(""),
     cst$91=caml_new_string("./"),
     cst$90=caml_new_string(".\\"),
     cst$89=caml_new_string("../"),
     cst$88=caml_new_string("..\\"),
     cst$87=caml_new_string("./"),
     cst$86=caml_new_string("../"),
     cst$85=caml_new_string(""),
     cst$84=caml_new_string(""),
     current_dir_name=caml_new_string("."),
     parent_dir_name=caml_new_string(".."),
     dir_sep=caml_new_string("/"),
     cst_TMPDIR=caml_new_string("TMPDIR"),
     cst_tmp=caml_new_string("/tmp"),
     quotequote=caml_new_string("'\\''"),
     current_dir_name$0=caml_new_string("."),
     parent_dir_name$0=caml_new_string(".."),
     dir_sep$0=caml_new_string("\\"),
     cst_TEMP=caml_new_string("TEMP"),
     cst$92=caml_new_string("."),
     current_dir_name$1=caml_new_string("."),
     parent_dir_name$1=caml_new_string(".."),
     dir_sep$1=caml_new_string("/"),
     cst_Cygwin=caml_new_string("Cygwin"),
     cst_Win32=caml_new_string("Win32"),
     zero$2=[254,0,0],
     one$2=[254,1,0],
     i=[254,0,1],
     cst_Series_is_closed$0=caml_new_string("Series is closed"),
     cst_Series_is_closed=caml_new_string("Series is closed"),
     cst_Bigarray_array3_of_genarray=
      caml_new_string("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarray=
      caml_new_string("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarray=
      caml_new_string("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarray=
      caml_new_string("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_non_cubic_data=
      caml_new_string("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_non_cubic_data$0=
      caml_new_string("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_non_rectangular_data=
      caml_new_string("Bigarray.Array2.of_array: non-rectangular data"),
     End_of_file=global_data.End_of_file,
     Sys_error=global_data.Sys_error,
     Failure=global_data.Failure,
     Invalid_argument=global_data.Invalid_argument,
     Not_found=global_data.Not_found,
     Assert_failure=global_data.Assert_failure,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Match_failure=global_data.Match_failure,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _m_=[0,0,[0,6,0]],
     _l_=[0,0,[0,7,0]],
     _k_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _j_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _h_=[0,1],
     _i_=[0,0],
     _a_=[255,0,0,32752],
     _b_=[255,0,0,65520],
     _c_=[255,1,0,32752],
     _d_=[255,16777215,16777215,32751],
     _e_=[255,0,0,16],
     _f_=[255,0,0,15536],
     _t_=[0,0,0],
     _u_=[0,caml_new_string("list.ml"),268,11],
     _J_=[0,caml_new_string("array.ml"),233,4],
     _N_=[255,16777215,16777215,65535],
     _M_=[255,0,0,0],
     _L_=[255,1,0,0],
     _K_=[255,1,0,0],
     _O_=[0,0,0,0],
     _P_=[0,0,0],
     _Q_=[0,caml_new_string("set.ml"),514,18],
     _R_=[0,0,0,0],
     _S_=[0,caml_new_string("map.ml"),397,10],
     _T_=[0,0,0],
     _U_=[0,caml_new_string("stream.ml"),53,12],
     _V_=[0,0],
     _W_=[0,caml_new_string("stream.ml"),82,12],
     _ab_=[0,caml_new_string("buffer.ml"),205,9],
     _aa_=[0,caml_new_string("buffer.ml"),141,19],
     _$_=[0,caml_new_string("buffer.ml"),159,8],
     ___=[0,caml_new_string("buffer.ml"),120,19],
     _Z_=[0,caml_new_string("buffer.ml"),138,8],
     _Y_=[0,caml_new_string("buffer.ml"),84,19],
     _X_=[0,caml_new_string("buffer.ml"),117,8],
     _ac_=[0,caml_new_string("camlinternalFormat.ml"),846,23],
     _an_=[0,caml_new_string("camlinternalFormat.ml"),810,21],
     _af_=[0,caml_new_string("camlinternalFormat.ml"),811,21],
     _ao_=[0,caml_new_string("camlinternalFormat.ml"),814,21],
     _ag_=[0,caml_new_string("camlinternalFormat.ml"),815,21],
     _ap_=[0,caml_new_string("camlinternalFormat.ml"),818,19],
     _ah_=[0,caml_new_string("camlinternalFormat.ml"),819,19],
     _aq_=[0,caml_new_string("camlinternalFormat.ml"),822,22],
     _ai_=[0,caml_new_string("camlinternalFormat.ml"),823,22],
     _ar_=[0,caml_new_string("camlinternalFormat.ml"),827,30],
     _aj_=[0,caml_new_string("camlinternalFormat.ml"),828,30],
     _al_=[0,caml_new_string("camlinternalFormat.ml"),832,26],
     _ad_=[0,caml_new_string("camlinternalFormat.ml"),833,26],
     _am_=[0,caml_new_string("camlinternalFormat.ml"),842,28],
     _ae_=[0,caml_new_string("camlinternalFormat.ml"),843,28],
     _ak_=[0,caml_new_string("camlinternalFormat.ml"),847,23],
     _as_=[0,caml_new_string("camlinternalFormat.ml"),1525,4],
     _at_=[0,caml_new_string("camlinternalFormat.ml"),1593,39],
     _au_=[0,caml_new_string("camlinternalFormat.ml"),1616,31],
     _av_=[0,caml_new_string("camlinternalFormat.ml"),1617,31],
     _aw_=[0,caml_new_string("camlinternalFormat.ml"),1797,8],
     _a0_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _aZ_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _aC_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", duplicate flag "),[1,0]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aD_=[0,1,0],
     _aE_=[0,0],
     _aG_=[1,0],
     _aF_=[1,1],
     _aI_=[1,1],
     _aH_=[1,1],
     _aM_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", flag "),
            [1,
             [11,
              caml_new_string(" is only allowed after the '"),
              [12,
               37,
               [11,caml_new_string("', before padding and precision"),0]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aJ_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_new_string
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aK_=[0,0],
     _aL_=[0,0],
     _aN_=[0,[12,64,0]],
     _aO_=[0,caml_new_string("@ "),1,0],
     _aP_=[0,caml_new_string("@,"),0,0],
     _aQ_=[2,60],
     _aR_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": '"),
          [12,
           37,
           [11,
            caml_new_string("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_new_string(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aS_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": integer "),
          [4,
           0,
           0,
           0,
           [11,caml_new_string(" is greater than the limit "),[4,0,0,0,0]]]]]],
       caml_new_string
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aT_=[0,caml_new_string("camlinternalFormat.ml"),2811,11],
     _aU_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,[11,caml_new_string('" at character number '),[4,0,0,0,0]]]]]]],
       caml_new_string
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aV_=[0,caml_new_string("camlinternalFormat.ml"),2873,34],
     _aW_=[0,caml_new_string("camlinternalFormat.ml"),2906,28],
     _aX_=[0,caml_new_string("camlinternalFormat.ml"),2940,25],
     _aY_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,
             0,
             [11,
              caml_new_string(" is incompatible with '"),
              [0,[11,caml_new_string("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _aB_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,0,[11,caml_new_string(" expected, read "),[1,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _aA_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", '"),
            [0,[11,caml_new_string("' without "),[2,0,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, '%c' without %s")],
     _az_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", "),[2,0,0]]]]]],
       caml_new_string("invalid format %S: at character number %d, %s")],
     _ay_=
      [0,
       [11,caml_new_string("invalid box description "),[3,0,0]],
       caml_new_string("invalid box description %S")],
     _ax_=[0,0,4],
     _bk_=[0,[2,0,[0,0]],caml_new_string("%s%c")],
     _be_=[0,[2,0,0],caml_new_string("%s")],
     _bf_=[0,[2,0,0],caml_new_string("%s")],
     _bc_=[0,[2,0,0],caml_new_string("%s")],
     _bd_=[0,[2,0,0],caml_new_string("%s")],
     _ba_=[0,[2,0,0],caml_new_string("%s")],
     _bb_=[0,[2,0,0],caml_new_string("%s")],
     _a6_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": unknown option '"),
         [2,0,[11,caml_new_string("'.\n"),0]]]],
       caml_new_string("%s: unknown option '%s'.\n")],
     _a9_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": wrong argument '"),
         [2,
          0,
          [11,
           caml_new_string("'; option '"),
           [2,
            0,
            [11,
             caml_new_string("' expects "),
             [2,0,[11,caml_new_string(".\n"),0]]]]]]]],
       caml_new_string("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a__=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": option '"),
         [2,0,[11,caml_new_string("' needs an argument.\n"),0]]]],
       caml_new_string("%s: option '%s' needs an argument.\n")],
     _a$_=
      [0,
       [2,0,[11,caml_new_string(": "),[2,0,[11,caml_new_string(".\n"),0]]]],
       caml_new_string("%s: %s.\n")],
     _a7_=[0,caml_new_string("-help")],
     _a8_=[0,caml_new_string("--help")],
     _a5_=[0,[2,0,0],caml_new_string("%s")],
     _a4_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _a3_=[0,caml_new_string("-help")],
     _a1_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_new_string("  %s %s\n")],
     _a2_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_new_string("  %s %s%s\n")],
     _bp_=
      [0,[11,caml_new_string(", "),[2,0,[2,0,0]]],caml_new_string(", %s%s")],
     _by_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bw_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bx_=
      [0,
       [11,
        caml_new_string
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_new_string
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bu_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(' file "'),
         [2,
          0,
          [12,
           34,
           [2,
            0,
            [11,
             caml_new_string(", line "),
             [4,
              0,
              0,
              0,
              [11,caml_new_string(", characters "),[4,0,0,0,[12,45,partial]]]]]]]]]],
       caml_new_string('%s file "%s"%s, line %d, characters %d-%d')],
     _bv_=
      [0,
       [2,0,[11,caml_new_string(" unknown location"),0]],
       caml_new_string("%s unknown location")],
     _bt_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _bs_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _bq_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_new_string("(%s%s)")],
     _br_=[0,[12,40,[2,0,[12,41,0]]],caml_new_string("(%s)")],
     _bo_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bn_=[0,[3,0,0],caml_new_string("%S")],
     _bH_=
      [0,
       [11,caml_new_string("minor_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("minor_collections: %d\n")],
     _bI_=
      [0,
       [11,caml_new_string("major_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("major_collections: %d\n")],
     _bJ_=
      [0,
       [11,caml_new_string("compactions:       "),[4,0,0,0,[12,10,0]]],
       caml_new_string("compactions:       %d\n")],
     _bK_=[0,[12,10,0],caml_new_string("\n")],
     _bL_=[0,[8,0,0,[0,0],0],caml_new_string("%.0f")],
     _bM_=
      [0,
       [11,caml_new_string("minor_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("minor_words:    %*.0f\n")],
     _bN_=
      [0,
       [11,caml_new_string("promoted_words: "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("promoted_words: %*.0f\n")],
     _bO_=
      [0,
       [11,caml_new_string("major_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("major_words:    %*.0f\n")],
     _bP_=[0,[12,10,0],caml_new_string("\n")],
     _bQ_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bR_=
      [0,
       [11,caml_new_string("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("top_heap_words: %*d\n")],
     _bS_=
      [0,
       [11,caml_new_string("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("heap_words:     %*d\n")],
     _bT_=
      [0,
       [11,caml_new_string("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("live_words:     %*d\n")],
     _bU_=
      [0,
       [11,caml_new_string("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("free_words:     %*d\n")],
     _bV_=
      [0,
       [11,caml_new_string("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("largest_free:   %*d\n")],
     _bW_=
      [0,
       [11,caml_new_string("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("fragments:      %*d\n")],
     _bX_=[0,[12,10,0],caml_new_string("\n")],
     _bY_=
      [0,
       [11,caml_new_string("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("live_blocks: %d\n")],
     _bZ_=
      [0,
       [11,caml_new_string("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("free_blocks: %d\n")],
     _b0_=
      [0,
       [11,caml_new_string("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("heap_chunks: %d\n")],
     _b3_=[255,1,0,0],
     _b4_=[255,0,0,0],
     _b5_=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _b9_=[0,0],
     _b8_=[0,caml_new_string("hashtbl.ml"),108,23],
     _b$_=[3,0,3],
     _b__=[0,caml_new_string("")],
     _cr_=[0,91],
     _cq_=[0,123],
     _cs_=[0,caml_new_string("scanf.ml"),1455,13],
     _ct_=[0,[3,0,[10,0]],caml_new_string("%S%!")],
     _cp_=[0,37,caml_new_string("")],
     _co_=
      [0,
       [11,
        caml_new_string("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_new_string(": "),[2,0,0]]]],
       caml_new_string("scanf: bad input at char number %i: %s")],
     _cn_=
      [0,
       [11,
        caml_new_string("the character "),
        [1,[11,caml_new_string(" cannot start a boolean"),0]]],
       caml_new_string("the character %C cannot start a boolean")],
     _cm_=
      [0,
       [11,caml_new_string("bad character hexadecimal encoding \\"),[0,[0,0]]],
       caml_new_string("bad character hexadecimal encoding \\%c%c")],
     _cl_=
      [0,
       [11,caml_new_string("bad character decimal encoding \\"),[0,[0,[0,0]]]],
       caml_new_string("bad character decimal encoding \\%c%c%c")],
     _ck_=
      [0,
       [11,
        caml_new_string("character "),
        [1,
         [11,
          caml_new_string(" is not a valid "),
          [2,0,[11,caml_new_string(" digit"),0]]]]],
       caml_new_string("character %C is not a valid %s digit")],
     _cj_=
      [0,
       [11,
        caml_new_string("character "),
        [1,[11,caml_new_string(" is not a decimal digit"),0]]],
       caml_new_string("character %C is not a decimal digit")],
     _ci_=[0,caml_new_string("scanf.ml"),555,9],
     _ch_=
      [0,
       [11,caml_new_string("invalid boolean '"),[2,0,[12,39,0]]],
       caml_new_string("invalid boolean '%s'")],
     _cg_=
      [0,
       [11,
        caml_new_string("looking for "),
        [1,[11,caml_new_string(", found "),[1,0]]]],
       caml_new_string("looking for %C, found %C")],
     _cf_=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _ce_=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: the specified length was too short for token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: the specified length was too short for token")],
     _cd_=
      [0,
       [11,caml_new_string("illegal escape character "),[1,0]],
       caml_new_string("illegal escape character %C")],
     _cA_=[0,caml_new_string("camlinternalOO.ml"),438,17],
     _cz_=[0,caml_new_string("camlinternalOO.ml"),420,13],
     _cy_=[0,caml_new_string("camlinternalOO.ml"),417,13],
     _cx_=[0,caml_new_string("camlinternalOO.ml"),414,13],
     _cw_=[0,caml_new_string("camlinternalOO.ml"),411,13],
     _cv_=[0,caml_new_string("camlinternalOO.ml"),408,13],
     _cu_=[0,caml_new_string("camlinternalOO.ml"),281,50],
     _cD_=[0,0],
     _cC_=[0,0],
     _cB_=[0,0],
     _cH_=[0,7,0],
     _cG_=[0,1,[0,3,[0,5,0]]],
     _cF_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_new_string("%s%06x%s")],
     _cI_=[254,0,0];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (646,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Stdlib_Pervasives_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon_float=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function _g_(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_h_
              :_i_}
    function string_of_int(n){return caml_new_string("" + n)}
    function int_of_string_opt(s)
     {try
       {var _y9_=[0,caml_int_of_string(s)];return _y9_}
      catch(_y__)
       {_y__ = caml_wrap_exception(_y__);
        if(_y__[1] === Failure)return 0;
        throw _y__}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return _g_(s,cst);
        var
         match=caml_string_get(s,i),
         switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function string_of_float(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function float_of_string_opt(s)
     {try
       {var _y7_=[0,caml_float_of_string(s)];return _y7_}
      catch(_y8_)
       {_y8_ = caml_wrap_exception(_y8_);
        if(_y8_[1] === Failure)return 0;
        throw _y8_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_j_,438,name)}
    function open_out_bin(name){return open_out_gen(_k_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_y6_)
             {_y6_ = caml_wrap_exception(_y6_);
              if(_y6_[1] !== Sys_error)throw _y6_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(s) - len | 0) < ofs))
         return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_y5_){}
      try
       {var _y3_=caml_ml_close_channel(oc);return _y3_}
      catch(_y4_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_l_,0,name)}
    function open_in_bin(name){return open_in_gen(_m_,0,name)}
    function input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);
      really_input(ic,s,0,len);
      return caml_string_of_bytes(s)}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _y2_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _y2_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _y2_=res}
        return caml_string_of_bytes(_y2_)}}
    function close_in_noerr(ic)
     {try
       {var _y0_=caml_ml_close_channel(ic);return _y0_}
      catch(_y1_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_new_string("" + i))}
    function print_float(f){return output_string(stdout,string_of_float(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_new_string("" + i))}
    function prerr_float(f){return output_string(stderr,string_of_float(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return float_of_string_opt(read_line(0))}
    var LargeFile=[0];
    function string_of_format(param){var str=param[2];return str}
    function _n_(param,_yY_)
     {var
       str2=_yY_[2],
       fmt2=_yY_[1],
       str1=param[2],
       fmt1=param[1],
       _yZ_=_g_(str1,_g_(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_yZ_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {var g=exit_function[1],f_already_ran=[0,0];
      exit_function[1]
      =
      function(param)
       {if(1 - f_already_ran[1]){f_already_ran[1] = 1;caml_call1(f,0)}
        return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    var
     _o_=
      [0,
       invalid_arg,
       failwith,
       Exit,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       _g_,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       caml_ml_output_int,
       output_value,
       caml_ml_seek_out,
       caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       caml_ml_input_int,
       caml_input_value,
       caml_ml_seek_in,
       caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       _n_,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit],
     Stdlib=
      [0,
       _o_,
       invalid_arg,
       failwith,
       Exit,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       _g_,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       caml_ml_output_int,
       output_value,
       caml_ml_seek_out,
       caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       caml_ml_input_int,
       caml_input_value,
       caml_ml_seek_in,
       caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       LargeFile,
       string_of_format,
       _n_,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0];
    caml_register_global(651,Stdlib,"Stdlib");
    function empty(param){return 0}
    function return$0(x,param){return [0,x,empty]}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _yW_=function(_yX_){return map(f,next,_yX_)};
        return [0,caml_call1(f,x),_yW_]}
      return 0}
    function filter_map(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1],match$0=caml_call1(f,x);
          if(match$0)
           {var y=match$0[1];
            return [0,y,function(_yV_){return filter_map(f,next,_yV_)}]}
          var seq$0=next;
          continue}
        return 0}}
    function filter(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          if(caml_call1(f,x))
           return [0,x,function(_yU_){return filter(f,next,_yU_)}];
          var seq$0=next;
          continue}
        return 0}}
    function flat_map$0(counter,f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1],_yT_=caml_call1(f,x),_yS_=0;
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return flat_map_app$0(counter$0,f,_yT_,next,_yS_)}
        return caml_trampoline_return(flat_map_app$0,[0,f,_yT_,next,_yS_])}
      return 0}
    function flat_map_app$0(counter,f,seq,tail,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_yR_){return flat_map_app(f,next,tail,_yR_)}]}
      var _yQ_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return flat_map$0(counter$0,f,tail,_yQ_)}
      return caml_trampoline_return(flat_map$0,[0,f,tail,_yQ_])}
    function flat_map(f,seq,param)
     {return caml_trampoline(flat_map$0(0,f,seq,param))}
    function flat_map_app(f,seq,tail,param)
     {return caml_trampoline(flat_map_app$0(0,f,seq,tail,param))}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    var
     Stdlib_seq=
      [0,empty,return$0,map,filter,filter_map,flat_map,fold_left,iter];
    caml_register_global(652,Stdlib_seq,"Stdlib__seq");
    function chr(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {if(40 <= c)
       {if(92 === c)return cst$1;var switch$0=127 <= c?0:1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;var switch$0=1}
       else
        if(14 <= c)
         var switch$0=0;
        else
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r;
           default:var switch$0=0}
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var switch$0=65 <= c?90 < c?0:1:0;
      if(! switch$0)
       {var switch$1=192 <= c?214 < c?0:1:0;
        if(! switch$1)
         {var switch$2=216 <= c?222 < c?1:0:1;if(switch$2)return c}}
      return c + 32 | 0}
    function uppercase(c)
     {var switch$0=97 <= c?122 < c?0:1:0;
      if(! switch$0)
       {var switch$1=224 <= c?246 < c?0:1:0;
        if(! switch$1)
         {var switch$2=248 <= c?254 < c?1:0:1;if(switch$2)return c}}
      return c - 32 | 0}
    function lowercase_ascii(c)
     {if(65 <= c)if(! (90 < c))return c + 32 | 0;return c}
    function uppercase_ascii(c)
     {if(97 <= c)if(! (122 < c))return c - 32 | 0;return c}
    function compare(c1,c2){return c1 - c2 | 0}
    function equal(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Stdlib_char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal];
    caml_register_global(653,Stdlib_char,"Stdlib__char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _yM_=0 <= i?1:0,_yN_=_yM_?i <= 55295?1:0:_yM_;
      if(_yN_)
       var _yO_=_yN_;
      else
       var _yP_=57344 <= i?1:0,_yO_=_yP_?i <= 1114111?1:0:_yP_;
      return _yO_}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (_g_
                  (caml_format_int(cst_X,i),
                   cst_is_not_an_Unicode_scalar_value))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (_g_
                  (cst_U,
                   _g_
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_yL_){return _yL_}
    function equal$0(_yK_,_yJ_){return _yK_ === _yJ_?1:0}
    var compare$0=caml_int_compare;
    function hash(_yI_){return _yI_}
    function _p_(_yH_){return _yH_}
    var
     Stdlib_uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_yG_){return _yG_},
       _p_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$0,
       compare$0,
       hash];
    caml_register_global(654,Stdlib_uchar,"Stdlib__uchar");
    var
     match=runtime.caml_sys_get_argv(0),
     _q_=match[2],
     match$0=runtime.caml_sys_get_config(0),
     os_type=match$0[1],
     match$1=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     _r_=match[1],
     big_endian=0,
     size=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _yE_=[0,caml_sys_getenv(s)];return _yE_}
      catch(_yF_)
       {_yF_ = caml_wrap_exception(_yF_);
        if(_yF_ === Not_found)return 0;
        throw _yF_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Stdlib_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    var
     Stdlib_sys=
      [0,
       _q_,
       _r_,
       getenv_opt,
       interactive,
       os_type,
       match$1,
       unix,
       win32,
       cygwin,
       size,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled];
    caml_register_global(656,Stdlib_sys,"Stdlib__sys");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    var rev_init_threshold=typeof match$1 === "number"?1e4:50;
    function init(len,f)
     {if(0 <= len)
       {if(rev_init_threshold < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$0(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$0(f,l)]}
      return 0}
    function _s_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_s_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _s_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left$0(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_yD_=caml_call1(p,a);
          if(_yD_){var param$0=l;continue}
          return _yD_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_yC_=caml_call1(p,a);
          if(_yC_)return _yC_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _yB_=caml_call2(p,a1,a2);
            if(_yB_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _yB_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _yA_=caml_call2(p,a1,a2);
            if(_yA_)return _yA_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_yz_=0 === caml_compare(a,x)?1:0;
          if(_yz_)return _yz_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_yy_=a === x?1:0;
          if(_yy_)return _yy_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _yx_=0 === caml_compare(a,x)?1:0;
          if(_yx_)return _yx_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_yw_=a === x?1:0;
          if(_yw_)return _yw_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _yv_=rev(no);
        return [0,rev(yes),_yv_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _t_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function chop(k,l)
     {var k$0=k,l$0=l;
      for(;;)
       {if(0 === k$0)return l$0;
        if(l$0){var l$1=l$0[2],k$1=k$0 - 1 | 0,k$0=k$1,l$0=l$1;continue}
        throw [0,Assert_failure,_u_]}}
    function fast_sort(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _ys_=l[2];
            if(_ys_)
             {var x2=_ys_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _yt_=l[2];
            if(_yt_)
             {var _yu_=_yt_[2];
              if(_yu_)
               {var x3=_yu_[1],x2$0=_yt_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x1$0,x3)
                          ?0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                            :[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x2$0,[0,x1$0,[0,x3,0]]]
                        :0 < caml_call2(cmp,x2$0,x3)
                          ?0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]
                          :[0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _yp_=l[2];
            if(_yp_)
             {var x2=_yp_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _yq_=l[2];
            if(_yq_)
             {var _yr_=_yq_[2];
              if(_yr_)
               {var x3=_yr_[1],x2$0=_yq_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x2$0,x3)
                          ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]
                        :0 < caml_call2(cmp,x1$0,x3)
                          ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                            :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function sort_uniq(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _ym_=l[2];
            if(_ym_)
             {var x2=_ym_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _yn_=l[2];
            if(_yn_)
             {var _yo_=_yn_[2];
              if(_yo_)
               {var
                 x3=_yo_[1],
                 x2$0=_yn_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]]}
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)return [0,x2$0,[0,x1$0,0]];
                  if(0 <= c$3)
                   {var c$4=caml_call2(cmp,x2$0,x3);
                    return 0 === c$4
                            ?[0,x2$0,[0,x1$0,0]]
                            :0 <= c$4
                              ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                              :[0,x2$0,[0,x3,[0,x1$0,0]]]}
                  return [0,x2$0,[0,x1$0,[0,x3,0]]]}
                var c$5=caml_call2(cmp,x2$0,x3);
                if(0 === c$5)return [0,x1$0,[0,x2$0,0]];
                if(0 <= c$5)
                 {var c$6=caml_call2(cmp,x1$0,x3);
                  return 0 === c$6
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 <= c$6
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]}
                return [0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _yj_=l[2];
            if(_yj_)
             {var x2=_yj_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _yk_=l[2];
            if(_yk_)
             {var _yl_=_yk_[2];
              if(_yl_)
               {var
                 x3=_yl_[1],
                 x2$0=_yk_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]]}
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)return [0,x1$0,[0,x2$0,0]];
                  if(0 < c$3)return [0,x1$0,[0,x2$0,[0,x3,0]]];
                  var c$4=caml_call2(cmp,x1$0,x3);
                  return 0 === c$4
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 < c$4
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]}
                var c$5=caml_call2(cmp,x1$0,x3);
                if(0 === c$5)return [0,x2$0,[0,x1$0,0]];
                if(0 < c$5)return [0,x2$0,[0,x1$0,[0,x3,0]]];
                var c$6=caml_call2(cmp,x2$0,x3);
                return 0 === c$6
                        ?[0,x2$0,[0,x1$0,0]]
                        :0 < c$6
                          ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    function to_seq(l)
     {function aux(l,param)
       {if(l)
         {var tail=l[2],x=l[1];
          return [0,x,function(_yi_){return aux(tail,_yi_)}]}
        return 0}
      return function(_yh_){return aux(l,_yh_)}}
    function of_seq(seq)
     {function direct(depth,seq)
       {if(0 === depth)
         {var _yg_=0;
          return rev(fold_left(function(acc,x){return [0,x,acc]},_yg_,seq))}
        var match=caml_call1(seq,0);
        if(match)
         {var next=match[2],x=match[1];
          return [0,x,direct(depth - 1 | 0,next)]}
        return 0}
      return direct(500,seq)}
    var
     include=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$0,
       iteri,
       map$0,
       mapi,
       rev_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
    caml_register_global(658,include,"Stdlib__list");
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_ye_=n - 1 | 0,_yd_=0;
      if(! (_ye_ < 0))
       {var i=_yd_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _yf_=i + 1 | 0;
          if(_ye_ !== i){var i=_yf_;continue}
          break}}
      return s}
    var empty$0=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string(b){return caml_string_of_bytes(copy(b))}
    function of_string(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         {var r=caml_create_bytes(len);
          caml_blit_bytes(s,ofs,r,0,len);
          return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function _v_(a,b)
     {var
       c=a + b | 0,
       _yc_=b < 0?1:0,
       match=c < 0?1:0,
       switch$0=
        0 === (a < 0?1:0)
         ?0 === _yc_?0 === match?0:1:0
         :0 === _yc_?0:0 === match?1:0;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=_v_(_v_(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var srcoff=0,dstoff=left;
      else
       var srcoff=- left | 0,dstoff=0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_bytes_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_string_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_string)}
    function iter$1(f,a)
     {var _ya_=caml_ml_bytes_length(a) - 1 | 0,_x$_=0;
      if(! (_ya_ < 0))
       {var i=_x$_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _yb_=i + 1 | 0;
          if(_ya_ !== i){var i=_yb_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _x9_=caml_ml_bytes_length(a) - 1 | 0,_x8_=0;
      if(! (_x9_ < 0))
       {var i=_x8_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _x__=i + 1 | 0;
          if(_x9_ !== i){var i=_x__;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _x3_=param[2],_x4_=param[1];
            if(_x3_)
             {var
               x=(caml_ml_bytes_length(_x4_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=_x3_;
              continue}
            var _x7_=caml_ml_bytes_length(_x4_) + acc | 0}
          else
           var _x7_=acc;
          var dst=caml_create_bytes(_x7_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _x5_=param$0[2],_x6_=param$0[1];
              if(_x5_)
               {caml_blit_bytes(_x6_,0,dst,pos,caml_ml_bytes_length(_x6_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_x6_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_x6_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_x5_;
                continue}
              caml_blit_bytes(_x6_,0,dst,pos,caml_ml_bytes_length(_x6_));
              return dst}
            return dst}}}
      return empty$0}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var
       _x2_=param - 9 | 0,
       switch$0=4 < _x2_ >>> 0?23 === _x2_?1:0:2 === _x2_?0:1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len)
         if(is_space(caml_bytes_unsafe_get(s,i[1]))){i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1])
           if(is_space(caml_bytes_unsafe_get(s,j[1]))){j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty$0}}}
    function escaped$0(s)
     {var n=[0,0],_xV_=caml_ml_bytes_length(s) - 1 | 0,_xU_=0;
      if(! (_xV_ < 0))
       {var i$0=_xU_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0);
          if(32 <= match)
           {var _xZ_=match - 34 | 0;
            if(58 < _xZ_ >>> 0)
             if(93 <= _xZ_)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(56 < (_xZ_ - 1 | 0) >>> 0)
              var switch$0=1,switch$1=0;
             else
              var switch$1=1;
            if(switch$1)var _x0_=1,switch$0=2}
          else
           var switch$0=11 <= match?13 === match?1:0:8 <= match?1:0;
          switch(switch$0){case 0:var _x0_=4;break;case 1:var _x0_=2;break}
          n[1] = n[1] + _x0_ | 0;
          var _x1_=i$0 + 1 | 0;
          if(_xV_ !== i$0){var i$0=_x1_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _xX_=caml_ml_bytes_length(s) - 1 | 0,_xW_=0;
      if(! (_xX_ < 0))
       {var i=_xW_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i);
          if(35 <= c)
           var switch$2=92 === c?1:127 <= c?0:2;
          else
           if(32 <= c)
            var switch$2=34 <= c?1:2;
           else
            if(14 <= c)
             var switch$2=0;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                var switch$2=3;
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                var switch$2=3;
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                var switch$2=3;
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                var switch$2=3;
                break;
               default:var switch$2=0}
          switch(switch$2)
           {case 0:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 2:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _xY_=i + 1 | 0;
          if(_xX_ !== i){var i=_xY_;continue}
          break}}
      return s$0}
    function map$1(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_xS_=l - 1 | 0,_xR_=0;
      if(! (_xS_ < 0))
       {var i=_xR_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _xT_=i + 1 | 0;
          if(_xS_ !== i){var i=_xT_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_xP_=l - 1 | 0,_xO_=0;
      if(! (_xP_ < 0))
       {var i=_xO_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _xQ_=i + 1 | 0;
          if(_xP_ !== i){var i=_xQ_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$1(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$1(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i)if(! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_bytes_length(s) <= i))return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec(s,l,i,c);var _xM_=1;return _xM_}
        catch(_xN_)
         {_xN_ = caml_wrap_exception(_xN_);
          if(_xN_ === Not_found)return 0;
          throw _xN_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_bytes_length(s) <= i))
        try
         {rindex_rec(s,i,c);var _xK_=1;return _xK_}
        catch(_xL_)
         {_xL_ = caml_wrap_exception(_xL_);
          if(_xL_ === Not_found)return 0;
          throw _xL_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from)}
    var compare$1=runtime.caml_bytes_compare;
    function uppercase$0(s){return map$1(uppercase,s)}
    function lowercase$0(s){return map$1(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function to_seq$0(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_xI_=i + 1 | 0;
        return [0,x,function(_xJ_){return aux(_xI_,_xJ_)}]}
      var _xG_=0;
      return function(_xH_){return aux(_xG_,_xH_)}}
    function to_seqi(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_xE_=i + 1 | 0;
        return [0,[0,i,x],function(_xF_){return aux(_xE_,_xF_)}]}
      var _xC_=0;
      return function(_xD_){return aux(_xC_,_xD_)}}
    function of_seq$0(i)
     {var n=[0,0],buf=[0,make(256,0)];
      iter
       (function(c)
         {if(n[1] === caml_ml_bytes_length(buf[1]))
           {var
             new_len=
              min(2 * caml_ml_bytes_length(buf[1]) | 0,max_string_length);
            if(caml_ml_bytes_length(buf[1]) === new_len)
             failwith(cst_Bytes_of_seq_cannot_grow_bytes);
            var new_buf=make(new_len,0);
            blit(buf[1],0,new_buf,0,n[1]);
            buf[1] = new_buf}
          caml_bytes_set(buf[1],n[1],c);
          n[1]++;
          return 0},
        i);
      return sub(buf[1],0,n[1])}
    var
     unsafe_of_string=caml_bytes_of_string,
     unsafe_to_string=caml_string_of_bytes,
     equal$1=runtime.caml_bytes_equal,
     include$0=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$1,
       iteri$0,
       map$1,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$1,
       equal$1,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$0,
       to_seqi,
       of_seq$0];
    caml_register_global(659,include$0,"Stdlib__bytes");
    function make$0(n,c){return caml_string_of_bytes(make(n,c))}
    function init$1(n,f){return caml_string_of_bytes(init$0(n,f))}
    function copy$0(s)
     {return caml_string_of_bytes(copy(caml_bytes_of_string(s)))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _xx_=param[2],_xy_=param[1];
            if(_xx_)
             {var
               x=(caml_ml_string_length(_xy_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=_xx_;
              continue}
            var _xB_=caml_ml_string_length(_xy_) + acc | 0}
          else
           var _xB_=acc;
          var dst=caml_create_bytes(_xB_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _xz_=param$0[2],_xA_=param$0[1];
              if(_xz_)
               {caml_blit_string(_xA_,0,dst,pos,caml_ml_string_length(_xA_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_xA_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_xA_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_xz_;
                continue}
              caml_blit_string(_xA_,0,dst,pos,caml_ml_string_length(_xA_))}
            return caml_string_of_bytes(dst)}}}
      return cst$3}
    function iter$2(f,s)
     {var _xv_=caml_ml_string_length(s) - 1 | 0,_xu_=0;
      if(! (_xv_ < 0))
       {var i=_xu_;
        for(;;)
         {caml_call1(f,caml_string_unsafe_get(s,i));
          var _xw_=i + 1 | 0;
          if(_xv_ !== i){var i=_xw_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _xs_=caml_ml_string_length(s) - 1 | 0,_xr_=0;
      if(! (_xs_ < 0))
       {var i=_xr_;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(s,i));
          var _xt_=i + 1 | 0;
          if(_xs_ !== i){var i=_xt_;continue}
          break}}
      return 0}
    function map$2(f,s)
     {return caml_string_of_bytes(map$1(f,caml_bytes_of_string(s)))}
    function mapi$1(f,s)
     {return caml_string_of_bytes(mapi$0(f,caml_bytes_of_string(s)))}
    function is_space$0(param)
     {var
       _xq_=param - 9 | 0,
       switch$0=4 < _xq_ >>> 0?23 === _xq_?1:0:2 === _xq_?0:1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if(! is_space$0(caml_string_unsafe_get(s,0)))
       if
        (!
         is_space$0
          (caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
        return s;
      return caml_string_of_bytes(trim(caml_bytes_of_string(s)))}
    function escaped$1(s)
     {var n=caml_ml_string_length(s),i=0;
      for(;;)
       {if(n <= i)return s;
        var
         match=caml_string_unsafe_get(s,i),
         _xp_=match - 32 | 0,
         switch$0=
          59 < _xp_ >>> 0?33 < (_xp_ - 61 | 0) >>> 0?1:0:2 === _xp_?1:0;
        if(switch$0)
         return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec$0(s,l,i,c);var _xn_=1;return _xn_}
        catch(_xo_)
         {_xo_ = caml_wrap_exception(_xo_);
          if(_xo_ === Not_found)return 0;
          throw _xo_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_string_length(s) <= i))
        try
         {rindex_rec$0(s,i,c);var _xl_=1;return _xl_}
        catch(_xm_)
         {_xm_ = caml_wrap_exception(_xm_);
          if(_xm_ === Not_found)return 0;
          throw _xm_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from$0)}
    function uppercase_ascii$1(s)
     {return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s)))}
    function lowercase_ascii$1(s)
     {return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s)))}
    function capitalize_ascii$0(s)
     {return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s)))}
    function uncapitalize_ascii$0(s)
     {return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s)))}
    var compare$2=caml_string_compare;
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _xh_=caml_ml_string_length(s) - 1 | 0;
      if(! (_xh_ < 0))
       {var i=_xh_;
        for(;;)
         {if(caml_string_unsafe_get(s,i) === sep)
           {var _xj_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_xj_];
            j[1] = i}
          var _xk_=i - 1 | 0;
          if(0 !== i){var i=_xk_;continue}
          break}}
      var _xi_=r[1];
      return [0,sub$0(s,0,j[1]),_xi_]}
    function uppercase$1(s)
     {return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s)))}
    function lowercase$1(s)
     {return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s)))}
    function capitalize$0(s)
     {return caml_string_of_bytes(capitalize(caml_bytes_of_string(s)))}
    function uncapitalize$0(s)
     {return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s)))}
    function to_seq$1(s){return to_seq$0(caml_bytes_of_string(s))}
    function to_seqi$0(s){return to_seqi(caml_bytes_of_string(s))}
    function of_seq$1(g){return caml_string_of_bytes(of_seq$0(g))}
    var
     equal$2=caml_string_equal,
     include$1=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$2,
       iteri$1,
       map$2,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$2,
       equal$2,
       split_on_char,
       to_seq$1,
       to_seqi$0,
       of_seq$1];
    caml_register_global(660,include$1,"Stdlib__string");
    function merge$0(order,l1,l2)
     {if(l1)
       {var t1=l1[2],h1=l1[1];
        if(l2)
         {var t2=l2[2],h2=l2[1];
          return caml_call2(order,h1,h2)
                  ?[0,h1,merge$0(order,t1,l2)]
                  :[0,h2,merge$0(order,l1,t2)]}
        return l1}
      return l2}
    function list(order,l)
     {function initlist(param)
       {if(param)
         {var _xd_=param[2],_xe_=param[1];
          if(_xd_)
           {var
             rest=_xd_[2],
             e2=_xd_[1],
             _xf_=initlist(rest),
             _xg_=
              caml_call2(order,_xe_,e2)?[0,_xe_,[0,e2,0]]:[0,e2,[0,_xe_,0]];
            return [0,_xg_,_xf_]}
          return [0,[0,_xe_,0],0]}
        return 0}
      function merge2(x)
       {if(x)
         {var _xb_=x[2];
          if(_xb_)
           {var rest=_xb_[2],l2=_xb_[1],l1=x[1],_xc_=merge2(rest);
            return [0,merge$0(order,l1,l2),_xc_]}}
        return x}
      var llist$1=initlist(l),llist=llist$1;
      for(;;)
       {if(llist)
         {if(llist[2]){var llist$0=merge2(llist),llist=llist$0;continue}
          var l$0=llist[1];
          return l$0}
        return 0}}
    function swap(arr,i,j)
     {var tmp=arr[i + 1];arr[i + 1] = arr[j + 1];return arr[j + 1] = tmp}
    function array(cmp,arr)
     {function qsort(lo,hi)
       {var lo$0=lo,hi$0=hi;
        a:
        for(;;)
         {var _w__=6 <= (hi$0 - lo$0 | 0)?1:0;
          if(_w__)
           {var mid=(lo$0 + hi$0 | 0) >>> 1 | 0;
            if(caml_call2(cmp,arr[mid + 1],arr[lo$0 + 1]))swap(arr,mid,lo$0);
            if(caml_call2(cmp,arr[hi$0 + 1],arr[mid + 1]))
             {swap(arr,mid,hi$0);
              if(caml_call2(cmp,arr[mid + 1],arr[lo$0 + 1]))swap(arr,mid,lo$0)}
            var
             pivot=arr[mid + 1],
             i=[0,lo$0 + 1 | 0],
             j=[0,hi$0 - 1 | 0],
             _w$_=1 - caml_call2(cmp,pivot,arr[hi$0 + 1]),
             _xa_=_w$_ || 1 - caml_call2(cmp,arr[lo$0 + 1],pivot);
            if(_xa_)throw [0,Invalid_argument,cst_Sort_array];
            b:
            for(;;)
             {if(i[1] < j[1])
               for(;;)
                {if(caml_call2(cmp,pivot,arr[i[1] + 1]))
                  for(;;)
                   {if(caml_call2(cmp,arr[j[1] + 1],pivot))
                     {if(i[1] < j[1])swap(arr,i[1],j[1]);
                      i[1]++;
                      j[1] += -1;
                      continue b}
                    j[1] += -1;
                    continue}
                 i[1]++;
                 continue}
              if((j[1] - lo$0 | 0) <= (hi$0 - i[1] | 0))
               {qsort(lo$0,j[1]);var lo$1=i[1],lo$0=lo$1;continue a}
              qsort(i[1],hi$0);
              var hi$1=j[1],hi$0=hi$1;
              continue a}}
          return _w__}}
      qsort(0,arr.length - 1 - 1 | 0);
      var _w8_=arr.length - 1 - 1 | 0,_w7_=1;
      if(! (_w8_ < 1))
       {var i=_w7_;
        for(;;)
         {var val_i=arr[i + 1];
          if(1 - caml_call2(cmp,arr[(i - 1 | 0) + 1],val_i))
           {arr[i + 1] = arr[(i - 1 | 0) + 1];
            var j=[0,i - 1 | 0];
            for(;;)
             {if(1 <= j[1])
               if(! caml_call2(cmp,arr[(j[1] - 1 | 0) + 1],val_i))
                {arr[j[1] + 1] = arr[(j[1] - 1 | 0) + 1];j[1] += -1;continue}
              arr[j[1] + 1] = val_i;
              break}}
          var _w9_=i + 1 | 0;
          if(_w8_ !== i){var i=_w9_;continue}
          break}}
      return 0}
    var Stdlib_sort=[0,list,array,merge$0];
    caml_register_global(661,Stdlib_sort,"Stdlib__sort");
    function to_buffer(buff,ofs,len,v,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buff) - len | 0) < ofs))
         return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substring_out_of_bounds)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        {var len=caml_marshal_data_size(buff,ofs);
         return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                 ?invalid_arg(cst_Marshal_from_bytes$0)
                 :runtime.caml_input_value_from_bytes(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs)
     {return from_bytes(caml_bytes_of_string(buff),ofs)}
    var
     Stdlib_marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(662,Stdlib_marshal,"Stdlib__marshal");
    function is_block(a){return 1 - (typeof a === "number")}
    var
     double_field=runtime.caml_array_get,
     set_double_field=runtime.caml_array_set;
    function marshal(obj){return runtime.caml_output_value_to_bytes(obj,0)}
    function unmarshal(str,pos)
     {var _w6_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_w6_]}
    var
     first_non_constant_constructor_tag=0,
     last_non_constant_constructor_tag=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1e3,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function extension_constructor(x)
     {if(is_block(x))
       if(caml_obj_tag(x) !== 248)
        if(1 <= x.length - 1)var slot=x[1],switch$0=1;else var switch$0=0;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var slot=x;
      if(is_block(slot))
       if(caml_obj_tag(slot) === 248)
        var name=slot[1],switch$1=1;
       else
        var switch$1=0;
      else
       var switch$1=0;
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function extension_name(slot){return slot[1]}
    function extension_id(slot){return slot[2]}
    function length$0(x){return x.length - 1 - 2 | 0}
    var _w_=runtime.caml_ephe_blit_data,_x_=runtime.caml_ephe_check_data;
    function _y_(_w5_){return runtime.caml_ephe_unset_data(_w5_)}
    var
     _z_=runtime.caml_ephe_set_data,
     _A_=runtime.caml_ephe_get_data_copy,
     _B_=runtime.caml_ephe_get_data;
    function _C_(_w4_,_w3_,_w2_,_w1_,_w0_)
     {return runtime.caml_ephe_blit_key(_w4_,_w3_,_w2_,_w1_,_w0_)}
    function _D_(_wZ_,_wY_){return runtime.caml_ephe_check_key(_wZ_,_wY_)}
    var _E_=runtime.caml_ephe_unset_key,_F_=runtime.caml_ephe_set_key;
    function _G_(_wX_,_wW_){return runtime.caml_ephe_get_key_copy(_wX_,_wW_)}
    function _H_(_wV_,_wU_){return runtime.caml_ephe_get_key(_wV_,_wU_)}
    var
     _I_=
      [0,
       function(_wT_){return runtime.caml_ephe_create(_wT_)},
       length$0,
       _H_,
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_],
     Stdlib_obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor_tag,
       last_non_constant_constructor_tag,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _I_];
    caml_register_global(663,Stdlib_obj,"Stdlib__obj");
    var
     infinity$0=_o_[10],
     neg_infinity$0=_o_[11],
     nan$0=_o_[12],
     max_float$0=_o_[13],
     min_float$0=_o_[14],
     epsilon=_o_[15],
     of_string_opt=_o_[24],
     to_string$0=_o_[23],
     pi=3.14159265358979312;
    function equal$3(x,y){return 0 === caml_float_compare(x,y)?1:0}
    function hash$0(x){return caml_hash(10,100,0,x)}
    var
     Array=[0],
     Stdlib_float=
      [0,
       infinity$0,
       neg_infinity$0,
       nan$0,
       pi,
       max_float$0,
       min_float$0,
       epsilon,
       of_string_opt,
       to_string$0,
       caml_float_compare,
       equal$3,
       hash$0,
       Array];
    caml_register_global(664,Stdlib_float,"Stdlib__float");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_wR_=l - 1 | 0,_wQ_=1;
        if(! (_wR_ < 1))
         {var i=_wQ_;
          for(;;)
           {res[i + 1] = caml_call1(f,i);
            var _wS_=i + 1 | 0;
            if(_wR_ !== i){var i=_wS_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_wO_=sx - 1 | 0,_wN_=0;
      if(! (_wO_ < 0))
       {var x=_wN_;
        for(;;)
         {res[x + 1] = caml_make_vect(sy,init);
          var _wP_=x + 1 | 0;
          if(_wO_ !== x){var x=_wP_;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$0(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         {var _wL_=(ofs + len | 0) - 1 | 0;
          if(! (_wL_ < ofs))
           {var i=ofs;
            for(;;)
             {a[i + 1] = v;
              var _wM_=i + 1 | 0;
              if(_wL_ !== i){var i=_wM_;continue}
              break}}
          return 0}
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((a1.length - 1 - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((a2.length - 1 - len | 0) < ofs2))
           return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$3(f,a)
     {var _wJ_=a.length - 1 - 1 | 0,_wI_=0;
      if(! (_wJ_ < 0))
       {var i=_wI_;
        for(;;)
         {caml_call1(f,a[i + 1]);
          var _wK_=i + 1 | 0;
          if(_wJ_ !== i){var i=_wK_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_have_the_same_length);
      var _wG_=a.length - 1 - 1 | 0,_wF_=0;
      if(! (_wG_ < 0))
       {var i=_wF_;
        for(;;)
         {caml_call2(f,a[i + 1],b[i + 1]);
          var _wH_=i + 1 | 0;
          if(_wG_ !== i){var i=_wH_;continue}
          break}}
      return 0}
    function map$3(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_wD_=l - 1 | 0,_wC_=1;
      if(! (_wD_ < 1))
       {var i=_wC_;
        for(;;)
         {r[i + 1] = caml_call1(f,a[i + 1]);
          var _wE_=i + 1 | 0;
          if(_wD_ !== i){var i=_wE_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)
       return invalid_arg(cst_Array_map2_arrays_must_have_the_same_length);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_wA_=la - 1 | 0,_wz_=1;
      if(! (_wA_ < 1))
       {var i=_wz_;
        for(;;)
         {r[i + 1] = caml_call2(f,a[i + 1],b[i + 1]);
          var _wB_=i + 1 | 0;
          if(_wA_ !== i){var i=_wB_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _wx_=a.length - 1 - 1 | 0,_ww_=0;
      if(! (_wx_ < 0))
       {var i=_ww_;
        for(;;)
         {caml_call2(f,i,a[i + 1]);
          var _wy_=i + 1 | 0;
          if(_wx_ !== i){var i=_wy_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_wu_=l - 1 | 0,_wt_=1;
      if(! (_wu_ < 1))
       {var i=_wt_;
        for(;;)
         {r[i + 1] = caml_call2(f,i,a[i + 1]);
          var _wv_=i + 1 | 0;
          if(_wu_ !== i){var i=_wv_;continue}
          break}}
      return r}
    function to_list(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[i + 1],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         a=caml_make_vect(list_length(0,l),hd),
         i=1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[i + 1] = hd$0;
            var i$0=i + 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    function fold_left$1(f,x,a)
     {var r=[0,x],_wr_=a.length - 1 - 1 | 0,_wq_=0;
      if(! (_wr_ < 0))
       {var i=_wq_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[i + 1]);
          var _ws_=i + 1 | 0;
          if(_wr_ !== i){var i=_ws_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_wo_=a.length - 1 - 1 | 0;
      if(! (_wo_ < 0))
       {var i=_wo_;
        for(;;)
         {r[1] = caml_call2(f,a[i + 1],r[1]);
          var _wp_=i - 1 | 0;
          if(0 !== i){var i=_wp_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[i + 1]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[i + 1])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[i + 1],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[i + 1])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Stdlib_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _wh_=i31 + 1 | 0,_wi_=caml_check_bound(a,_wh_)[_wh_ + 1];
          if(caml_call2(cmp,caml_check_bound(a,i31)[i31 + 1],_wi_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _wj_=i31 + 2 | 0,
           _wk_=caml_check_bound(a,_wj_)[_wj_ + 1],
           _wl_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_wl_)[_wl_ + 1],_wk_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _wm_=i31 + 1 | 0,_wn_=caml_check_bound(a,_wm_)[_wm_ + 1];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[i31 + 1],_wn_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[j + 1],e))
           {var _wg_=caml_check_bound(a,j)[j + 1];
            caml_check_bound(a,i$0)[i$0 + 1] = _wg_;
            var i$0=j;
            continue}
          return caml_check_bound(a,i$0)[i$0 + 1] = e}}
      function trickle(l,i,e)
       {try
         {var _wf_=trickledown(l,i,e);return _wf_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];return caml_check_bound(a,i$0)[i$0 + 1] = e}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_we_=caml_check_bound(a,i$1)[i$1 + 1];
          caml_check_bound(a,i$0)[i$0 + 1] = _we_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _wd_=bubbledown(l,i);return _wd_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_v7_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_v7_ < 0))
       {var i$2=_v7_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[i$2 + 1]);
          var _wc_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_wc_;continue}
          break}}
      var _v8_=l - 1 | 0;
      if(! (_v8_ < 2))
       {var i$0=_v8_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[i$0 + 1],
           _wa_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[i$0 + 1] = _wa_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_J_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[father + 1],e$0))
             caml_check_bound(a,i)[i + 1] = e$0;
            else
             {var _v6_=caml_check_bound(a,father)[father + 1];
              caml_check_bound(a,i)[i + 1] = _v6_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _wb_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_wb_;continue a}
            break}
          break}}
      var _v9_=1 < l?1:0;
      if(_v9_)
       {var e=caml_check_bound(a,1)[2],_v__=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _v__;
        var _v$_=caml_check_bound(a,0)[1] = e}
      else
       var _v$_=_v9_;
      return _v$_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[src2ofs + 1],
         s1$1=caml_check_bound(a,src1ofs)[src1ofs + 1],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[d + 1] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[i2$0 + 1],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[d + 1] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[i1$0 + 1],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _vY_=len - 1 | 0,_vX_=0;
        if(! (_vY_ < 0))
         {var i=_vX_;
          a:
          for(;;)
           {var
             _vZ_=srcofs + i | 0,
             e=caml_check_bound(a,_vZ_)[_vZ_ + 1],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _v0_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_v0_)[_v0_ + 1],e))
                 {var
                   _v1_=j[1],
                   _v2_=caml_check_bound(dst,_v1_)[_v1_ + 1],
                   _v3_=j[1] + 1 | 0;
                  caml_check_bound(dst,_v3_)[_v3_ + 1] = _v2_;
                  j[1] += -1;
                  continue}}
              var _v4_=j[1] + 1 | 0;
              caml_check_bound(dst,_v4_)[_v4_ + 1] = e;
              var _v5_=i + 1 | 0;
              if(_vY_ !== i){var i=_v5_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$2(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[i + 1],_vV_=i + 1 | 0;
          return [0,x,function(_vW_){return aux(_vV_,_vW_)}]}
        return 0}
      var _vT_=0;
      return function(_vU_){return aux(_vT_,_vU_)}}
    function to_seqi$1(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[i + 1],_vR_=i + 1 | 0;
          return [0,[0,i,x],function(_vS_){return aux(_vR_,_vS_)}]}
        return 0}
      var _vP_=0;
      return function(_vQ_){return aux(_vP_,_vQ_)}}
    function of_seq$2(i$2)
     {var _vO_=0,l=fold_left(function(acc,x){return [0,x,acc]},_vO_,i$2);
      if(l)
       {var
         tl=l[2],
         hd=l[1],
         len=list_length(0,l),
         a=caml_make_vect(len,hd),
         i$1=len - 2 | 0,
         i=i$1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[i + 1] = hd$0;
            var i$0=i - 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    var
     concat$1=caml_array_concat,
     include$2=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list,
       of_list,
       iter$3,
       iteri$2,
       map$3,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$2,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(665,include$2,"Stdlib__array");
    var zero=0,one=1,minus_one=-1;
    function succ$0(n){return n + 1 | 0}
    function pred$0(n){return n - 1 | 0}
    function abs$0(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$0=-2147483648,max_int$0=2147483647;
    function lognot(n){return n ^ -1}
    function to_string$1(n){return caml_format_int(cst_d,n)}
    function of_string_opt$0(s)
     {try
       {var _vM_=[0,caml_int_of_string(s)];return _vM_}
      catch(_vN_)
       {_vN_ = caml_wrap_exception(_vN_);
        if(_vN_[1] === Failure)return 0;
        throw _vN_}}
    var compare$3=caml_int_compare;
    function equal$4(x,y){return 0 === caml_int_compare(x,y)?1:0}
    var
     Stdlib_int32=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       of_string_opt$0,
       to_string$1,
       compare$3,
       equal$4];
    caml_register_global(666,Stdlib_int32,"Stdlib__int32");
    function succ$1(n){return caml_int64_add(n,_K_)}
    function pred$1(n){return caml_int64_sub(n,_L_)}
    function abs$1(n)
     {return caml_greaterequal(n,_M_)?n:runtime.caml_int64_neg(n)}
    function lognot$0(n){return runtime.caml_int64_xor(n,_N_)}
    function to_string$2(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$1(s)
     {try
       {var _vK_=[0,caml_int64_of_string(s)];return _vK_}
      catch(_vL_)
       {_vL_ = caml_wrap_exception(_vL_);
        if(_vL_[1] === Failure)return 0;
        throw _vL_}}
    var compare$4=caml_int64_compare;
    function equal$5(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    var
     Stdlib_int64=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       of_string_opt$1,
       to_string$2,
       compare$4,
       equal$5];
    caml_register_global(667,Stdlib_int64,"Stdlib__int64");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$2(n){return n + 1 | 0}
    function pred$2(n){return n - 1 | 0}
    function abs$2(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$2=-2147483648,max_int$2=2147483647;
    function lognot$1(n){return n ^ -1}
    function to_string$3(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$2(s)
     {try
       {var _vI_=[0,caml_int_of_string(s)];return _vI_}
      catch(_vJ_)
       {_vJ_ = caml_wrap_exception(_vJ_);
        if(_vJ_[1] === Failure)return 0;
        throw _vJ_}}
    var compare$5=caml_int_compare;
    function equal$6(x,y){return 0 === caml_int_compare(x,y)?1:0}
    var
     Stdlib_nativeint=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       succ$2,
       pred$2,
       abs$2,
       size,
       max_int$2,
       min_int$2,
       lognot$1,
       of_string_opt$2,
       to_string$3,
       compare$5,
       equal$6];
    caml_register_global(668,Stdlib_nativeint,"Stdlib__nativeint");
    function engine(tbl,state,buf)
     {var result=runtime.caml_lex_engine(tbl,state,buf);
      if(0 <= result)
       {buf[11] = buf[12];
        var _vH_=buf[12];
        buf[12] = [0,_vH_[1],_vH_[2],_vH_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var result=runtime.caml_new_lex_engine(tbl,state,buf);
      if(0 <= result)
       {buf[11] = buf[12];
        var _vG_=buf[12];
        buf[12] = [0,_vG_[1],_vG_[2],_vG_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(f)
     {var
       aux_buffer=caml_create_bytes(512),
       _vu_=[0],
       _vv_=0,
       _vw_=0,
       _vx_=0,
       _vy_=0,
       _vz_=0,
       _vA_=0,
       _vB_=0,
       _vC_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_grow_buffer);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_vE_=t.length - 1 - 1 | 0,_vD_=0;
                  if(! (_vE_ < 0))
                   {var i=_vD_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[i + 1];
                      if(0 <= v)caml_check_bound(t,i)[i + 1] = v - s | 0;
                      var _vF_=i + 1 | 0;
                      if(_vE_ !== i){var i=_vF_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _vC_,
              _vB_,
              _vA_,
              _vz_,
              _vy_,
              _vx_,
              _vw_,
              _vv_,
              _vu_,
              zero_pos,
              zero_pos]}
    function from_channel(ic)
     {return from_function(function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(s)
     {var
       _vl_=[0],
       _vm_=1,
       _vn_=0,
       _vo_=0,
       _vp_=0,
       _vq_=0,
       _vr_=0,
       _vs_=caml_ml_string_length(s),
       _vt_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _vt_,
              _vs_,
              _vr_,
              _vq_,
              _vp_,
              _vo_,
              _vn_,
              _vm_,
              _vl_,
              zero_pos,
              zero_pos]}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var lcp=lexbuf[12];
      lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]];
      return 0}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var _vk_=lb[12];
      lb[12] = [0,_vk_[1],_vk_[2],_vk_[3],0];
      lb[3] = 0;
      return 0}
    var
     Stdlib_lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(669,Stdlib_lexing,"Stdlib__lexing");
    var
     YYexit=[248,cst_Stdlib_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Stdlib_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _vf_=env[13],
                _vg_=
                 caml_call1(caml_check_bound(tables[1],_vf_)[_vf_ + 1],env),
                _vh_=4,
                cmd$0=_vh_,
                arg$1=_vg_}
             catch(_vj_)
              {_vj_ = caml_wrap_exception(_vj_);
               if(_vj_ !== Parse_error)throw _vj_;
               var cmd$0=5,arg$1=0}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _vi_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_vi_)[_vi_ + 1] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[tok + 1] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _ve_=env[11] - n | 0;return caml_check_bound(env[2],_ve_)[_ve_ + 1]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _vb_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_vb_)[_vb_ + 1],
           _vc_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_vc_)[_vc_ + 1];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _vd_=env[11];
        return caml_check_bound(env[4],_vd_)[_vd_ + 1]}}
    function symbol_end_pos(param)
     {var _va_=env[11];return caml_check_bound(env[4],_va_)[_va_ + 1]}
    function rhs_start_pos(n)
     {var _u$_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_u$_)[_u$_ + 1]}
    function rhs_end_pos(n)
     {var _u__=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_u__)[_u__ + 1]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Stdlib_parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_u9_){return runtime.caml_set_parser_trace(_u9_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(670,Stdlib_parsing,"Stdlib__parsing");
    var
     Stdlib_set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _u8_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_u8_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_u3_=height(lr);
               if(_u3_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_u4_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_u4_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_u5_=height(rl);
               if(_u5_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_u6_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_u6_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _u7_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_u7_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _u2_=param$0[1];
               if(_u2_){var param$0=_u2_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _u1_=param$0[1];
               if(_u1_){var param$0=_u1_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _uZ_=param$0[3],_u0_=param$0[2];
               if(_uZ_){var param$0=_uZ_;continue}
               return _u0_}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _uX_=param$0[3],_uY_=param$0[2];
               if(_uX_){var param$0=_uX_;continue}
               return [0,_uY_]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _uW_=param[1];
             if(_uW_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_uW_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _uV_=remove_min_elt(match);
               return join(t,min_elt(match),_uV_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _O_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _uU_=0 === c?1:0;
               if(_uU_)return _uU_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _uT_=remove_min_elt(r);return bal(l,min_elt(r),_uT_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _uR_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_uR_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _uS_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_uS_)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _uN_=split(v1,match),
                _uO_=_uN_[1];
               if(0 === _uN_[2])
                {var r2=_uN_[3],_uP_=inter(r1,r2);
                 return concat(inter(l1,_uO_),_uP_)}
               var r2$0=_uN_[3],_uQ_=inter(r1,r2$0);
               return join(inter(l1,_uO_),v1,_uQ_)}
             return 0}
           return 0}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _uJ_=split(v1,match),
                _uK_=_uJ_[1];
               if(0 === _uJ_[2])
                {var r2=_uJ_[3],_uL_=diff(r1,r2);
                 return join(diff(l1,_uK_),v1,_uL_)}
               var r2$0=_uJ_[3],_uM_=diff(r1,r2$0);
               return concat(diff(l1,_uK_),_uM_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _uG_=subset(l1,l2);
                   if(_uG_){var s1$0=r1,s2$0=r2;continue}
                   return _uG_}
                 if(0 <= c)
                  {var _uH_=subset([0,0,v1,r1,0],r2);
                   if(_uH_){var s1$0=l1;continue}
                   return _uH_}
                 var _uI_=subset([0,l1,v1,0,0],l2);
                 if(_uI_){var s1$0=r1;continue}
                 return _uI_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uD_=caml_call1(p,v);
               if(_uD_)
                {var _uE_=for_all(p,l);
                 if(_uE_){var param$0=r;continue}
                 var _uF_=_uE_}
               else
                var _uF_=_uD_;
               return _uF_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uA_=caml_call1(p,v);
               if(_uA_)
                var _uB_=_uA_;
               else
                {var _uC_=exists(p,l);
                 if(! _uC_){var param$0=r;continue}
                 var _uB_=_uC_}
               return _uB_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0)if(r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _uy_=concat(lf,rf);return [0,join(lt,v,rt),_uy_]}
             var _uz_=join(lf,v,rf);
             return [0,concat(lt,rt),_uz_]}
           return _P_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_ux_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _ux_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0)if(v === v$0)if(r === r$0)return t;
             if(0 === l$0)
              var switch$0=0;
             else
              var
               _uw_=max_elt(l$0),
               switch$0=0 <= caml_call2(Ord[1],_uw_,v$0)?1:0;
             if(! switch$0)
              {if(0 === r$0)
                var switch$1=0;
               else
                var
                 _uv_=min_elt(r$0),
                 switch$1=0 <= caml_call2(Ord[1],v$0,_uv_)?1:0;
               if(! switch$1)return join(l$0,v$0,r$0)}
             return union(l$0,add(v$0,r$0))}
           return 0}
         function of_list(l)
          {if(l)
            {var _uk_=l[2],_ul_=l[1];
             if(_uk_)
              {var _um_=_uk_[2],_un_=_uk_[1];
               if(_um_)
                {var _uo_=_um_[2],_up_=_um_[1];
                 if(_uo_)
                  {var _uq_=_uo_[2],_ur_=_uo_[1];
                   if(_uq_)
                    {if(_uq_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _us_=l[2];
                                 if(_us_)
                                  {var l$4=_us_[2],x1=_us_[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _ut_=l[2];
                                 if(_ut_)
                                  {var _uu_=_ut_[2];
                                   if(_uu_)
                                    {var l$5=_uu_[2],x2=_uu_[1],x1$0=_ut_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_Q_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_uq_[1];
                     return add(x4,add(_ur_,add(_up_,add(_un_,singleton(_ul_)))))}
                   return add(_ur_,add(_up_,add(_un_,singleton(_ul_))))}
                 return add(_up_,add(_un_,singleton(_ul_)))}
               return add(_un_,singleton(_ul_))}
             return singleton(_ul_)}
           return empty}
         function add_seq(i,m)
          {return fold_left(function(s,x){return add(x,s)},m,i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_ui_=cons_enum(t,rest);
             return [0,x,function(_uj_){return seq_of_enum(_ui_,_uj_)}]}
           return 0}
         function to_seq(c)
          {var _ug_=cons_enum(c,0);
           return function(_uh_){return seq_of_enum(_ug_,_uh_)}}
         function to_seq_from(low,s)
          {var s$0=s,c=0;
           for(;;)
            {if(s$0)
              {var r=s$0[3],v=s$0[2],l=s$0[1],n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,r,c],s$0=l,c=c$0;continue}
                 var s$0=r;
                 continue}
               var _ue_=[0,v,r,c]}
             else
              var _ue_=c;
             return function(_uf_){return seq_of_enum(_ue_,_uf_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list,
                 to_seq_from,
                 to_seq,
                 add_seq,
                 of_seq]}];
    caml_register_global(671,Stdlib_set,"Stdlib__set");
    var
     Stdlib_map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_ud_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_ud_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_t__=height(lr);
               if(_t__ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _t$_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_t$_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_ua_=height(rl);
               if(_ua_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _ub_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_ub_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _uc_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_uc_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _t9_=0 === c?1:0;
               if(_t9_)return _t9_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _t8_=param$0[1];
               if(_t8_){var param$0=_t8_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _t7_=param$0[1];
               if(_t7_){var param$0=_t7_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _t4_=param$0[4],_t5_=param$0[3],_t6_=param$0[2];
               if(_t4_){var param$0=_t4_;continue}
               return [0,_t6_,_t5_]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _t1_=param$0[4],_t2_=param$0[3],_t3_=param$0[2];
               if(_t1_){var param$0=_t1_;continue}
               return [0,[0,_t3_,_t2_]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _t0_=param[1];
             if(_t0_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_t0_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _tD_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _tD_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _tD_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _tX_=caml_call2(p,v,d);
               if(_tX_)
                {var _tY_=for_all(p,l);
                 if(_tY_){var param$0=r;continue}
                 var _tZ_=_tY_}
               else
                var _tZ_=_tX_;
               return _tZ_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _tU_=caml_call2(p,v,d);
               if(_tU_)
                var _tV_=_tU_;
               else
                {var _tW_=exists(p,l);
                 if(! _tW_){var param$0=r;continue}
                 var _tV_=_tW_}
               return _tV_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _R_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _tQ_=merge(f,r1,r2),
                _tR_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_tR_,_tQ_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _tS_=merge(f,r1$0,r2$0),
              _tT_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_tT_,_tS_)}
           throw [0,Assert_failure,_S_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0)if(r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _tO_=concat(lf,rf);return [0,join(lt,v,d,rt),_tO_]}
             var _tP_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_tP_]}
           return _T_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _tL_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_tL_)
                  {var _tM_=caml_call2(cmp,d1,d2);
                   if(_tM_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _tN_=_tM_}
                 else
                  var _tN_=_tL_;
                 return _tN_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_tK_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _tK_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         function add_seq(i,m)
          {return fold_left
                   (function(m,param)
                     {var v=param[2],k=param[1];return add(k,v,m)},
                    m,
                    i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_tI_=cons_enum(t,rest);
             return [0,[0,k,v],function(_tJ_){return seq_of_enum(_tI_,_tJ_)}]}
           return 0}
         function to_seq(m)
          {var _tG_=cons_enum(m,0);
           return function(_tH_){return seq_of_enum(_tG_,_tH_)}}
         function to_seq_from(low,m)
          {var m$0=m,c=0;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
                 var m$0=r;
                 continue}
               var _tE_=[0,v,d,r,c]}
             else
              var _tE_=c;
             return function(_tF_){return seq_of_enum(_tE_,_tF_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 to_seq,
                 to_seq_from,
                 add_seq,
                 of_seq]}];
    caml_register_global(672,Stdlib_map,"Stdlib__map");
    var Empty=[248,cst_Stdlib_Stack_Empty,caml_fresh_oo_id(0)];
    function create(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$2(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _tC_=s[1];
      if(_tC_)
       {var tl=_tC_[2],hd=_tC_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function top(s)
     {var _tB_=s[1];if(_tB_){var hd=_tB_[1];return hd}throw Empty}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$4(f,s){return iter$0(f,s[1])}
    function fold(f,acc,s){return fold_left$0(f,acc,s[1])}
    function to_seq$3(s){return to_seq(s[1])}
    function add_seq(q,i){return iter(function(x){return push(x,q)},i)}
    function of_seq$3(g){var s=create(0);add_seq(s,g);return s}
    var
     Stdlib_stack=
      [0,
       Empty,
       create,
       push,
       pop,
       top,
       clear,
       copy$2,
       is_empty,
       length$1,
       iter$4,
       fold,
       to_seq$3,
       add_seq,
       of_seq$3];
    caml_register_global(673,Stdlib_stack,"Stdlib__stack");
    var Empty$0=[248,cst_Stdlib_Queue_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_tA_=q[3];
      return _tA_
              ?(q[1] = q[1] + 1 | 0,_tA_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _tz_=q[2];if(_tz_){var content=_tz_[1];return content}throw Empty$0}
    function take(q)
     {var _tw_=q[2];
      if(_tw_)
       {var _tx_=_tw_[1],_ty_=_tw_[2];
        return _ty_?(q[1] = q[1] - 1 | 0,q[2] = _ty_,_tx_):(clear$0(q),_tx_)}
      throw Empty$0}
    function copy$3(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$5(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$0(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _tu_=0 < q1[1]?1:0;
      if(_tu_)
       {var _tv_=q2[3];
        return _tv_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _tv_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _tu_}
    function to_seq$4(q)
     {function aux(c,param)
       {if(c)
         {var x=c[1],next=c[2];
          return [0,x,function(_tt_){return aux(next,_tt_)}]}
        return 0}
      var _tr_=q[2];
      return function(_ts_){return aux(_tr_,_ts_)}}
    function add_seq$0(q,i){return iter(function(x){return add(x,q)},i)}
    function of_seq$4(g){var q=create$0(0);add_seq$0(q,g);return q}
    var
     Stdlib_queue=
      [0,
       Empty$0,
       create$0,
       add,
       add,
       take,
       take,
       peek,
       peek,
       clear$0,
       copy$3,
       is_empty$0,
       length$2,
       iter$5,
       fold$0,
       transfer,
       to_seq$4,
       add_seq$0,
       of_seq$4];
    caml_register_global(674,Stdlib_queue,"Stdlib__queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        blk[1] = result;
        caml_obj_set_tag(blk,250);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      blk[1] = result;
      caml_obj_set_tag(blk,250);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(675,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250)if(t !== 246)if(t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Stdlib_lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(676,Stdlib_lazy,"Stdlib__lazy");
    var
     Failure$0=[248,cst_Stdlib_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stdlib_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_U_]}
           case 2:
            var
             f=d$0[1],
             _tn_=caml_obj_tag(f),
             d$1=250 === _tn_?f[1]:246 === _tn_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _to_=d$0[1],_tp_=_to_[1];
            if(_tp_)
             {var _tq_=_tp_[1];
              if(_tq_){var a$0=_tq_[1];_to_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_to_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _to_[1] = _V_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _ti_=s[2];
        if(typeof _ti_ === "number")
         return 0;
        else
         switch(_ti_[0])
          {case 0:var a=_ti_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_W_]}
           case 2:
            var
             f=_ti_[1],
             _tj_=caml_obj_tag(f),
             _tk_=250 === _tj_?f[1]:246 === _tj_?force_lazy_block(f):f;
            s[2] = _tk_;
            continue;
           case 3:
            var _tl_=_ti_[1],_tm_=_tl_[1];
            if(_tm_){var a$1=_tm_[1];return a$1}
            var x=caml_call1(_tl_[2],s[1]);
            _tl_[1] = [0,x];
            return x;
           default:
            var b=_ti_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _tg_=s[2];
        if(typeof _tg_ !== "number")
         switch(_tg_[0])
          {case 0:var d=_tg_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _th_=_tg_[1];
            if(_th_[1]){s[1] = s[1] + 1 | 0;_th_[1] = 0;return 0}
            break;
           case 4:
            var b=_tg_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :(s[1] = s[1] + 1 | 0,b[4] = b[4] + 1 | 0,0)
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$1(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$6(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$0(l)
     {var _tf_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_tf_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _te_=data(s);return [0,[0,0,[1,data(i),_te_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_tc_)
                  {var _td_=data(s);return [1,data(caml_call1(f,0)),_td_]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_ta_)
                  {var _tb_=data(s);return [0,caml_call1(f,0),_tb_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_s$_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_s__){return data(caml_call1(f,0))}]]]]}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$5);
      return print_newline(0)}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$6);
          dump_data(f,d);
          return print_string(cst$7);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$8);
          dump_data(f,d2);
          return print_string(cst$9);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    var
     Stdlib_stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$0,
       of_string$0,
       of_bytes,
       of_channel,
       iter$6,
       next,
       empty$1,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(677,Stdlib_stream,"Stdlib__stream");
    function create$1(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$2(b,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((b[2] - len | 0) < ofs))return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$2(src,srcoff,dst,dstoff,len)
     {if(0 <= len)
       if(0 <= srcoff)
        if(! ((src[2] - len | 0) < srcoff))
         if(0 <= dstoff)
          if(! ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
           return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs)if(! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var len=b[3],new_len=[0,len];
      for(;;)
       {if(new_len[1] < (b[2] + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((b[2] + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buffer);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        return 0}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_X_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_Y_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_Z_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,___]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_$_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_aa_]}
    function add_substring(b,s,offset,len)
     {var _s7_=offset < 0?1:0;
      if(_s7_)
       var _s8_=_s7_;
      else
       var
        _s9_=len < 0?1:0,
        _s8_=_s9_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_s8_)invalid_arg(cst_Buffer_add_substring_add_subbytes);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,caml_string_of_bytes(s),offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,caml_string_of_bytes(s))}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len$1)
     {var _s5_=len$1 < 0?1:0,_s6_=_s5_ || (max_string_length < len$1?1:0);
      if(_s6_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len$1 | 0))resize(b,len$1);
      var len=len$1;
      for(;;)
       {var _s4_=0 < len?1:0;
        if(_s4_)
         {var n=input(ic,b[1],b[2],len);
          b[2] = b[2] + n | 0;
          if(0 === n)throw End_of_file;
          var len$0=len - n | 0,len=len$0;
          continue}
        return _s4_}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start);
            if(40 === opening)
             var switch$0=0;
            else
             if(123 === opening)
              var switch$0=0;
             else
              {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
               for(;;)
                {if(lim$0 <= i$3)
                  var stop=lim$0;
                 else
                  {var
                    match=caml_string_get(s,i$3),
                    switch$1=
                     91 <= match
                      ?97 <= match?123 <= match?0:1:95 === match?1:0
                      :58 <= match?65 <= match?1:0:48 <= match?1:0;
                   if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                   var stop=i$3}
                 var
                  match$0=[0,sub$0(s,start,stop - start | 0),stop],
                  switch$0=1;
                 break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _s2_=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,_ab_];var _s2_=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _s2_)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _s3_=92 === previous?1:0;
        return _s3_?add_char(b,previous):_s3_}}
    function truncate(b,len)
     {if(0 <= len)if(! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    function to_seq$5(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_get(b[1],i),_s0_=i + 1 | 0;
        return [0,x,function(_s1_){return aux(_s0_,_s1_)}]}
      var _sY_=0;
      return function(_sZ_){return aux(_sY_,_sZ_)}}
    function to_seqi$2(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_get(b[1],i),_sW_=i + 1 | 0;
        return [0,[0,i,x],function(_sX_){return aux(_sW_,_sX_)}]}
      var _sU_=0;
      return function(_sV_){return aux(_sU_,_sV_)}}
    function add_seq$1(b,seq)
     {return iter(function(_sT_){return add_char(b,_sT_)},seq)}
    function of_seq$5(i){var b=create$1(32);add_seq$1(b,i);return b}
    var
     Stdlib_buffer=
      [0,
       create$1,
       contents,
       to_bytes,
       sub$2,
       blit$2,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate,
       to_seq$5,
       to_seqi$2,
       add_seq$1,
       of_seq$5];
    caml_register_global(678,Stdlib_buffer,"Stdlib__buffer");
    function create_char_set(param){return make(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _sS_=i + 1 | 0;
        if(31 !== i){var i=_sS_;continue}
        return caml_string_of_bytes(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_sR_=[0,ndec];else var _sR_=0;
          return [0,[8,0,pad_of_pad_opt(pad_opt$5),_sR_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    var default_float_precision=-6;
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _sP_=len < min_len?1:0;
      if(_sP_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _sQ_=0}
      else
       var _sQ_=_sP_;
      return _sQ_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 12:return 117;
        case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 0:
        case 1:
        case 2:return 100;
        default:return 105}}
    function char_of_fconv(fconv)
     {switch(fconv)
       {case 15:return 70;
        case 0:
        case 1:
        case 2:return 102;
        case 3:
        case 4:
        case 5:return 101;
        case 6:
        case 7:
        case 8:return 69;
        case 9:
        case 10:
        case 11:return 103;
        case 12:
        case 13:
        case 14:return 71;
        case 16:
        case 17:
        case 18:return 104;
        default:return 72}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_new_string("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_new_string("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")
       return 0 === prec?0:buffer_add_string(buf,cst$10);
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_new_string("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv)
       {case 1:
        case 4:
        case 7:
        case 10:
        case 13:
        case 17:
        case 20:return buffer_add_char(buf,43);
        case 2:
        case 5:
        case 8:
        case 11:
        case 14:
        case 18:
        case 21:return buffer_add_char(buf,32);
        default:return 0}}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$11;
         case 1:return cst$12;
         case 2:return cst$13;
         case 3:return cst$14;
         case 4:return cst$15;
         case 5:return cst$16;
         default:return cst$17}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return _g_(cst$18,make$0(1,c))}}
    function string_of_formatting_gen(formatting_gen)
     {if(0 === formatting_gen[0])
       {var match=formatting_gen[1],str=match[2];return str}
      var match$0=formatting_gen[1],str$0=match$0[2];
      return str$0}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$19):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _sN_=caml_ml_string_length(str) - 1 | 0,_sM_=0;
      if(! (_sN_ < 0))
       {var i=_sM_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _sO_=i + 1 | 0;
          if(_sN_ !== i){var i=_sO_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$20);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$21);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$22);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$23);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$25);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           bprint_string_literal(buf,cst$26);
           bprint_string_literal(buf,string_of_formatting_gen(fmting_gen));
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _sC_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_sH_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _sI_=is_in_char_set(_sH_,c);
                 if(_sI_)
                  var
                   _sJ_=is_in_char_set(_sH_,before),
                   _sK_=_sJ_?is_in_char_set(_sH_,after):_sJ_,
                   _sL_=1 - _sK_;
                 else
                  var _sL_=_sI_;
                 return _sL_}
               return is_alone},
            is_alone=is_alone$0(_sC_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_sC_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0;
               if(48 < switcher >>> 0)
                var switch$0=210 <= switcher?(print_char(buf,255),1):0;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 var switch$0=0}
               if(! switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_sC_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var match$0=char_of_int(i$1),switcher$1=match$0 - 45 | 0;
                 if(48 < switcher$1 >>> 0)
                  var
                   switch$1=
                    210 <= switcher$1
                     ?(print_char(buf,254),print_char(buf,255),1)
                     :0;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_sC_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     var switch$1=0}
                   else
                    var switch$1=0}
                 if(! switch$1)
                  {if(! is_in_char_set(_sC_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0)
                      if(is_in_char_set(_sC_,char_of_int(j$0)))
                       {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _sD_=108;break;
             case 1:var _sD_=110;break;
             default:var _sD_=78}
           buffer_add_char(buf,_sD_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$1=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$1[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _sF_=int_of_custom_arity(arity),
            _sE_=1;
           if(! (_sF_ < 1))
            {var i$8=_sE_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _sG_=i$8 + 1 | 0;
               if(_sF_ !== i$8){var i$8=_sG_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _se_=function(param){return 0},
         _sf_=function(param){return 0},
         _sg_=function(param){return 0};
        return [0,function(param){return 0},_sg_,_sf_,_se_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _sh_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_sh_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _si_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _si_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _sj_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _sj_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _sk_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _sk_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _sl_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _sl_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _sm_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _sm_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _sn_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _sn_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _so_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _so_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _sp_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _sp_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _sq_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _sr_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _ss_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _ss_,
                  _sr_,
                  _sq_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _st_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _st_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _su_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _su_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _sv_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _sv_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _sw_=function(param){caml_call1(de$12,0);return 0},
           _sx_=function(param){caml_call1(ed$12,0);return 0},
           _sy_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _sy_,
                  _sx_,
                  _sw_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _sz_=function(param){caml_call1(de$13,0);return 0},
           _sA_=function(param){caml_call1(ed$13,0);return 0},
           _sB_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _sB_,
                  _sA_,
                  _sz_]}}
    function trans(ty1,match)
     {if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:var switch$0=0;break;
          case 11:var switch$0=1;break;
          case 12:var switch$0=2;break;
          case 13:var switch$0=3;break;
          case 14:var switch$0=4;break;
          case 8:var switch$0=5;break;
          case 9:var switch$0=6;break;
          default:throw [0,Assert_failure,_ac_]}
      else
       switch(ty1[0])
        {case 0:
          var _rX_=ty1[1];
          if(typeof match === "number")
           var switch$1=1;
          else
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_rX_,rest2)];
             case 8:var switch$0=5,switch$1=0;break;
             case 9:var switch$0=6,switch$1=0;break;
             case 10:var switch$0=0,switch$1=0;break;
             case 11:var switch$0=1,switch$1=0;break;
             case 12:var switch$0=2,switch$1=0;break;
             case 13:var switch$0=3,switch$1=0;break;
             case 14:var switch$0=4,switch$1=0;break;
             default:var switch$1=1}
          if(switch$1)var switch$0=7;
          break;
         case 1:
          var _rY_=ty1[1];
          if(typeof match === "number")
           var switch$2=1;
          else
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_rY_,rest2$0)];
             case 8:var switch$0=5,switch$2=0;break;
             case 9:var switch$0=6,switch$2=0;break;
             case 10:var switch$0=0,switch$2=0;break;
             case 11:var switch$0=1,switch$2=0;break;
             case 12:var switch$0=2,switch$2=0;break;
             case 13:var switch$0=3,switch$2=0;break;
             case 14:var switch$0=4,switch$2=0;break;
             default:var switch$2=1}
          if(switch$2)var switch$0=7;
          break;
         case 2:
          var _rZ_=ty1[1];
          if(typeof match === "number")
           var switch$3=1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_rZ_,rest2$1)];
             case 8:var switch$0=5,switch$3=0;break;
             case 9:var switch$0=6,switch$3=0;break;
             case 10:var switch$0=0,switch$3=0;break;
             case 11:var switch$0=1,switch$3=0;break;
             case 12:var switch$0=2,switch$3=0;break;
             case 13:var switch$0=3,switch$3=0;break;
             case 14:var switch$0=4,switch$3=0;break;
             default:var switch$3=1}
          if(switch$3)var switch$0=7;
          break;
         case 3:
          var _r0_=ty1[1];
          if(typeof match === "number")
           var switch$4=1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_r0_,rest2$2)];
             case 8:var switch$0=5,switch$4=0;break;
             case 9:var switch$0=6,switch$4=0;break;
             case 10:var switch$0=0,switch$4=0;break;
             case 11:var switch$0=1,switch$4=0;break;
             case 12:var switch$0=2,switch$4=0;break;
             case 13:var switch$0=3,switch$4=0;break;
             case 14:var switch$0=4,switch$4=0;break;
             default:var switch$4=1}
          if(switch$4)var switch$0=7;
          break;
         case 4:
          var _r1_=ty1[1];
          if(typeof match === "number")
           var switch$5=1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_r1_,rest2$3)];
             case 8:var switch$0=5,switch$5=0;break;
             case 9:var switch$0=6,switch$5=0;break;
             case 10:var switch$0=0,switch$5=0;break;
             case 11:var switch$0=1,switch$5=0;break;
             case 12:var switch$0=2,switch$5=0;break;
             case 13:var switch$0=3,switch$5=0;break;
             case 14:var switch$0=4,switch$5=0;break;
             default:var switch$5=1}
          if(switch$5)var switch$0=7;
          break;
         case 5:
          var _r2_=ty1[1];
          if(typeof match === "number")
           var switch$6=1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_r2_,rest2$4)];
             case 8:var switch$0=5,switch$6=0;break;
             case 9:var switch$0=6,switch$6=0;break;
             case 10:var switch$0=0,switch$6=0;break;
             case 11:var switch$0=1,switch$6=0;break;
             case 12:var switch$0=2,switch$6=0;break;
             case 13:var switch$0=3,switch$6=0;break;
             case 14:var switch$0=4,switch$6=0;break;
             default:var switch$6=1}
          if(switch$6)var switch$0=7;
          break;
         case 6:
          var _r3_=ty1[1];
          if(typeof match === "number")
           var switch$7=1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_r3_,rest2$5)];
             case 8:var switch$0=5,switch$7=0;break;
             case 9:var switch$0=6,switch$7=0;break;
             case 10:var switch$0=0,switch$7=0;break;
             case 11:var switch$0=1,switch$7=0;break;
             case 12:var switch$0=2,switch$7=0;break;
             case 13:var switch$0=3,switch$7=0;break;
             case 14:var switch$0=4,switch$7=0;break;
             default:var switch$7=1}
          if(switch$7)var switch$0=7;
          break;
         case 7:
          var _r4_=ty1[1];
          if(typeof match === "number")
           var switch$8=1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_r4_,rest2$6)];
             case 8:var switch$0=5,switch$8=0;break;
             case 9:var switch$0=6,switch$8=0;break;
             case 10:var switch$0=0,switch$8=0;break;
             case 11:var switch$0=1,switch$8=0;break;
             case 12:var switch$0=2,switch$8=0;break;
             case 13:var switch$0=3,switch$8=0;break;
             case 14:var switch$0=4,switch$8=0;break;
             default:var switch$8=1}
          if(switch$8)var switch$0=7;
          break;
         case 8:
          var _r5_=ty1[2],_r6_=ty1[1];
          if(typeof match === "number")
           var switch$9=1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_r7_=trans(_r5_,rest2$7);
              return [8,trans(_r6_,ty2),_r7_];
             case 10:var switch$0=0,switch$9=0;break;
             case 11:var switch$0=1,switch$9=0;break;
             case 12:var switch$0=2,switch$9=0;break;
             case 13:var switch$0=3,switch$9=0;break;
             case 14:var switch$0=4,switch$9=0;break;
             default:var switch$9=1}
          if(switch$9)throw [0,Assert_failure,_al_];
          break;
         case 9:
          var _r8_=ty1[3],_r9_=ty1[2],_r__=ty1[1];
          if(typeof match === "number")
           var switch$10=1;
          else
           switch(match[0])
            {case 8:var switch$0=5,switch$10=0;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_r9_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_r__,ty22,trans(_r8_,rest2$8)];
             case 10:var switch$0=0,switch$10=0;break;
             case 11:var switch$0=1,switch$10=0;break;
             case 12:var switch$0=2,switch$10=0;break;
             case 13:var switch$0=3,switch$10=0;break;
             case 14:var switch$0=4,switch$10=0;break;
             default:var switch$10=1}
          if(switch$10)throw [0,Assert_failure,_am_];
          break;
         case 10:
          var _r$_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_r$_,rest2$9)]}
          throw [0,Assert_failure,_an_];
         case 11:
          var _sa_=ty1[1];
          if(typeof match === "number")
           var switch$11=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$11=0;break;
             case 11:var rest2$10=match[1];return [11,trans(_sa_,rest2$10)];
             default:var switch$11=1}
          if(switch$11)throw [0,Assert_failure,_ao_];
          break;
         case 12:
          var _sb_=ty1[1];
          if(typeof match === "number")
           var switch$12=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$12=0;break;
             case 11:var switch$0=1,switch$12=0;break;
             case 12:var rest2$11=match[1];return [12,trans(_sb_,rest2$11)];
             default:var switch$12=1}
          if(switch$12)throw [0,Assert_failure,_ap_];
          break;
         case 13:
          var _sc_=ty1[1];
          if(typeof match === "number")
           var switch$13=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$13=0;break;
             case 11:var switch$0=1,switch$13=0;break;
             case 12:var switch$0=2,switch$13=0;break;
             case 13:var rest2$12=match[1];return [13,trans(_sc_,rest2$12)];
             default:var switch$13=1}
          if(switch$13)throw [0,Assert_failure,_aq_];
          break;
         default:
          var _sd_=ty1[1];
          if(typeof match === "number")
           var switch$14=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$14=0;break;
             case 11:var switch$0=1,switch$14=0;break;
             case 12:var switch$0=2,switch$14=0;break;
             case 13:var switch$0=3,switch$14=0;break;
             case 14:var rest2$13=match[1];return [14,trans(_sd_,rest2$13)];
             default:var switch$14=1}
          if(switch$14)throw [0,Assert_failure,_ar_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_af_];
        case 1:throw [0,Assert_failure,_ag_];
        case 2:throw [0,Assert_failure,_ah_];
        case 3:throw [0,Assert_failure,_ai_];
        case 4:throw [0,Assert_failure,_aj_];
        case 5:throw [0,Assert_failure,_ad_];
        case 6:throw [0,Assert_failure,_ae_];
        default:throw [0,Assert_failure,_ak_]}}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _rV_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_rW_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _rW_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_rW_,_rV_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?0 === prec?fmtty:[2,fmtty]:fmtty}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mismatch,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(0 === prec)
         {var rest=match[2],pad$0=match[1];return [0,pad$0,0,rest]}
        var _rU_=match[2];
        if(typeof _rU_ !== "number" && 2 === _rU_[0])
         {var rest$0=_rU_[1],pad$1=match[1];return [0,pad$1,1,rest$0]}
        throw Type_mismatch}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_format(fmt,fmtty)
     {var _rT_=type_format_gen(fmt,fmtty);
      if(typeof _rT_[2] === "number"){var fmt$0=_rT_[1];return fmt$0}
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           _ro_=type_padding(pad,fmtty),
           _rp_=_ro_[2],
           _rq_=_ro_[1];
          if(typeof _rp_ !== "number" && 1 === _rp_[0])
           {var
             fmtty_rest$1=_rp_[1],
             match$1=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$1[2],
             fmt$2=match$1[1];
            return [0,[2,_rq_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           _rr_=type_padding(pad$0,fmtty),
           _rs_=_rr_[2],
           _rt_=_rr_[1];
          if(typeof _rs_ !== "number" && 1 === _rs_[0])
           {var
             fmtty_rest$2=_rs_[1],
             match$2=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$2[2],
             fmt$3=match$2[1];
            return [0,[3,_rt_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           _ru_=type_padprec(pad$1,prec,fmtty),
           _rv_=_ru_[3],
           _rw_=_ru_[2],
           _rx_=_ru_[1];
          if(typeof _rv_ !== "number" && 2 === _rv_[0])
           {var
             fmtty_rest$3=_rv_[1],
             match$3=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$3[2],
             fmt$4=match$3[1];
            return [0,[4,iconv,_rx_,_rw_,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$0=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           _ry_=type_padprec(pad$2,prec$0,fmtty),
           _rz_=_ry_[3],
           _rA_=_ry_[2],
           _rB_=_ry_[1];
          if(typeof _rz_ !== "number" && 3 === _rz_[0])
           {var
             fmtty_rest$4=_rz_[1],
             match$4=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$4[2],
             fmt$5=match$4[1];
            return [0,[5,iconv$0,_rB_,_rA_,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$1=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           _rC_=type_padprec(pad$3,prec$1,fmtty),
           _rD_=_rC_[3],
           _rE_=_rC_[2],
           _rF_=_rC_[1];
          if(typeof _rD_ !== "number" && 4 === _rD_[0])
           {var
             fmtty_rest$5=_rD_[1],
             match$5=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$5[2],
             fmt$6=match$5[1];
            return [0,[6,iconv$1,_rF_,_rE_,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$2=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           _rG_=type_padprec(pad$4,prec$2,fmtty),
           _rH_=_rG_[3],
           _rI_=_rG_[2],
           _rJ_=_rG_[1];
          if(typeof _rH_ !== "number" && 5 === _rH_[0])
           {var
             fmtty_rest$6=_rH_[1],
             match$6=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$6[2],
             fmt$7=match$6[1];
            return [0,[7,iconv$2,_rJ_,_rI_,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$3=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           _rK_=type_padprec(pad$5,prec$3,fmtty),
           _rL_=_rK_[3],
           _rM_=_rK_[2],
           _rN_=_rK_[1];
          if(typeof _rL_ !== "number" && 6 === _rL_[0])
           {var
             fmtty_rest$7=_rL_[1],
             match$7=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$7[2],
             fmt$8=match$7[1];
            return [0,[8,fconv,_rN_,_rM_,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           _rO_=type_padding(pad$6,fmtty),
           _rP_=_rO_[2],
           _rQ_=_rO_[1];
          if(typeof _rP_ !== "number" && 7 === _rP_[0])
           {var
             fmtty_rest$8=_rP_[1],
             match$8=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$8[2],
             fmt$9=match$8[1];
            return [0,[9,_rQ_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$9=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$9[2],
           fmt$10=match$9[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$10=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$10[2],
           fmt$11=match$10[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$11=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$11[2],
           fmt$12=match$11[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$12=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$12[2],
             fmt$13=match$12[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _rR_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_rR_))
             throw Type_mismatch;
            var
             match$13=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$13[2],
             fmt$14=match$13[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$14=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$14[2],
             fmt$15=match$14[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$15=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$15[2],
             fmt$16=match$15[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$16=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$16[2],
           fmt$17=match$16[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$20=formatting_gen[1],
             str$0=match$20[2],
             fmt1=match$20[1],
             match$21=type_format_gen(fmt1,fmtty),
             fmtty2=match$21[2],
             fmt2=match$21[1],
             match$22=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$22[2],
             fmt3=match$22[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$23=formatting_gen[1],
           str$1=match$23[2],
           fmt1$0=match$23[1],
           match$24=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$24[2],
           fmt2$0=match$24[1],
           match$25=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$25[2],
           fmt3$0=match$25[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$17=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$17[2],
             fmt$18=match$17[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$18=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$18[2],
             fmt$19=match$18[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$19=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$19[2],
             fmt$20=match$19[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$26=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$26[2],
                 fmt$21=match$26[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _rS_=type_ignored_format_substitution(sub_fmtty$3,rest,fmtty),
               match$27=_rS_[2],
               fmtty$22=match$27[2],
               fmt$22=match$27[1],
               sub_fmtty$4=_rS_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_format_substitution(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substitution(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substitution
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substitution
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substitution
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substitution
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substitution
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substitution
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substitution
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substitution
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _rm_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_rm_))
             throw Type_mismatch;
            var _rn_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_rn_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substitution
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substitution
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substitution
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substitution
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substitution
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _rl_=2 === padty$0?48:32,res=make(width$0,_rl_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         if(0 < len)
          {if(43 === caml_string_get(str,0))
            var switch$1=1;
           else
            if(45 === caml_string_get(str,0))
             var switch$1=1;
            else
             if(32 === caml_string_get(str,0))
              var switch$1=1;
             else
              var switch$0=0,switch$1=0;
           if(switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0);
             var switch$0=1}}
         else
          var switch$0=0;
         if(! switch$0)
          {if(1 < len)
            if(48 === caml_string_get(str,0))
             {if(120 === caml_string_get(str,1))
               var switch$3=1;
              else
               if(88 === caml_string_get(str,1))
                var switch$3=1;
               else
                var switch$2=0,switch$3=0;
              if(switch$3)
               {caml_bytes_set(res,1,caml_string_get(str,1));
                blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0);
                var switch$2=1}}
            else
             var switch$2=0;
           else
            var switch$2=0;
           if(! switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0);
      if(58 <= c)
       var switch$0=71 <= c?5 < (c - 97 | 0) >>> 0?1:0:65 <= c?0:1;
      else
       {if(32 === c)
         var switch$1=1;
        else
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0))
               if(1 < len)
                {var
                  switch$2=
                   120 === caml_string_get(str,1)
                    ?0
                    :88 === caml_string_get(str,1)?0:1;
                 if(! switch$2)
                  {var res$1=make(prec$0 + 2 | 0,48);
                   caml_bytes_set(res$1,1,caml_string_get(str,1));
                   blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                   return caml_string_of_bytes(res$1)}}
              var switch$0=0,switch$1=0;
              break;
             case 0:
             case 2:var switch$1=1;break;
             case 1:
             case 3:
             case 4:var switch$0=1,switch$1=0;break;
             default:var switch$0=0,switch$1=0}}
         else
          var switch$0=1,switch$1=0;
        if(switch$1)
         {if(len < (prec$0 + 1 | 0))
           {var res$0=make(prec$0 + 1 | 0,48);
            caml_bytes_set(res$0,0,c);
            blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
            return caml_string_of_bytes(res$0)}
          var switch$0=1}}
      if(! switch$0)
       if(len < prec$0)
        {var res=make(prec$0,48);
         blit$0(str,0,res,prec$0 - len | 0,len);
         return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 0:var _rk_=cst_d$2;break;
        case 1:var _rk_=cst_d$3;break;
        case 2:var _rk_=cst_d$4;break;
        case 3:var _rk_=cst_i$0;break;
        case 4:var _rk_=cst_i$1;break;
        case 5:var _rk_=cst_i$2;break;
        case 6:var _rk_=cst_x;break;
        case 7:var _rk_=cst_x$0;break;
        case 8:var _rk_=cst_X$0;break;
        case 9:var _rk_=cst_X$1;break;
        case 10:var _rk_=cst_o;break;
        case 11:var _rk_=cst_o$0;break;
        default:var _rk_=cst_u}
      return caml_format_int(_rk_,n)}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 0:var _rj_=cst_ld;break;
        case 1:var _rj_=cst_ld$0;break;
        case 2:var _rj_=cst_ld$1;break;
        case 3:var _rj_=cst_li$0;break;
        case 4:var _rj_=cst_li$1;break;
        case 5:var _rj_=cst_li$2;break;
        case 6:var _rj_=cst_lx;break;
        case 7:var _rj_=cst_lx$0;break;
        case 8:var _rj_=cst_lX;break;
        case 9:var _rj_=cst_lX$0;break;
        case 10:var _rj_=cst_lo;break;
        case 11:var _rj_=cst_lo$0;break;
        default:var _rj_=cst_lu}
      return caml_format_int(_rj_,n)}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 0:var _ri_=cst_nd;break;
        case 1:var _ri_=cst_nd$0;break;
        case 2:var _ri_=cst_nd$1;break;
        case 3:var _ri_=cst_ni$0;break;
        case 4:var _ri_=cst_ni$1;break;
        case 5:var _ri_=cst_ni$2;break;
        case 6:var _ri_=cst_nx;break;
        case 7:var _ri_=cst_nx$0;break;
        case 8:var _ri_=cst_nX;break;
        case 9:var _ri_=cst_nX$0;break;
        case 10:var _ri_=cst_no;break;
        case 11:var _ri_=cst_no$0;break;
        default:var _ri_=cst_nu}
      return caml_format_int(_ri_,n)}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 0:var _rh_=cst_Ld;break;
        case 1:var _rh_=cst_Ld$0;break;
        case 2:var _rh_=cst_Ld$1;break;
        case 3:var _rh_=cst_Li$0;break;
        case 4:var _rh_=cst_Li$1;break;
        case 5:var _rh_=cst_Li$2;break;
        case 6:var _rh_=cst_Lx;break;
        case 7:var _rh_=cst_Lx$0;break;
        case 8:var _rh_=cst_LX;break;
        case 9:var _rh_=cst_LX$0;break;
        case 10:var _rh_=cst_Lo;break;
        case 11:var _rh_=cst_Lo$0;break;
        default:var _rh_=cst_Lu}
      return caml_int64_format(_rh_,n)}
    function convert_float(fconv,prec$0,x)
     {if(16 <= fconv)
       {if(17 <= fconv)
         switch(fconv - 17 | 0)
          {case 2:var switch$0=0;break;
           case 0:
           case 3:var sign=43,switch$0=1;break;
           default:var sign=32,switch$0=1}
        else
         var switch$0=0;
        if(! switch$0)var sign=45;
        var str=runtime.caml_hexstring_of_float(x,prec$0,sign);
        return 19 <= fconv?uppercase_ascii$1(str):str}
      if(15 === fconv)
       var _re_=cst_12g$0;
      else
       {var prec=abs(prec$0),symb=char_of_fconv(fconv),buf=buffer_create(16);
        buffer_add_char(buf,37);
        bprint_fconv_flag(buf,fconv);
        buffer_add_char(buf,46);
        buffer_add_string(buf,caml_new_string("" + prec));
        buffer_add_char(buf,symb);
        var _re_=buffer_contents(buf)}
      var str$0=caml_format_float(_re_,x);
      if(15 === fconv)
       {var
         len=caml_ml_string_length(str$0),
         match$0=runtime.caml_classify_float(x);
        if(3 === match$0)return x < 0?cst_neg_infinity:cst_infinity;
        if(4 <= match$0)return cst_nan;
        var i=0;
        for(;;)
         {if(i === len)
           var _rg_=0;
          else
           {var
             match=caml_string_get(str$0,i),
             _rf_=match - 46 | 0,
             switch$1=
              23 < _rf_ >>> 0?55 === _rf_?1:0:21 < (_rf_ - 1 | 0) >>> 0?1:0;
            if(! switch$1){var i$0=i + 1 | 0,i=i$0;continue}
            var _rg_=1}
          return _rg_?str$0:_g_(str$0,cst$27)}}
      return str$0}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_int_padding_precision(k,o,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return 0 === match
                 ?function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,o,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _rb_=pad[2],_rc_=pad[1];
          if(typeof match === "number")
           return 0 === match
                   ?function(x)
                     {var str=fix_padding(_rc_,_rb_,caml_call2(trans,iconv,x));
                      return make_printf(k,o,[4,acc,str],fmt)}
                   :function(p,x)
                     {var
                       str=
                        fix_padding
                         (_rc_,_rb_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,o,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_rc_,_rb_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,o,[4,acc,str],fmt)}}
        var _rd_=pad[1];
        if(typeof match === "number")
         return 0 === match
                 ?function(w,x)
                   {var str=fix_padding(_rd_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_rd_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_rd_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,o,[4,acc,str],fmt)}}}
    function make_padding(k,o,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,o,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,o,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,o,new_acc,fmt)}}}
    function make_printf$0(counter,k,o,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call2(k$0,o,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,o,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,o,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding
                   (k$0,o,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(x)
                        {var str=convert_float(fconv,default_float_precision,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)}
                      :function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _q__=pad$5[2],_q$_=pad$5[1];
               if(typeof prec$3 === "number")
                return 0 === prec$3
                        ?function(x)
                          {var
                            str=convert_float(fconv,default_float_precision,x),
                            str$0=fix_padding(_q$_,_q__,str);
                           return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                        :function(p,x)
                          {var str=fix_padding(_q$_,_q__,convert_float(fconv,p,x));
                           return make_printf(k$0,o,[4,acc$0,str],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_q$_,_q__,convert_float(fconv,p$0,x));
                 return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
             var _ra_=pad$5[1];
             if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision,x),
                          str$0=fix_padding(_ra_,w,str);
                         return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                      :function(w,p,x)
                        {var str=fix_padding(_ra_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_ra_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str)
            {return make_printf(k$0,o,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,o,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      o,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,o,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _q8_=fmt$0[1];
           if(0 === _q8_[0])
            {var
              rest$13=fmt$0[2],
              match=_q8_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(koc,kacc)
                  {return make_printf(k,koc,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_q8_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(koc,kacc)
                {return make_printf(k,koc,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_as_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,o,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,o,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];
             return make_printf(k$0,o,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,o,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,o,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _q9_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,o,acc$0,rest$19,arity,_q9_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,o,acc$0,rest$19,arity,_q9_])}}
    function make_ignored_param$0(counter,k,o,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:throw [0,Assert_failure,_at_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,o,acc,fmtty,fmt)}
          return caml_trampoline_return
                  (make_from_fmtty$0,[0,k,o,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}}
    function make_from_fmtty$0(counter,k,o,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,o,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,o,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,o,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_q7_)
           {return make_from_fmtty(k,o,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_au_];
         default:throw [0,Assert_failure,_av_]}}
    function make_invalid_arg(counter,k,o,acc,fmt)
     {var _q6_=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_q6_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_q6_,fmt])}
    function make_custom$0(counter,k,o,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,o,acc,rest,arity$0,caml_call1(f,x))}}
      var _q5_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_q5_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_q5_,rest])}
    function make_printf(k,o,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,o,acc,fmt))}
    function make_ignored_param(k,o,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,o,acc,ign,fmt))}
    function make_from_fmtty(k,o,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,o,acc,fmtty,fmt))}
    function make_custom(k,o,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,o,acc,rest,arity,f))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {var _qB_=make_iprintf(k,o,fmt);return function(_qT_){return _qB_}}
          var _qC_=make_iprintf(k,o,fmt),_qD_=function(_qS_){return _qC_};
          return function(_qR_){return _qD_}}
        var _qE_=make_iprintf(k,o,fmt);
        return function(_qQ_){return _qE_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(0 === prec)
             {var _qF_=make_iprintf(k,o,fmt);
              return function(_q4_){return _qF_}}
            var _qG_=make_iprintf(k,o,fmt),_qH_=function(_q3_){return _qG_};
            return function(_q2_){return _qH_}}
          var _qI_=make_iprintf(k,o,fmt);
          return function(_q1_){return _qI_}}
        if(typeof prec === "number")
         {if(0 === prec)
           {var _qJ_=make_iprintf(k,o,fmt),_qK_=function(_q0_){return _qJ_};
            return function(_qZ_){return _qK_}}
          var
           _qL_=make_iprintf(k,o,fmt),
           _qM_=function(_qY_){return _qL_},
           _qN_=function(_qX_){return _qM_};
          return function(_qW_){return _qN_}}
        var _qO_=make_iprintf(k,o,fmt),_qP_=function(_qV_){return _qO_};
        return function(_qU_){return _qP_}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_pS_=make_iprintf(k$0,o,rest);
           return function(_qA_){return _pS_};
          case 1:
           var rest$0=fmt$0[1],_pT_=make_iprintf(k$0,o,rest$0);
           return function(_qz_){return _pT_};
          case 2:
           var _pU_=fmt$0[1];
           if(typeof _pU_ === "number")
            {var rest$1=fmt$0[2],_pV_=make_iprintf(k$0,o,rest$1);
             return function(_qv_){return _pV_}}
           else
            {if(0 === _pU_[0])
              {var rest$2=fmt$0[2],_pW_=make_iprintf(k$0,o,rest$2);
               return function(_qy_){return _pW_}}
             var
              rest$3=fmt$0[2],
              _pX_=make_iprintf(k$0,o,rest$3),
              _pY_=function(_qx_){return _pX_};
             return function(_qw_){return _pY_}}
          case 3:
           var _pZ_=fmt$0[1];
           if(typeof _pZ_ === "number")
            {var rest$4=fmt$0[2],_p0_=make_iprintf(k$0,o,rest$4);
             return function(_qr_){return _p0_}}
           else
            {if(0 === _pZ_[0])
              {var rest$5=fmt$0[2],_p1_=make_iprintf(k$0,o,rest$5);
               return function(_qu_){return _p1_}}
             var
              rest$6=fmt$0[2],
              _p2_=make_iprintf(k$0,o,rest$6),
              _p3_=function(_qt_){return _p2_};
             return function(_qs_){return _p3_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _p4_=fmt$0[1];
           if(typeof _p4_ === "number")
            {var rest$12=fmt$0[2],_p5_=make_iprintf(k$0,o,rest$12);
             return function(_qn_){return _p5_}}
           else
            {if(0 === _p4_[0])
              {var rest$13=fmt$0[2],_p6_=make_iprintf(k$0,o,rest$13);
               return function(_qq_){return _p6_}}
             var
              rest$14=fmt$0[2],
              _p7_=make_iprintf(k$0,o,rest$14),
              _p8_=function(_qp_){return _p7_};
             return function(_qo_){return _p8_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_p9_=make_iprintf(k$0,o,rest$15);
           return function(_qm_){return _p9_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _p__=make_iprintf(k$0,o,rest$17),
            _p$_=function(_ql_){return _p__};
           return function(_qk_){return _p$_};
          case 16:
           var rest$18=fmt$0[1],_qa_=make_iprintf(k$0,o,rest$18);
           return function(_qj_){return _qa_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _qb_=fmt$0[1];
           if(0 === _qb_[0])
            {var
              rest$19=fmt$0[2],
              match=_qb_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_qb_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_aw_];
          case 20:
           var rest$21=fmt$0[3],_qc_=make_iprintf(k$0,o,rest$21);
           return function(_qi_){return _qc_};
          case 21:
           var rest$22=fmt$0[2],_qd_=make_iprintf(k$0,o,rest$22);
           return function(_qh_){return _qd_};
          case 22:
           var rest$23=fmt$0[1],_qe_=make_iprintf(k$0,o,rest$23);
           return function(_qg_){return _qe_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_qf_=0;
           return make_ignored_param
                   (function(x,param){return caml_call1(k$0,x)},
                    o,
                    _qf_,
                    ign,
                    rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_pQ_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_pR_){return _pQ_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _pO_=acc$0[2],_pP_=acc$0[1];
           if(0 === _pO_[0])
            {var acc$1=_pO_[1];
             output_acc(o,_pP_);
             output_string(o,cst$28);
             var acc$0=acc$1;
             continue}
           var acc$2=_pO_[1];
           output_acc(o,_pP_);
           output_string(o,cst$29);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _pM_=acc$0[2],_pN_=acc$0[1];
           if(0 === _pM_[0])
            {var acc$1=_pM_[1];
             bufput_acc(b,_pN_);
             add_string(b,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_pM_[1];
           bufput_acc(b,_pN_);
           add_string(b,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _pK_=acc$0[2],_pL_=acc$0[1];
           if(0 === _pK_[0])
            {var acc$1=_pK_[1];
             strput_acc(b,_pL_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_pK_[1];
           strput_acc(b,_pL_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$1(256);
      function k(param,acc)
       {strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$34))return _ax_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_ay_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match)if(32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var
           match=caml_string_get(str,j$0),
           switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _pI_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_pI_}
       catch(_pJ_)
        {_pJ_ = caml_wrap_exception(_pJ_);
         if(_pJ_[1] !== Failure)throw _pJ_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      if(caml_string_notequal(box_name,cst$35))
       if(caml_string_notequal(box_name,cst_b$0))
        if(caml_string_notequal(box_name,cst_h))
         if(caml_string_notequal(box_name,cst_hov))
          if(caml_string_notequal(box_name,cst_hv))
           if(caml_string_notequal(box_name,cst_v))
            var box_type=invalid_box(0),switch$0=1;
           else
            var box_type=1,switch$0=1;
          else
           var box_type=2,switch$0=1;
         else
          var box_type=3,switch$0=1;
        else
         var box_type=0,switch$0=1;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=0 === prec?[0,0,fmt]:[0,1,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_az_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_aA_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_aB_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _pH_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_pH_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aN_;
            else
             {var c=caml_string_get(str,str_ind$0);
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  var switch$0=0;
                 else
                  switch(switcher)
                   {case 0:
                     var
                      match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]],
                      switch$0=1}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var
                      match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]],
                      switch$0=1}}
                else
                 var switch$0=0;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]],
                 switch$0=1;
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aO_,fmt_rest$5]],
                      switch$0=1;
                     break;
                    case 5:
                     if((str_ind$0 + 1 | 0) < end_ind)
                      if(37 === caml_string_get(str,str_ind$0 + 1 | 0))
                       var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]],
                        switch$0=1,
                        switch$1=0;
                      else
                       var switch$1=1;
                     else
                      var switch$1=1;
                     if(switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]],
                       switch$0=1;
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aP_,fmt_rest$8]],
                      switch$0=1;
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]],
                      switch$0=1;
                     break;
                    case 27:
                     var
                      match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 28:
                     var
                      match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]],
                      switch$0=1;
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]],
                      switch$0=1;
                     break;
                    default:var switch$0=0}}
                else
                 var switch$0=0;
              if(! switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number")if(0 === match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aH_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aI_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$36);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$37)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        if(124 <= symb)
         var switch$0=0;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]],
             switch$0=1;
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _pg_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _pg_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_pg_,switch$0=1;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind),switch$0=1;break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _pi_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_pi_,
             switch$0=1;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_po_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _po_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_po_,switch$0=1;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _pp_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _pp_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_pp_,switch$0=1;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _pG_=i + 1 | 0;
                    if(c !== i){var i=_pG_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aR_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _pF_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_pF_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_pF_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0);
                  if(46 <= c$1)
                   if(64 === c$1)
                    var switch$0=0;
                   else
                    {if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}
                     var switch$0=1}
                  else
                   if(37 === c$1)
                    var switch$0=0;
                   else
                    {if(45 <= c$1)
                      {var str_ind$2=str_ind$0 + 1 | 0;
                       if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                       var c$2=caml_string_get(str,str_ind$2);
                       if(37 === c$2)
                        {if((str_ind$2 + 1 | 0) === end_ind)
                          unexpected_end_of_format(end_ind);
                         var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                         if(37 !== c$3)
                          if(64 !== c$3)return fail_single_percent(str_ind$2);
                         add_range(c$0,c$3);
                         var _pD_=str_ind$2 + 2 | 0;
                         if(counter < 50)
                          {var counter$2=counter + 1 | 0;
                           return parse_char_set_content(counter$2,_pD_,end_ind)}
                         return caml_trampoline_return
                                 (parse_char_set_content,[0,_pD_,end_ind])}
                       if(93 === c$2)
                        {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                       add_range(c$0,c$2);
                       var _pE_=str_ind$2 + 1 | 0;
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return parse_char_set_content(counter$1,_pE_,end_ind)}
                       return caml_trampoline_return
                               (parse_char_set_content,[0,_pE_,end_ind])}
                     var switch$0=1}
                  if(! switch$0)
                   if(37 === c$0)
                    {add_char(c$1);
                     var _pC_=str_ind$0 + 1 | 0;
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return parse_char_set_content(counter$0,_pC_,end_ind)}
                     return caml_trampoline_return
                             (parse_char_set_content,[0,_pC_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,str_ind$1=str_ind$0,reverse=1;
            else
             var str_ind$1=str_ind,reverse=0;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _pu_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _pu_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_pu_,switch$0=1;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]],
             switch$0=1;
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _pv_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _pw_=_pv_;
              else
               var
                _pw_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,
                     cst_non_zero_widths_are_unsupported_for_c_conversions);
              var _px_=_pw_}
            else
             var _px_=char_format(fmt_rest$21);
            var fmt_result=_px_,switch$0=1;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _py_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_py_,
             switch$0=1;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _pz_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _pz_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_pz_,switch$0=1;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]],
             switch$0=1;
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _pA_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _pA_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_pA_,switch$0=1;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _ph_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _ph_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_ph_,switch$0=1;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]],
             switch$0=1;
            break;
           case 76:
           case 108:
           case 110:
            if(str_ind === end_ind)
             var switch$1=1;
            else
             {var symb$0=caml_string_get(str,str_ind),_pB_=symb$0 - 88 | 0;
              if(32 < _pB_ >>> 0)
               var switch$2=0;
              else
               switch(_pB_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _pn_=1,switch$2=1;break;
                 default:var switch$2=0}
              if(! switch$2)var _pn_=0;
              if(_pn_)var switch$0=0,switch$1=0;else var switch$1=1}
            if(switch$1)
             {var match$15=parse(str_ind,end_ind),fmt_rest$13=match$15[1];
              if(108 <= symb)
               if(111 <= symb)
                var switch$3=0;
               else
                {var switcher$0=symb - 108 | 0;
                 switch(switcher$0)
                  {case 0:var counter=0,switch$3=1;break;
                   case 1:var switch$3=0;break;
                   default:var counter=1,switch$3=1}}
              else
               if(76 === symb)var counter=2,switch$3=1;else var switch$3=0;
              if(! switch$3)throw [0,Assert_failure,_aV_];
              if(get_ign(0))
               var ignored$5=[11,counter],_pm_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _pm_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_pm_,switch$0=1}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=caml_call3(failwith_message(_aM_),str,pct_ind,symb),
             switch$0=1;
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _pq_=get_space(0),
             _pr_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_pr_,_pq_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _ps_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _pt_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_pt_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _ps_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_ps_,switch$0=1;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             plus$2=get_plus(0),
             plus$3=plus$2,
             space$2=space$1;
            for(;;)
             {if(0 === plus$3)
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$1=symb - 101 | 0;
                   if(3 < switcher$1 >>> 0)
                    var switch$4=0;
                   else
                    switch(switcher$1)
                     {case 0:var fconv=3,switch$4=1;break;
                      case 1:var fconv=0,switch$4=1;break;
                      case 2:var fconv=9,switch$4=1;break;
                      default:var fconv=16,switch$4=1}}
                 else
                  if(69 <= symb)
                   {var switcher$2=symb - 69 | 0;
                    switch(switcher$2)
                     {case 0:var fconv=6,switch$4=1;break;
                      case 1:var fconv=15,switch$4=1;break;
                      case 2:var fconv=12,switch$4=1;break;
                      default:var fconv=19,switch$4=1}}
                  else
                   var switch$4=0;
                 if(! switch$4)throw [0,Assert_failure,_aX_]}
               else
                {if(73 <= symb)
                  {var switcher$3=symb - 101 | 0;
                   if(3 < switcher$3 >>> 0)
                    var switch$5=0;
                   else
                    switch(switcher$3)
                     {case 0:var fconv=5,switch$5=1;break;
                      case 1:var fconv=2,switch$5=1;break;
                      case 2:var fconv=11,switch$5=1;break;
                      default:var fconv=18,switch$5=1}}
                 else
                  if(69 <= symb)
                   {var switcher$4=symb - 69 | 0;
                    switch(switcher$4)
                     {case 0:var fconv=8,switch$5=1;break;
                      case 1:var switch$5=0;break;
                      case 2:var fconv=14,switch$5=1;break;
                      default:var fconv=21,switch$5=1}}
                  else
                   var switch$5=0;
                 if(! switch$5)
                  {if(legacy_behavior$0){var space$2=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$48)}}
              else
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$5=symb - 101 | 0;
                   if(3 < switcher$5 >>> 0)
                    var switch$6=0;
                   else
                    switch(switcher$5)
                     {case 0:var fconv=4,switch$6=1;break;
                      case 1:var fconv=1,switch$6=1;break;
                      case 2:var fconv=10,switch$6=1;break;
                      default:var fconv=17,switch$6=1}}
                 else
                  if(69 <= symb)
                   {var switcher$6=symb - 69 | 0;
                    switch(switcher$6)
                     {case 0:var fconv=7,switch$6=1;break;
                      case 1:var switch$6=0;break;
                      case 2:var fconv=13,switch$6=1;break;
                      default:var fconv=20,switch$6=1}}
                  else
                   var switch$6=0;
                 if(! switch$6)
                  {if(legacy_behavior$0){var plus$3=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$49)}}
               else
                {if(legacy_behavior$0){var space$2=0;continue}
                 var fconv=incompatible_flag(pct_ind,str_ind,32,cst$50)}
              var match$13=parse(str_ind,end_ind),fmt_rest$11=match$13[1];
              if(get_ign(0))
               {var match=get_prec(0);
                if(typeof match === "number")
                 var
                  _pj_=
                   0 === match?0:incompatible_flag(pct_ind,str_ind,95,cst$38);
                else
                 var ndec=match[1],_pj_=[0,ndec];
                var
                 ignored$4=[6,get_pad_opt(95),_pj_],
                 _pk_=[0,[23,ignored$4,fmt_rest$11]]}
              else
               var
                _pl_=get_prec(0),
                match$14=make_padprec_fmt_ebb(get_pad(0),_pl_,fmt_rest$11),
                fmt_rest$12=match$14[3],
                prec$3=match$14[2],
                pad$5=match$14[1],
                _pk_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
              var fmt_result=_pk_,switch$0=1;
              break}
            break;
           default:var switch$0=0}
        if(! switch$0)
         {if(108 <= symb)
           if(111 <= symb)
            var switch$7=0;
           else
            {var switcher=symb - 108 | 0;
             switch(switcher)
              {case 0:
                var
                 _o2_=caml_string_get(str,str_ind),
                 _o3_=get_space(0),
                 _o4_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_o4_,_o3_,_o2_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _o5_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _o7_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_o7_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _o5_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _o6_=_o5_,switch$8=1;
                break;
               case 1:var switch$7=0,switch$8=0;break;
               default:
                var
                 _o8_=caml_string_get(str,str_ind),
                 _o9_=get_space(0),
                 _o__=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_o__,_o9_,_o8_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _o$_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _pa_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_pa_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _o$_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _o6_=_o$_,switch$8=1}
             if(switch$8)var fmt_result=_o6_,switch$7=1}
          else
           if(76 === symb)
            {var
              _pb_=caml_string_get(str,str_ind),
              _pc_=get_space(0),
              _pd_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_pd_,_pc_,_pb_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _pe_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _pf_=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_pf_,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _pe_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_pe_,switch$7=1}
           else
            var switch$7=0;
          if(! switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aJ_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _oT_=1 - plus_used[1],plus$0=_oT_?plus:_oT_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$39);
          var _oU_=1 - hash_used[1],hash$0=_oU_?hash:_oU_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$40);
          var _oV_=1 - space_used[1],space$0=_oV_?space:_oV_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _oW_=1 - pad_used[1],_oX_=_oW_?caml_notequal([0,pad],_aK_):_oW_;
          if(_oX_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _oY_=1 - prec_used[1],
           _oZ_=_oY_?caml_notequal([0,prec],_aL_):_oY_;
          if(_oZ_)
           {var _o0_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_o0_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$42)}
        var _o1_=1 - ign_used[1],ign$0=_o1_?ign:_o1_;
        if(ign$0)
         {var
           switch$9=
            38 <= symb
             ?44 === symb?0:64 === symb?0:1
             :33 === symb?0:37 <= symb?0:1,
           switch$10=switch$9?0:legacy_behavior$0?1:0;
          if(! switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$43)}
        return fmt_result}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number")if(0 === match)return parse_conv(0);
          if(0 === minus)
           {if(typeof match === "number")return parse_conv(_aF_);
            var n=match[1];
            return parse_conv([0,1,n])}
          if(typeof match === "number")return parse_conv(_aG_);
          var n$0=match[1];
          return parse_conv([0,0,n$0])}
        return parse_conv(pad)}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _oS_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_oS_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aE_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _oP_=flag[1],_oQ_=_oP_?1 - legacy_behavior$0:_oP_;
          if(_oQ_)
           {var _oR_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_aC_),str,str_ind,_oR_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _oK_=space[1],
           _oL_=hash[1],
           _oM_=plus[1],
           _oN_=minus[1],
           _oO_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            0 === _oO_
             ?0 === _oN_?1:0
             :0 === _oN_
               ?2
               :legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0),
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _oN_,
                       _oM_,
                       _oL_,
                       _oK_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _oN_,
                     _oM_,
                     _oL_,
                     _oK_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oN_,_oM_,_oL_,_oK_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oN_,_oM_,_oL_,_oK_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oN_,_oM_,_oL_,_oK_,ign,_aD_)}}}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str];
            if(is_open_tag)
             var formatting$0=[0,sub_format$0];
            else
             {if(typeof sub_fmt === "number")
               var switch$0=0;
              else
               if(11 === sub_fmt[0])
                if(typeof sub_fmt[2] === "number")
                 {var str$0=sub_fmt[1];
                  try
                   {open_box_of_string(str$0);var switch$1=1}
                  catch(_oJ_)
                   {_oJ_ = caml_wrap_exception(_oJ_);
                    if(_oJ_[1] !== Failure)throw _oJ_;
                    var switch$0=1,switch$1=0}
                  if(switch$1)var switch$0=1}
                else
                 var switch$0=0;
               else
                var switch$0=0;
              var formatting$0=[1,sub_format$0]}
            var _oH_=[0,[18,formatting$0,fmt_rest$0]];
            return _oH_}
          throw Not_found}
        catch(_oI_)
         {_oI_ = caml_wrap_exception(_oI_);
          if(_oI_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _oI_}}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _oA_=str_ind === end_ind?1:0,
           _oB_=_oA_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_oB_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$0?58 <= match$0?0:1:45 === match$0?1:0;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _oC_=[0,s,width,0],
             _oD_=str_ind_3 + 1 | 0,
             next_ind=_oD_,
             formatting_lit$0=_oC_,
             switch$1=1;
           else
            var switch$1=0;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _oE_=[0,s$0,width,offset],
               _oF_=str_ind_5 + 1 | 0,
               next_ind=_oF_,
               formatting_lit$0=_oE_,
               switch$1=1}
            else
             var switch$1=0}
          if(! switch$1)throw Not_found}
        catch(_oG_)
         {_oG_ = caml_wrap_exception(_oG_);
          if(_oG_ !== Not_found)if(_oG_[1] !== Failure)throw _oG_;
          var next_ind=str_ind,formatting_lit$0=formatting_lit}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$2?58 <= match$2?0:1:45 === match$2?1:0;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _oy_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _oy_=0;
          var _ox_=_oy_}
        catch(_oz_)
         {_oz_ = caml_wrap_exception(_oz_);
          if(_oz_ !== Not_found)if(_oz_[1] !== Failure)throw _oz_;
          var _ox_=0}
        if(_ox_)
         {var
           match=_ox_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aQ_,fmt_rest$0]]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aS_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aT_]}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aU_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aY_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {if(0 === plus$0)
           if(0 === hash$0)
            if(0 === space$0)
             {var switcher=symb - 88 | 0;
              if(32 < switcher >>> 0)
               var switch$0=1;
              else
               switch(switcher)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6;
                 default:var switch$0=1}}
            else
             {if(100 === symb)return 2;
              if(105 === symb)return 5;
              var switch$0=1}
           else
            if(0 === space$0)
             {if(88 === symb)return 9;
              if(111 === symb)return 11;
              if(120 === symb)return 7;
              var switch$0=0}
            else
             var switch$0=0;
          else
           if(0 === hash$0)
            if(0 === space$0)
             {if(100 === symb)return 1;
              if(105 === symb)return 4;
              var switch$0=1}
            else
             var switch$0=1;
           else
            var switch$0=0;
          if(! switch$0)
           {var switcher$0=symb - 88 | 0;
            if(! (32 < switcher$0 >>> 0))
             switch(switcher$0)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$47)
               }}
          if(0 === plus$0)
           {if(0 === space$0)throw [0,Assert_failure,_aW_];
            if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$44)}
          if(0 === space$0)
           {if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$45)}
          if(legacy_behavior$0){var space$0=0;continue}
          return incompatible_flag(pct_ind,str_ind,32,cst$46)}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _ov_=[0,type_format(fmt,fmtty),str];return _ov_}
      catch(_ow_)
       {_ow_ = caml_wrap_exception(_ow_);
        if(_ow_ === Type_mismatch)
         {var _ou_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aZ_),str,_ou_)}
        throw _ow_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _os_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _os_}
      catch(_ot_)
       {_ot_ = caml_wrap_exception(_ot_);
        if(_ot_ === Type_mismatch)
         return caml_call2(failwith_message(_a0_),str,str$0);
        throw _ot_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_formatting_gen,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(679,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_or_=0;
      return make_printf
              (function(o,acc){output_acc(o,acc);return caml_call1(k,o)},
               o,
               _or_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_oq_=0;
      return make_printf
              (function(b,acc){bufput_acc(b,acc);return caml_call1(k,b)},
               b,
               _oq_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_op_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_oo_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_on_){return 0},oc,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(param,acc)
       {var buf=create$1(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Stdlib_printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ksprintf];
    caml_register_global(680,Stdlib_printf,"Stdlib__printf");
    var
     Bad=[248,cst_Stdlib_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Stdlib_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Stdlib_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$0=t;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _om_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_om_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_ol_=_g_(prefix,h);
        return _g_
                (fold_left$0(function(x,y){return _g_(x,_g_(sep,y))},_ol_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a3_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _oi_=0,_og_=_oi_}
      catch(_ok_)
       {_ok_ = caml_wrap_exception(_ok_);
        if(_ok_ !== Not_found)throw _ok_;
        var
         _og_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_options],0]}
      try
       {assoc3(cst_help$1,speclist);var _oh_=0,add2=_oh_}
      catch(_oj_)
       {_oj_ = caml_wrap_exception(_oj_);
        if(_oj_ !== Not_found)throw _oj_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_options$0],
           0]}
      return append(speclist,append(_og_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a4_),errmsg);
      var _od_=add_help(speclist);
      return iter$0
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _oe_=0 < caml_ml_string_length(doc)?1:0;
                 if(_oe_)
                  {if(11 === spec[0])
                    {var l=spec[1],_of_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_a2_),key,_of_,doc)}
                   return caml_call2(bprintf(buf,_a1_),key,doc)}
                 return _oe_},
               _od_)}
    function usage_string(speclist,errmsg)
     {var b=create$1(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _oc_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a5_),_oc_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _oa_=[0,bool_of_string(x)];return _oa_}
      catch(_ob_)
       {_ob_ = caml_wrap_exception(_ob_);
        if(_ob_[1] === Invalid_argument)return 0;
        throw _ob_}}
    function int_of_string_opt$0(x)
     {try
       {var _n__=[0,caml_int_of_string(x)];return _n__}
      catch(_n$_)
       {_n$_ = caml_wrap_exception(_n$_);
        if(_n$_[1] === Failure)return 0;
        throw _n$_}}
    function float_of_string_opt$0(x)
     {try
       {var _n8_=[0,caml_float_of_string(x)];return _n8_}
      catch(_n9_)
       {_n9_ = caml_wrap_exception(_n9_);
        if(_n9_[1] === Failure)return 0;
        throw _n9_}}
    function parse_and_expand_argv_dynamic_aux
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$1(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[initpos + 1]
           :cst$54;
        switch(error[0])
         {case 0:
           var _n7_=error[1];
           if(caml_string_notequal(_n7_,cst_help$3))
            if(caml_string_notequal(_n7_,cst_help$4))
             caml_call2(bprintf(b,_a6_),progname,_n7_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a9_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a__),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a$_),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a7_))
         if(! caml_equal(error,_a8_))return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var _n0_=current[1],s=caml_check_bound(argv[1],_n0_)[_n0_ + 1];
            if(1 <= caml_ml_string_length(s))
             if(45 === caml_string_get(s,0))
              {try
                {var
                  follow$1=0,
                  _n2_=assoc3(s,speclist[1]),
                  action=_n2_,
                  follow$0=follow$1}
               catch(_n5_)
                {_n5_ = caml_wrap_exception(_n5_);
                 if(_n5_ !== Not_found)throw _n5_;
                 try
                  {var
                    match=split$0(s),
                    arg=match[2],
                    keyword=match[1],
                    follow=[0,arg],
                    _n1_=assoc3(keyword,speclist[1])}
                 catch(_n6_)
                  {_n6_ = caml_wrap_exception(_n6_);
                   if(_n6_ === Not_found)throw [0,Stop,[0,s]];
                   throw _n6_}
                 var action=_n1_,follow$0=follow}
               var
                no_arg$0=
                 function(s,follow)
                  {function no_arg(param)
                    {if(follow)
                      {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                     return 0}
                   return no_arg},
                no_arg=no_arg$0(s,follow$0),
                get_arg$0=
                 function(s,follow)
                  {function get_arg(param)
                    {if(follow){var arg=follow[1];return arg}
                     if((current[1] + 1 | 0) < argv[1].length - 1)
                      {var _n4_=current[1] + 1 | 0;
                       return caml_check_bound(argv[1],_n4_)[_n4_ + 1]}
                     throw [0,Stop,[2,s]]}
                   return get_arg},
                get_arg=get_arg$0(s,follow$0),
                consume_arg$0=
                 function(follow)
                  {function consume_arg(param)
                    {return follow?0:(current[1]++,0)}
                   return consume_arg},
                consume_arg=consume_arg$0(follow$0),
                treat_action$0=
                 function(s,no_arg,get_arg,consume_arg)
                  {function treat_action(param)
                    {switch(param[0])
                      {case 0:var f=param[1];return caml_call1(f,0);
                       case 1:
                        var
                         f$0=param[1],
                         arg=get_arg(0),
                         match=bool_of_string_opt$0(arg);
                        if(match)
                         {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg,cst_a_boolean]];
                       case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                       case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                       case 4:
                        var f$1=param[1],arg$0=get_arg(0);
                        caml_call1(f$1,arg$0);
                        return consume_arg(0);
                       case 5:
                        var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                       case 6:
                        var
                         f$2=param[1],
                         arg$1=get_arg(0),
                         match$0=int_of_string_opt$0(arg$1);
                        if(match$0)
                         {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                       case 7:
                        var
                         r$2=param[1],
                         arg$2=get_arg(0),
                         match$1=int_of_string_opt$0(arg$2);
                        if(match$1)
                         {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                       case 8:
                        var
                         f$3=param[1],
                         arg$3=get_arg(0),
                         match$2=float_of_string_opt$0(arg$3);
                        if(match$2)
                         {var x$1=match$2[1];
                          caml_call1(f$3,x$1);
                          return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$3,cst_a_float]];
                       case 9:
                        var
                         r$3=param[1],
                         arg$4=get_arg(0),
                         match$3=float_of_string_opt$0(arg$4);
                        if(match$3)
                         {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                       case 10:
                        var specs=param[1];return iter$0(treat_action,specs);
                       case 11:
                        var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                        if(mem(arg$5,symb))
                         {caml_call1(f$4,arg$5);return consume_arg(0)}
                        throw [0,
                               Stop,
                               [1,
                                s,
                                arg$5,
                                _g_(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                       case 12:
                        var f$5=param[1];
                        for(;;)
                         {if(current[1] < (argv[1].length - 1 - 1 | 0))
                           {var _n3_=current[1] + 1 | 0;
                            caml_call1(f$5,caml_check_bound(argv[1],_n3_)[_n3_ + 1]);
                            consume_arg(0);
                            continue}
                          return 0}
                       default:
                        var f$6=param[1];
                        if(1 - allow_expand)
                         throw [0,
                                Invalid_argument,
                                cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic];
                        var arg$6=get_arg(0),newarg=caml_call1(f$6,arg$6);
                        consume_arg(0);
                        var
                         before=sub$1(argv[1],0,current[1] + 1 | 0),
                         after=
                          sub$1
                           (argv[1],
                            current[1] + 1 | 0,
                            (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                        argv[1]
                        =
                        caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                        return 0}}
                   return treat_action},
                treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
               treat_action(action);
               var switch$0=1}
             else
              var switch$0=0;
            else
             var switch$0=0;
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Bad){var m=exn[2];throw convert_error([3,m])}
            if(exn[1] === Stop){var e=exn[2];throw convert_error(e)}
            throw exn}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_aux
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_aux
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _nZ_=parse_argv(0,_q_,l,f,msg);return _nZ_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_ba_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bb_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _nY_=parse_argv_dynamic(0,_q_,l,f,msg);return _nY_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bc_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bd_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,_q_],
         spec=[0,l],
         current$0=[0,current[1]],
         _nX_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _nX_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_be_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bf_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_nV_)
       {_nV_ = caml_wrap_exception(_nV_);
        if(_nV_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_nW_)
           {_nW_ = caml_wrap_exception(_nW_);
            if(_nW_ === Not_found)return len;
            throw _nW_}
          return loop(n + 1 | 0)}
        throw _nV_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$2
              (function(c)
                {if(9 === c)if(! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left$0(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map$0
              (function(ksd)
                {var _nT_=ksd[2],_nU_=ksd[1];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _nT_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$0(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _nU_,
                             _nT_,
                             _g_(cst$59,_g_(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_nU_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$0(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_nU_,_nT_,_g_(prefix,_g_(spaces,suffix))]}
                   return [0,_nU_,_nT_,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$1(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s);
          if(0 < len)
           if(13 === caml_string_get(s,len - 1 | 0))
            var _nS_=sub$0(s,0,len - 1 | 0),switch$0=1;
           else
            var switch$0=0;
          else
           var switch$0=0;
          if(! switch$0)var _nS_=s;
          var word=_nS_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      try
       {for(;;)
         {var c=caml_ml_input_char(ic);
          if(c === sep)stash(0);else add_char(buf,c);
          continue}}
      catch(_nR_)
       {_nR_ = caml_wrap_exception(_nR_);
        if(_nR_ === End_of_file)
         {if(0 < buf[2])stash(0);
          caml_ml_close_channel(ic);
          return of_list(rev(words[1]))}
        throw _nR_}}
    var _bg_=10,_bh_=1;
    function read_arg(_nQ_){return read_aux(_bh_,_bg_,_nQ_)}
    var _bi_=0,_bj_=0;
    function read_arg0(_nP_){return read_aux(_bj_,_bi_,_nP_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$3(function(s){return caml_call2(fprintf(oc,_bk_),s,sep)},args);
      return close_out(oc)}
    var _bl_=10;
    function write_arg(_nN_,_nO_){return write_aux(_bl_,_nN_,_nO_)}
    var _bm_=0;
    function write_arg0(_nL_,_nM_){return write_aux(_bm_,_nL_,_nM_)}
    var
     Stdlib_arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(681,Stdlib_arg,"Stdlib__arg");
    var printers=[0,0];
    function field(x,i)
     {var f=x[i + 1];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bn_),f)
                :caml_obj_tag(f) === 253?string_of_float(f):cst$60
              :caml_call1(sprintf(_bo_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _nJ_=other_fields(x,i + 1 | 0),_nK_=field(x,i);
      return caml_call2(sprintf(_bp_),_nK_,_nJ_)}
    function fields(x)
     {var match=x.length - 1;
      if(2 < match >>> 0)
       {var _nG_=other_fields(x,2),_nH_=field(x,1);
        return caml_call2(sprintf(_bq_),_nH_,_nG_)}
      switch(match)
       {case 0:return cst$62;
        case 1:return cst$63;
        default:var _nI_=field(x,1);return caml_call1(sprintf(_br_),_nI_)}}
    function to_string$4(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try {var _nE_=caml_call1(hd,x),_nD_=_nE_}catch(_nF_){var _nD_=0}
            if(_nD_){var s=_nD_[1];return s}
            var param$0=tl;
            continue}
          if(x === Out_of_memory)return cst_Out_of_memory;
          if(x === Stack_overflow)return cst_Stack_overflow;
          if(x[1] === Match_failure)
           {var match=x[2],char$0=match[3],line=match[2],file=match[1];
            return caml_call5
                    (sprintf(locfmt),
                     file,
                     line,
                     char$0,
                     char$0 + 5 | 0,
                     cst_Pattern_matching_failed)}
          if(x[1] === Assert_failure)
           {var
             match$0=x[2],
             char$1=match$0[3],
             line$0=match$0[2],
             file$0=match$0[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$0,
                     line$0,
                     char$1,
                     char$1 + 6 | 0,
                     cst_Assertion_failed)}
          if(x[1] === Undefined_recursive_module)
           {var
             match$1=x[2],
             char$2=match$1[3],
             line$1=match$1[2],
             file$1=match$1[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$1,
                     line$1,
                     char$2,
                     char$2 + 6 | 0,
                     cst_Undefined_recursive_module)}
          if(0 === caml_obj_tag(x))
           {var constructor=x[1][1];return _g_(constructor,fields(x))}
          return x[1]}}
      return conv(printers[1])}
    function print(fct,arg)
     {try
       {var _nC_=caml_call1(fct,arg);return _nC_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _nB_=to_string$4(x);
        caml_call1(eprintf(_bs_),_nB_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _nA_=caml_call1(fct,arg);return _nA_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _nz_=to_string$4(x);
        caml_call1(eprintf(_bt_),_nz_);
        return exit(2)}}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos
                  ?cst_Raised_by_primitive_operation_at
                  :cst_Called_from}
      if(0 === slot[0])
       {var
         _ns_=slot[5],
         _nt_=slot[4],
         _nu_=slot[3],
         _nv_=slot[6]?cst_inlined:cst$64,
         _nw_=slot[2],
         _nx_=info(slot[1]);
        return [0,caml_call6(sprintf(_bu_),_nx_,_nw_,_nv_,_nu_,_nt_,_ns_)]}
      if(slot[1])return 0;
      var _ny_=info(0);
      return [0,caml_call1(sprintf(_bv_),_ny_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_nq_=a.length - 1 - 1 | 0,_np_=0;
        if(! (_nq_ < 0))
         {var i=_np_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[i + 1]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bw_),str)}
            var _nr_=i + 1 | 0;
            if(_nq_ !== i){var i=_nr_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bx_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtrace(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$1(1024),_nn_=a.length - 1 - 1 | 0,_nm_=0;
        if(! (_nn_ < 0))
         {var i=_nm_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[i + 1]);
            if(match){var str=match[1];caml_call1(bprintf(b,_by_),str)}
            var _no_=i + 1 | 0;
            if(_nn_ !== i){var i=_no_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_cannot_print_stack_backtrace}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _nl_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[i + 1],
             _nk_=0 === param[0]?1:0;
            if(! _nk_){var i$0=i - 1 | 0,i=i$0;continue}
            var _nl_=_nk_}
          return _nl_?[0,backtrace]:0}}
      return 0}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtrace(0))}
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var uncaught_exception_handler=[0,0];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = [0,fn];return 0}
    function _bz_(_nj_){return runtime.caml_raw_backtrace_next_slot(_nj_)}
    function _bA_(_ni_){return runtime.caml_convert_raw_backtrace_slot(_ni_)}
    function _bB_(_nh_,_ng_)
     {return runtime.caml_raw_backtrace_slot(_nh_,_ng_)}
    function _bC_(_nf_){return runtime.caml_raw_backtrace_length(_nf_)}
    var
     _bD_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       format_backtrace_slot];
    function _bE_(_ne_){return runtime.caml_get_current_callstack(_ne_)}
    function _bF_(_nd_){return caml_get_exception_raw_backtrace(_nd_)}
    function _bG_(_nc_){return runtime.caml_backtrace_status(_nc_)}
    var
     Stdlib_printexc=
      [0,
       to_string$4,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_nb_){return runtime.caml_record_backtrace(_nb_)},
       _bG_,
       register_printer,
       _bF_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       _bE_,
       set_uncaught_exception_handler,
       backtrace_slots,
       _bD_,
       _bC_,
       _bB_,
       _bA_,
       _bz_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(686,Stdlib_printexc,"Stdlib__printexc");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_mW_=st[4];
      caml_call1(fprintf(c,_bH_),_mW_);
      var _mX_=st[5];
      caml_call1(fprintf(c,_bI_),_mX_);
      var _mY_=st[14];
      caml_call1(fprintf(c,_bJ_),_mY_);
      fprintf(c,_bK_);
      var
       _mZ_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bL_),_mZ_)),
       _m0_=st[1];
      caml_call2(fprintf(c,_bM_),l1,_m0_);
      var _m1_=st[2];
      caml_call2(fprintf(c,_bN_),l1,_m1_);
      var _m2_=st[3];
      caml_call2(fprintf(c,_bO_),l1,_m2_);
      fprintf(c,_bP_);
      var
       _m3_=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bQ_),_m3_)),
       _m4_=st[15];
      caml_call2(fprintf(c,_bR_),l2,_m4_);
      var _m5_=st[6];
      caml_call2(fprintf(c,_bS_),l2,_m5_);
      var _m6_=st[8];
      caml_call2(fprintf(c,_bT_),l2,_m6_);
      var _m7_=st[10];
      caml_call2(fprintf(c,_bU_),l2,_m7_);
      var _m8_=st[12];
      caml_call2(fprintf(c,_bV_),l2,_m8_);
      var _m9_=st[13];
      caml_call2(fprintf(c,_bW_),l2,_m9_);
      fprintf(c,_bX_);
      var _m__=st[9];
      caml_call1(fprintf(c,_bY_),_m__);
      var _m$_=st[11];
      caml_call1(fprintf(c,_bZ_),_m$_);
      var _na_=st[7];
      return caml_call1(fprintf(c,_b0_),_na_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _b1_(_mV_){return runtime.caml_final_release(_mV_)}
    function _b2_(_mU_,_mT_)
     {return runtime.caml_final_register_called_without_value(_mU_,_mT_)}
    var
     Stdlib_gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_mS_,_mR_){return runtime.caml_final_register(_mS_,_mR_)},
       _b2_,
       _b1_,
       create_alarm,
       delete_alarm];
    caml_register_global(687,Stdlib_gc,"Stdlib__gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(caml_string_of_bytes(b))}
    function substring(str,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(str) - len | 0) < ofs))
         return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len)
     {return substring(caml_string_of_bytes(b),ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _mQ_=10 <= n?87:48;return n + _mQ_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _mP_=i + 1 | 0;
        if(15 !== i){var i=_mP_;continue}
        return caml_string_of_bytes(result)}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_mN_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _mN_ | 0));
        var _mO_=i + 1 | 0;
        if(15 !== i){var i=_mO_;continue}
        return caml_string_of_bytes(result)}}
    var
     Stdlib_digest=
      [0,
       compare$2,
       equal$2,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(688,Stdlib_digest,"Stdlib__digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[i$0 + 1] = i$0;
        var _mM_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_mM_;continue}
        var accu=[0,cst_x$1],_mI_=54 + max(55,l) | 0,_mH_=0;
        if(! (_mI_ < 0))
         {var i=_mH_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[k + 1];
            accu[1] = string(_g_(accu[1],caml_new_string("" + x)));
            var
             _mJ_=accu[1],
             _mD_=caml_string_get(_mJ_,3) << 24,
             _mE_=caml_string_get(_mJ_,2) << 16,
             _mF_=caml_string_get(_mJ_,1) << 8,
             _mG_=((caml_string_get(_mJ_,0) + _mF_ | 0) + _mE_ | 0) + _mD_ | 0,
             _mK_=(caml_check_bound(s[1],j)[j + 1] ^ _mG_) & 1073741823;
            caml_check_bound(s[1],j)[j + 1] = _mK_;
            var _mL_=i + 1 | 0;
            if(_mI_ !== i){var i=_mL_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$1(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$1(caml_sys_random_seed(0))}
    function copy$4(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _mA_=s[2],
       curval=caml_check_bound(s[1],_mA_)[_mA_ + 1],
       _mB_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_mB_)[_mB_ + 1]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _mC_=s[2];
      caml_check_bound(s[1],_mC_)[_mC_ + 1] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound))
       if(0 < bound)
        for(;;)
         {var r=bits(s),v=caml_mod(r,bound);
          if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
          return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b4_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$1,bound),_b3_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824 + r2) / 1073741824 * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b5_.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$3(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$4(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b6_=
      [0,
       make$1,
       make_self_init,
       copy$4,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Stdlib_random=
      [0,
       init$3,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b6_,
       get_state,
       set_state];
    caml_register_global(689,Stdlib_random,"Stdlib__random");
    function hash$1(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function ongoing_traversal(h)
     {var _my_=h.length - 1 < 4?1:0,_mz_=_my_ || (h[4] < 0?1:0);return _mz_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cN_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cN_}
    catch(_mw_)
     {_mw_ = caml_wrap_exception(_mw_);
      if(_mw_ !== Not_found)throw _mw_;
      try
       {var _cM_=caml_sys_getenv(cst_CAMLRUNPARAM),_b7_=_cM_}
      catch(_mx_)
       {_mx_ = caml_wrap_exception(_mx_);
        if(_mx_ !== Not_found)throw _mx_;
        var _b7_=cst$65}
      var params=_b7_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_mv_){return caml_call1(_b6_[2],0)}];
    function create$2(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var x=16;
      for(;;)
       {if(! (initial_size <= x))
         if(! (max_array_length < (x * 2 | 0)))
          {var x$0=x * 2 | 0,x=x$0;continue}
        if(random)
         var
          _mt_=caml_obj_tag(prng),
          _mu_=250 === _mt_?prng[1]:246 === _mt_?force_lazy_block(prng):prng,
          seed=caml_call1(_b6_[4],_mu_);
        else
         var seed=0;
        return [0,0,caml_make_vect(x,0),seed,x]}}
    function clear$2(h)
     {h[1] = 0;
      var len=h[2].length - 1,_mr_=len - 1 | 0,_mq_=0;
      if(! (_mr_ < 0))
       {var i=_mq_;
        for(;;)
         {caml_check_bound(h[2],i)[i + 1] = 0;
          var _ms_=i + 1 | 0;
          if(_mr_ !== i){var i=_ms_;continue}
          break}}
      return 0}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1)
       if(len !== abs(h[4]))
        {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_b8_]}
          return prec$0}}
      return 0}
    function copy$5(init)
     {var _mn_=init[4],_mo_=init[3],_mp_=map$3(copy_bucketlist,init[2]);
      return [0,init[1],_mp_,_mo_,_mn_]}
    function length$4(h){return h[1]}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _me_=nsize < max_array_length?1:0;
      if(_me_)
       {var
         ndata=caml_make_vect(nsize,0),
         ndata_tail=caml_make_vect(nsize,0),
         inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        var _mg_=osize - 1 | 0,_mf_=0;
        if(! (_mg_ < 0))
         {var i$0=_mf_;
          a:
          for(;;)
           {var cell$1=caml_check_bound(odata,i$0)[i$0 + 1],cell=cell$1;
            for(;;)
             {if(cell)
               {var
                 key=cell[1],
                 data=cell[2],
                 next=cell[3],
                 cell$0=inplace?cell:[0,key,data,0],
                 nidx=caml_call2(indexfun,h,key),
                 match=caml_check_bound(ndata_tail,nidx)[nidx + 1];
                if(match)
                 match[3] = cell$0;
                else
                 caml_check_bound(ndata,nidx)[nidx + 1] = cell$0;
                caml_check_bound(ndata_tail,nidx)[nidx + 1] = cell$0;
                var cell=next;
                continue}
              var _mm_=i$0 + 1 | 0;
              if(_mg_ !== i$0){var i$0=_mm_;continue a}
              break}
            break}}
        if(inplace)
         {var _mi_=nsize - 1 | 0,_mh_=0;
          if(! (_mi_ < 0))
           {var i=_mh_;
            for(;;)
             {var match$0=caml_check_bound(ndata_tail,i)[i + 1];
              if(match$0)match$0[3] = 0;
              var _ml_=i + 1 | 0;
              if(_mi_ !== i){var i=_ml_;continue}
              break}}
          var _mj_=0}
        else
         var _mj_=inplace;
        var _mk_=_mj_}
      else
       var _mk_=_me_;
      return _mk_}
    function key_index(h,key)
     {return 3 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :caml_mod
                (runtime.caml_hash_univ_param(10,100,key),h[2].length - 1)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[i + 1]];
      caml_check_bound(h[2],i)[i + 1] = bucket;
      h[1] = h[1] + 1 | 0;
      var _md_=h[2].length - 1 << 1 < h[1]?1:0;
      return _md_?resize$0(key_index,h):_md_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[i + 1],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :caml_check_bound(h[2],i)[i + 1] = next}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _mc_=key_index(h,key),match=caml_check_bound(h[2],_mc_)[_mc_ + 1];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _mb_=key_index(h,key),match=caml_check_bound(h[2],_mb_)[_mb_ + 1];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _ma_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_ma_)[_ma_ + 1])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[i + 1],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _l9_=0}
        else
         var _l9_=1;
        if(_l9_)
         {caml_check_bound(h[2],i)[i + 1] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _l__=h[2].length - 1 << 1 < h[1]?1:0;
          if(_l__)return resize$0(key_index,h);
          var _l$_=_l__}
        else
         var _l$_=_l9_;
        return _l$_}}
    function mem$1(h,key)
     {var
       _l8_=key_index(h,key),
       param$0=caml_check_bound(h[2],_l8_)[_l8_ + 1],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_l7_=0 === caml_compare(k,key)?1:0;
          if(_l7_)return _l7_;
          var param=next;
          continue}
        return 0}}
    function iter$7(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_l3_=d.length - 1 - 1 | 0,_l2_=0;
        if(! (_l3_ < 0))
         {var i=_l2_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[i + 1]);
            var _l6_=i + 1 | 0;
            if(_l3_ !== i){var i=_l6_;continue}
            break}}
        var _l4_=1 - old_trav,_l5_=_l4_?flip_ongoing_traversal(h):_l4_;
        return _l5_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[i + 1] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0?(prec$0[3] = 0,0):caml_check_bound(h[2],i)[i + 1] = 0}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _lZ_=d.length - 1 - 1 | 0,_lY_=0;
        if(! (_lZ_ < 0))
         {var i=_lY_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[i + 1]);
            var _l1_=i + 1 | 0;
            if(_lZ_ !== i){var i=_l1_;continue}
            break}}
        var _l0_=0;
        return _l0_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$1(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_lU_=d.length - 1 - 1 | 0,_lT_=0;
        if(! (_lU_ < 0))
         {var i=_lT_;
          for(;;)
           {var _lW_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[i + 1],_lW_);
            var _lX_=i + 1 | 0;
            if(_lU_ !== i){var i=_lX_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _lV_=accu[1];
        return _lV_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _lQ_=h[2],
       _lR_=0,
       mbl=
        fold_left$1(function(m,b){return max(m,bucket_length(0,b))},_lR_,_lQ_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _lS_=h[2];
      iter$3
       (function(b)
         {var l=bucket_length(0,b);
          return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
        _lS_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq$6(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_lP_){return aux(i$0,next,_lP_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[i$0 + 1],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _lM_=0,_lN_=0;
      return function(_lO_){return aux(_lN_,_lM_,_lO_)}}
    function to_seq_keys(m)
     {var _lI_=to_seq$6(m);
      function _lJ_(_lL_){return _lL_[1]}
      return function(_lK_){return map(_lJ_,_lI_,_lK_)}}
    function to_seq_values(m)
     {var _lE_=to_seq$6(m);
      function _lF_(_lH_){return _lH_[2]}
      return function(_lG_){return map(_lF_,_lE_,_lG_)}}
    function add_seq$2(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return add$0(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq$6(i){var tbl=create$2(0,16);replace_seq(tbl,i);return tbl}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _lD_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _lD_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[i + 1]];
        caml_check_bound(h[2],i)[i + 1] = bucket;
        h[1] = h[1] + 1 | 0;
        var _lC_=h[2].length - 1 << 1 < h[1]?1:0;
        return _lC_?resize$0(key_index,h):_lC_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[i + 1],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :caml_check_bound(h[2],i)[i + 1] = next}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _lB_=key_index(h,key),match=caml_check_bound(h[2],_lB_)[_lB_ + 1];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _lA_=key_index(h,key),match=caml_check_bound(h[2],_lA_)[_lA_ + 1];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _lz_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_lz_)[_lz_ + 1])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[i + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _lw_=0}
          else
           var _lw_=1;
          if(_lw_)
           {caml_check_bound(h[2],i)[i + 1] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _lx_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_lx_)return resize$0(key_index,h);
            var _ly_=_lx_}
          else
           var _ly_=_lw_;
          return _ly_}}
      function mem(h,key)
       {var
         _lv_=key_index(h,key),
         param$0=caml_check_bound(h[2],_lv_)[_lv_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_lu_=caml_call2(H[1],k,key);
            if(_lu_)return _lu_;
            var param=next;
            continue}
          return 0}}
      return [0,
              create$2,
              clear$2,
              reset$0,
              copy$5,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$7,
              filter_map_inplace,
              fold$1,
              length$4,
              stats,
              to_seq$6,
              to_seq_keys,
              to_seq_values,
              add_seq$2,
              replace_seq,
              of_seq$6]}
    function Make(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       of_seq=include[22],
       _lt_=include[1];
      function create(sz){return caml_call2(_lt_,_b9_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    var
     Stdlib_hashtbl=
      [0,
       create$2,
       clear$2,
       reset$0,
       copy$5,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$1,
       remove,
       replace,
       iter$7,
       filter_map_inplace,
       fold$1,
       length$4,
       randomize,
       is_randomized,
       stats,
       to_seq$6,
       to_seq_keys,
       to_seq_values,
       add_seq$2,
       replace_seq,
       of_seq$6,
       Make,
       MakeSeeded,
       hash$1,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(690,Stdlib_hashtbl,"Stdlib__hashtbl");
    function length$5(x){return x.length - 1 - 2 | 0}
    function fill$1(ar,ofs,len,x)
     {if(0 <= ofs)
       if(0 <= len)
        if(! (length$5(ar) < (ofs + len | 0)))
         {var _lr_=(ofs + len | 0) - 1 | 0;
          if(! (_lr_ < ofs))
           {var i=ofs;
            for(;;)
             {caml_weak_set(ar,i,x);
              var _ls_=i + 1 | 0;
              if(_lr_ !== i){var i=_ls_;continue}
              break}}
          return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$0(H)
     {var emptybucket=caml_weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _lp_=t[1].length - 1 - 1 | 0,_lo_=0;
        if(! (_lp_ < 0))
         {var i=_lo_;
          for(;;)
           {caml_check_bound(t[1],i)[i + 1] = emptybucket;
            caml_check_bound(t[2],i)[i + 1] = [0];
            var _lq_=i + 1 | 0;
            if(_lp_ !== i){var i=_lq_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _ln_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=caml_weak_get(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _ln_,
                 init)}
      function iter(f,t)
       {var _lm_=t[1],i=0;
        return iter$3
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=caml_weak_get(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _lm_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _ll_=caml_weak_check(b,i$0)?1:0,
           accu$1=accu$0 + _ll_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _lg_=0,_lh_=t[1],_li_=0;
        return fold_right$0
                (function(_lj_,_lk_){return count_bucket(_li_,_lj_,_lk_)},
                 _lh_,
                 _lg_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)
             failwith(cst_Weak_Make_hash_bucket_cannot_grow_more);
            var
             newbucket=caml_weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            caml_weak_blit(bucket$0,0,newbucket,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket,sz,d);
            caml_check_bound(newhashes,sz)[sz + 1] = h;
            caml_check_bound(t[1],index)[index + 1] = newbucket;
            caml_check_bound(t[2],index)[index + 1] = newhashes;
            var _lc_=sz <= t[3]?1:0,_ld_=_lc_?t[3] < newsz?1:0:_lc_;
            if(_ld_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _k7_=t[5],
                 bucket=caml_check_bound(t[1],_k7_)[_k7_ + 1],
                 _k8_=t[5],
                 hbucket=caml_check_bound(t[2],_k8_)[_k8_ + 1],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(caml_weak_check(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(caml_weak_check(bucket,j))
                       {caml_weak_blit(bucket,j,bucket,i$0,1);
                        var _k9_=caml_check_bound(hbucket,j)[j + 1];
                        caml_check_bound(hbucket,i$0)[i$0 + 1] = _k9_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _k__=t[5];
                      caml_check_bound(t[1],_k__)[_k__ + 1] = emptybucket;
                      var _k$_=t[5];
                      caml_check_bound(t[2],_k$_)[_k$_ + 1] = [0]}
                    else
                     {caml_obj_truncate(bucket,prev_len + 2 | 0);
                      caml_obj_truncate(hbucket,prev_len)}
                    var _la_=t[3] < n?1:0,_lb_=_la_?prev_len <= t[3]?1:0:_la_;
                    if(_lb_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _lf_=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_lf_;continue}
                break}}
            var _le_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_le_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_k6_=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=caml_weak_check(ob,i$0);
                      if(0 === match){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      var
                       oh=caml_check_bound(t[2],j)[j + 1],
                       setter$0=
                        function(i)
                         {function setter(nb,ni,param)
                           {return caml_weak_blit(ob,i,nb,ni,1)}
                          return setter},
                       setter=setter$0(i$0),
                       h=caml_check_bound(oh,i$0)[i$0 + 1];
                      add_aux(newt,setter,0,h,get_index(newt,h));
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _k6_);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _le_}
          if(caml_weak_check(bucket$0,i$3))
           {var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          return caml_check_bound(hashes,i$3)[i$3 + 1] = h}}
      function add(t,d)
       {var h=caml_call1(H[2],d);
        return add_aux(t,caml_weak_set,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=caml_weak_get(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,
                 d,
                 function(h,index)
                  {add_aux(t,caml_weak_set,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=caml_weak_get(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _k5_=0;
        return find_shadow
                (t,d,function(w,i){return caml_weak_set(w,i,0)},_k5_)}
      function mem(t,d)
       {var _k4_=0;return find_shadow(t,d,function(w,i){return 1},_k4_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=caml_weak_get(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$3(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _kW_=0,
         totlen=
          fold_left$1(function(_k3_,_k2_){return _k3_ + _k2_ | 0},_kW_,lens),
         _kX_=len - 1 | 0,
         _kZ_=len / 2 | 0,
         _kY_=caml_check_bound(lens,_kX_)[_kX_ + 1],
         _k0_=caml_check_bound(lens,_kZ_)[_kZ_ + 1],
         _k1_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_k1_,_k0_,_kY_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Stdlib_weak=
      [0,
       caml_weak_create,
       length$5,
       caml_weak_set,
       caml_weak_get,
       caml_weak_get_copy,
       caml_weak_check,
       fill$1,
       caml_weak_blit,
       Make$0];
    caml_register_global(691,Stdlib_weak,"Stdlib__weak");
    function add_queue(x,q)
     {var c=[0,x,0],_kV_=q[1];
      return _kV_?(q[1] = c,_kV_[2] = c,0):(q[1] = c,q[2] = c,0)}
    var Empty_queue=[248,cst_Stdlib_Format_Empty_queue,caml_fresh_oo_id(0)];
    function take_queue(q)
     {var _kU_=q[2];
      if(_kU_)
       {var x=_kU_[1],tl=_kU_[2];q[2] = tl;if(0 === tl)q[1] = 0;return x}
      throw Empty_queue}
    function pp_enqueue(state,token)
     {var len=token[3];
      state[13] = state[13] + len | 0;
      return add_queue(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function break_new_line(state,offset,width)
     {pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      return caml_call1(state[21],state[10])}
    function break_line(state,width){return break_new_line(state,0,width)}
    function break_same_line(state,width)
     {state[9] = state[9] - width | 0;return caml_call1(state[20],width)}
    function pp_force_break_line(state)
     {var _kR_=state[2];
      if(_kR_)
       {var
         match=_kR_[1],
         width=match[2],
         bl_ty=match[1],
         _kS_=state[9] < width?1:0;
        if(_kS_)
         {if(0 !== bl_ty)return 5 <= bl_ty?0:break_line(state,width);
          var _kT_=0}
        else
         var _kT_=_kS_;
        return _kT_}
      return pp_output_newline(state)}
    function pp_skip_token(state)
     {var match=take_queue(state[28]),size=match[1],len=match[3];
      state[12] = state[12] - len | 0;
      state[9] = state[9] + size | 0;
      return 0}
    function format_pp_token(state,size,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:
          var _kG_=state[3];
          if(_kG_)
           {var
             match=_kG_[1],
             tabs=match[1],
             add_tab=
              function(n,ls)
               {if(ls)
                 {var l=ls[2],x=ls[1];
                  return runtime.caml_lessthan(n,x)
                          ?[0,n,ls]
                          :[0,x,add_tab(n,l)]}
                return [0,n,0]};
            tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1]);
            return 0}
          return 0;
         case 1:
          var _kH_=state[2];
          if(_kH_){var ls=_kH_[2];state[2] = ls;return 0}
          return 0;
         case 2:
          var _kI_=state[3];
          if(_kI_){var ls$0=_kI_[2];state[3] = ls$0;return 0}
          return 0;
         case 3:
          var _kJ_=state[2];
          if(_kJ_)
           {var match$0=_kJ_[1],width=match$0[2];
            return break_line(state,width)}
          return pp_output_newline(state);
         case 4:
          var _kK_=state[10] !== (state[6] - state[9] | 0)?1:0;
          return _kK_?pp_skip_token(state):_kK_;
         default:
          var _kL_=state[5];
          if(_kL_)
           {var
             tags=_kL_[2],
             tag_name=_kL_[1],
             marker=caml_call1(state[25],tag_name);
            pp_output_string(state,marker);
            state[5] = tags;
            return 0}
          return 0}
      else
       switch(param[0])
        {case 0:
          var s=param[1];
          state[9] = state[9] - size | 0;
          pp_output_string(state,s);
          state[11] = 0;
          return 0;
         case 1:
          var off=param[2],n=param[1],_kM_=state[2];
          if(_kM_)
           {var match$1=_kM_[1],width$0=match$1[2],ty=match$1[1];
            switch(ty)
             {case 0:return break_same_line(state,n);
              case 1:return break_new_line(state,off,width$0);
              case 2:return break_new_line(state,off,width$0);
              case 3:
               return state[9] < size
                       ?break_new_line(state,off,width$0)
                       :break_same_line(state,n);
              case 4:
               return state[11]
                       ?break_same_line(state,n)
                       :state[9] < size
                         ?break_new_line(state,off,width$0)
                         :((state[6] - width$0 | 0) + off | 0) < state[10]
                           ?break_new_line(state,off,width$0)
                           :break_same_line(state,n);
              default:return break_same_line(state,n)}}
          return 0;
         case 2:
          var
           off$0=param[2],
           n$0=param[1],
           insertion_point=state[6] - state[9] | 0,
           _kN_=state[3];
          if(_kN_)
           {var
             match$2=_kN_[1],
             tabs$0=match$2[1],
             find=
              function(n,param)
               {var param$0=param;
                for(;;)
                 {if(param$0)
                   {var l=param$0[2],x=param$0[1];
                    if(caml_greaterequal(x,n))return x;
                    var param$0=l;
                    continue}
                  throw Not_found}},
             _kO_=tabs$0[1];
            if(_kO_)
             {var x=_kO_[1];
              try
               {var _kP_=find(insertion_point,tabs$0[1]),x$0=_kP_}
              catch(_kQ_)
               {_kQ_ = caml_wrap_exception(_kQ_);
                if(_kQ_ !== Not_found)throw _kQ_;
                var x$0=x}
              var tab=x$0}
            else
             var tab=insertion_point;
            var offset=tab - insertion_point | 0;
            return 0 <= offset
                    ?break_same_line(state,offset + n$0 | 0)
                    :break_new_line(state,tab + off$0 | 0,state[6])}
          return 0;
         case 3:
          var
           ty$0=param[2],
           off$1=param[1],
           insertion_point$0=state[6] - state[9] | 0;
          if(state[8] < insertion_point$0)pp_force_break_line(state);
          var
           offset$0=state[9] - off$1 | 0,
           bl_type=1 === ty$0?1:state[9] < size?ty$0:5;
          state[2] = [0,[0,bl_type,offset$0],state[2]];
          return 0;
         case 4:var tbox=param[1];state[3] = [0,tbox,state[3]];return 0;
         default:
          var tag_name$0=param[1],marker$0=caml_call1(state[24],tag_name$0);
          pp_output_string(state,marker$0);
          state[5] = [0,tag_name$0,state[5]];
          return 0}}
    function advance_loop(state)
     {for(;;)
       {var _kC_=state[28][2];
        if(_kC_)
         {var
           x=_kC_[1],
           size=x[1],
           len=x[3],
           tok=x[2],
           _kD_=size < 0?1:0,
           _kE_=_kD_?(state[13] - state[12] | 0) < state[9]?1:0:_kD_,
           _kF_=1 - _kE_;
          if(_kF_)
           {take_queue(state[28]);
            var size$0=0 <= size?size:pp_infinity;
            format_pp_token(state,size$0,tok);
            state[12] = len + state[12] | 0;
            continue}
          return _kF_}
        throw Empty_queue}}
    function advance_left(state)
     {try
       {var _kA_=advance_loop(state);return _kA_}
      catch(_kB_)
       {_kB_ = caml_wrap_exception(_kB_);
        if(_kB_ === Empty_queue)return 0;
        throw _kB_}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    var q_elem=[0,-1,_b__,0],scan_stack_bottom=[0,[0,-1,q_elem],0];
    function clear_scan_stack(state){state[1] = scan_stack_bottom;return 0}
    function set_size(state,ty)
     {var _kw_=state[1];
      if(_kw_)
       {var
         match=_kw_[1],
         queue_elem=match[2],
         left_tot=match[1],
         size=queue_elem[1],
         t=_kw_[2],
         tok=queue_elem[2];
        if(left_tot < state[12])return clear_scan_stack(state);
        if(typeof tok !== "number")
         switch(tok[0])
          {case 3:
            var
             _ky_=1 - ty,
             _kz_=
              _ky_?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):_ky_;
            return _kz_;
           case 1:
           case 2:
            var
             _kx_=
              ty?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):ty;
            return _kx_
           }
        return 0}
      return 0}
    function scan_push(state,b,tok)
     {pp_enqueue(state,tok);
      if(b)set_size(state,1);
      state[1] = [0,[0,state[13],tok],state[1]];
      return 0}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var elem=[0,- state[13] | 0,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _ku_=state[14] === state[15]?1:0;
      if(_ku_)
       {var _kv_=state[16],len=caml_ml_string_length(_kv_);
        return enqueue_string_as(state,len,_kv_)}
      return _ku_}
    function pp_close_box(state,param)
     {var _ks_=1 < state[14]?1:0;
      if(_ks_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,0,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _kt_=0}
      else
       var _kt_=_ks_;
      return _kt_}
    function pp_open_tag(state,tag_name)
     {if(state[22])
       {state[4] = [0,tag_name,state[4]];caml_call1(state[26],tag_name)}
      var _kr_=state[23];
      return _kr_?pp_enqueue(state,[0,0,[5,tag_name],0]):_kr_}
    function pp_close_tag(state,param)
     {if(state[23])pp_enqueue(state,[0,0,5,0]);
      var _ko_=state[22];
      if(_ko_)
       {var _kp_=state[4];
        if(_kp_)
         {var tags=_kp_[2],tag_name=_kp_[1];
          caml_call1(state[27],tag_name);
          state[4] = tags;
          return 0}
        var _kq_=0}
      else
       var _kq_=_ko_;
      return _kq_}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_tag_functions(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      var _kn_=state[28];
      _kn_[1] = 0;
      _kn_[2] = 0;
      clear_scan_stack(state);
      state[2] = 0;
      state[3] = 0;
      state[4] = 0;
      state[5] = 0;
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _km_=state[4];
      iter$0(function(param){return pp_close_tag(state,0)},_km_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _kl_=state[14] < state[15]?1:0;
      return _kl_?enqueue_string_as(state,size,s):_kl_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_new_string("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,string_of_float(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _kk_=state[14] < state[15]?1:0;
      return _kk_?enqueue_advance(state,[0,0,3,0]):_kk_}
    function pp_print_if_newline(state,param)
     {var _kj_=state[14] < state[15]?1:0;
      return _kj_?enqueue_advance(state,[0,0,4,0]):_kj_}
    function pp_print_break(state,width,offset)
     {var _ki_=state[14] < state[15]?1:0;
      if(_ki_)
       {var elem=[0,- state[13] | 0,[1,width,offset],width];
        return scan_push(state,1,elem)}
      return _ki_}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _kh_=state[14] < state[15]?1:0;
      if(_kh_)
       {var elem=[0,0,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _kh_}
    function pp_close_tbox(state,param)
     {var _ke_=1 < state[14]?1:0;
      if(_ke_)
       {var _kf_=state[14] < state[15]?1:0;
        if(_kf_)
         {var elem=[0,0,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _kg_=0}
        else
         var _kg_=_kf_}
      else
       var _kg_=_ke_;
      return _kg_}
    function pp_print_tbreak(state,width,offset)
     {var _kd_=state[14] < state[15]?1:0;
      if(_kd_)
       {var elem=[0,- state[13] | 0,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _kd_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _kc_=state[14] < state[15]?1:0;
      if(_kc_){var elem=[0,0,0,0];return enqueue_advance(state,elem)}
      return _kc_}
    function pp_set_max_boxes(state,n)
     {var _ka_=1 < n?1:0,_kb_=_ka_?(state[15] = n,0):_ka_;return _kb_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var n$1=state[6] - n$0 | 0,_j$_=1 <= n$1?1:0;
      if(_j$_)
       {var n=pp_limit(n$1);
        state[7] = n;
        state[8] = state[6] - state[7] | 0;
        return pp_rinit(state)}
      return _j$_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _j__=1 <= n?1:0;
      if(_j__)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _j__}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functions(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functions(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$66,0,1)}
    var blank_line=make$0(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _j9_=0 < n$0?1:0;
        if(_j9_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _j9_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_j6_,_j7_,_j8_){return output_substring(oc,_j6_,_j7_,_j8_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_j5_){return display_newline(state,_j5_)};
      state[20] = function(_j4_){return display_indent(state,_j4_)};
      state[21] = function(_j3_){return display_indent(state,_j3_)};
      return 0}
    function default_pp_mark_open_tag(s){return _g_(cst$68,_g_(s,cst$67))}
    function default_pp_mark_close_tag(s){return _g_(cst$70,_g_(s,cst$69))}
    function default_pp_print_open_tag(_j2_){return 0}
    function default_pp_print_close_tag(_j1_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=[0,0,0],sys_tok=[0,-1,_b$_,0];
      add_queue(sys_tok,pp_queue);
      var sys_scan_stack=[0,[0,1,sys_tok],scan_stack_bottom];
      return [0,
              sys_scan_stack,
              0,
              0,
              0,
              0,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$71,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _jT_(_j0_){return 0}
      function _jU_(_jZ_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_jY_){return 0},_jU_,_jT_);
      ppf[19] = function(_jX_){return display_newline(ppf,_jX_)};
      ppf[20] = function(_jW_){return display_indent(ppf,_jW_)};
      ppf[21] = function(_jV_){return display_indent(ppf,_jV_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _jP_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_jQ_,_jR_,_jS_)
                {return output_substring(oc,_jQ_,_jR_,_jS_)},
               _jP_)}
    function formatter_of_buffer(b)
     {function _jK_(_jO_){return 0}
      return make_formatter
              (function(_jL_,_jM_,_jN_)
                {return add_substring(b,_jL_,_jM_,_jN_)},
               _jK_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$1(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(_o_[27]),
     err_formatter=formatter_of_out_channel(_o_[28]),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_buffer(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_jJ_){return add_symbolic_output_item(sob,0)}
      function h(_jI_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_jH_){return pp_open_hbox(std_formatter,_jH_)}
    function open_vbox(_jG_){return pp_open_vbox(std_formatter,_jG_)}
    function open_hvbox(_jF_){return pp_open_hvbox(std_formatter,_jF_)}
    function open_hovbox(_jE_){return pp_open_hovbox(std_formatter,_jE_)}
    function open_box(_jD_){return pp_open_box(std_formatter,_jD_)}
    function close_box(_jC_){return pp_close_box(std_formatter,_jC_)}
    function open_tag(_jB_){return pp_open_tag(std_formatter,_jB_)}
    function close_tag(_jA_){return pp_close_tag(std_formatter,_jA_)}
    function print_as(_jy_,_jz_){return pp_print_as(std_formatter,_jy_,_jz_)}
    function print_string$0(_jx_){return pp_print_string(std_formatter,_jx_)}
    function print_int$0(_jw_){return pp_print_int(std_formatter,_jw_)}
    function print_float$0(_jv_){return pp_print_float(std_formatter,_jv_)}
    function print_char$0(_ju_){return pp_print_char(std_formatter,_ju_)}
    function print_bool(_jt_){return pp_print_bool(std_formatter,_jt_)}
    function print_break(_jr_,_js_)
     {return pp_print_break(std_formatter,_jr_,_js_)}
    function print_cut(_jq_){return pp_print_cut(std_formatter,_jq_)}
    function print_space(_jp_){return pp_print_space(std_formatter,_jp_)}
    function force_newline(_jo_){return pp_force_newline(std_formatter,_jo_)}
    function print_flush(_jn_){return pp_print_flush(std_formatter,_jn_)}
    function print_newline$0(_jm_)
     {return pp_print_newline(std_formatter,_jm_)}
    function print_if_newline(_jl_)
     {return pp_print_if_newline(std_formatter,_jl_)}
    function open_tbox(_jk_){return pp_open_tbox(std_formatter,_jk_)}
    function close_tbox(_jj_){return pp_close_tbox(std_formatter,_jj_)}
    function print_tbreak(_jh_,_ji_)
     {return pp_print_tbreak(std_formatter,_jh_,_ji_)}
    function set_tab(_jg_){return pp_set_tab(std_formatter,_jg_)}
    function print_tab(_jf_){return pp_print_tab(std_formatter,_jf_)}
    function set_margin(_je_){return pp_set_margin(std_formatter,_je_)}
    function get_margin(_jd_){return std_formatter[6]}
    function set_max_indent(_jc_)
     {return pp_set_max_indent(std_formatter,_jc_)}
    function get_max_indent(_jb_){return std_formatter[8]}
    function set_max_boxes(_ja_){return pp_set_max_boxes(std_formatter,_ja_)}
    function get_max_boxes(_i$_){return std_formatter[15]}
    function over_max_boxes(_i__)
     {return pp_over_max_boxes(std_formatter,_i__)}
    function set_ellipsis_text(_i9_)
     {return pp_set_ellipsis_text(std_formatter,_i9_)}
    function get_ellipsis_text(_i8_){return std_formatter[16]}
    function set_formatter_out_channel(_i7_)
     {return pp_set_formatter_out_channel(std_formatter,_i7_)}
    function set_formatter_out_functions(_i6_)
     {return pp_set_formatter_out_functions(std_formatter,_i6_)}
    function get_formatter_out_functions(_i5_)
     {return pp_get_formatter_out_functions(std_formatter,_i5_)}
    function set_formatter_output_functions(_i3_,_i4_)
     {return pp_set_formatter_output_functions(std_formatter,_i3_,_i4_)}
    function get_formatter_output_functions(_i2_)
     {return pp_get_formatter_output_functions(std_formatter,_i2_)}
    function set_formatter_tag_functions(_i1_)
     {return pp_set_formatter_tag_functions(std_formatter,_i1_)}
    function get_formatter_tag_functions(_i0_)
     {return pp_get_formatter_tag_functions(std_formatter,_i0_)}
    function set_print_tags(_iZ_)
     {return pp_set_print_tags(std_formatter,_iZ_)}
    function get_print_tags(_iY_){return std_formatter[22]}
    function set_mark_tags(_iX_){return pp_set_mark_tags(std_formatter,_iX_)}
    function get_mark_tags(_iW_){return std_formatter[23]}
    function set_tags(_iV_){return pp_set_tags(std_formatter,_iV_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _iT_=param$0[2],_iU_=param$0[1];
          if(_iT_)
           {caml_call2(pp_v,ppf,_iU_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=_iT_;
            continue}
          return caml_call2(pp_v,ppf,_iU_)}
        return 0}}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _iS_=left[1] !== len?1:0;
        return _iS_?flush(0):_iS_}}
    function compute_tag(output,tag_acc)
     {var buf=create$1(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$2(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _iI_=acc[2],_iJ_=acc[1];
          if(0 === _iI_[0])
           {var acc$0=_iI_[1];
            output_acc$0(ppf,_iJ_);
            return pp_open_tag(ppf,compute_tag(output_acc$0,acc$0))}
          var acc$1=_iI_[1];
          output_acc$0(ppf,_iJ_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _iK_=acc[1];
          if(typeof _iK_ === "number")
           var switch$1=1;
          else
           if(0 === _iK_[0])
            {var _iL_=_iK_[2];
             if(typeof _iL_ === "number")
              var switch$2=1;
             else
              if(1 === _iL_[0])
               var
                s$0=acc[2],
                size=_iL_[2],
                p$1=_iK_[1],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var s=acc[2],p$0=_iK_,switch$0=2;
          break;
         case 3:
          var _iM_=acc[1];
          if(typeof _iM_ === "number")
           var switch$3=1;
          else
           if(0 === _iM_[0])
            {var _iN_=_iM_[2];
             if(typeof _iN_ === "number")
              var switch$4=1;
             else
              if(1 === _iN_[0])
               var
                c$0=acc[2],
                size$0=_iN_[2],
                p$3=_iM_[1],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var c=acc[2],p$2=_iM_,switch$0=3;
          break;
         case 4:
          var _iO_=acc[1];
          if(typeof _iO_ === "number")
           var switch$5=1;
          else
           if(0 === _iO_[0])
            {var _iP_=_iO_[2];
             if(typeof _iP_ === "number")
              var switch$6=1;
             else
              if(1 === _iP_[0])
               var
                s$0=acc[2],
                size=_iP_[2],
                p$1=_iO_[1],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var s=acc[2],p$0=_iO_,switch$0=2;
          break;
         case 5:
          var _iQ_=acc[1];
          if(typeof _iQ_ === "number")
           var switch$7=1;
          else
           if(0 === _iQ_[0])
            {var _iR_=_iQ_[2];
             if(typeof _iR_ === "number")
              var switch$8=1;
             else
              if(1 === _iR_[0])
               var
                c$0=acc[2],
                size$0=_iR_[2],
                p$3=_iQ_[1],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var c=acc[2],p$2=_iQ_,switch$0=3;
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _iw_=acc[2],_ix_=acc[1];
          if(0 === _iw_[0])
           {var acc$0=_iw_[1];
            strput_acc$0(ppf,_ix_);
            return pp_open_tag(ppf,compute_tag(strput_acc$0,acc$0))}
          var acc$1=_iw_[1];
          strput_acc$0(ppf,_ix_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _iy_=acc[1];
          if(typeof _iy_ === "number")
           var switch$1=1;
          else
           if(0 === _iy_[0])
            {var _iz_=_iy_[2];
             if(typeof _iz_ === "number")
              var switch$2=1;
             else
              if(1 === _iz_[0])
               var
                s$0=acc[2],
                size=_iz_[2],
                p$1=_iy_[1],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var s=acc[2],p$0=_iy_,switch$0=2;
          break;
         case 3:
          var _iA_=acc[1];
          if(typeof _iA_ === "number")
           var switch$3=1;
          else
           if(0 === _iA_[0])
            {var _iB_=_iA_[2];
             if(typeof _iB_ === "number")
              var switch$4=1;
             else
              if(1 === _iB_[0])
               var
                c$0=acc[2],
                size$0=_iB_[2],
                p$3=_iA_[1],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var c=acc[2],p$2=_iA_,switch$0=3;
          break;
         case 4:
          var _iC_=acc[1];
          if(typeof _iC_ === "number")
           var switch$5=1;
          else
           if(0 === _iC_[0])
            {var _iD_=_iC_[2];
             if(typeof _iD_ === "number")
              var switch$6=1;
             else
              if(1 === _iD_[0])
               var
                s$0=acc[2],
                size=_iD_[2],
                p$1=_iC_[1],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var s=acc[2],p$0=_iC_,switch$0=2;
          break;
         case 5:
          var _iE_=acc[1];
          if(typeof _iE_ === "number")
           var switch$7=1;
          else
           if(0 === _iE_[0])
            {var _iF_=_iE_[2];
             if(typeof _iF_ === "number")
              var switch$8=1;
             else
              if(1 === _iF_[0])
               var
                c$0=acc[2],
                size$0=_iF_[2],
                p$3=_iE_[1],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var c=acc[2],p$2=_iE_,switch$0=3;
          break;
         case 6:
          var _iG_=acc[1];
          if(typeof _iG_ !== "number" && 0 === _iG_[0])
           {var _iH_=_iG_[2];
            if(typeof _iH_ !== "number" && 1 === _iH_[0])
             {var f$1=acc[2],size$1=_iH_[2],p$4=_iG_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_iG_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_iv_=0;
      return make_printf
              (function(ppf,acc)
                {output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               ppf,
               _iv_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function fprintf$0(ppf)
     {function _is_(_iu_){return 0}
      return function(_it_){return kfprintf$0(_is_,ppf,_it_)}}
    function ifprintf$0(ppf)
     {function _ip_(_ir_){return 0}
      return function(_iq_){return ikfprintf$0(_ip_,ppf,_iq_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function ksprintf$0(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(param,acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,0,fmt)}
    function sprintf$0(fmt){return ksprintf$0(function(s){return s},fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(ppf,acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,ppf,0,fmt)}
    function asprintf(fmt){return kasprintf(function(s){return s},fmt)}
    at_exit(print_flush);
    function pp_set_all_formatter_output_functions(state,f,g,h,i)
     {pp_set_formatter_output_functions(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_functions(_il_,_im_,_in_,_io_)
     {return pp_set_all_formatter_output_functions
              (std_formatter,_il_,_im_,_in_,_io_)}
    function get_all_formatter_output_functions(_ik_)
     {return pp_get_all_formatter_output_functions(std_formatter,_ik_)}
    function bprintf$0(b,param)
     {var fmt=param[1];
      function k(ppf,acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,formatter_of_buffer(b),0,fmt)}
    var
     Stdlib_format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functions,
       set_formatter_output_functions,
       pp_get_formatter_output_functions,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_buffer,
       pp_print_list,
       pp_print_text,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       ifprintf$0,
       kfprintf$0,
       ikfprintf$0,
       ksprintf$0,
       kasprintf,
       bprintf$0,
       ksprintf$0,
       set_all_formatter_output_functions,
       get_all_formatter_output_functions,
       pp_set_all_formatter_output_functions,
       pp_get_all_formatter_output_functions];
    caml_register_global(692,Stdlib_format,"Stdlib__format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_ij_)
       {_ij_ = caml_wrap_exception(_ij_);
        if(_ij_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _ij_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _ii_=ib[9];
      if(typeof _ii_ === "number")
       return 0 === _ii_?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _ii_[0])return cst_unnamed_Pervasives_input_channel;
        var fname=_ii_[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$3(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$1(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$3(1,next)}
    var _ca_=0;
    function from_function$0(_ih_){return create$3(_ca_,_ih_)}
    var len=1024;
    function scan_close_at_end(ic){caml_call1(_o_[81],ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$3(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$72,_o_[26]],_o_[26]);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$73))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    var _cb_=_o_[67];
    function from_file(_ig_){return open_in_file(_cb_,_ig_)}
    var _cc_=_o_[68];
    function from_file_bin(_if_){return open_in_file(_cc_,_if_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in(ib)
     {var _ie_=ib[9];
      if(typeof _ie_ === "number")
       return 0;
      else
       {if(0 === _ie_[0]){var ic=_ie_[1];return caml_call1(_o_[81],ic)}
        var ic$0=_ie_[2];
        return caml_call1(_o_[81],ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _ic_=assq(ic,memo[1]);return _ic_}
      catch(_id_)
       {_id_ = caml_wrap_exception(_id_);
        if(_id_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _id_}}
    function memo_from_channel(_ib_)
     {return memo_from_ic(scan_raise_at_end,_ib_)}
    var Scan_failure=[248,cst_Stdlib_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_cd_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_ce_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_found_in_float_token)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexadecimal_notation)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_cg_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_h$_=1 - ib[1];
         if(_h$_)
          {var
            _ia_=c - 9 | 0,
            switch$0=
             4 < _ia_ >>> 0?23 === _ia_?1:0:1 < (_ia_ - 2 | 0) >>> 0?1:0;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _h$_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$2)
              ?caml_string_notequal(s,cst_true$2)
                ?bad_input(caml_call1(sprintf(_ch_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_ci_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=_g_(cst_0b,token_string(ib));break;
        case 3:var tok=_g_(cst_0o,token_string(ib));break;
        case 4:var tok=_g_(cst_0u,token_string(ib));break;
        case 5:var tok=_g_(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l)
       if(43 === caml_string_get(tok,0))return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_cj_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_ck_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_h9_,_h__)
     {return scan_digit_plus(cst_binary,is_binary_digit,_h9_,_h__)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_h7_,_h8_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_h7_,_h8_)}
    function is_hexa_digit(param)
     {var
       _h6_=param - 48 | 0,
       switch$0=
        22 < _h6_ >>> 0
         ?5 < (_h6_ - 49 | 0) >>> 0?0:1
         :6 < (_h6_ - 10 | 0) >>> 0?1:0;
      return switch$0?1:0}
    function scan_hexadecimal_int(_h4_,_h5_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_h4_,_h5_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal_int(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal_int(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             var switch$0=120 === c$0?1:0}
           else
            if(88 === c$0)
             var switch$0=1;
            else
             {if(98 <= c$0)
               return scan_binary_int(store_char(width,ib,c$0),ib);
              var switch$0=0}
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c)if(101 !== c)return width;
      return scan_optionally_signed_decimal_int(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _h1_=len - 1 | 0,
       _h0_=0;
      if(! (_h1_ < 0))
       {var i=_h0_;
        for(;;)
         {var c=peek_char(ib),_h2_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _h2_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _h3_=i + 1 | 0;
          if(_h1_ !== i){var i=_h3_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _hN_=0 === width?1:0,_hO_=_hN_ || end_of_input(ib);
      if(_hO_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _hP_=0 === width$0?1:0,
       _hQ_=_hP_ || end_of_input(ib);
      if(_hQ_)bad_hex_float(0);
      var c=peek_char(ib);
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _hR_=0 === width$1?1:0,
             _hS_=_hR_ || end_of_input(ib);
            if(_hS_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}
          var switch$0=0}
        else
         var switch$0=26 === switcher?1:0}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _hV_=0 === width$3?1:0,
           _hW_=_hV_ || end_of_input(ib);
          if(_hW_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4)
           if(! end_of_input(ib))
            {var
              match=peek_char(ib),
              _hX_=match - 46 | 0,
              switch$1=
               34 < _hX_ >>> 0?66 === _hX_?1:0:32 < (_hX_ - 1 | 0) >>> 0?1:0,
              width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
             if(0 !== width$5)
              if(! end_of_input(ib))
               {var c$0=peek_char(ib);
                if(46 === c$0)
                 {var width$6=store_char(width$5,ib,c$0);
                  if(0 === width$6)
                   var switch$2=0;
                  else
                   if(end_of_input(ib))
                    var switch$2=0;
                   else
                    {var match$0=peek_char(ib);
                     if(80 === match$0)
                      var switch$3=0;
                     else
                      if(112 === match$0)
                       var switch$3=0;
                      else
                       var
                        precision$0=min(width$6,precision),
                        width$10=
                         width$6
                         -
                         (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                         |
                         0,
                        switch$3=1;
                     if(! switch$3)var width$10=width$6;
                     var width$7=width$10,switch$2=1}
                  if(! switch$2)var width$7=width$6;
                  var width$8=width$7}
                else
                 var width$8=width$5;
                if(0 !== width$8)
                 if(! end_of_input(ib))
                  {var c$1=peek_char(ib);
                   if(80 !== c$1)if(112 !== c$1)return width$8;
                   var
                    width$9=store_char(width$8,ib,c$1),
                    _hY_=0 === width$9?1:0,
                    _hZ_=_hY_ || end_of_input(ib);
                   if(_hZ_)bad_hex_float(0);
                   return scan_optionally_signed_decimal_int(width$9,ib)}
                return width$8}
             return width$5}
          return width$4}
        var switch$0=73 === c?1:0}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _hT_=0 === width$2?1:0,
         _hU_=_hT_ || end_of_input(ib);
        if(_hU_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _hJ_=0 === width?1:0,_hK_=_hJ_ || end_of_input(ib);
      if(_hK_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _hL_=0 === width$0?1:0,
       _hM_=_hL_ || end_of_input(ib);
      if(_hM_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _hv_=0 === width?1:0,_hw_=_hv_ || end_of_input(ib);
      if(_hw_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _hx_=0 === width$0?1:0,
       _hy_=_hx_ || end_of_input(ib);
      if(_hy_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _hz_=0 === width$1?1:0,
           _hA_=_hz_ || end_of_input(ib);
          if(_hA_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _hB_=0 === width$2?1:0,
          _hC_=_hB_ || end_of_input(ib);
         if(_hC_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0)
          if(120 !== c$0)return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _hD_=0 === width$3?1:0,
          _hE_=_hD_ || end_of_input(ib);
         if(_hE_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _hF_=0 === width$4?1:0,
          _hG_=_hF_ || end_of_input(ib);
         if(_hG_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1);
            if(0 === width$5)
             var switch$1=0;
            else
             if(end_of_input(ib))
              var switch$1=0;
             else
              {var match=peek_char(ib);
               if(80 === match)
                var switch$2=0;
               else
                if(112 === match)
                 var switch$2=0;
                else
                 var
                  precision$0=min(width$5,precision),
                  width$10=
                   width$5
                   -
                   (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                   |
                   0,
                  switch$2=1;
               if(! switch$2)var width$10=width$5;
               var width$6=width$10,switch$1=1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6,switch$0=0}
          else
           var switch$0=1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)
            var width$7=width$4,switch$0=0;
           else
            var switch$0=1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8)
          if(! end_of_input(ib))
           {var c$2=peek_char(ib);
            if(80 !== c$2)if(112 !== c$2)return width$8;
            var
             width$9=store_char(width$8,ib,c$2),
             _hH_=0 === width$9?1:0,
             _hI_=_hH_ || end_of_input(ib);
            if(_hI_)bad_hex_float(0);
            return scan_optionally_signed_decimal_int(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var
         _hu_=c - 9 | 0,
         switch$0=4 < _hu_ >>> 0?23 === _hu_?1:0:1 < (_hu_ - 2 | 0) >>> 0?1:0;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_cf_),message)):c}
    function check_next_char_for_char(_hs_,_ht_)
     {return check_next_char(cst_a_Char,_hs_,_ht_)}
    function check_next_char_for_string(_hq_,_hr_)
     {return check_next_char(cst_a_String,_hq_,_hr_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib);
      if(40 <= c0)
       if(58 <= c0)
        {var switcher$0=c0 - 92 | 0;
         if(28 < switcher$0 >>> 0)
          var switch$0=0;
         else
          switch(switcher$0)
           {case 28:
             var
              get_digit=
               function(param)
                {var
                  c=next_char(ib),
                  _hp_=c - 48 | 0,
                  switch$0=
                   22 < _hp_ >>> 0
                    ?5 < (_hp_ - 49 | 0) >>> 0?0:1
                    :6 < (_hp_ - 10 | 0) >>> 0?1:0;
                 return switch$0?c:bad_input_escape(c)},
              c1=get_digit(0),
              c2=get_digit(0),
              _hl_=hexadecimal_value_of_char(c2),
              c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _hl_ | 0;
             if(0 <= c$0)
              if(255 < c$0)
               var switch$1=0;
              else
               var _hn_=char_of_int(c$0),switch$1=1;
             else
              var switch$1=0;
             if(! switch$1)
              var _hn_=bad_input(caml_call2(sprintf(_cm_),c1,c2));
             return store_char(width - 2 | 0,ib,_hn_);
            case 0:
            case 6:
            case 18:
            case 22:
            case 24:var switch$0=1;break;
            default:var switch$0=0}}
       else
        {if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0;
           if(0 <= c)
            if(255 < c)var switch$2=0;else var _ho_=char_of_int(c),switch$2=1;
           else
            var switch$2=0;
           if(! switch$2)
            var _ho_=bad_input(caml_call3(sprintf(_cl_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_ho_)}
         var switch$0=0}
      else
       var switch$0=34 === c0?1:39 <= c0?1:0;
      if(switch$0)
       {if(110 <= c0)
         if(117 <= c0)
          var switch$3=0;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _hm_=10,switch$3=1;break;
             case 4:var _hm_=13,switch$3=1;break;
             case 6:var _hm_=9,switch$3=1;break;
             default:var switch$3=0}}
        else
         if(98 === c0)var _hm_=8,switch$3=1;else var switch$3=0;
        if(! switch$3)var _hm_=c0;
        return store_char(width,ib,_hm_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _hj_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_hj_)}
              return caml_trampoline_return(skip_spaces,[0,_hj_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _hk_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_hk_)}
                return caml_trampoline_return(skip_spaces,[0,_hk_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_hf_=0 < i$0?1:0;
          if(_hf_)
           {var _hg_=1 - ib[1];
            if(_hg_)
             var _hh_=is_in_char_set(char_set,c),_hi_=_hh_?c !== stp?1:0:_hh_;
            else
             var _hi_=_hg_}
          else
           var _hi_=_hf_;
          if(_hi_)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _hi_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _he_=1 - ib[1];
        if(_he_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _he_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_co_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cp_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_hc_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_hc_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_hc_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _hd_=fmt$0[1];
           if(0 === _hd_[0])
            {var
              rest$0=fmt$0[2],
              match=_hd_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_hd_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {caml_call3(scan,max_int,max_int,ib);
            var x=caml_call1(token,ib);
            return [0,x,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion)}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(0 === pad[1])return invalid_arg(cst_scanf_bad_conversion$0);
          var _hb_=pad[2];
          if(typeof prec === "number")
           {if(0 === prec)
             {caml_call3(scan,_hb_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            return invalid_arg(cst_scanf_bad_conversion$1)}
          var p$0=prec[1];
          caml_call3(scan,_hb_,p$0,ib);
          var x$2=caml_call1(token,ib);
          return [0,x$2,make_scanf(ib,fmt,readers)]}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _gY_=fmt$0[2],_gZ_=fmt$0[1];
           if(typeof _gY_ !== "number")
            switch(_gY_[0])
             {case 17:
               var
                rest$1=_gY_[2],
                fmting_lit=_gY_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$1];
               return pad_prec_scanf
                       (ib,str_rest,readers,_gZ_,0,scan$0,token_string);
              case 18:
               var _g0_=_gY_[1];
               if(0 === _g0_[0])
                {var
                  rest$2=_gY_[2],
                  match$0=_g0_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cq_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$2),
                          readers,
                          _gZ_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$3=_gY_[2],
                match$1=_g0_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_cr_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$3),
                        readers,
                        _gZ_,
                        0,
                        scan$2,
                        token_string)
              }
           var scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,_gY_,readers,_gZ_,0,scan,token_string);
          case 3:
           var
            rest$4=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$4,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$5=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$5,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$6=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$7=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$8=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           var _g1_=fmt$0[1];
           if(15 === _g1_)
            {var rest$9=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$9,readers,pad$4,prec$3,scan_caml_float,token_float)}
           if(16 <= _g1_)
            {var rest$10=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$10,readers,pad$5,prec$4,scan_hex_float,token_float)}
           var rest$11=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
           return pad_prec_scanf
                   (ib,rest$11,readers,pad$6,prec$5,scan_float,token_float);
          case 9:
           var
            rest$12=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_ha_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_cn_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$12,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$13=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$13;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$14=fmt$0[2],str$0=fmt$0[1];
           iter$2(function(_g$_){return check_char(ib,_g$_)},str$0);
           var fmt$0=rest$14;
           continue;
          case 12:
           var rest$15=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$15;
           continue;
          case 13:
           var rest$16=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _g2_=format_of_string_fmtty(s,fmtty),fmt$3=_g2_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$16,readers)];
          case 14:
           var rest$17=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _g4_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=_g4_,
              fmt$4=fmt$8}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _g3_=bad_input(msg$0),
              fmt$5=_g3_[1],
              fmt$4=_g3_[2]}
           return [0,
                   [0,fmt$5,s$0],
                   make_scanf(ib,concat_fmt(fmt$4,rest$17),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$18=fmt$0[2],
            formatting_lit=fmt$0[1],
            _g5_=string_of_formatting_lit(formatting_lit);
           iter$2(function(_g__){return check_char(ib,_g__)},_g5_);
           var fmt$0=rest$18;
           continue;
          case 18:
           var _g6_=fmt$0[1];
           if(0 === _g6_[0])
            {var rest$19=fmt$0[2],match$4=_g6_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$19),fmt$0=fmt$10;
             continue}
           var rest$20=fmt$0[2],match$5=_g6_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$20),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _g7_=fmt$0[3],_g8_=fmt$0[2],_g9_=fmt$0[1];
           if(typeof _g7_ !== "number" && 17 === _g7_[0])
            {var
              rest$21=_g7_[2],
              fmting_lit$0=_g7_[1],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_g9_);
             scan_chars_in_char_set(_g8_,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$21];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var width=width_of_pad_opt(_g9_);
           scan_chars_in_char_set(_g8_,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,_g7_,readers)];
          case 21:
           var
            rest$22=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$22,readers)];
          case 22:
           var rest$23=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$23,readers)];
          case 23:
           var
            rest$24=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$24),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cs_];
          default:
           return invalid_arg(cst_scanf_bad_conversion_custom_converter)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _gX_=[0,make_scanf(ib,fmt,readers)],_gW_=_gX_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          if(exc[1] === Scan_failure)
           var switch$0=0;
          else
           if(exc[1] === Failure)
            var switch$0=0;
           else
            if(exc === End_of_file)
             var switch$0=0;
            else
             {if(exc[1] !== Invalid_argument)throw exc;
              var
               msg=exc[2],
               _gV_=
                invalid_arg
                 (_g_(msg,_g_(cst_in_format,_g_(escaped$1(str),cst$74)))),
               switch$0=1}
          if(! switch$0)var _gV_=[1,exc];
          var _gW_=_gV_}
        if(0 === _gW_[0]){var args=_gW_[1];return apply(f,args)}
        var exc=_gW_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _gU_=format_of_string_format(str,format),fmt=_gU_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {var l=caml_ml_string_length(s);
      function _gT_(x){return x}
      var b=create$1(l + 2 | 0);
      add_char(b,34);
      var _gR_=l - 1 | 0,_gQ_=0;
      if(! (_gR_ < 0))
       {var i=_gQ_;
        for(;;)
         {var c=caml_string_get(s,i);
          if(34 === c)add_char(b,92);
          add_char(b,c);
          var _gS_=i + 1 | 0;
          if(_gR_ !== i){var i=_gS_;continue}
          break}}
      add_char(b,34);
      return sscanf_format(contents(b),fmt,_gT_)}
    function unescaped(s)
     {function _gP_(x){return x}
      return caml_call1(sscanf(_g_(cst$76,_g_(s,cst$75)),_ct_),_gP_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Stdlib_scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(693,Stdlib_scanf,"Stdlib__scanf");
    var register=caml_register_named_value;
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Stdlib_callback=[0,register,register_exception];
    caml_register_global(694,Stdlib_callback,"Stdlib__callback");
    function copy$6(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_gM_=caml_ml_string_length(s) - 1 | 0,_gL_=0;
      if(! (_gM_ < 0))
       {var i=_gL_;
        for(;;)
         {var _gN_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _gN_ | 0;
          var _gO_=i + 1 | 0;
          if(_gM_ !== i){var i=_gO_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    var
     compare$6=caml_string_compare,
     Vars=caml_call1(Stdlib_map[1],[0,compare$6]),
     compare$7=caml_string_compare,
     Meths=caml_call1(Stdlib_map[1],[0,compare$7]),
     compare$8=caml_int_compare,
     Labs=caml_call1(Stdlib_map[1],[0,compare$8]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _gF_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _gF_;
      var _gH_=len - 1 | 0,_gG_=0;
      if(! (_gH_ < 0))
       {var i=_gG_;
        for(;;)
         {var
           _gJ_=(i * 2 | 0) + 3 | 0,
           _gI_=caml_check_bound(pub_labels,i)[i + 1];
          caml_check_bound(methods,_gJ_)[_gJ_ + 1] = _gI_;
          var _gK_=i + 1 | 0;
          if(_gH_ !== i){var i=_gK_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_gD_=old_size < new_size?1:0;
      if(_gD_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _gE_=0}
      else
       var _gE_=_gD_;
      return _gE_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _gB_=caml_call2(Meths[27],name,table[3]);return _gB_}
      catch(_gC_)
       {_gC_ = caml_wrap_exception(_gC_);
        if(_gC_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _gC_}}
    function get_method_labels(table,names)
     {return map$3(function(_gA_){return get_method_label(table,_gA_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[27],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[label + 1]
                =
                element)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _gy_=assoc(label,table[6]);return _gy_}
      catch(_gz_)
       {_gz_ = caml_wrap_exception(_gz_);
        if(_gz_ === Not_found)
         return caml_check_bound(table[2],label)[label + 1];
        throw _gz_}}
    function to_list$0(arr){return arr === 0?0:to_list(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$0(vars),
       virt_meths$0=to_list$0(virt_meths),
       concr_meths$0=to_list$0(concr_meths),
       virt_meth_labs=
        map$0
         (function(_gx_){return get_method_label(table,_gx_)},virt_meths$0),
       concr_meth_labs=
        map$0
         (function(_gw_){return get_method_label(table,_gw_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _gn_=Vars[1],_go_=table[7];
      function _gp_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_gp_,_go_,_gn_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _gs_=by_label[1];
          try
           {var _gu_=caml_call2(Labs[27],label,table[4]),_gt_=_gu_}
          catch(_gv_)
           {_gv_ = caml_wrap_exception(_gv_);
            if(_gv_ !== Not_found)throw _gv_;
            var _gt_=1}
          by_label[1] = caml_call3(Labs[4],label,_gt_,_gs_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _gq_=0,_gr_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _gr_,
        _gq_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left$0
       (function(s,v)
         {var _gm_=caml_call2(Vars[27],v,table[7]);
          return caml_call3(Vars[4],v,_gm_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _gl_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _gl_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _gj_=caml_call2(Vars[27],name,table[7]);return _gj_}
      catch(_gk_)
       {_gk_ = caml_wrap_exception(_gk_);
        if(_gk_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$77))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _gk_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _gb_=nmeths - 1 | 0,
       _ga_=0;
      if(! (_gb_ < 0))
       {var i$0=_ga_;
        for(;;)
         {var
           _gh_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[i$0 + 1]);
          caml_check_bound(res,i$0)[i$0 + 1] = _gh_;
          var _gi_=i$0 + 1 | 0;
          if(_gb_ !== i$0){var i$0=_gi_;continue}
          break}}
      var _gd_=nvals - 1 | 0,_gc_=0;
      if(! (_gd_ < 0))
       {var i=_gc_;
        for(;;)
         {var
           _gf_=i + nmeths | 0,
           _ge_=new_variable(table,caml_check_bound(vals,i)[i + 1]);
          caml_check_bound(res,_gf_)[_gf_ + 1] = _ge_;
          var _gg_=i + 1 | 0;
          if(_gd_ !== i){var i=_gg_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _f__=caml_call2(Vars[27],name,table[7]);return _f__}
      catch(_f$_)
       {_f$_ = caml_wrap_exception(_f$_);
        if(_f$_ === Not_found)throw [0,Assert_failure,_cu_];
        throw _f$_}}
    function get_variables(table,names)
     {return map$3(function(_f9_){return get_variable(table,_f9_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(public_methods === 0)return new_table([0]);
      var
       tags=map$3(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _f4_=0,
       _f5_=to_array(concr_meths),
       _f6_=
        [0,
         map$3
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_f5_),
         _f4_],
       _f7_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$3(function(_f8_){return get_variable(cla,_f8_)},_f7_),
                 _f6_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_f3_=0 !== inits?1:0;
      return _f3_?iter_f(obj,inits):_f3_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initializers(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cy_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_fZ_=0;
      if(! (n < 0))
       {var i=_fZ_;
        for(;;)
         {var _f1_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[i + 1],_f1_,0];
          var _f2_=i + 1 | 0;
          if(n !== i){var i=_f2_;continue}
          break}}
      var _f0_=r[1];
      if(tables){tables[2] = _f0_;return res}
      throw [0,Assert_failure,_cv_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[i + 1],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cA_]}
                if(tables$0)
                 {var _fY_=tables$0[3];
                  if(_fY_){var tables$0=_fY_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_cw_]}
                throw [0,Assert_failure,_cz_]}
              throw [0,Assert_failure,_cx_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table);
      if(0 === (n % 2 | 0))
       var switch$0=0;
      else
       if((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n)
        var switch$0=0;
       else
        var n$0=new_method(table),switch$0=1;
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[n$0 + 1] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _fS_=i[1],
           label=caml_check_bound(methods,_fS_)[_fS_ + 1],
           next=
            function(param)
             {i[1]++;
              var _fX_=i[1];
              return caml_check_bound(methods,_fX_)[_fX_ + 1]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[n + 1]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[e + 1][n + 1]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][n + 1],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[n + 1] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[n + 1])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[e + 1][n + 1])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][n + 1],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[n + 1])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[e + 1][n + 1])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][n + 1],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[n + 1],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[e + 1][n + 1],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][n + 1],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,obj[m + 1])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,obj[e + 1][m + 1])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _fV_=caml_call1(obj[1][m + 1],obj);
                     return caml_call2(obj[1][n + 1],obj,_fV_)}}
                 (n$15,m$1);
              break;
             case 20:
              var
               m$2=next(0),
               x$9=next(0),
               c=new_cache(table),
               clo$0=
                function(m,x,c)
                  {return function(obj)
                    {return caml_call2(caml_get_public_method(x,m,0),x,c)}}
                 (m$2,x$9,c);
              break;
             case 21:
              var
               m$3=next(0),
               n$16=next(0),
               c$0=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _fU_=obj[n + 1];
                     return caml_call2(caml_get_public_method(_fU_,m,0),_fU_,c)}}
                 (m$3,n$16,c$0);
              break;
             case 22:
              var
               m$4=next(0),
               e$4=next(0),
               n$17=next(0),
               c$1=new_cache(table),
               clo$0=
                function(m,e,n,c)
                  {return function(obj)
                    {var _fT_=obj[e + 1][n + 1];
                     return caml_call2(caml_get_public_method(_fT_,m,0),_fT_,c)}}
                 (m$4,e$4,n$17,c$1);
              break;
             default:
              var
               m$5=next(0),
               n$18=next(0),
               c$2=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _fW_=caml_call1(obj[1][n + 1],obj);
                     return caml_call2(caml_get_public_method(_fW_,m,0),_fW_,c)}}
                 (m$5,n$18,c$2)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$6,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initializers,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(695,CamlinternalOO,"CamlinternalOO");
    var Stdlib_oo=[0,copy$6,public_method_label,public_method_label];
    caml_register_global(696,Stdlib_oo,"Stdlib__oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(697,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Stdlib_hashtbl[1],0,17);
      iter$0
       (function(s){return caml_call3(Stdlib_hashtbl[5],kwd_table,s,[0,s])},
        keywords);
      function ident_or_keyword(id)
       {try
         {var _fQ_=caml_call2(Stdlib_hashtbl[6],kwd_table,id);return _fQ_}
        catch(_fR_)
         {_fR_ = caml_wrap_exception(_fR_);
          if(_fR_ === Not_found)return [1,id];
          throw _fR_}}
      function keyword_or_error(c)
       {var s=make$0(1,c);
        try
         {var _fO_=caml_call2(Stdlib_hashtbl[6],kwd_table,s);return _fO_}
        catch(_fP_)
         {_fP_ = caml_wrap_exception(_fP_);
          if(_fP_ === Not_found)throw [0,Error,_g_(cst_Illegal_character,s)];
          throw _fP_}}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fN_=match[1],switcher=_fN_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_fN_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _fM_=match[1],switch$0=43 === _fM_?0:45 === _fM_?0:1;
          if(! switch$0)
           {junk(strm);store(_fM_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _fJ_=match[1];
            if(58 <= _fJ_)
             {var switch$0=69 === _fJ_?0:101 === _fJ_?0:1;
              if(! switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _fJ_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _fK_=match$0[1],_fL_=_fK_ - 69 | 0;
                    if(32 < _fL_ >>> 0)
                     {var switcher=_fL_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_fK_);continue}}
                    else
                     {var switcher$0=_fL_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _fJ_){junk(s);store(_fJ_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fH_=match[1];
            if(94 <= _fH_)
             var
              _fI_=_fH_ - 95 | 0,
              switch$0=30 < _fI_ >>> 0?32 <= _fI_?1:0:29 === _fI_?0:1;
            else
             if(65 <= _fH_)
              var switch$0=92 === _fH_?0:1;
             else
              if(33 <= _fH_)
               switch(_fH_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:var switch$0=0;break;
                 default:var switch$0=1}
              else
               var switch$0=1;
            if(! switch$0){junk(strm);store(_fH_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _fG_=match[1],switcher=_fG_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_fG_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fE_=match[1];
            if(91 <= _fE_)
             var
              _fF_=_fE_ - 95 | 0,
              switch$0=27 < _fF_ >>> 0?97 <= _fF_?0:1:1 === _fF_?1:0;
            else
             var
              switch$0=
               48 <= _fE_?6 < (_fE_ - 58 | 0) >>> 0?0:1:39 === _fE_?0:1;
            if(! switch$0){junk(strm);store(_fE_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fv_=match[1];
            if(124 <= _fv_)
             var switch$0=127 <= _fv_?192 <= _fv_?1:0:125 === _fv_?0:2;
            else
             {var _fw_=_fv_ - 65 | 0;
              if(57 < _fw_ >>> 0)
               if(58 <= _fw_)
                var switch$0=0;
               else
                {var switcher=_fw_ + 65 | 0;
                 switch(switcher)
                  {case 34:
                    junk(strm);
                    reset_buffer(0);
                    for(;;)
                     {var match$1=peek$0(strm);
                      if(match$1)
                       {var _fy_=match$1[1];
                        if(34 === _fy_){junk(strm);return [0,[4,get_string(0)]]}
                        if(92 === _fy_)
                         {junk(strm);
                          try
                           {var c$0=escape(strm)}
                          catch(_fD_)
                           {_fD_ = caml_wrap_exception(_fD_);
                            if(_fD_ === Failure$0)throw [0,Error,cst$80];
                            throw _fD_}
                          store(c$0);
                          continue}
                        junk(strm);
                        store(_fy_);
                        continue}
                      throw Failure$0}
                   case 39:
                    junk(strm);
                    try
                     {var match$2=peek$0(strm);
                      if(! match$2)throw Failure$0;
                      var _fz_=match$2[1];
                      if(92 === _fz_)
                       {junk(strm);
                        try
                         {var _fA_=escape(strm)}
                        catch(_fC_)
                         {_fC_ = caml_wrap_exception(_fC_);
                          if(_fC_ === Failure$0)throw [0,Error,cst$81];
                          throw _fC_}
                        var c=_fA_}
                      else
                       {junk(strm);var c=_fz_}}
                    catch(_fB_)
                     {_fB_ = caml_wrap_exception(_fB_);
                      if(_fB_ === Failure$0)throw [0,Error,cst$78];
                      throw _fB_}
                    var match$0=peek$0(strm);
                    if(match$0)
                     if(39 === match$0[1]){junk(strm);return [0,[5,c]]}
                    throw [0,Error,cst$79];
                   case 40:
                    junk(strm);
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return maybe_comment(counter$0,strm)}
                    return caml_trampoline_return(maybe_comment,[0,strm]);
                   case 45:junk(strm);return neg_number(strm);
                   case 9:
                   case 10:
                   case 12:
                   case 13:
                   case 26:
                   case 32:junk(strm);continue;
                   case 48:
                   case 49:
                   case 50:
                   case 51:
                   case 52:
                   case 53:
                   case 54:
                   case 55:
                   case 56:
                   case 57:
                    junk(strm);reset_buffer(0);store(_fv_);return number(strm);
                   case 33:
                   case 35:
                   case 36:
                   case 37:
                   case 38:
                   case 42:
                   case 43:
                   case 47:
                   case 58:
                   case 60:
                   case 61:
                   case 62:
                   case 63:
                   case 64:var switch$0=2;break;
                   default:var switch$0=0}}
              else
               {var _fx_=_fw_ - 26 | 0;
                if(5 < _fx_ >>> 0)
                 var switch$0=1;
                else
                 switch(_fx_)
                  {case 4:var switch$0=1;break;
                   case 1:
                   case 3:var switch$0=2;break;
                   default:var switch$0=0}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_fv_)];
              case 1:
               junk(strm);reset_buffer(0);store(_fv_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_fv_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match)
         if(42 === match[1])
          {junk(strm);
           comment(strm);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return next_token$0(counter$0,strm)}
           return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _fs_=match[1];
          if(58 <= _fs_)
           {var switcher=_fs_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _fs_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _ft_=match$0[1],switcher$0=_ft_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _fu_=match$1[1],switcher$1=_fu_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_fs_ - 48 | 0) * 100 | 0)
                               +
                               ((_ft_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_fu_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$83]}}
             throw [0,Error,cst$82]}
          junk(strm);
          return _fs_}
        throw Failure$0}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _fr_=match$1[1];
                    if(41 === _fr_){junk(strm);return 0}
                    if(42 === _fr_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Stdlib_genlex=[0,make_lexer];
    caml_register_global(698,Stdlib_genlex,"Stdlib__genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_fq_){return caml_call1(_b6_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Stdlib_hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x))
           if(! (max_array_length < (x * 2 | 0)))
            {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _fo_=caml_obj_tag(prng),
            _fp_=250 === _fo_?prng[1]:246 === _fo_?force_lazy_block(prng):prng,
            seed=caml_call1(_b6_[4],_fp_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_fm_=len - 1 | 0,_fl_=0;
        if(! (_fm_ < 0))
         {var i=_fl_;
          for(;;)
           {caml_check_bound(h[2],i)[i + 1] = 0;
            var _fn_=i + 1 | 0;
            if(_fm_ !== i){var i=_fn_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _fi_=init[4],_fj_=init[3],_fk_=copy$1(init[2]);
        return [0,init[1],_fk_,_fj_,_fi_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hkey=param$0[1];
              if(caml_call1(H[7],c))return [0,hkey,c,do_bucket(rest)];
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_ff_=d.length - 1 - 1 | 0,_fe_=0;
        if(! (_ff_ < 0))
         {var i=_fe_;
          for(;;)
           {var _fg_=do_bucket(caml_check_bound(d,i)[i + 1]);
            caml_check_bound(d,i)[i + 1] = _fg_;
            var _fh_=i + 1 | 0;
            if(_ff_ !== i){var i=_fh_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _e__=nsize < max_array_length?1:0,
         _e$_=_e__?(osize >>> 1 | 0) <= h[1]?1:0:_e__;
        if(_e$_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var nidx=key_index(h,hkey);
                return ndata[nidx + 1]
                       =
                       [0,hkey,data,caml_check_bound(ndata,nidx)[nidx + 1]]}
              return 0},
           _fb_=osize - 1 | 0,
           _fa_=0;
          if(! (_fb_ < 0))
           {var i=_fa_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[i + 1]);
              var _fd_=i + 1 | 0;
              if(_fb_ !== i){var i=_fd_;continue}
              break}}
          var _fc_=0}
        else
         var _fc_=_e$_;
        return _fc_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[i + 1]];
        caml_check_bound(h[2],i)[i + 1] = bucket;
        h[1] = h[1] + 1 | 0;
        var _e9_=h[2].length - 1 << 1 < h[1]?1:0;
        return _e9_?resize(h):_e9_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              return [0,hk,c,remove_bucket(next)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _e8_=remove_bucket(caml_check_bound(h[2],i)[i + 1]);
        return caml_check_bound(h[2],i)[i + 1] = _e8_}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _e7_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_e7_)[_e7_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _e6_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_e6_)[_e6_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$0=rest;
              continue}
            return 0}}
        var _e5_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_e5_)[_e5_ + 1])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(0 === match)return caml_call3(H[6],c,key,info);
                var param$0=next;
                continue}
              var param$0=next;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[i + 1];
        try
         {var _e3_=replace_bucket(l);return _e3_}
        catch(_e4_)
         {_e4_ = caml_wrap_exception(_e4_);
          if(_e4_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[i + 1] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _e2_=h[2].length - 1 << 1 < h[1]?1:0;
            return _e2_?resize(h):_e2_}
          throw _e4_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _e1_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_e1_)[_e1_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(0 === match)return 1;
              var param=rest;
              continue}
            var param=rest;
            continue}
          return 0}}
      function iter$0(f,h)
       {var d$0=h[2],_eZ_=d$0.length - 1 - 1 | 0,_eY_=0;
        if(! (_eZ_ < 0))
         {var i=_eY_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[i + 1],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  {var d=match$0[1],k=match[1];
                   caml_call2(f,k,d);
                   var switch$0=1}
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                var param=rest;
                continue}
              var _e0_=i + 1 | 0;
              if(_eZ_ !== i){var i=_e0_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_eV_=d$0.length - 1 - 1 | 0,_eU_=0;
        if(! (_eV_ < 0))
         {var i=_eU_;
          a:
          for(;;)
           {var
             _eW_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[i + 1],
             b=b$0,
             accu=_eW_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  var
                   d=match$0[1],
                   k=match[1],
                   accu$0=caml_call3(f,k,d,accu),
                   switch$0=1;
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _eX_=i + 1 | 0;
              if(_eV_ !== i){var i=_eX_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match)
               if(match$0)
                {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                 if(match$1)
                  {var new_d=match$1[1];
                   caml_call3(H[6],c,k,new_d);
                   return [0,hk,c,do_bucket(rest)]}
                 var param$0=rest;
                 continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_eR_=d.length - 1 - 1 | 0,_eQ_=0;
        if(! (_eR_ < 0))
         {var i=_eQ_;
          for(;;)
           {var _eS_=do_bucket(caml_check_bound(d,i)[i + 1]);
            caml_check_bound(d,i)[i + 1] = _eS_;
            var _eT_=i + 1 | 0;
            if(_eR_ !== i){var i=_eT_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _eN_=h[2],
         _eO_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length(0,b))},_eO_,_eN_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _eP_=h[2];
        iter$3
         (function(b)
           {var l=bucket_length(0,b);
            return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
          _eP_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$0=rest;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _eK_=h[2],
         _eL_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length_alive(0,b))},_eL_,_eK_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _eM_=h[2];
        iter$3
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
          _eM_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      function to_seq(tbl)
       {var tbl_data=tbl[2];
        function aux(i,buck,param)
         {var i$0=i,buck$0=buck;
          for(;;)
           {if(buck$0)
             {var
               next=buck$0[3],
               c=buck$0[2],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match)
               if(match$0)
                {var data=match$0[1],key=match[1];
                 return [0,
                         [0,key,data],
                         function(_eJ_){return aux(i$0,next,_eJ_)}]}
              var buck$0=next;
              continue}
            if(i$0 === tbl_data.length - 1)return 0;
            var
             buck$1=caml_check_bound(tbl_data,i$0)[i$0 + 1],
             i$1=i$0 + 1 | 0,
             i$0=i$1,
             buck$0=buck$1;
            continue}}
        var _eG_=0,_eH_=0;
        return function(_eI_){return aux(_eH_,_eG_,_eI_)}}
      function to_seq_keys(m)
       {var _eC_=to_seq(m);
        function _eD_(_eF_){return _eF_[1]}
        return function(_eE_){return map(_eD_,_eC_,_eE_)}}
      function to_seq_values(m)
       {var _ey_=to_seq(m);
        function _ez_(_eB_){return _eB_[2]}
        return function(_eA_){return map(_ez_,_ey_,_eA_)}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$0,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$4(param){return caml_call1(_I_[1],1)}
    function get_key(t){return caml_call2(_I_[3],t,0)}
    function get_key_copy(t){return caml_call2(_I_[4],t,0)}
    function set_key(t,k){return caml_call3(_I_[5],t,0,k)}
    function unset_key(t){return caml_call2(_I_[6],t,0)}
    function check_key(t){return caml_call2(_I_[7],t,0)}
    function blit_key(t1,t2){return caml_call5(_I_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_I_[9],t)}
    function get_data_copy(t){return caml_call1(_I_[10],t)}
    function set_data(t,d){return caml_call2(_I_[11],t,d)}
    function unset_data(t){return caml_call1(_I_[12],t)}
    function check_data(t){return caml_call1(_I_[13],t)}
    function blit_data(t1,t2){return caml_call2(_I_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$4(0);set_data(c,d);set_key(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$1,get_key,set_key_data,check_key])}
    function Make$1(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       of_seq=include[22],
       clean=include[23],
       stats_alive=include[24],
       _ex_=include[1];
      function create(sz){return caml_call2(_ex_,_cB_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_I_[1],2)}
    function get_key1(t){return caml_call2(_I_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_I_[4],t,0)}
    function set_key1(t,k){return caml_call3(_I_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_I_[6],t,0)}
    function check_key1(t){return caml_call2(_I_[7],t,0)}
    function get_key2(t){return caml_call2(_I_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_I_[4],t,1)}
    function set_key2(t,k){return caml_call3(_I_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_I_[6],t,1)}
    function check_key2(t){return caml_call2(_I_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_I_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_I_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_I_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_I_[9],t)}
    function get_data_copy$0(t){return caml_call1(_I_[10],t)}
    function set_data$0(t,d){return caml_call2(_I_[11],t,d)}
    function unset_data$0(t){return caml_call1(_I_[12],t)}
    function check_data$0(t){return caml_call1(_I_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_I_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$5(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _ew_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _ew_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0)
          {var k2$0=match$0[1],k1$0=match[1];
           if(caml_call2(H1[1],k1,k1$0))if(caml_call2(H2[1],k2,k2$0))return 0;
           return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0){var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _ev_=check_key1(c);return _ev_?check_key2(c):_ev_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$2(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_et_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_et_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       of_seq=include[22],
       clean=include[23],
       stats_alive=include[24],
       _eu_=include[1];
      function create(sz){return caml_call2(_eu_,_cC_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$6(n){return caml_call1(_I_[1],n)}
    function length$6(k){return caml_call1(_I_[2],k)}
    function get_key$0(t,n){return caml_call2(_I_[3],t,n)}
    function get_key_copy$0(t,n){return caml_call2(_I_[4],t,n)}
    function set_key$0(t,n,k){return caml_call3(_I_[5],t,n,k)}
    function unset_key$0(t,n){return caml_call2(_I_[6],t,n)}
    function check_key$0(t,n){return caml_call2(_I_[7],t,n)}
    function blit_key$0(t1,o1,t2,o2,l)
     {return caml_call5(_I_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_I_[9],t)}
    function get_data_copy$1(t){return caml_call1(_I_[10],t)}
    function set_data$1(t,d){return caml_call2(_I_[11],t,d)}
    function unset_data$1(t){return caml_call1(_I_[12],t)}
    function check_data$1(t){return caml_call1(_I_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_I_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$6(k.length - 1);
        set_data$1(c,d);
        var _er_=k.length - 1 - 1 | 0,_eq_=0;
        if(! (_er_ < 0))
         {var i=_eq_;
          for(;;)
           {set_key$0(c,i,caml_check_bound(k,i)[i + 1]);
            var _es_=i + 1 | 0;
            if(_er_ !== i){var i=_es_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_em_=k.length - 1 - 1 | 0,_el_=0;
        if(! (_em_ < 0))
         {var i=_el_;
          for(;;)
           {var _en_=h[1],_eo_=caml_check_bound(k,i)[i + 1];
            h[1] = (caml_call2(H[2],seed,_eo_) * 65599 | 0) + _en_ | 0;
            var _ep_=i + 1 | 0;
            if(_em_ !== i){var i=_ep_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$0(c,i);
            if(match)
             {var ki=match[1],_ek_=caml_check_bound(k,i)[i + 1];
              if(caml_call2(H[1],_ek_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$0(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$0(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[i + 1] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _ei_=k.length - 1 - 1 | 0,_eh_=0;
        if(! (_ei_ < 0))
         {var i=_eh_;
          for(;;)
           {set_key$0(c,i,caml_check_bound(k,i)[i + 1]);
            var _ej_=i + 1 | 0;
            if(_ei_ !== i){var i=_ej_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _ee_=i < 0?1:0;
          if(_ee_)
           var _ef_=_ee_;
          else
           {var _eg_=check_key$0(c,i);
            if(_eg_){var i$0=i - 1 | 0,i=i$0;continue}
            var _ef_=_eg_}
          return _ef_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$3(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       of_seq=include[22],
       clean=include[23],
       stats_alive=include[24],
       _ed_=include[1];
      function create(sz){return caml_call2(_ed_,_cD_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    var
     Stdlib_ephemeron=
      [0,
       [0,
        create$4,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$1,
        MakeSeeded$1],
       [0,
        create$5,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$2,
        MakeSeeded$2],
       [0,
        create$6,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$3,
        MakeSeeded$3],
       [0,
        function(_ec_)
         {return MakeSeeded$0
                  ([0,_ec_[3],_ec_[1],_ec_[2],_ec_[5],_ec_[4],_ec_[6],_ec_[7]])}]];
    caml_register_global(699,Stdlib_ephemeron,"Stdlib__ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$84))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$85))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _ea_=caml_ml_string_length(n) < 1?1:0,
       _eb_=_ea_ || (47 !== caml_string_get(n,0)?1:0);
      return _eb_}
    function is_implicit(n)
     {var _d7_=is_relative(n);
      if(_d7_)
       {var
         _d8_=caml_ml_string_length(n) < 2?1:0,
         _d9_=_d8_ || caml_string_notequal(sub$0(n,0,2),cst$87);
        if(_d9_)
         var
          _d__=caml_ml_string_length(n) < 3?1:0,
          _d$_=_d__ || caml_string_notequal(sub$0(n,0,3),cst$86);
        else
         var _d$_=_d9_}
      else
       var _d$_=_d7_;
      return _d$_}
    function check_suffix(name,suff)
     {var
       _d5_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _d6_=
        _d5_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_d5_;
      return _d6_}
    try
     {var _cL_=caml_sys_getenv(cst_TMPDIR),_cE_=_cL_}
    catch(_d4_)
     {_d4_ = caml_wrap_exception(_d4_);
      if(_d4_ !== Not_found)throw _d4_;
      var _cE_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$1(l + 20 | 0);
      add_char(b,39);
      var _d2_=l - 1 | 0,_d1_=0;
      if(! (_d2_ < 0))
       {var i=_d1_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _d3_=i + 1 | 0;
          if(_d2_ !== i){var i=_d3_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function basename(_d0_)
     {return generic_basename(is_dir_sep,current_dir_name,_d0_)}
    function dirname(_dZ_)
     {return generic_dirname(is_dir_sep,current_dir_name,_dZ_)}
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_dW_=47 === c?1:0;
      if(_dW_)
       var _dX_=_dW_;
      else
       var _dY_=92 === c?1:0,_dX_=_dY_ || (58 === c?1:0);
      return _dX_}
    function is_relative$0(n)
     {var
       _dQ_=caml_ml_string_length(n) < 1?1:0,
       _dR_=_dQ_ || (47 !== caml_string_get(n,0)?1:0);
      if(_dR_)
       {var
         _dS_=caml_ml_string_length(n) < 1?1:0,
         _dT_=_dS_ || (92 !== caml_string_get(n,0)?1:0);
        if(_dT_)
         var
          _dU_=caml_ml_string_length(n) < 2?1:0,
          _dV_=_dU_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _dV_=_dT_}
      else
       var _dV_=_dR_;
      return _dV_}
    function is_implicit$0(n)
     {var _dH_=is_relative$0(n);
      if(_dH_)
       {var
         _dI_=caml_ml_string_length(n) < 2?1:0,
         _dJ_=_dI_ || caml_string_notequal(sub$0(n,0,2),cst$91);
        if(_dJ_)
         {var
           _dK_=caml_ml_string_length(n) < 2?1:0,
           _dL_=_dK_ || caml_string_notequal(sub$0(n,0,2),cst$90);
          if(_dL_)
           {var
             _dM_=caml_ml_string_length(n) < 3?1:0,
             _dN_=_dM_ || caml_string_notequal(sub$0(n,0,3),cst$89);
            if(_dN_)
             var
              _dO_=caml_ml_string_length(n) < 3?1:0,
              _dP_=_dO_ || caml_string_notequal(sub$0(n,0,3),cst$88);
            else
             var _dP_=_dN_}
          else
           var _dP_=_dL_}
        else
         var _dP_=_dJ_}
      else
       var _dP_=_dH_;
      return _dP_}
    function check_suffix$0(name,suff)
     {var _dE_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_dE_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _dF_=lowercase_ascii$1(suff),
        _dG_=caml_string_equal(lowercase_ascii$1(s),_dF_);
      else
       var _dG_=_dE_;
      return _dG_}
    try
     {var _cK_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cK_}
    catch(_dD_)
     {_dD_ = caml_wrap_exception(_dD_);
      if(_dD_ !== Not_found)throw _dD_;
      var temp_dir_name=cst$92}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$1(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _dB_=1;
        if(! (n < 1))
         {var j=_dB_;
          for(;;)
           {add_char(b,92);
            var _dC_=j + 1 | 0;
            if(n !== j){var j=_dC_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _dz_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_dz_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_dz_,i$0])}
          if(92 === c)
           {var _dA_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_dA_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_dA_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _dy_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_dy_)}
            return caml_trampoline_return(loop$0,[0,_dy_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function drive_and_path(s)
     {var _du_=2 <= caml_ml_string_length(s)?1:0;
      if(_du_)
       var
        param=caml_string_get(s,0),
        switch$0=91 <= param?25 < (param - 97 | 0) >>> 0?0:1:65 <= param?1:0,
        _dv_=switch$0?1:0,
        _dw_=_dv_?58 === caml_string_get(s,1)?1:0:_dv_;
      else
       var _dw_=_du_;
      if(_dw_)
       {var _dx_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_dx_]}
      return [0,cst$93,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return _g_(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    function basename$1(_dt_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_dt_)}
    function dirname$1(_ds_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_ds_)}
    if(caml_string_notequal(os_type,cst_Cygwin))
     if(caml_string_notequal(os_type,cst_Win32))
      var
       current_dir_name$2=current_dir_name,
       parent_dir_name$2=parent_dir_name,
       dir_sep$2=dir_sep,
       is_dir_sep$1=is_dir_sep,
       is_relative$1=is_relative,
       is_implicit$1=is_implicit,
       check_suffix$1=check_suffix,
       temp_dir_name$0=_cE_,
       quote$1=quote,
       basename$2=basename,
       dirname$2=dirname,
       switch$0=1;
     else
      var
       _cJ_=
        [0,
         current_dir_name$0,
         parent_dir_name$0,
         dir_sep$0,
         is_dir_sep$0,
         is_relative$0,
         is_implicit$0,
         check_suffix$0,
         temp_dir_name,
         quote$0,
         basename$0,
         dirname$0],
       switch$0=0;
    else
     var
      _cJ_=
       [0,
        current_dir_name$1,
        parent_dir_name$1,
        dir_sep$1,
        is_dir_sep$0,
        is_relative$0,
        is_implicit$0,
        check_suffix$0,
        _cE_,
        quote,
        basename$1,
        dirname$1],
      switch$0=0;
    if(! switch$0)
     var
      current_dir_name$2=_cJ_[1],
      parent_dir_name$2=_cJ_[2],
      dir_sep$2=_cJ_[3],
      is_dir_sep$1=is_dir_sep$0,
      is_relative$1=is_relative$0,
      is_implicit$1=is_implicit$0,
      check_suffix$1=check_suffix$0,
      temp_dir_name$0=_cJ_[8],
      quote$1=_cJ_[9],
      basename$2=_cJ_[10],
      dirname$2=_cJ_[11];
    function concat$2(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l)
       if(! is_dir_sep$1(dirname,l - 1 | 0))
        return _g_(dirname,_g_(dir_sep$2,filename));
      return _g_(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1)
         if(! is_dir_sep$1(name,i$1))
          {if(46 === caml_string_get(name,i$1))
            {var i$2=i$1 - 1 | 0,i=i$2;
             for(;;)
              {if(0 <= i)
                if(! is_dir_sep$1(name,i))
                 {if(46 === caml_string_get(name,i))
                   {var i$0=i - 1 | 0,i=i$0;continue}
                  return caml_ml_string_length(name) - i$1 | 0}
               return 0}}
           var i$3=i$1 - 1 | 0,i$1=i$3;
           continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$94:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_dr_){return caml_call1(_b6_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _dp_=caml_obj_tag(prng$0),
       _dq_=
        250 === _dp_?prng$0[1]:246 === _dp_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b6_[4],_dq_) & 16777215;
      return concat$2(temp_dir,caml_call3(sprintf(_cF_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cG_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1e3 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_dn_,_dm_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cH_;
      if(_dn_)var sth$0=_dn_[1],perms=sth$0;else var perms=384;
      if(_dm_)
       var sth$1=_dm_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _do_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _do_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1e3 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Stdlib_filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$2,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1];
    caml_register_global(700,Stdlib_filename,"Stdlib__filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$3(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$2,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0)return i;
      if(i == 0)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1 + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1 + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0)if(x[2] == 0)return _cI_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1 + Math.sqrt(1 + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1 + q$0 * q$0)));
      if(0 <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0 <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _dl_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_dl_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Stdlib_complex=
      [0,
       zero$2,
       one$2,
       i,
       neg,
       conj,
       add$1,
       sub$3,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(701,Stdlib_complex,"Stdlib__complex");
    var
     Stdlib_arrayLabels=
      [0,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list,
       of_list,
       iter$3,
       map$3,
       iteri$2,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       exists$0,
       for_all$0,
       mem$0,
       memq$0,
       make_float,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$2,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(702,Stdlib_arrayLabels,"Stdlib__arrayLabels");
    var
     Stdlib_listLabels=
      [0,
       length,
       hd,
       compare_lengths,
       compare_length_with,
       cons,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$0,
       iteri,
       map$0,
       mapi,
       rev_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
    caml_register_global(703,Stdlib_listLabels,"Stdlib__listLabels");
    var
     Stdlib_bytesLabels=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$1,
       iteri$0,
       map$1,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$1,
       equal$1,
       to_seq$0,
       to_seqi,
       of_seq$0,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(704,Stdlib_bytesLabels,"Stdlib__bytesLabels");
    var
     Stdlib_stringLabels=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$2,
       iteri$1,
       map$2,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$2,
       equal$2,
       split_on_char,
       to_seq$1,
       to_seqi$0,
       of_seq$1];
    caml_register_global(705,Stdlib_stringLabels,"Stdlib__stringLabels");
    var Stdlib_moreLabels=[0,Stdlib_hashtbl,Stdlib_map,Stdlib_set];
    caml_register_global(706,Stdlib_moreLabels,"Stdlib__moreLabels");
    var Stdlib_stdLabels=[0,0,0,0,0];
    caml_register_global(707,Stdlib_stdLabels,"Stdlib__stdLabels");
    var enabled=caml_spacetime_enabled(0);
    function if_spacetime_enabled(f){return enabled?caml_call1(f,0):0}
    function create$7(path)
     {if(caml_spacetime_enabled(0))
       {var channel=open_out(path),t=[0,channel,0];
        caml_spacetime_only_works_for_native_code(t[1]);
        return t}
      return [0,stdout,1]}
    function save_event(time,t,event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code
                         (time,t[1],event_name)})}
    function save_and_close(time,t)
     {return if_spacetime_enabled
              (function(param)
                {if(t[2])failwith(cst_Series_is_closed);
                 caml_spacetime_only_works_for_native_code(time,t[1]);
                 close_out(t[1]);
                 t[2] = 1;
                 return 0})}
    var Series=[0,create$7,save_event,save_and_close];
    function take$0(time,param)
     {var channel=param[1],closed=param[2];
      return if_spacetime_enabled
              (function(param)
                {if(closed)failwith(cst_Series_is_closed$0);
                 runtime.caml_gc_minor(0);
                 return caml_spacetime_only_works_for_native_code
                         (time,channel)})}
    var Snapshot=[0,take$0];
    function save_event_for_automatic_snapshots(event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code(event_name)})}
    var
     Stdlib_spacetime=
      [0,enabled,Series,Snapshot,save_event_for_automatic_snapshots];
    caml_register_global(708,Stdlib_spacetime,"Stdlib__spacetime");
    var
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32$1=6,
     int64$1=7,
     int$2=8,
     nativeint$1=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return 4;
        case 9:return 4;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_di_=n - 1 | 0,_dh_=0;
      if(! (_di_ < 0))
       {var i=_dh_;
        for(;;)
         {var _dj_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[i + 1] = _dj_;
          var _dk_=i + 1 | 0;
          if(_di_ !== i){var i=_dk_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var
       _dc_=dims(arr),
       _dd_=1,
       _de_=
        fold_left$1(function(_dg_,_df_){return caml_mul(_dg_,_df_)},_dd_,_dc_);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_de_)}
    var Genarray=[0,dims,size_in_bytes];
    function create$8(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set(arr)
     {var _da_=[0];
      return function(_db_){return runtime.caml_ba_set_generic(arr,_da_,_db_)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create$8(kind,layout);caml_call1(set(a),v);return a}
    function create$9(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _c$_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c$_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return 0 === match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function of_array(kind,layout,data)
     {var
       ba=create$9(kind,layout,data.length - 1),
       ofs=0 === layout?0:1,
       _c9_=data.length - 1 - 1 | 0,
       _c8_=0;
      if(! (_c9_ < 0))
       {var i=_c8_;
        for(;;)
         {runtime.caml_ba_set_1
           (ba,i + ofs | 0,caml_check_bound(data,i)[i + 1]);
          var _c__=i + 1 | 0;
          if(_c9_ !== i){var i=_c__;continue}
          break}}
      return ba}
    function create$10(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _c6_=caml_ba_dim_2(arr),_c7_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c7_),_c6_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$10(kind,layout,dim1,dim2),
       ofs=0 === layout?0:1,
       _c1_=dim1 - 1 | 0,
       _c0_=0;
      if(! (_c1_ < 0))
       {var i=_c0_;
        for(;;)
         {var row=caml_check_bound(data,i)[i + 1];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array2_of_array_non_rectangular_data);
          var _c3_=dim2 - 1 | 0,_c2_=0;
          if(! (_c3_ < 0))
           {var j=_c2_;
            for(;;)
             {runtime.caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[j + 1]);
              var _c5_=j + 1 | 0;
              if(_c3_ !== j){var j=_c5_;continue}
              break}}
          var _c4_=i + 1 | 0;
          if(_c1_ !== i){var i=_c4_;continue}
          break}}
      return ba}
    function create$11(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _cX_=runtime.caml_ba_dim_3(arr),
       _cY_=caml_ba_dim_2(arr),
       _cZ_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_cZ_),_cY_),
               _cX_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$11(kind,layout,dim1,dim2,dim3),
       ofs=0 === layout?0:1,
       _cP_=dim1 - 1 | 0,
       _cO_=0;
      if(! (_cP_ < 0))
       {var i=_cO_;
        for(;;)
         {var row=caml_check_bound(data,i)[i + 1];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array3_of_array_non_cubic_data);
          var _cR_=dim2 - 1 | 0,_cQ_=0;
          if(! (_cR_ < 0))
           {var j=_cQ_;
            for(;;)
             {var col=caml_check_bound(row,j)[j + 1];
              if(col.length - 1 !== dim3)
               invalid_arg(cst_Bigarray_Array3_of_array_non_cubic_data$0);
              var _cU_=dim3 - 1 | 0,_cT_=0;
              if(! (_cU_ < 0))
               {var k=_cT_;
                for(;;)
                 {runtime.caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[k + 1]);
                  var _cW_=k + 1 | 0;
                  if(_cU_ !== k){var k=_cW_;continue}
                  break}}
              var _cV_=j + 1 | 0;
              if(_cR_ !== j){var j=_cV_;continue}
              break}}
          var _cS_=i + 1 | 0;
          if(_cP_ !== i){var i=_cS_;continue}
          break}}
      return ba}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array0_of_genarray)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array1_of_genarray)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array2_of_genarray)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array3_of_genarray)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Stdlib_bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$2,
       int32$1,
       int64$1,
       nativeint$1,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       Genarray,
       [0,create$8,caml_ba_change_layout,size_in_bytes$0,get,set,of_value],
       [0,create$9,caml_ba_change_layout,size_in_bytes$1,slice,of_array],
       [0,
        create$10,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$11,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    caml_register_global(709,Stdlib_bigarray,"Stdlib__bigarray");
    return}
  (function(){return this}()));


//# 1 "../.js/js_of_ocaml/js_of_ocaml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_from_string=runtime.caml_js_from_string,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_to_byte_string=runtime.caml_js_to_byte_string,
     caml_js_to_string=runtime.caml_js_to_string,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_new_string("parseFloat"),
     cst_parseInt=caml_new_string("parseInt"),
     cst_Js_Error=caml_new_string("Js.Error"),
     cst_jsError=caml_new_string("jsError"),
     cst_can_t_retrieve_file_name_not_implemented=
      caml_new_string("can't retrieve file name: not implemented"),
     cst_endings=caml_new_string("endings"),
     cst_type=caml_new_string("type"),
     cst_loadstart=caml_new_string("loadstart"),
     cst_progress=caml_new_string("progress"),
     cst_abort=caml_new_string("abort"),
     cst_error=caml_new_string("error"),
     cst_load=caml_new_string("load"),
     cst_loadend=caml_new_string("loadend"),
     cst_a$1=caml_new_string("a"),
     cst_area$1=caml_new_string("area"),
     cst_audio$1=caml_new_string("audio"),
     cst_base$1=caml_new_string("base"),
     cst_blockquote$1=caml_new_string("blockquote"),
     cst_body$1=caml_new_string("body"),
     cst_br$1=caml_new_string("br"),
     cst_button$1=caml_new_string("button"),
     cst_canvas$1=caml_new_string("canvas"),
     cst_caption$1=caml_new_string("caption"),
     cst_col$1=caml_new_string("col"),
     cst_colgroup$1=caml_new_string("colgroup"),
     cst_del$1=caml_new_string("del"),
     cst_div$1=caml_new_string("div"),
     cst_dl$1=caml_new_string("dl"),
     cst_embed$1=caml_new_string("embed"),
     cst_fieldset$1=caml_new_string("fieldset"),
     cst_form$1=caml_new_string("form"),
     cst_frame$1=caml_new_string("frame"),
     cst_frameset$1=caml_new_string("frameset"),
     cst_h1$1=caml_new_string("h1"),
     cst_h2$1=caml_new_string("h2"),
     cst_h3$1=caml_new_string("h3"),
     cst_h4$1=caml_new_string("h4"),
     cst_h5$1=caml_new_string("h5"),
     cst_h6$1=caml_new_string("h6"),
     cst_head$1=caml_new_string("head"),
     cst_hr$1=caml_new_string("hr"),
     cst_html$1=caml_new_string("html"),
     cst_iframe$1=caml_new_string("iframe"),
     cst_img$1=caml_new_string("img"),
     cst_input$2=caml_new_string("input"),
     cst_ins$1=caml_new_string("ins"),
     cst_label$1=caml_new_string("label"),
     cst_legend$1=caml_new_string("legend"),
     cst_li$1=caml_new_string("li"),
     cst_link$1=caml_new_string("link"),
     cst_map$1=caml_new_string("map"),
     cst_meta$1=caml_new_string("meta"),
     cst_object$1=caml_new_string("object"),
     cst_ol$1=caml_new_string("ol"),
     cst_optgroup$1=caml_new_string("optgroup"),
     cst_option$1=caml_new_string("option"),
     cst_p$1=caml_new_string("p"),
     cst_param$1=caml_new_string("param"),
     cst_pre$1=caml_new_string("pre"),
     cst_q$1=caml_new_string("q"),
     cst_script$1=caml_new_string("script"),
     cst_select$2=caml_new_string("select"),
     cst_style$1=caml_new_string("style"),
     cst_table$1=caml_new_string("table"),
     cst_tbody$1=caml_new_string("tbody"),
     cst_td$1=caml_new_string("td"),
     cst_textarea$1=caml_new_string("textarea"),
     cst_tfoot$1=caml_new_string("tfoot"),
     cst_th$1=caml_new_string("th"),
     cst_thead$1=caml_new_string("thead"),
     cst_title$1=caml_new_string("title"),
     cst_tr$1=caml_new_string("tr"),
     cst_ul$1=caml_new_string("ul"),
     cst_video$1=caml_new_string("video"),
     cst_KeyH=caml_new_string("KeyH"),
     cst_Digit6=caml_new_string("Digit6"),
     cst_BrowserRefresh=caml_new_string("BrowserRefresh"),
     cst_Backslash=caml_new_string("Backslash"),
     cst_AltLeft=caml_new_string("AltLeft"),
     cst_AltRight=caml_new_string("AltRight"),
     cst_ArrowDown=caml_new_string("ArrowDown"),
     cst_ArrowLeft=caml_new_string("ArrowLeft"),
     cst_ArrowRight=caml_new_string("ArrowRight"),
     cst_ArrowUp=caml_new_string("ArrowUp"),
     cst_Backquote=caml_new_string("Backquote"),
     cst_Backspace=caml_new_string("Backspace"),
     cst_BracketLeft=caml_new_string("BracketLeft"),
     cst_BracketRight=caml_new_string("BracketRight"),
     cst_BrowserBack=caml_new_string("BrowserBack"),
     cst_BrowserFavorites=caml_new_string("BrowserFavorites"),
     cst_BrowserForward=caml_new_string("BrowserForward"),
     cst_BrowserHome=caml_new_string("BrowserHome"),
     cst_Delete=caml_new_string("Delete"),
     cst_BrowserSearch=caml_new_string("BrowserSearch"),
     cst_BrowserStop=caml_new_string("BrowserStop"),
     cst_CapsLock=caml_new_string("CapsLock"),
     cst_Comma=caml_new_string("Comma"),
     cst_ContextMenu=caml_new_string("ContextMenu"),
     cst_ControlLeft=caml_new_string("ControlLeft"),
     cst_ControlRight=caml_new_string("ControlRight"),
     cst_Digit0=caml_new_string("Digit0"),
     cst_Digit1=caml_new_string("Digit1"),
     cst_Digit2=caml_new_string("Digit2"),
     cst_Digit3=caml_new_string("Digit3"),
     cst_Digit4=caml_new_string("Digit4"),
     cst_Digit5=caml_new_string("Digit5"),
     cst_F6=caml_new_string("F6"),
     cst_F1=caml_new_string("F1"),
     cst_Digit7=caml_new_string("Digit7"),
     cst_Digit8=caml_new_string("Digit8"),
     cst_Digit9=caml_new_string("Digit9"),
     cst_End=caml_new_string("End"),
     cst_Enter=caml_new_string("Enter"),
     cst_Equal=caml_new_string("Equal"),
     cst_Escape=caml_new_string("Escape"),
     cst_F10=caml_new_string("F10"),
     cst_F11=caml_new_string("F11"),
     cst_F12=caml_new_string("F12"),
     cst_F2=caml_new_string("F2"),
     cst_F3=caml_new_string("F3"),
     cst_F4=caml_new_string("F4"),
     cst_F5=caml_new_string("F5"),
     cst_KeyA=caml_new_string("KeyA"),
     cst_F7=caml_new_string("F7"),
     cst_F8=caml_new_string("F8"),
     cst_F9=caml_new_string("F9"),
     cst_Home=caml_new_string("Home"),
     cst_Insert=caml_new_string("Insert"),
     cst_IntlBackslash=caml_new_string("IntlBackslash"),
     cst_IntlYen=caml_new_string("IntlYen"),
     cst_KeyB=caml_new_string("KeyB"),
     cst_KeyC=caml_new_string("KeyC"),
     cst_KeyD=caml_new_string("KeyD"),
     cst_KeyE=caml_new_string("KeyE"),
     cst_KeyF=caml_new_string("KeyF"),
     cst_KeyG=caml_new_string("KeyG"),
     cst_Numpad4=caml_new_string("Numpad4"),
     cst_KeyX=caml_new_string("KeyX"),
     cst_KeyP=caml_new_string("KeyP"),
     cst_KeyI=caml_new_string("KeyI"),
     cst_KeyJ=caml_new_string("KeyJ"),
     cst_KeyK=caml_new_string("KeyK"),
     cst_KeyL=caml_new_string("KeyL"),
     cst_KeyM=caml_new_string("KeyM"),
     cst_KeyN=caml_new_string("KeyN"),
     cst_KeyO=caml_new_string("KeyO"),
     cst_KeyQ=caml_new_string("KeyQ"),
     cst_KeyR=caml_new_string("KeyR"),
     cst_KeyS=caml_new_string("KeyS"),
     cst_KeyT=caml_new_string("KeyT"),
     cst_KeyU=caml_new_string("KeyU"),
     cst_KeyV=caml_new_string("KeyV"),
     cst_KeyW=caml_new_string("KeyW"),
     cst_MetaRight=caml_new_string("MetaRight"),
     cst_KeyY=caml_new_string("KeyY"),
     cst_KeyZ=caml_new_string("KeyZ"),
     cst_MediaPlayPause=caml_new_string("MediaPlayPause"),
     cst_MediaStop=caml_new_string("MediaStop"),
     cst_MediaTrackNext=caml_new_string("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_new_string("MediaTrackPrevious"),
     cst_MetaLeft=caml_new_string("MetaLeft"),
     cst_Minus=caml_new_string("Minus"),
     cst_NumLock=caml_new_string("NumLock"),
     cst_Numpad0=caml_new_string("Numpad0"),
     cst_Numpad1=caml_new_string("Numpad1"),
     cst_Numpad2=caml_new_string("Numpad2"),
     cst_Numpad3=caml_new_string("Numpad3"),
     cst_PageUp=caml_new_string("PageUp"),
     cst_NumpadDivide=caml_new_string("NumpadDivide"),
     cst_Numpad5=caml_new_string("Numpad5"),
     cst_Numpad6=caml_new_string("Numpad6"),
     cst_Numpad7=caml_new_string("Numpad7"),
     cst_Numpad8=caml_new_string("Numpad8"),
     cst_Numpad9=caml_new_string("Numpad9"),
     cst_NumpadAdd=caml_new_string("NumpadAdd"),
     cst_NumpadDecimal=caml_new_string("NumpadDecimal"),
     cst_NumpadEnter=caml_new_string("NumpadEnter"),
     cst_NumpadEqual=caml_new_string("NumpadEqual"),
     cst_NumpadMultiply=caml_new_string("NumpadMultiply"),
     cst_NumpadSubtract=caml_new_string("NumpadSubtract"),
     cst_OSLeft=caml_new_string("OSLeft"),
     cst_OSRight=caml_new_string("OSRight"),
     cst_PageDown=caml_new_string("PageDown"),
     cst_ShiftRight=caml_new_string("ShiftRight"),
     cst_Pause=caml_new_string("Pause"),
     cst_Period=caml_new_string("Period"),
     cst_PrintScreen=caml_new_string("PrintScreen"),
     cst_Quote=caml_new_string("Quote"),
     cst_ScrollLock=caml_new_string("ScrollLock"),
     cst_Semicolon=caml_new_string("Semicolon"),
     cst_ShiftLeft=caml_new_string("ShiftLeft"),
     cst_Slash=caml_new_string("Slash"),
     cst_Space=caml_new_string("Space"),
     cst_Tab=caml_new_string("Tab"),
     cst_VolumeDown=caml_new_string("VolumeDown"),
     cst_VolumeMute=caml_new_string("VolumeMute"),
     cst_VolumeUp=caml_new_string("VolumeUp"),
     cst_mouseout$0=caml_new_string("mouseout"),
     cst_mouseover$0=caml_new_string("mouseover"),
     cst_video$0=caml_new_string("video"),
     cst_audio$0=caml_new_string("audio"),
     cst_ul$0=caml_new_string("ul"),
     cst_tr$0=caml_new_string("tr"),
     cst_title$0=caml_new_string("title"),
     cst_thead$0=caml_new_string("thead"),
     cst_th$0=caml_new_string("th"),
     cst_tfoot$0=caml_new_string("tfoot"),
     cst_textarea$0=caml_new_string("textarea"),
     cst_td$0=caml_new_string("td"),
     cst_tbody$0=caml_new_string("tbody"),
     cst_table$0=caml_new_string("table"),
     cst_style$0=caml_new_string("style"),
     cst_select$1=caml_new_string("select"),
     cst_script$0=caml_new_string("script"),
     cst_q$0=caml_new_string("q"),
     cst_pre$0=caml_new_string("pre"),
     cst_param$0=caml_new_string("param"),
     cst_p$0=caml_new_string("p"),
     cst_option$0=caml_new_string("option"),
     cst_optgroup$0=caml_new_string("optgroup"),
     cst_ol$0=caml_new_string("ol"),
     cst_object$0=caml_new_string("object"),
     cst_meta$0=caml_new_string("meta"),
     cst_map$0=caml_new_string("map"),
     cst_link$0=caml_new_string("link"),
     cst_li$0=caml_new_string("li"),
     cst_legend$0=caml_new_string("legend"),
     cst_label$0=caml_new_string("label"),
     cst_ins$0=caml_new_string("ins"),
     cst_input$1=caml_new_string("input"),
     cst_img$0=caml_new_string("img"),
     cst_iframe$0=caml_new_string("iframe"),
     cst_html$0=caml_new_string("html"),
     cst_hr$0=caml_new_string("hr"),
     cst_head$0=caml_new_string("head"),
     cst_h6$0=caml_new_string("h6"),
     cst_h5$0=caml_new_string("h5"),
     cst_h4$0=caml_new_string("h4"),
     cst_h3$0=caml_new_string("h3"),
     cst_h2$0=caml_new_string("h2"),
     cst_h1$0=caml_new_string("h1"),
     cst_frame$0=caml_new_string("frame"),
     cst_frameset$0=caml_new_string("frameset"),
     cst_form$0=caml_new_string("form"),
     cst_embed$0=caml_new_string("embed"),
     cst_fieldset$0=caml_new_string("fieldset"),
     cst_dl$0=caml_new_string("dl"),
     cst_div$0=caml_new_string("div"),
     cst_del$0=caml_new_string("del"),
     cst_colgroup$0=caml_new_string("colgroup"),
     cst_col$0=caml_new_string("col"),
     cst_caption$0=caml_new_string("caption"),
     cst_canvas$0=caml_new_string("canvas"),
     cst_button$0=caml_new_string("button"),
     cst_br$0=caml_new_string("br"),
     cst_body$0=caml_new_string("body"),
     cst_blockquote$0=caml_new_string("blockquote"),
     cst_base$0=caml_new_string("base"),
     cst_area$0=caml_new_string("area"),
     cst_a$0=caml_new_string("a"),
     cst_canvas=caml_new_string("canvas"),
     cst_video=caml_new_string("video"),
     cst_audio=caml_new_string("audio"),
     cst_iframe=caml_new_string("iframe"),
     cst_frame=caml_new_string("frame"),
     cst_frameset=caml_new_string("frameset"),
     cst_address=caml_new_string("address"),
     cst_noscript=caml_new_string("noscript"),
     cst_dt=caml_new_string("dt"),
     cst_dd=caml_new_string("dd"),
     cst_abbr=caml_new_string("abbr"),
     cst_var=caml_new_string("var"),
     cst_kbd=caml_new_string("kbd"),
     cst_samp=caml_new_string("samp"),
     cst_code=caml_new_string("code"),
     cst_dfn=caml_new_string("dfn"),
     cst_cite=caml_new_string("cite"),
     cst_strong=caml_new_string("strong"),
     cst_em=caml_new_string("em"),
     cst_small=caml_new_string("small"),
     cst_big=caml_new_string("big"),
     cst_b=caml_new_string("b"),
     cst_i=caml_new_string("i"),
     cst_tt=caml_new_string("tt"),
     cst_span=caml_new_string("span"),
     cst_sup=caml_new_string("sup"),
     cst_sub=caml_new_string("sub"),
     cst_td=caml_new_string("td"),
     cst_th=caml_new_string("th"),
     cst_tr=caml_new_string("tr"),
     cst_tbody=caml_new_string("tbody"),
     cst_tfoot=caml_new_string("tfoot"),
     cst_thead=caml_new_string("thead"),
     cst_colgroup=caml_new_string("colgroup"),
     cst_col=caml_new_string("col"),
     cst_caption=caml_new_string("caption"),
     cst_table=caml_new_string("table"),
     cst_script=caml_new_string("script"),
     cst_area=caml_new_string("area"),
     cst_map=caml_new_string("map"),
     cst_param=caml_new_string("param"),
     cst_object=caml_new_string("object"),
     cst_img=caml_new_string("img"),
     cst_a=caml_new_string("a"),
     cst_del=caml_new_string("del"),
     cst_ins=caml_new_string("ins"),
     cst_hr=caml_new_string("hr"),
     cst_br=caml_new_string("br"),
     cst_pre=caml_new_string("pre"),
     cst_blockquote=caml_new_string("blockquote"),
     cst_q=caml_new_string("q"),
     cst_h6=caml_new_string("h6"),
     cst_h5=caml_new_string("h5"),
     cst_h4=caml_new_string("h4"),
     cst_h3=caml_new_string("h3"),
     cst_h2=caml_new_string("h2"),
     cst_h1=caml_new_string("h1"),
     cst_p=caml_new_string("p"),
     cst_embed=caml_new_string("embed"),
     cst_div=caml_new_string("div"),
     cst_li=caml_new_string("li"),
     cst_dl=caml_new_string("dl"),
     cst_ol=caml_new_string("ol"),
     cst_ul=caml_new_string("ul"),
     cst_legend=caml_new_string("legend"),
     cst_fieldset=caml_new_string("fieldset"),
     cst_label=caml_new_string("label"),
     cst_button=caml_new_string("button"),
     cst_textarea=caml_new_string("textarea"),
     cst_input$0=caml_new_string("input"),
     cst_select$0=caml_new_string("select"),
     cst_option=caml_new_string("option"),
     cst_optgroup=caml_new_string("optgroup"),
     cst_form=caml_new_string("form"),
     cst_body=caml_new_string("body"),
     cst_style=caml_new_string("style"),
     cst_base=caml_new_string("base"),
     cst_meta=caml_new_string("meta"),
     cst_title=caml_new_string("title"),
     cst_link=caml_new_string("link"),
     cst_head=caml_new_string("head"),
     cst_html=caml_new_string("html"),
     cst_click=caml_new_string("click"),
     cst_dblclick=caml_new_string("dblclick"),
     cst_mousedown=caml_new_string("mousedown"),
     cst_mouseup=caml_new_string("mouseup"),
     cst_mouseover=caml_new_string("mouseover"),
     cst_mousemove=caml_new_string("mousemove"),
     cst_mouseout=caml_new_string("mouseout"),
     cst_keypress=caml_new_string("keypress"),
     cst_keydown=caml_new_string("keydown"),
     cst_keyup=caml_new_string("keyup"),
     cst_mousewheel=caml_new_string("mousewheel"),
     cst_DOMMouseScroll=caml_new_string("DOMMouseScroll"),
     cst_touchstart=caml_new_string("touchstart"),
     cst_touchmove=caml_new_string("touchmove"),
     cst_touchend=caml_new_string("touchend"),
     cst_touchcancel=caml_new_string("touchcancel"),
     cst_dragstart=caml_new_string("dragstart"),
     cst_dragend=caml_new_string("dragend"),
     cst_dragenter=caml_new_string("dragenter"),
     cst_dragover=caml_new_string("dragover"),
     cst_dragleave=caml_new_string("dragleave"),
     cst_drag=caml_new_string("drag"),
     cst_drop=caml_new_string("drop"),
     cst_hashchange=caml_new_string("hashchange"),
     cst_change=caml_new_string("change"),
     cst_input=caml_new_string("input"),
     cst_timeupdate=caml_new_string("timeupdate"),
     cst_submit=caml_new_string("submit"),
     cst_scroll=caml_new_string("scroll"),
     cst_focus=caml_new_string("focus"),
     cst_blur=caml_new_string("blur"),
     cst_load$0=caml_new_string("load"),
     cst_unload=caml_new_string("unload"),
     cst_beforeunload=caml_new_string("beforeunload"),
     cst_resize=caml_new_string("resize"),
     cst_orientationchange=caml_new_string("orientationchange"),
     cst_popstate=caml_new_string("popstate"),
     cst_error$0=caml_new_string("error"),
     cst_abort$0=caml_new_string("abort"),
     cst_select=caml_new_string("select"),
     cst_online=caml_new_string("online"),
     cst_offline=caml_new_string("offline"),
     cst_checking=caml_new_string("checking"),
     cst_noupdate=caml_new_string("noupdate"),
     cst_downloading=caml_new_string("downloading"),
     cst_progress$0=caml_new_string("progress"),
     cst_updateready=caml_new_string("updateready"),
     cst_cached=caml_new_string("cached"),
     cst_obsolete=caml_new_string("obsolete"),
     cst_DOMContentLoaded=caml_new_string("DOMContentLoaded"),
     cst_animationstart=caml_new_string("animationstart"),
     cst_animationend=caml_new_string("animationend"),
     cst_animationiteration=caml_new_string("animationiteration"),
     cst_animationcancel=caml_new_string("animationcancel"),
     cst_canplay=caml_new_string("canplay"),
     cst_canplaythrough=caml_new_string("canplaythrough"),
     cst_durationchange=caml_new_string("durationchange"),
     cst_emptied=caml_new_string("emptied"),
     cst_ended=caml_new_string("ended"),
     cst_loadeddata=caml_new_string("loadeddata"),
     cst_loadedmetadata=caml_new_string("loadedmetadata"),
     cst_loadstart$0=caml_new_string("loadstart"),
     cst_pause=caml_new_string("pause"),
     cst_play=caml_new_string("play"),
     cst_playing=caml_new_string("playing"),
     cst_ratechange=caml_new_string("ratechange"),
     cst_seeked=caml_new_string("seeked"),
     cst_seeking=caml_new_string("seeking"),
     cst_stalled=caml_new_string("stalled"),
     cst_suspend=caml_new_string("suspend"),
     cst_volumechange=caml_new_string("volumechange"),
     cst_waiting=caml_new_string("waiting"),
     cst_Dom_html_Canvas_not_available=
      caml_new_string("Dom_html.Canvas_not_available"),
     cst_checkbox=caml_new_string("checkbox"),
     cst_file=caml_new_string("file"),
     cst_password=caml_new_string("password"),
     cst_radio=caml_new_string("radio"),
     cst_reset=caml_new_string("reset"),
     cst_submit$0=caml_new_string("submit"),
     cst_text=caml_new_string("text"),
     cst_readystatechange=caml_new_string("readystatechange"),
     cst_loadstart$1=caml_new_string("loadstart"),
     cst_progress$1=caml_new_string("progress"),
     cst_abort$1=caml_new_string("abort"),
     cst_error$1=caml_new_string("error"),
     cst_load$1=caml_new_string("load"),
     cst_timeout=caml_new_string("timeout"),
     cst_loadend$0=caml_new_string("loadend"),
     cst_Worker_onmessage_is_undefined$0=
      caml_new_string("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefined=
      caml_new_string("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_undefined=
      caml_new_string("Worker.import_scripts is undefined"),
     cst_webglcontextlost=caml_new_string("webglcontextlost"),
     cst_webglcontextrestored=caml_new_string("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_new_string("webglcontextcreationerror"),
     cst_g=caml_new_string("g"),
     cst=caml_new_string("[\\][()\\\\|+*.?{}^$]"),
     cst$37=caml_new_string(""),
     cst$13=caml_new_string(""),
     cst$21=caml_new_string(""),
     cst$14=caml_new_string("#"),
     cst$15=caml_new_string("?"),
     cst$20=caml_new_string(""),
     cst$16=caml_new_string("/"),
     cst$17=caml_new_string("/"),
     cst$19=caml_new_string(":"),
     cst$18=caml_new_string(""),
     cst_http$1=caml_new_string("http://"),
     cst$22=caml_new_string(""),
     cst$30=caml_new_string(""),
     cst$23=caml_new_string("#"),
     cst$24=caml_new_string("?"),
     cst$29=caml_new_string(""),
     cst$25=caml_new_string("/"),
     cst$26=caml_new_string("/"),
     cst$28=caml_new_string(":"),
     cst$27=caml_new_string(""),
     cst_https$1=caml_new_string("https://"),
     cst$31=caml_new_string(""),
     cst$36=caml_new_string(""),
     cst$32=caml_new_string("#"),
     cst$33=caml_new_string("?"),
     cst$35=caml_new_string(""),
     cst$34=caml_new_string("/"),
     cst_file$2=caml_new_string("file://"),
     cst$12=caml_new_string(""),
     cst$11=caml_new_string(""),
     cst$10=caml_new_string(""),
     cst$9=caml_new_string(""),
     cst$8=caml_new_string(""),
     cst$7=caml_new_string(""),
     cst$6=caml_new_string(""),
     cst$4=caml_new_string("="),
     cst$5=caml_new_string("&"),
     cst$2=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_file$0=caml_new_string("file"),
     cst_file$1=caml_new_string("file:"),
     cst_http=caml_new_string("http"),
     cst_http$0=caml_new_string("http:"),
     cst_https=caml_new_string("https"),
     cst_https$0=caml_new_string("https:"),
     cst$1=caml_new_string(" "),
     cst_2B=caml_new_string("%2B"),
     cst_Url_Local_exn=caml_new_string("Url.Local_exn"),
     cst$0=caml_new_string("+"),
     cst_Url_Not_an_http_protocol=caml_new_string("Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0_9a_zA_Z_0_9A_Fa_f_0_9=
      caml_new_string
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_new_string
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     js_of_ocaml_version=caml_new_string("3.2.0"),
     git_version=caml_new_string(""),
     cst_Jstable_keys=caml_new_string("Jstable.keys"),
     dummy_string=caml_new_string(""),
     cst_is_not_a_valid_length$0=caml_new_string(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_new_string("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_new_string("length conversion error: "),
     cst_deg$0=caml_new_string("deg"),
     cst_grad$0=caml_new_string("grad"),
     cst_rad$0=caml_new_string("rad"),
     cst_turns$0=caml_new_string("turns"),
     cst_deg=caml_new_string("deg"),
     cst_grad=caml_new_string("grad"),
     cst_rad=caml_new_string("rad"),
     cst_turns=caml_new_string("turns"),
     cst_is_not_a_valid_length=caml_new_string(" is not a valid length"),
     cst_0$0=caml_new_string("0"),
     cst_d_d_s_S=caml_new_string("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=caml_new_string("length conversion error: "),
     cst_pc$0=caml_new_string("pc"),
     cst_ch$0=caml_new_string("ch"),
     cst_cm$0=caml_new_string("cm"),
     cst_em$1=caml_new_string("em"),
     cst_ex$0=caml_new_string("ex"),
     cst_gd$0=caml_new_string("gd"),
     cst_in$0=caml_new_string("in"),
     cst_mm$0=caml_new_string("mm"),
     cst_pt$0=caml_new_string("pt"),
     cst_px$0=caml_new_string("px"),
     cst_rem$0=caml_new_string("rem"),
     cst_vh$0=caml_new_string("vh"),
     cst_vm$0=caml_new_string("vm"),
     cst_vw$0=caml_new_string("vw"),
     cst_0=caml_new_string("0"),
     cst_em$0=caml_new_string("em"),
     cst_ex=caml_new_string("ex"),
     cst_px=caml_new_string("px"),
     cst_gd=caml_new_string("gd"),
     cst_rem=caml_new_string("rem"),
     cst_vw=caml_new_string("vw"),
     cst_vh=caml_new_string("vh"),
     cst_vm=caml_new_string("vm"),
     cst_ch=caml_new_string("ch"),
     cst_mm=caml_new_string("mm"),
     cst_cm=caml_new_string("cm"),
     cst_in=caml_new_string("in"),
     cst_pt=caml_new_string("pt"),
     cst_pc=caml_new_string("pc"),
     cst$39=caml_new_string("): "),
     cst_color_conversion_error$0=caml_new_string("color conversion error ("),
     cst$38=caml_new_string("): "),
     cst_color_conversion_error=caml_new_string("color conversion error ("),
     cst_is_not_a_valid_color$0=caml_new_string(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_new_string
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_new_string
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_new_string
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_new_string("rgb"),
     cst_rgba=caml_new_string("rgba"),
     cst_rgb$0=caml_new_string("rgb"),
     cst_rgba$0=caml_new_string("rgba"),
     cst_hsl=caml_new_string("hsl"),
     cst_hsla=caml_new_string("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_new_string("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_new_string("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_new_string("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_new_string
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_new_string("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_new_string("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_new_string(" is not a valid color"),
     cst_is_out_of_valid_range=caml_new_string(" is out of valid range"),
     partial=[8,0,0,0,[12,41,0]],
     partial$0=[12,41,0],
     cst_lightgrey$0=caml_new_string("lightgrey"),
     cst_darkslategray$0=caml_new_string("darkslategray"),
     cst_cornsilk$0=caml_new_string("cornsilk"),
     cst_blue$0=caml_new_string("blue"),
     cst_aliceblue$0=caml_new_string("aliceblue"),
     cst_antiquewhite$0=caml_new_string("antiquewhite"),
     cst_aqua$0=caml_new_string("aqua"),
     cst_aquamarine$0=caml_new_string("aquamarine"),
     cst_azure$0=caml_new_string("azure"),
     cst_beige$0=caml_new_string("beige"),
     cst_bisque$0=caml_new_string("bisque"),
     cst_black$0=caml_new_string("black"),
     cst_blanchedalmond$0=caml_new_string("blanchedalmond"),
     cst_blueviolet$0=caml_new_string("blueviolet"),
     cst_brown$0=caml_new_string("brown"),
     cst_burlywood$0=caml_new_string("burlywood"),
     cst_cadetblue$0=caml_new_string("cadetblue"),
     cst_chartreuse$0=caml_new_string("chartreuse"),
     cst_chocolate$0=caml_new_string("chocolate"),
     cst_coral$0=caml_new_string("coral"),
     cst_cornflowerblue$0=caml_new_string("cornflowerblue"),
     cst_darkkhaki$0=caml_new_string("darkkhaki"),
     cst_crimson$0=caml_new_string("crimson"),
     cst_cyan$0=caml_new_string("cyan"),
     cst_darkblue$0=caml_new_string("darkblue"),
     cst_darkcyan$0=caml_new_string("darkcyan"),
     cst_darkgoldenrod$0=caml_new_string("darkgoldenrod"),
     cst_darkgray$0=caml_new_string("darkgray"),
     cst_darkgreen$0=caml_new_string("darkgreen"),
     cst_darkgrey$0=caml_new_string("darkgrey"),
     cst_darkmagenta$0=caml_new_string("darkmagenta"),
     cst_darkolivegreen$0=caml_new_string("darkolivegreen"),
     cst_darkorange$0=caml_new_string("darkorange"),
     cst_darkorchid$0=caml_new_string("darkorchid"),
     cst_darkred$0=caml_new_string("darkred"),
     cst_darksalmon$0=caml_new_string("darksalmon"),
     cst_darkseagreen$0=caml_new_string("darkseagreen"),
     cst_darkslateblue$0=caml_new_string("darkslateblue"),
     cst_greenyellow$0=caml_new_string("greenyellow"),
     cst_floralwhite$0=caml_new_string("floralwhite"),
     cst_darkslategrey$0=caml_new_string("darkslategrey"),
     cst_darkturquoise$0=caml_new_string("darkturquoise"),
     cst_darkviolet$0=caml_new_string("darkviolet"),
     cst_deeppink$0=caml_new_string("deeppink"),
     cst_deepskyblue$0=caml_new_string("deepskyblue"),
     cst_dimgray$0=caml_new_string("dimgray"),
     cst_dimgrey$0=caml_new_string("dimgrey"),
     cst_dodgerblue$0=caml_new_string("dodgerblue"),
     cst_firebrick$0=caml_new_string("firebrick"),
     cst_forestgreen$0=caml_new_string("forestgreen"),
     cst_fuchsia$0=caml_new_string("fuchsia"),
     cst_gainsboro$0=caml_new_string("gainsboro"),
     cst_ghostwhite$0=caml_new_string("ghostwhite"),
     cst_gold$0=caml_new_string("gold"),
     cst_goldenrod$0=caml_new_string("goldenrod"),
     cst_gray$0=caml_new_string("gray"),
     cst_green$0=caml_new_string("green"),
     cst_lavenderblush$0=caml_new_string("lavenderblush"),
     cst_grey$0=caml_new_string("grey"),
     cst_honeydew$0=caml_new_string("honeydew"),
     cst_hotpink$0=caml_new_string("hotpink"),
     cst_indianred$0=caml_new_string("indianred"),
     cst_indigo$0=caml_new_string("indigo"),
     cst_ivory$0=caml_new_string("ivory"),
     cst_khaki$0=caml_new_string("khaki"),
     cst_lavender$0=caml_new_string("lavender"),
     cst_lawngreen$0=caml_new_string("lawngreen"),
     cst_lemonchiffon$0=caml_new_string("lemonchiffon"),
     cst_lightblue$0=caml_new_string("lightblue"),
     cst_lightcoral$0=caml_new_string("lightcoral"),
     cst_lightcyan$0=caml_new_string("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_new_string("lightgoldenrodyellow"),
     cst_lightgray$0=caml_new_string("lightgray"),
     cst_lightgreen$0=caml_new_string("lightgreen"),
     cst_paleturquoise$0=caml_new_string("paleturquoise"),
     cst_mediumslateblue$0=caml_new_string("mediumslateblue"),
     cst_limegreen$0=caml_new_string("limegreen"),
     cst_lightpink$0=caml_new_string("lightpink"),
     cst_lightsalmon$0=caml_new_string("lightsalmon"),
     cst_lightseagreen$0=caml_new_string("lightseagreen"),
     cst_lightskyblue$0=caml_new_string("lightskyblue"),
     cst_lightslategray$0=caml_new_string("lightslategray"),
     cst_lightslategrey$0=caml_new_string("lightslategrey"),
     cst_lightsteelblue$0=caml_new_string("lightsteelblue"),
     cst_lightyellow$0=caml_new_string("lightyellow"),
     cst_lime$0=caml_new_string("lime"),
     cst_linen$0=caml_new_string("linen"),
     cst_magenta$0=caml_new_string("magenta"),
     cst_maroon$0=caml_new_string("maroon"),
     cst_mediumaquamarine$0=caml_new_string("mediumaquamarine"),
     cst_mediumblue$0=caml_new_string("mediumblue"),
     cst_mediumorchid$0=caml_new_string("mediumorchid"),
     cst_mediumpurple$0=caml_new_string("mediumpurple"),
     cst_mediumseagreen$0=caml_new_string("mediumseagreen"),
     cst_navy$0=caml_new_string("navy"),
     cst_mediumspringgreen$0=caml_new_string("mediumspringgreen"),
     cst_mediumturquoise$0=caml_new_string("mediumturquoise"),
     cst_mediumvioletred$0=caml_new_string("mediumvioletred"),
     cst_midnightblue$0=caml_new_string("midnightblue"),
     cst_mintcream$0=caml_new_string("mintcream"),
     cst_mistyrose$0=caml_new_string("mistyrose"),
     cst_moccasin$0=caml_new_string("moccasin"),
     cst_navajowhite$0=caml_new_string("navajowhite"),
     cst_oldlace$0=caml_new_string("oldlace"),
     cst_olive$0=caml_new_string("olive"),
     cst_olivedrab$0=caml_new_string("olivedrab"),
     cst_orange$0=caml_new_string("orange"),
     cst_orangered$0=caml_new_string("orangered"),
     cst_orchid$0=caml_new_string("orchid"),
     cst_palegoldenrod$0=caml_new_string("palegoldenrod"),
     cst_palegreen$0=caml_new_string("palegreen"),
     cst_skyblue$0=caml_new_string("skyblue"),
     cst_rosybrown$0=caml_new_string("rosybrown"),
     cst_palevioletred$0=caml_new_string("palevioletred"),
     cst_papayawhip$0=caml_new_string("papayawhip"),
     cst_peachpuff$0=caml_new_string("peachpuff"),
     cst_peru$0=caml_new_string("peru"),
     cst_pink$0=caml_new_string("pink"),
     cst_plum$0=caml_new_string("plum"),
     cst_powderblue$0=caml_new_string("powderblue"),
     cst_purple$0=caml_new_string("purple"),
     cst_red$0=caml_new_string("red"),
     cst_royalblue$0=caml_new_string("royalblue"),
     cst_saddlebrown$0=caml_new_string("saddlebrown"),
     cst_salmon$0=caml_new_string("salmon"),
     cst_sandybrown$0=caml_new_string("sandybrown"),
     cst_seagreen$0=caml_new_string("seagreen"),
     cst_seashell$0=caml_new_string("seashell"),
     cst_sienna$0=caml_new_string("sienna"),
     cst_silver$0=caml_new_string("silver"),
     cst_thistle$0=caml_new_string("thistle"),
     cst_slateblue$0=caml_new_string("slateblue"),
     cst_slategray$0=caml_new_string("slategray"),
     cst_slategrey$0=caml_new_string("slategrey"),
     cst_snow$0=caml_new_string("snow"),
     cst_springgreen$0=caml_new_string("springgreen"),
     cst_steelblue$0=caml_new_string("steelblue"),
     cst_tan$0=caml_new_string("tan"),
     cst_teal$0=caml_new_string("teal"),
     cst_tomato$0=caml_new_string("tomato"),
     cst_turquoise$0=caml_new_string("turquoise"),
     cst_violet$0=caml_new_string("violet"),
     cst_wheat$0=caml_new_string("wheat"),
     cst_white$0=caml_new_string("white"),
     cst_whitesmoke$0=caml_new_string("whitesmoke"),
     cst_yellow$0=caml_new_string("yellow"),
     cst_yellowgreen$0=caml_new_string("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_new_string(" is not a valid color name"),
     cst_aliceblue=caml_new_string("aliceblue"),
     cst_antiquewhite=caml_new_string("antiquewhite"),
     cst_aqua=caml_new_string("aqua"),
     cst_aquamarine=caml_new_string("aquamarine"),
     cst_azure=caml_new_string("azure"),
     cst_beige=caml_new_string("beige"),
     cst_bisque=caml_new_string("bisque"),
     cst_black=caml_new_string("black"),
     cst_blanchedalmond=caml_new_string("blanchedalmond"),
     cst_blue=caml_new_string("blue"),
     cst_blueviolet=caml_new_string("blueviolet"),
     cst_brown=caml_new_string("brown"),
     cst_burlywood=caml_new_string("burlywood"),
     cst_cadetblue=caml_new_string("cadetblue"),
     cst_chartreuse=caml_new_string("chartreuse"),
     cst_chocolate=caml_new_string("chocolate"),
     cst_coral=caml_new_string("coral"),
     cst_cornflowerblue=caml_new_string("cornflowerblue"),
     cst_cornsilk=caml_new_string("cornsilk"),
     cst_crimson=caml_new_string("crimson"),
     cst_cyan=caml_new_string("cyan"),
     cst_darkblue=caml_new_string("darkblue"),
     cst_darkcyan=caml_new_string("darkcyan"),
     cst_darkgoldenrod=caml_new_string("darkgoldenrod"),
     cst_darkgray=caml_new_string("darkgray"),
     cst_darkgreen=caml_new_string("darkgreen"),
     cst_darkgrey=caml_new_string("darkgrey"),
     cst_darkkhaki=caml_new_string("darkkhaki"),
     cst_darkmagenta=caml_new_string("darkmagenta"),
     cst_darkolivegreen=caml_new_string("darkolivegreen"),
     cst_darkorange=caml_new_string("darkorange"),
     cst_darkorchid=caml_new_string("darkorchid"),
     cst_darkred=caml_new_string("darkred"),
     cst_darksalmon=caml_new_string("darksalmon"),
     cst_darkseagreen=caml_new_string("darkseagreen"),
     cst_darkslateblue=caml_new_string("darkslateblue"),
     cst_darkslategray=caml_new_string("darkslategray"),
     cst_darkslategrey=caml_new_string("darkslategrey"),
     cst_darkturquoise=caml_new_string("darkturquoise"),
     cst_darkviolet=caml_new_string("darkviolet"),
     cst_deeppink=caml_new_string("deeppink"),
     cst_deepskyblue=caml_new_string("deepskyblue"),
     cst_dimgray=caml_new_string("dimgray"),
     cst_dimgrey=caml_new_string("dimgrey"),
     cst_dodgerblue=caml_new_string("dodgerblue"),
     cst_firebrick=caml_new_string("firebrick"),
     cst_floralwhite=caml_new_string("floralwhite"),
     cst_forestgreen=caml_new_string("forestgreen"),
     cst_fuchsia=caml_new_string("fuchsia"),
     cst_gainsboro=caml_new_string("gainsboro"),
     cst_ghostwhite=caml_new_string("ghostwhite"),
     cst_gold=caml_new_string("gold"),
     cst_goldenrod=caml_new_string("goldenrod"),
     cst_gray=caml_new_string("gray"),
     cst_grey=caml_new_string("grey"),
     cst_green=caml_new_string("green"),
     cst_greenyellow=caml_new_string("greenyellow"),
     cst_honeydew=caml_new_string("honeydew"),
     cst_hotpink=caml_new_string("hotpink"),
     cst_indianred=caml_new_string("indianred"),
     cst_indigo=caml_new_string("indigo"),
     cst_ivory=caml_new_string("ivory"),
     cst_khaki=caml_new_string("khaki"),
     cst_lavender=caml_new_string("lavender"),
     cst_lavenderblush=caml_new_string("lavenderblush"),
     cst_lawngreen=caml_new_string("lawngreen"),
     cst_lemonchiffon=caml_new_string("lemonchiffon"),
     cst_lightblue=caml_new_string("lightblue"),
     cst_lightcoral=caml_new_string("lightcoral"),
     cst_lightcyan=caml_new_string("lightcyan"),
     cst_lightgoldenrodyellow=caml_new_string("lightgoldenrodyellow"),
     cst_lightgray=caml_new_string("lightgray"),
     cst_lightgreen=caml_new_string("lightgreen"),
     cst_lightgrey=caml_new_string("lightgrey"),
     cst_lightpink=caml_new_string("lightpink"),
     cst_lightsalmon=caml_new_string("lightsalmon"),
     cst_lightseagreen=caml_new_string("lightseagreen"),
     cst_lightskyblue=caml_new_string("lightskyblue"),
     cst_lightslategray=caml_new_string("lightslategray"),
     cst_lightslategrey=caml_new_string("lightslategrey"),
     cst_lightsteelblue=caml_new_string("lightsteelblue"),
     cst_lightyellow=caml_new_string("lightyellow"),
     cst_lime=caml_new_string("lime"),
     cst_limegreen=caml_new_string("limegreen"),
     cst_linen=caml_new_string("linen"),
     cst_magenta=caml_new_string("magenta"),
     cst_maroon=caml_new_string("maroon"),
     cst_mediumaquamarine=caml_new_string("mediumaquamarine"),
     cst_mediumblue=caml_new_string("mediumblue"),
     cst_mediumorchid=caml_new_string("mediumorchid"),
     cst_mediumpurple=caml_new_string("mediumpurple"),
     cst_mediumseagreen=caml_new_string("mediumseagreen"),
     cst_mediumslateblue=caml_new_string("mediumslateblue"),
     cst_mediumspringgreen=caml_new_string("mediumspringgreen"),
     cst_mediumturquoise=caml_new_string("mediumturquoise"),
     cst_mediumvioletred=caml_new_string("mediumvioletred"),
     cst_midnightblue=caml_new_string("midnightblue"),
     cst_mintcream=caml_new_string("mintcream"),
     cst_mistyrose=caml_new_string("mistyrose"),
     cst_moccasin=caml_new_string("moccasin"),
     cst_navajowhite=caml_new_string("navajowhite"),
     cst_navy=caml_new_string("navy"),
     cst_oldlace=caml_new_string("oldlace"),
     cst_olive=caml_new_string("olive"),
     cst_olivedrab=caml_new_string("olivedrab"),
     cst_orange=caml_new_string("orange"),
     cst_orangered=caml_new_string("orangered"),
     cst_orchid=caml_new_string("orchid"),
     cst_palegoldenrod=caml_new_string("palegoldenrod"),
     cst_palegreen=caml_new_string("palegreen"),
     cst_paleturquoise=caml_new_string("paleturquoise"),
     cst_palevioletred=caml_new_string("palevioletred"),
     cst_papayawhip=caml_new_string("papayawhip"),
     cst_peachpuff=caml_new_string("peachpuff"),
     cst_peru=caml_new_string("peru"),
     cst_pink=caml_new_string("pink"),
     cst_plum=caml_new_string("plum"),
     cst_powderblue=caml_new_string("powderblue"),
     cst_purple=caml_new_string("purple"),
     cst_red=caml_new_string("red"),
     cst_rosybrown=caml_new_string("rosybrown"),
     cst_royalblue=caml_new_string("royalblue"),
     cst_saddlebrown=caml_new_string("saddlebrown"),
     cst_salmon=caml_new_string("salmon"),
     cst_sandybrown=caml_new_string("sandybrown"),
     cst_seagreen=caml_new_string("seagreen"),
     cst_seashell=caml_new_string("seashell"),
     cst_sienna=caml_new_string("sienna"),
     cst_silver=caml_new_string("silver"),
     cst_skyblue=caml_new_string("skyblue"),
     cst_slateblue=caml_new_string("slateblue"),
     cst_slategray=caml_new_string("slategray"),
     cst_slategrey=caml_new_string("slategrey"),
     cst_snow=caml_new_string("snow"),
     cst_springgreen=caml_new_string("springgreen"),
     cst_steelblue=caml_new_string("steelblue"),
     cst_tan=caml_new_string("tan"),
     cst_teal=caml_new_string("teal"),
     cst_thistle=caml_new_string("thistle"),
     cst_tomato=caml_new_string("tomato"),
     cst_turquoise=caml_new_string("turquoise"),
     cst_violet=caml_new_string("violet"),
     cst_wheat=caml_new_string("wheat"),
     cst_white=caml_new_string("white"),
     cst_whitesmoke=caml_new_string("whitesmoke"),
     cst_yellow=caml_new_string("yellow"),
     cst_yellowgreen=caml_new_string("yellowgreen"),
     cst_vkern$0=caml_new_string("vkern"),
     cst_view$0=caml_new_string("view"),
     cst_use$0=caml_new_string("use"),
     cst_tspan$0=caml_new_string("tspan"),
     cst_tref$0=caml_new_string("tref"),
     cst_title$3=caml_new_string("title"),
     cst_textpath$0=caml_new_string("textpath"),
     cst_text$1=caml_new_string("text"),
     cst_symbol$0=caml_new_string("symbol"),
     cst_switch$0=caml_new_string("switch"),
     cst_svg$0=caml_new_string("svg"),
     cst_style$3=caml_new_string("style"),
     cst_stop$0=caml_new_string("stop"),
     cst_set$0=caml_new_string("set"),
     cst_script$3=caml_new_string("script"),
     cst_rect$0=caml_new_string("rect"),
     cst_radialgradient$0=caml_new_string("radialgradient"),
     cst_polyline$0=caml_new_string("polyline"),
     cst_polygon$0=caml_new_string("polygon"),
     cst_parttern$0=caml_new_string("parttern"),
     cst_path$0=caml_new_string("path"),
     cst_mpath$0=caml_new_string("mpath"),
     cst_missing_glyph$0=caml_new_string("missing-glyph"),
     cst_metadata$0=caml_new_string("metadata"),
     cst_mask$0=caml_new_string("mask"),
     cst_lineargradient$0=caml_new_string("lineargradient"),
     cst_line$0=caml_new_string("line"),
     cst_image$0=caml_new_string("image"),
     cst_hkern$0=caml_new_string("hkern"),
     cst_glyphref$0=caml_new_string("glyphref"),
     cst_glyph$0=caml_new_string("glyph"),
     cst_g$1=caml_new_string("g"),
     cst_foreignobject$0=caml_new_string("foreignobject"),
     cst_font_face_uri$0=caml_new_string("font-face-uri"),
     cst_font_face_src$0=caml_new_string("font-face-src"),
     cst_font_face_name$0=caml_new_string("font-face-name"),
     cst_font_face_format$0=caml_new_string("font-face-format"),
     cst_font_face$0=caml_new_string("font-face"),
     cst_font$0=caml_new_string("font"),
     cst_filter$0=caml_new_string("filter"),
     cst_ellipse$0=caml_new_string("ellipse"),
     cst_desc$0=caml_new_string("desc"),
     cst_defs$0=caml_new_string("defs"),
     cst_cursor$0=caml_new_string("cursor"),
     cst_clippath$0=caml_new_string("clippath"),
     cst_circle$0=caml_new_string("circle"),
     cst_animatetransform$0=caml_new_string("animatetransform"),
     cst_animatemotion$0=caml_new_string("animatemotion"),
     cst_animatecolor$0=caml_new_string("animatecolor"),
     cst_animate$0=caml_new_string("animate"),
     cst_altglyphitem$0=caml_new_string("altglyphitem"),
     cst_altglyphdef$0=caml_new_string("altglyphdef"),
     cst_altglyph$0=caml_new_string("altglyph"),
     cst_a$3=caml_new_string("a"),
     cst_vkern=caml_new_string("vkern"),
     cst_view=caml_new_string("view"),
     cst_use=caml_new_string("use"),
     cst_tspan=caml_new_string("tspan"),
     cst_tref=caml_new_string("tref"),
     cst_title$2=caml_new_string("title"),
     cst_textpath=caml_new_string("textpath"),
     cst_text$0=caml_new_string("text"),
     cst_symbol=caml_new_string("symbol"),
     cst_switch=caml_new_string("switch"),
     cst_svg=caml_new_string("svg"),
     cst_style$2=caml_new_string("style"),
     cst_stop=caml_new_string("stop"),
     cst_set=caml_new_string("set"),
     cst_script$2=caml_new_string("script"),
     cst_rect=caml_new_string("rect"),
     cst_radialgradient=caml_new_string("radialgradient"),
     cst_polyline=caml_new_string("polyline"),
     cst_polygon=caml_new_string("polygon"),
     cst_parttern=caml_new_string("parttern"),
     cst_path=caml_new_string("path"),
     cst_mpath=caml_new_string("mpath"),
     cst_missing_glyph=caml_new_string("missing-glyph"),
     cst_metadata=caml_new_string("metadata"),
     cst_mask=caml_new_string("mask"),
     cst_lineargradient=caml_new_string("lineargradient"),
     cst_line=caml_new_string("line"),
     cst_image=caml_new_string("image"),
     cst_hkern=caml_new_string("hkern"),
     cst_glyphref=caml_new_string("glyphref"),
     cst_glyph=caml_new_string("glyph"),
     cst_g$0=caml_new_string("g"),
     cst_foreignobject=caml_new_string("foreignobject"),
     cst_font_face_uri=caml_new_string("font-face-uri"),
     cst_font_face_src=caml_new_string("font-face-src"),
     cst_font_face_name=caml_new_string("font-face-name"),
     cst_font_face_format=caml_new_string("font-face-format"),
     cst_font_face=caml_new_string("font-face"),
     cst_font=caml_new_string("font"),
     cst_filter=caml_new_string("filter"),
     cst_ellipse=caml_new_string("ellipse"),
     cst_desc=caml_new_string("desc"),
     cst_defs=caml_new_string("defs"),
     cst_cursor=caml_new_string("cursor"),
     cst_clippath=caml_new_string("clippath"),
     cst_circle=caml_new_string("circle"),
     cst_animatetransform=caml_new_string("animatetransform"),
     cst_animatemotion=caml_new_string("animatemotion"),
     cst_animatecolor=caml_new_string("animatecolor"),
     cst_animate=caml_new_string("animate"),
     cst_altglyphitem=caml_new_string("altglyphitem"),
     cst_altglyphdef=caml_new_string("altglyphdef"),
     cst_altglyph=caml_new_string("altglyph"),
     cst_a$2=caml_new_string("a"),
     cst_Dom_svg_SVGError=caml_new_string("Dom_svg.SVGError"),
     Stdlib=global_data.Stdlib,
     Stdlib_callback=global_data.Stdlib__callback,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_printf=global_data.Stdlib__printf,
     Failure=global_data.Failure,
     Stdlib_string=global_data.Stdlib__string,
     Invalid_argument=global_data.Invalid_argument,
     global=joo_global_object,
     Unsafe=[0,global],
     no_handler=null,
     t37=undefined,
     _d_=[0,caml_new_string("lib/dom.ml"),276,66],
     _e_=[0,caml_new_string("transparent")],
     _f_=[0,caml_new_string("native")],
     _j_=[0,caml_new_string("lib/dom_html.ml"),1657,57],
     _i_=[0,caml_new_string("lib/dom_html.ml"),1656,59],
     _h_=
      [0,
       [11,
        caml_new_string("getElementById_exn: "),
        [3,0,[11,caml_new_string(" not found"),0]]],
       caml_new_string("getElementById_exn: %S not found")],
     _m_=[0,caml_new_string("lib/form.ml"),172,9],
     _l_=[0,1],
     _n_=[0,caml_new_string("lib/xmlHttpRequest.ml"),86,2],
     _o_=[0,caml_new_string("lib/regexp.ml"),35,64],
     _p_=[0,caml_new_string(""),0],
     _cj_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ck_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cl_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cm_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b7_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b8_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b9_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b__=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b$_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ca_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cb_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cc_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cd_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ce_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cf_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cg_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ch_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ci_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b6_=
      caml_list_of_js_array
       ([caml_new_string("aliceblue"),
         caml_new_string("antiquewhite"),
         caml_new_string("aqua"),
         caml_new_string("aquamarine"),
         caml_new_string("azure"),
         caml_new_string("beige"),
         caml_new_string("bisque"),
         caml_new_string("black"),
         caml_new_string("blanchedalmond"),
         caml_new_string("blue"),
         caml_new_string("blueviolet"),
         caml_new_string("brown"),
         caml_new_string("burlywood"),
         caml_new_string("cadetblue"),
         caml_new_string("chartreuse"),
         caml_new_string("chocolate"),
         caml_new_string("coral"),
         caml_new_string("cornflowerblue"),
         caml_new_string("cornsilk"),
         caml_new_string("crimson"),
         caml_new_string("cyan"),
         caml_new_string("darkblue"),
         caml_new_string("darkcyan"),
         caml_new_string("darkgoldenrod"),
         caml_new_string("darkgray"),
         caml_new_string("darkgreen"),
         caml_new_string("darkgrey"),
         caml_new_string("darkkhaki"),
         caml_new_string("darkmagenta"),
         caml_new_string("darkolivegreen"),
         caml_new_string("darkorange"),
         caml_new_string("darkorchid"),
         caml_new_string("darkred"),
         caml_new_string("darksalmon"),
         caml_new_string("darkseagreen"),
         caml_new_string("darkslateblue"),
         caml_new_string("darkslategray"),
         caml_new_string("darkslategrey"),
         caml_new_string("darkturquoise"),
         caml_new_string("darkviolet"),
         caml_new_string("deeppink"),
         caml_new_string("deepskyblue"),
         caml_new_string("dimgray"),
         caml_new_string("dimgrey"),
         caml_new_string("dodgerblue"),
         caml_new_string("firebrick"),
         caml_new_string("floralwhite"),
         caml_new_string("forestgreen"),
         caml_new_string("fuchsia"),
         caml_new_string("gainsboro"),
         caml_new_string("ghostwhite"),
         caml_new_string("gold"),
         caml_new_string("goldenrod"),
         caml_new_string("gray"),
         caml_new_string("green"),
         caml_new_string("greenyellow"),
         caml_new_string("grey"),
         caml_new_string("honeydew"),
         caml_new_string("hotpink"),
         caml_new_string("indianred"),
         caml_new_string("indigo"),
         caml_new_string("ivory"),
         caml_new_string("khaki"),
         caml_new_string("lavender"),
         caml_new_string("lavenderblush"),
         caml_new_string("lawngreen"),
         caml_new_string("lemonchiffon"),
         caml_new_string("lightblue"),
         caml_new_string("lightcoral"),
         caml_new_string("lightcyan"),
         caml_new_string("lightgoldenrodyellow"),
         caml_new_string("lightgray"),
         caml_new_string("lightgreen"),
         caml_new_string("lightgrey"),
         caml_new_string("lightpink"),
         caml_new_string("lightsalmon"),
         caml_new_string("lightseagreen"),
         caml_new_string("lightskyblue"),
         caml_new_string("lightslategray"),
         caml_new_string("lightslategrey"),
         caml_new_string("lightsteelblue"),
         caml_new_string("lightyellow"),
         caml_new_string("lime"),
         caml_new_string("limegreen"),
         caml_new_string("linen"),
         caml_new_string("magenta"),
         caml_new_string("maroon"),
         caml_new_string("mediumaquamarine"),
         caml_new_string("mediumblue"),
         caml_new_string("mediumorchid"),
         caml_new_string("mediumpurple"),
         caml_new_string("mediumseagreen"),
         caml_new_string("mediumslateblue"),
         caml_new_string("mediumspringgreen"),
         caml_new_string("mediumturquoise"),
         caml_new_string("mediumvioletred"),
         caml_new_string("midnightblue"),
         caml_new_string("mintcream"),
         caml_new_string("mistyrose"),
         caml_new_string("moccasin"),
         caml_new_string("navajowhite"),
         caml_new_string("navy"),
         caml_new_string("oldlace"),
         caml_new_string("olive"),
         caml_new_string("olivedrab"),
         caml_new_string("orange"),
         caml_new_string("orangered"),
         caml_new_string("orchid"),
         caml_new_string("palegoldenrod"),
         caml_new_string("palegreen"),
         caml_new_string("paleturquoise"),
         caml_new_string("palevioletred"),
         caml_new_string("papayawhip"),
         caml_new_string("peachpuff"),
         caml_new_string("peru"),
         caml_new_string("pink"),
         caml_new_string("plum"),
         caml_new_string("powderblue"),
         caml_new_string("purple"),
         caml_new_string("red"),
         caml_new_string("rosybrown"),
         caml_new_string("royalblue"),
         caml_new_string("saddlebrown"),
         caml_new_string("salmon"),
         caml_new_string("sandybrown"),
         caml_new_string("seagreen"),
         caml_new_string("seashell"),
         caml_new_string("sienna"),
         caml_new_string("silver"),
         caml_new_string("skyblue"),
         caml_new_string("slateblue"),
         caml_new_string("slategray"),
         caml_new_string("slategrey"),
         caml_new_string("snow"),
         caml_new_string("springgreen"),
         caml_new_string("steelblue"),
         caml_new_string("tan"),
         caml_new_string("teal"),
         caml_new_string("thistle"),
         caml_new_string("tomato"),
         caml_new_string("turquoise"),
         caml_new_string("violet"),
         caml_new_string("wheat"),
         caml_new_string("white"),
         caml_new_string("whitesmoke"),
         caml_new_string("yellow"),
         caml_new_string("yellowgreen")]),
     _b5_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_new_string("#%02X%02X%02X")],
     _bZ_=
      [0,
       [11,
        caml_new_string("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_new_string("rgb(%d,%d,%d)")],
     _b0_=
      [0,
       [11,
        caml_new_string("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_new_string("rgb(%d%%,%d%%,%d%%)")],
     _b1_=
      [0,
       [11,
        caml_new_string("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,0,0,0,[12,41,0]]]]]]]]],
       caml_new_string("rgba(%d,%d,%d,%f)")],
     _b2_=
      [0,
       [11,
        caml_new_string("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_new_string("rgba(%d%%,%d%%,%d%%,%f)")],
     _b3_=
      [0,
       [11,
        caml_new_string("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_new_string("hsl(%d,%d%%,%d%%)")],
     _b4_=
      [0,
       [11,
        caml_new_string("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[8,0,0,0,partial$0]]]]]]]]]],
       caml_new_string("hsla(%d,%d%%,%d%%,%f)")],
     _w_=[0,240,248,255],
     _x_=[0,250,235,215],
     _y_=[0,0,255,255],
     _z_=[0,127,255,212],
     _A_=[0,240,255,255],
     _B_=[0,245,245,220],
     _C_=[0,255,228,196],
     _D_=[0,0,0,0],
     _E_=[0,255,235,205],
     _F_=[0,0,0,255],
     _G_=[0,138,43,226],
     _H_=[0,165,42,42],
     _I_=[0,222,184,135],
     _J_=[0,95,158,160],
     _K_=[0,127,255,0],
     _L_=[0,210,105,30],
     _M_=[0,255,127,80],
     _N_=[0,100,149,237],
     _O_=[0,255,248,220],
     _P_=[0,220,20,60],
     _Q_=[0,0,255,255],
     _R_=[0,0,0,139],
     _S_=[0,0,139,139],
     _T_=[0,184,134,11],
     _U_=[0,169,169,169],
     _V_=[0,0,100,0],
     _W_=[0,169,169,169],
     _X_=[0,189,183,107],
     _Y_=[0,139,0,139],
     _Z_=[0,85,107,47],
     ___=[0,255,140,0],
     _$_=[0,153,50,204],
     _aa_=[0,139,0,0],
     _ab_=[0,233,150,122],
     _ac_=[0,143,188,143],
     _ad_=[0,72,61,139],
     _ae_=[0,47,79,79],
     _af_=[0,47,79,79],
     _ag_=[0,0,206,209],
     _ah_=[0,148,0,211],
     _ai_=[0,255,20,147],
     _aj_=[0,0,191,255],
     _ak_=[0,105,105,105],
     _al_=[0,105,105,105],
     _am_=[0,30,144,255],
     _an_=[0,178,34,34],
     _ao_=[0,255,250,240],
     _ap_=[0,34,139,34],
     _aq_=[0,255,0,255],
     _ar_=[0,220,220,220],
     _as_=[0,248,248,255],
     _at_=[0,255,215,0],
     _au_=[0,218,165,32],
     _av_=[0,128,128,128],
     _aw_=[0,128,128,128],
     _ax_=[0,0,128,0],
     _ay_=[0,173,255,47],
     _az_=[0,240,255,240],
     _aA_=[0,255,105,180],
     _aB_=[0,205,92,92],
     _aC_=[0,75,0,130],
     _aD_=[0,255,255,240],
     _aE_=[0,240,230,140],
     _aF_=[0,230,230,250],
     _aG_=[0,255,240,245],
     _aH_=[0,124,252,0],
     _aI_=[0,255,250,205],
     _aJ_=[0,173,216,230],
     _aK_=[0,240,128,128],
     _aL_=[0,224,255,255],
     _aM_=[0,250,250,210],
     _aN_=[0,211,211,211],
     _aO_=[0,144,238,144],
     _aP_=[0,211,211,211],
     _aQ_=[0,255,182,193],
     _aR_=[0,255,160,122],
     _aS_=[0,32,178,170],
     _aT_=[0,135,206,250],
     _aU_=[0,119,136,153],
     _aV_=[0,119,136,153],
     _aW_=[0,176,196,222],
     _aX_=[0,255,255,224],
     _aY_=[0,0,255,0],
     _aZ_=[0,50,205,50],
     _a0_=[0,250,240,230],
     _a1_=[0,255,0,255],
     _a2_=[0,128,0,0],
     _a3_=[0,102,205,170],
     _a4_=[0,0,0,205],
     _a5_=[0,186,85,211],
     _a6_=[0,147,112,219],
     _a7_=[0,60,179,113],
     _a8_=[0,123,104,238],
     _a9_=[0,0,250,154],
     _a__=[0,72,209,204],
     _a$_=[0,199,21,133],
     _ba_=[0,25,25,112],
     _bb_=[0,245,255,250],
     _bc_=[0,255,228,225],
     _bd_=[0,255,228,181],
     _be_=[0,255,222,173],
     _bf_=[0,0,0,128],
     _bg_=[0,253,245,230],
     _bh_=[0,128,128,0],
     _bi_=[0,107,142,35],
     _bj_=[0,255,165,0],
     _bk_=[0,255,69,0],
     _bl_=[0,218,112,214],
     _bm_=[0,238,232,170],
     _bn_=[0,152,251,152],
     _bo_=[0,175,238,238],
     _bp_=[0,219,112,147],
     _bq_=[0,255,239,213],
     _br_=[0,255,218,185],
     _bs_=[0,205,133,63],
     _bt_=[0,255,192,203],
     _bu_=[0,221,160,221],
     _bv_=[0,176,224,230],
     _bw_=[0,128,0,128],
     _bx_=[0,255,0,0],
     _by_=[0,188,143,143],
     _bz_=[0,65,105,225],
     _bA_=[0,139,69,19],
     _bB_=[0,250,128,114],
     _bC_=[0,244,164,96],
     _bD_=[0,46,139,87],
     _bE_=[0,255,245,238],
     _bF_=[0,160,82,45],
     _bG_=[0,192,192,192],
     _bH_=[0,135,206,235],
     _bI_=[0,106,90,205],
     _bJ_=[0,112,128,144],
     _bK_=[0,112,128,144],
     _bL_=[0,255,250,250],
     _bM_=[0,0,255,127],
     _bN_=[0,70,130,180],
     _bO_=[0,210,180,140],
     _bP_=[0,0,128,128],
     _bQ_=[0,216,191,216],
     _bR_=[0,255,99,71],
     _bS_=[0,64,224,208],
     _bT_=[0,238,130,238],
     _bU_=[0,245,222,179],
     _bV_=[0,255,255,255],
     _bW_=[0,245,245,245],
     _bX_=[0,255,255,0],
     _bY_=[0,154,205,50];
    function return$0(_gG_){return _gG_}
    function map(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter(x,f)
     {var _gF_=1 - (x == no_handler?1:0);return _gF_?caml_call1(f,x):_gF_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gE_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gE_)}
    var
     Opt=
      [0,no_handler,return$0,map,bind,test,iter,case$0,get,option,to_option];
    function return$1(_gD_){return _gD_}
    function map$0(x,f){return x === t37?t37:caml_call1(f,x)}
    function bind$0(x,f){return x === t37?t37:caml_call1(f,x)}
    function test$0(x){return x !== t37?1:0}
    function iter$0(x,f)
     {var _gC_=x !== t37?1:0;return _gC_?caml_call1(f,x):_gC_}
    function case$1(x,f,g){return x === t37?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t37?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t37}
    function to_option$0(x)
     {function _gB_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gB_)}
    var
     Optdef=
      [0,
       t37,
       return$1,
       map$0,
       bind$0,
       test$0,
       iter$0,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gz_(param){return caml_call1(g,x)}
      var _gA_=caml_call1(f,x);
      return caml_call2(Opt[8],_gA_,_gz_)}
    function coerce_opt(x,f,g)
     {function _gx_(param){return caml_call1(g,x)}
      var _gy_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gy_,_gx_)}
    var
     true$0=true,
     false$0=false,
     string_constr=Unsafe[1].String,
     regExp_withFlags=Unsafe[1].RegExp,
     object_constructor=Unsafe[1].Object;
    function object_keys(o){return object_constructor.keys(o)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gw_){return _gw_}
    function match_result(_gv_){return _gv_}
    var
     date_ms=Unsafe[1].Date,
     math=Unsafe[1].Math,
     Error=[248,cst_Js_Error,caml_fresh_oo_id(0)],
     error_constr=Unsafe[1].Error;
    caml_call2(Stdlib_callback[2],cst_jsError,[0,Error,{}]);
    function raise_js_error(exn){throw exn}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Stdlib[3],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Stdlib[3],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error)
       {var e=param[2];return [0,caml_js_to_string(e.toString())]}
      return 0}
    caml_call1(Stdlib_printexc[8],_a_);
    function _b_(e)
     {return e instanceof array_length?0:[0,caml_js_to_string(e.toString())]}
    caml_call1(Stdlib_printexc[8],_b_);
    function string_of_error(e){return caml_js_to_string(e.toString())}
    function export_js(field,x)
     {return runtime.caml_js_export_var(0)[field] = x}
    function export$0(field,x){return export_js(field.toString(),x)}
    function export_all(obj)
     {var keys=object_keys(obj);
      return keys.forEach
              (caml_js_wrap_callback
                (function(key,param,_gu_){return export_js(key,obj[key])}))}
    function _c_(_gt_){return _gt_}
    var
     Js=
      [0,
       no_handler,
       function(_gs_){return _gs_},
       t37,
       _c_,
       Opt,
       Optdef,
       true$0,
       false$0,
       string_constr,
       regExp_withFlags,
       regExp_withFlags,
       regExp_withFlags,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       math,
       error_constr,
       string_of_error,
       raise_js_error,
       Error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe];
    caml_register_global(1609,Js,"Js");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(i < length)
         {var _gr_=nodeList.item(i),match=caml_call1(Opt[10],_gr_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(Stdlib_list[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return (t & mask) === mask?1:0}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(0 !== match)
       {var switcher=match - 1 | 0;
        switch(switcher)
         {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType)if(4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var e$0=event,res$0=caml_call1(f,e$0);
        if(1 - (res$0 | 0))e$0.returnValue = res$0;
        return res$0}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var e$0=event,res$0=caml_call2(f,this$0,e$0);
                 if(1 - (res$0 | 0))e$0.returnValue = res$0;
                 return res$0})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _go_(param)
       {function _gq_(param){throw Not_found}
        return caml_call2(Opt[8],e.srcElement,_gq_)}
      var target=caml_call2(Opt[8],e.target,_go_);
      if(target instanceof Unsafe[1].Node)
       {if(3 === target.nodeType)
         {var _gp_=function(param){throw [0,Assert_failure,_d_]};
          return caml_call2(Opt[8],target.parentNode,_gp_)}
        return target}
      return target}
    var make=caml_js_from_string,Event=[0,make];
    function addEventListener(e,typ,h,capt)
     {if(e.addEventListener === t37)
       {var
         ev="on".concat(typ),
         callback=
          function(e)
           {var _gl_=[0,h,e,[0]];
            return function(_gm_,_gn_)
             {return runtime.caml_js_call(_gl_,_gm_,_gn_)}};
        e.attachEvent(ev,callback);
        return function(param){return e.detachEvent(ev,callback)}}
      e.addEventListener(typ,h,capt);
      return function(param){return e.removeEventListener(typ,h,capt)}}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(ev)
     {return caml_call1(Optdef[5],ev.preventDefault)
              ?ev.preventDefault()
              :ev.returnValue = ! ! 0}
    var
     Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListener,
       removeEventListener,
       preventDefault];
    caml_register_global(1613,Dom,"Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     uint8Array_fromBuffer=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set,
     get$1=caml_js_get,
     unsafe_get=caml_js_get,
     dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new uint8Array_fromBuffer(ab);
      return runtime.caml_string_of_array(uint8)}
    var
     String=[0,of_arrayBuffer],
     Typed_array=
      [0,
       arrayBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,runtime.bigstring_to_array_buffer,runtime.bigstring_of_array_buffer],
       String];
    caml_register_global(1614,Typed_array,"Typed_array");
    var blob_constr=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _gh_=0;
      if(endings)
       var _gi_=116179762 <= endings[1]?_e_:_f_,_gj_=_gi_;
      else
       var _gj_=0;
      var
       _gk_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_gj_],_gh_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v){var v$0=v[1];return [0,[0,name,v$0.toString()]]}
            return 0},
          _gk_),
       options$0=
        options
         ?runtime.caml_js_object(caml_call1(Stdlib_array[12],options))
         :t37;
      return new blob_constr(caml_js_from_array(a),options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,s.toString()])}
    function blob_from_any(contentType,endings,l)
     {function _gf_(param)
       {var _gg_=param[1];
        if(155580615 === _gg_){var s=param[2];return s}
        if(486041214 <= _gg_)
         {if(1037850489 <= _gg_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _gg_){var s$0=param[2];return s$0.toString()}
        var b=param[2];
        return b}
      var l$0=caml_call2(Stdlib_list[17],_gf_,l);
      return blob_raw(contentType,endings,caml_call1(Stdlib_array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1
              (Stdlib[3],cst_can_t_retrieve_file_name_not_implemented)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof blob_constr?e:no_handler}
    function string(e)
     {return runtime.caml_equal(typeof e,"string")?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_ge_){return _ge_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1616,File,"File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$0=Event[1],
     Event$0=
      [0,
       click,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       pause,
       play,
       playing,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$0],
     d="2d";
    function location_origin(loc)
     {function _gc_(o){return o}
      function _gd_(param)
       {var protocol=loc.protocol,hostname=loc.hostname,port=loc.port;
        if(0 === protocol.length)if(0 === hostname.length)return "";
        var origin=protocol.concat("//",hostname);
        return 0 < port.length?origin.concat(":",loc.port):origin}
      return caml_call3(Optdef[7],loc.origin,_gd_,_gc_)}
    var _g_=Unsafe[1],document$0=_g_.document;
    function getElementById(id)
     {function _f$_(pnode){return pnode}
      function _ga_(param){throw Not_found}
      var _gb_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_gb_,_ga_,_f$_)}
    function getElementById_exn(id)
     {function _f7_(pnode){return pnode}
      function _f8_(param)
       {var _f__=caml_call2(Stdlib_printf[4],_h_,id);
        return caml_call1(Stdlib[3],_f__)}
      var _f9_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_f9_,_f8_,_f7_)}
    function getElementById_opt(id)
     {var _f6_=document$0.getElementById(id.toString());
      return caml_call1(Opt[10],_f6_)}
    function getElementById_coerce(id,coerce)
     {function _f2_(e)
       {var _f5_=caml_call1(coerce,e);return caml_call1(Opt[10],_f5_)}
      function _f3_(param){return 0}
      var _f4_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_f4_,_f3_,_f2_)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(doc,name)
     {return doc.createElement(name.toString())}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type)if(0 === name)return createElement(doc,elt);
        var _fW_=createElementSyntax[1];
        if(785140586 === _fW_)
         {try
           {var
             el=document$0.createElement('<input name="x">'),
             _fZ_=el.tagName.toLowerCase() === "input"?1:0,
             _f0_=_fZ_?el.name === "x"?1:0:_fZ_,
             _fX_=_f0_}
          catch(_f1_){var _fX_=0}
          var _fY_=_fX_?982028505:-1003883683;
          createElementSyntax[1] = _fY_;
          continue}
        if(982028505 <= _fW_)
         {var a=new array_length();
          a.push("<",elt.toString());
          opt_iter
           (type,
            function(t){a.push(' type="',caml_js_html_escape(t),'"');return 0});
          opt_iter
           (name,
            function(n){a.push(' name="',caml_js_html_escape(n),'"');return 0});
          a.push(">");
          return doc.createElement(a.join(""))}
        var res=createElement(doc,elt);
        opt_iter(type,function(t){return res.type = t});
        opt_iter(name,function(n){return res.name = n});
        return res}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Dom_html_Canvas_not_available,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var c=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],c.getContext))throw Canvas_not_available;
      return c}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t37
       ?function(e){return e.innerHTML === t37?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var _fV_=tag.toString();
      return e.tagName.toLowerCase() === _fV_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$1(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t37)if(ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function eventRelatedTarget(e)
     {function _fS_(param)
       {var match=caml_js_to_string(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _fT_=function(param){throw [0,Assert_failure,_i_]};
          return caml_call2(Optdef[8],e.fromElement,_fT_)}
        function _fU_(param){throw [0,Assert_failure,_j_]}
        return caml_call2(Optdef[8],e.toElement,_fU_)}
      return caml_call2(Optdef[8],e.relatedTarget,_fS_)}
    function eventAbsolutePosition(e)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              (e.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
              (e.clientY + body.scrollTop | 0) + html.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _fO_(x)
       {function _fQ_(y){return [0,x,y]}
        function _fR_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_fR_,_fQ_)}
      function _fP_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_fP_,_fO_)}
    function elementClientPosition(e)
     {var
       r=e.getBoundingClientRect(),
       body=document$0.body,
       html=document$0.documentElement;
      return [0,
              ((r.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
              ((r.top | 0) - body.clientTop | 0) - html.clientTop | 0]}
    function getDocumentScroll(param)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              body.scrollLeft + html.scrollLeft | 0,
              body.scrollTop + html.scrollTop | 0]}
    function buttonPressed(ev)
     {function _fM_(x){return x}
      function _fN_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_fN_,_fM_)}
    function addMousewheelEventListener(e,h,capt)
     {var d=createDiv(document$0);
      d.setAttribute("onmousewheel","return;");
      if(typeof d.onmousewheel === "function")
       {var
         _fI_=
          handler
           (function(e)
             {function _fK_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_fK_) | 0) / 40 | 0;
              function _fL_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_fL_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListener(e,Event$0[11],_fI_,capt)}
      var
       _fJ_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListener(e,Event$0[12],_fJ_,capt)}
    function f(v)
     {var
       match=caml_js_to_string(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 90;case 1:return 86;default:return 92}}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 91;case 1:return 87;default:return 93}}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        {var switcher$0=param - 12 | 0;
         switch(switcher$0)
          {case 0:return 73;
           case 1:return 83;
           case 21:return 77;
           case 22:return 71;
           case 23:return 69;
           case 24:return 75;
           case 25:return 72;
           case 26:return 76;
           case 27:return 74;
           case 28:return 70;
           case 33:return 68;
           case 34:return 81
           }}
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _fH_=switcher;
        if(67 <= _fH_)
         switch(_fH_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_fH_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return 0 === v?caml_call1(f,value):v}
    function _k_(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _fA_=evt.keyCode;
      function _fB_(_fG_){return run_next(_fA_,try_key_code_normal,_fG_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _fC_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _fx_=evt.keyCode,
           _fC_=function(_fE_){return run_next(_fx_,try_key_code_left,_fE_)};
          break;
         case 1:
          var
           _fy_=evt.keyCode,
           _fC_=function(_fD_){return run_next(_fy_,try_key_code_right,_fD_)};
          break;
         default:
          var
           _fz_=evt.keyCode,
           _fC_=function(_fF_){return run_next(_fz_,try_key_code_numpad,_fF_)}}
      var value=evt.code;
      return _k_
              (_k_
                (_k_
                  (0,
                   function(v)
                    {return 0 === v
                             ?caml_call3(Optdef[7],value,make_unidentified,f)
                             :v}),
                 _fC_),
               _fB_)}
    function char_of_int(value)
     {if(0 < value)
       try
        {var _fv_=[0,caml_call1(Stdlib_uchar[8],value)];return _fv_}
       catch(_fw_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var key=caml_call2(Optdef[8],evt.key,empty_string),match=key.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(key.charCodeAt(0) | 0):0}
    function element$1(_fu_){return _fu_}
    function tagged(e)
     {var tag=caml_js_to_byte_string(e.tagName.toLowerCase());
      if(0 === caml_ml_string_length(tag))return [61,e];
      var match=runtime.caml_string_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _fs_(e){return [0,tagged(e)]}
      function _ft_(param){return 0}
      return caml_call3(Opt[7],e,_ft_,_fs_)}
    function taggedEvent(ev)
     {function _fd_(ev){return [0,ev]}
      function _fe_(param)
       {function _fg_(ev){return [1,ev]}
        function _fh_(param)
         {function _fj_(ev){return [2,ev]}
          function _fk_(param)
           {function _fm_(ev){return [3,ev]}
            function _fn_(param)
             {function _fp_(ev){return [4,ev]}
              function _fq_(param){return [5,ev]}
              var _fr_=popStateEvent(ev);
              return caml_call3(Opt[7],_fr_,_fq_,_fp_)}
            var _fo_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_fo_,_fn_,_fm_)}
          var _fl_=wheelEvent(ev);
          return caml_call3(Opt[7],_fl_,_fk_,_fj_)}
        var _fi_=keyboardEvent(ev);
        return caml_call3(Opt[7],_fi_,_fh_,_fg_)}
      var _ff_=mouseEvent(ev);
      return caml_call3(Opt[7],_ff_,_fe_,_fd_)}
    function opt_taggedEvent(ev)
     {function _fb_(ev){return [0,taggedEvent(ev)]}
      function _fc_(param){return 0}
      return caml_call3(Opt[7],ev,_fc_,_fb_)}
    function stopPropagation(ev)
     {function _e$_(param){return ev.stopPropagation()}
      function _fa_(param){return ev.cancelBubble = true$0}
      return caml_call3(Optdef[7],ev.stopPropagation,_fa_,_e$_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _g_.requestAnimationFrame,
             [0,
              _g_.mozRequestAnimationFrame,
              [0,
               _g_.webkitRequestAnimationFrame,
               [0,
                _g_.oRequestAnimationFrame,
                [0,_g_.msRequestAnimationFrame,0]]]]];
          try
           {var
             _e8_=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(Stdlib_list[33],_e8_,l),
             _e9_=function(callback){return req(callback)};
            return _e9_}
          catch(_e__)
           {_e__ = caml_wrap_exception(_e__);
            if(_e__ === Not_found)
             {var
               now=function(param){return new date_ms().getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0?0:dt;
                last[1] = t;
                _g_.setTimeout(callback,dt$0);
                return 0}}
            throw _e__}});
    function hasPushState(param)
     {return caml_call1(Optdef[5],_g_.history.pushState)}
    function hasPlaceholder(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.placeholder)}
    function hasRequired(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.required)}
    var overflow_limit=2147483e3;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483e3 < step)
         var step$0=overflow_limit,remain=step - 2147483e3;
        else
         var step$0=step,remain=0;
        var cb=remain == 0?callback:function(_e7_){return loop(remain,_e7_)};
        id[1] = [0,_g_.setTimeout(caml_js_wrap_callback(cb),step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _e6_=id[1];
      if(_e6_){var x=_e6_[1];id[1] = 0;return _g_.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Dom_html=
      [0,
       d,
       document$0,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _g_,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListener,
       removeEventListener,
       addMousewheelEventListener,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$1,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1619,Dom_html,"Dom_html");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var _e4_=0 < elt.name.length?1:0,_e5_=_e4_?1 - (elt.disabled | 0):_e4_;
      return _e5_}
    function form_elements(get,form)
     {var length=form.elements.length;
      function _eS_(i)
       {var _e3_=form.elements.item(i);return caml_call1(Opt[10],_e3_)}
      var
       _eT_=caml_call2(Stdlib_array[2],length,_eS_),
       elements=caml_call1(Stdlib_array[11],_eT_);
      function _eU_(param)
       {if(param)
         {var v=param[1],match$3=tagged(v);
          switch(match$3[0])
           {case 31:
             var v$0=match$3[1];
             if(get)var sth=get[1],get$0=sth;else var get$0=0;
             if(have_content(v$0))
              {var
                name$1=caml_js_to_string(v$0.name),
                value=v$0.value,
                match=caml_js_to_byte_string(v$0.type.toLowerCase());
               if(caml_string_notequal(match,cst_checkbox))
                {if(! caml_string_notequal(match,cst_file))
                  {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                   var match$0=caml_call1(Optdef[10],v$0.files);
                   if(match$0)
                    {var list=match$0[1];
                     if(0 === list.length)
                      return [0,[0,name$1,[0,-976970511,""]],0];
                     var match$1=caml_call1(Optdef[10],v$0.multiple);
                     if(match$1)
                      if(0 !== match$1[1])
                       {var
                         _eZ_=function(i){return list.item(i)},
                         _e0_=caml_call2(Stdlib_array[2],list.length,_eZ_),
                         _e1_=caml_call1(Stdlib_array[11],_e0_);
                        return filter_map$0
                                (function(f)
                                  {var match=caml_call1(Opt[10],f);
                                   if(match)
                                    {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                   return 0},
                                 _e1_)}
                     var _eY_=list.item(0),match$2=caml_call1(Opt[10],_eY_);
                     if(match$2)
                      {var file=match$2[1];
                       return [0,[0,name$1,[0,781515420,file]],0]}
                     return 0}
                   return 0}
                 if(caml_string_notequal(match,cst_password))
                  if(caml_string_notequal(match,cst_radio))
                   {if(caml_string_notequal(match,cst_reset))
                     if(caml_string_notequal(match,cst_submit$0))
                      {if(caml_string_notequal(match,cst_text))
                        return [0,[0,name$1,[0,-976970511,value]],0];
                       var switch$0=1,switch$1=0}
                     else
                      var switch$1=1;
                    else
                     var switch$1=1;
                    if(switch$1)return 0}
                  else
                   var switch$0=0;
                 else
                  var switch$0=1;
                 if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
               return v$0.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
             return 0;
            case 48:
             var v$1=match$3[1];
             if(have_content(v$1))
              {var name$0=caml_js_to_string(v$1.name);
               if(v$1.multiple | 0)
                {var
                  _eW_=
                   function(i)
                    {var _e2_=v$1.options.item(i);
                     return caml_call1(Opt[10],_e2_)},
                  options=caml_call2(Stdlib_array[2],v$1.options.length,_eW_),
                  _eX_=caml_call1(Stdlib_array[11],options);
                 return filter_map$0
                         (function(param)
                           {if(param)
                             {var e=param[1];
                              return e.selected | 0
                                      ?[0,[0,name$0,[0,-976970511,e.value]]]
                                      :0}
                            return 0},
                          _eX_)}
               return [0,[0,name$0,[0,-976970511,v$1.value]],0]}
             return 0;
            case 53:
             var v$2=match$3[1];
             if(have_content(v$2))
              {var name=caml_js_to_string(v$2.name);
               return [0,[0,name,[0,-976970511,v$2.value]],0]}
             return 0;
            default:return 0}}
        return 0}
      var
       _eV_=caml_call2(Stdlib_list[17],_eU_,elements),
       contents=caml_call1(Stdlib_list[14],_eV_);
      return contents}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_eQ_=form_elt[2],_eR_=form_elt[1];
      if(781515420 <= _eQ_[1])
       {var file=_eQ_[2];return f.append(_eR_.toString(),file)}
      var s=_eQ_[2];
      return f.append(_eR_.toString(),s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_eN_=form_elements(0,form);
      function _eO_(_eP_){return append(contents,_eP_)}
      caml_call2(Stdlib_list[15],_eO_,_eN_);
      return contents}
    function get_form_contents(form)
     {var _eJ_=form_elements(_l_,form);
      function _eK_(param)
       {var _eL_=param[2],_eM_=param[1];
        if(typeof _eL_ !== "number")
         if(-976970511 === _eL_[1])
          {var s=_eL_[2];return [0,_eM_,caml_js_to_string(s)]}
        throw [0,Assert_failure,_m_]}
      return caml_call2(Stdlib_list[17],_eK_,_eJ_)}
    var
     Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1620,Form,"Form");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$1=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0];
    function create(param)
     {var
       xmlHttpRequest=Unsafe[1].XMLHttpRequest,
       activeXObject=Unsafe[1].activeXObject;
      try
       {var _eE_=new xmlHttpRequest();return _eE_}
      catch(_eF_)
       {try
         {var _eD_=new activeXObject("Msxml2.XMLHTTP");return _eD_}
        catch(_eG_)
         {try
           {var _eC_=new activeXObject("Msxml3.XMLHTTP");return _eC_}
          catch(_eH_)
           {try
             {var _eB_=new activeXObject("Microsoft.XMLHTTP");return _eB_}
            catch(_eI_){throw [0,Assert_failure,_n_]}}}}}
    var XmlHttpRequest=[0,create,Event$1];
    caml_register_global(1621,XmlHttpRequest,"XmlHttpRequest");
    var worker=Unsafe[1].Worker;
    function create$0(script){return new worker(script.toString())}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t37)
       caml_call1(Stdlib[2],cst_Worker_import_scripts_is_undefined);
      var
       _ez_=caml_call1(Stdlib_array[12],scripts),
       _eA_=caml_call2(Stdlib_array[15],caml_js_from_string,_ez_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_eA_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t37)
       caml_call1(Stdlib[2],cst_Worker_onmessage_is_undefined);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return Unsafe[1].onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(msg)
     {if(Unsafe[1].postMessage === t37)
       caml_call1(Stdlib[2],cst_Worker_onmessage_is_undefined$0);
      return Unsafe[1].postMessage(msg)}
    var Worker=[0,create$0,import_scripts,set_onmessage,post_message];
    caml_register_global(1622,Worker,"Worker");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported(param){return caml_call1(Optdef[5],webSocket)}
    var WebSockets=[0,webSocket,webSocket,webSocket,is_supported];
    caml_register_global(1623,WebSockets,"WebSockets");
    var
     defaultContextAttributes=
      {"alpha":true$0,
       "depth":true$0,
       "stencil":false$0,
       "antialias":true$0,
       "premultipliedAlpha":false$0,
       "preserveDrawingBuffer":false$0,
       "preferLowPowerToHighPerformance":false$0,
       "failIfMajorPerformanceCaveat":false$0},
     webglcontextlost=caml_call1(Event$0[73],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[73],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[73],cst_webglcontextcreationerror),
     Event$2=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(c)
     {var ctx=c.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:c.getContext("experimental-webgl")}
    function getContextWithAttributes(c,attribs)
     {var ctx=c.getContext("webgl",attribs);
      return caml_call1(Opt[5],ctx)
              ?ctx
              :c.getContext("experimental-webgl",attribs)}
    var
     WebGL=
      [0,defaultContextAttributes,Event$2,getContext,getContextWithAttributes];
    caml_register_global(1624,WebGL,"WebGL");
    function regexp(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"g")}
    function regexp_case_fold(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"gi")}
    function regexp_with_flag(s,f)
     {var _ey_=caml_call2(Stdlib[17],cst_g,f).toString();
      return new regExp_withFlags(caml_jsbytes_of_string(s),_ey_)}
    function blunt_str_array_get(a,i)
     {function _ex_(param){throw [0,Assert_failure,_o_]}
      return caml_js_to_byte_string(caml_call2(Optdef[8],a[i],_ex_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       _ev_=r.exec(caml_jsbytes_of_string(s)),
       _ew_=caml_call2(Opt[3],_ev_,match_result);
      return caml_call1(Opt[10],_ew_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      function _es_(res){return [0,res.index,res]}
      var
       _et_=r.exec(caml_jsbytes_of_string(s)),
       _eu_=caml_call2(Opt[3],_et_,_es_);
      return caml_call1(Opt[10],_eu_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _er_=caml_call2(Optdef[3],r[i],caml_js_to_byte_string);
      return caml_call1(Optdef[10],_er_)}
    var quote_repl_re=new regExp_withFlags("[$]","g");
    function quote_repl(s)
     {return caml_jsbytes_of_string(s).replace(quote_repl_re,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      var _eq_=quote_repl(s_by);
      return caml_js_to_byte_string(caml_jsbytes_of_string(s).replace(r,_eq_))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=0 === match?0 === match$0?"":"m":0 === match$0?"i":"mi",
       r$0=new regExp_withFlags(r.source,flags),
       _ep_=quote_repl(s_by);
      return caml_js_to_byte_string
              (caml_jsbytes_of_string(s).replace(r$0,_ep_))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(0 <= idx)
         {var
           idx$0=idx - 1 | 0,
           accu$0=[0,blunt_str_array_get(a,idx),accu],
           accu=accu$0,
           idx=idx$0;
          continue}
        return accu}}
    function split(r,s)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r,i))}
    var quote_re=regexp(cst);
    function quote(s)
     {return caml_js_to_byte_string
              (caml_jsbytes_of_string(s).replace(quote_re,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1625,Regexp,"Regexp");
    var Local_exn=[248,cst_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var
     plus_re=regexp_string(cst$0),
     plus_re_js_string=new regExp_withFlags("\\+","g");
    function urldecode_js_string_string(s)
     {plus_re_js_string.lastIndex = 0;
      return caml_js_to_byte_string
              (unescape(s.replace(plus_re_js_string," ")))}
    function urldecode(s)
     {return caml_js_to_byte_string
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$1))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_js_to_byte_string(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_js_to_byte_string(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Url_Not_an_http_protocol,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _en_=caml_call3(Stdlib_string[18],s,i,47),j=_en_}
        catch(_eo_)
         {_eo_ = caml_wrap_exception(_eo_);
          if(_eo_ !== Not_found)throw _eo_;
          var j=l}
        var word=caml_call3(Stdlib_string[4],s,i,j - i | 0);
        return l <= j?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a)
       if(! caml_string_notequal(a[1],cst$2))
        {var _em_=a[2];
         if(! _em_)return 0;
         if(! caml_string_notequal(_em_[1],cst$3))if(! _em_[2])return _p_}
      return a}
    function encode_arguments(l)
     {function _eh_(param)
       {var
         v=param[2],
         n=param[1],
         _ej_=urlencode(0,v),
         _ek_=caml_call2(Stdlib[17],cst$4,_ej_),
         _el_=urlencode(0,n);
        return caml_call2(Stdlib[17],_el_,_ek_)}
      var _ei_=caml_call2(Stdlib_list[17],_eh_,l);
      return caml_call2(Stdlib_string[7],cst$5,_ei_)}
    function decode_arguments_js_string(s)
     {var
       arr=s.split(caml_call2(Stdlib_string[1],1,38).toString()),
       len=arr.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(0 <= idx$0)
           try
            {var
              _d$_=idx$0 - 1 | 0,
              _ea_=
               function(s)
                {function _ef_(param)
                  {var
                    y=param[2],
                    x=param[1],
                    _eg_=urldecode_js_string_string(y);
                   return [0,urldecode_js_string_string(x),_eg_]}
                 var
                  index=
                   s.indexOf(caml_call2(Stdlib_string[1],1,61).toString());
                 if(0 <= index)
                  var
                   _ed_=s.slice(index + 1 | 0),
                   _ee_=[0,s.slice(0,index),_ed_];
                 else
                  var _ee_=t37;
                 return caml_call3(Optdef[7],_ee_,interrupt,_ef_)},
              _eb_=
               aux
                ([0,caml_call3(Optdef[7],arr[idx$0],interrupt,_ea_),acc],_d$_);
             return _eb_}
           catch(_ec_)
            {_ec_ = caml_wrap_exception(_ec_);
             if(_ec_ === Local_exn)
              {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
             throw _ec_}
          return acc}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     url_re=
      new
       regExp_withFlags
       (caml_jsbytes_of_string
         (cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0_9a_zA_Z_0_9A_Fa_f_0_9)),
     file_re=new regExp_withFlags(caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee));
    function url_of_js_string(s)
     {function _dS_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_js_to_byte_string(prot_string.toLowerCase());
        if(caml_string_notequal(match,cst_file$0))
         if(caml_string_notequal(match,cst_file$1))
          {if(caml_string_notequal(match,cst_http))
            if(caml_string_notequal(match,cst_http$0))
             {if(caml_string_notequal(match,cst_https))
               if(caml_string_notequal(match,cst_https$0))
                var switch$0=1,switch$1=0;
               else
                var switch$1=1;
              else
               var switch$1=1;
              if(switch$1)var ssl=1,switch$0=2}
            else
             var switch$0=0;
           else
            var switch$0=0;
           switch(switch$0)
            {case 0:var ssl=0,switch$2=1;break;
             case 1:var switch$2=0;break;
             default:var switch$2=1}
           if(switch$2)
            {var
              _d2_=function(param){return caml_jsbytes_of_string(cst$7)},
              path_str=
               urldecode_js_string_string(caml_call2(Optdef[8],res[6],_d2_)),
              _d3_=function(param){return caml_jsbytes_of_string(cst$8)},
              _d4_=
               urldecode_js_string_string(caml_call2(Optdef[8],res[10],_d3_)),
              _d5_=function(param){return caml_jsbytes_of_string(cst$9)},
              _d6_=
               decode_arguments_js_string(caml_call2(Optdef[8],res[8],_d5_)),
              _d7_=path_of_path_string(path_str),
              _d8_=function(param){return caml_jsbytes_of_string(cst$10)},
              s=caml_js_to_byte_string(caml_call2(Optdef[8],res[4],_d8_)),
              _d9_=
               caml_string_notequal(s,cst$6)?caml_int_of_string(s):ssl?443:80,
              url=
               [0,
                urldecode_js_string_string
                 (caml_call2(Optdef[8],res[2],interrupt)),
                _d9_,
                _d7_,
                path_str,
                _d6_,
                _d4_],
              _d__=ssl?[1,url]:[0,url];
             return [0,_d__]}}
        throw Not_an_http_protocol}
      function _dT_(param)
       {function _dV_(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _dY_(param){return caml_jsbytes_of_string(cst$11)}
          var _dZ_=caml_js_to_byte_string(caml_call2(Optdef[8],res[6],_dY_));
          function _d0_(param){return caml_jsbytes_of_string(cst$12)}
          var
           _d1_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_d0_));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_d1_,_dZ_]]]}
        function _dW_(param){return 0}
        var _dX_=file_re.exec(s);
        return caml_call3(Opt[7],_dX_,_dW_,_dV_)}
      var _dU_=url_re.exec(s);
      return caml_call3(Opt[7],_dU_,_dT_,_dS_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$13))
          var _df_=urlencode(0,frag),_dg_=caml_call2(Stdlib[17],cst$14,_df_);
         else
          var _dg_=cst$21;
         if(args)
          var
           _dh_=encode_arguments(args),
           _di_=caml_call2(Stdlib[17],cst$15,_dh_);
         else
          var _di_=cst$20;
         var
          _dj_=caml_call2(Stdlib[17],_di_,_dg_),
          _dk_=function(x){return urlencode(0,x)},
          _dl_=caml_call2(Stdlib_list[17],_dk_,path),
          _dm_=caml_call2(Stdlib_string[7],cst$16,_dl_),
          _dn_=caml_call2(Stdlib[17],_dm_,_dj_),
          _do_=caml_call2(Stdlib[17],cst$17,_dn_);
         if(80 === port)
          var _dp_=cst$18;
         else
          var
           _dt_=caml_call1(Stdlib[22],port),
           _dp_=caml_call2(Stdlib[17],cst$19,_dt_);
         var
          _dq_=caml_call2(Stdlib[17],_dp_,_do_),
          _dr_=urlencode(0,host),
          _ds_=caml_call2(Stdlib[17],_dr_,_dq_);
         return caml_call2(Stdlib[17],cst_http$1,_ds_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$22))
          var
           _du_=urlencode(0,frag$0),
           _dv_=caml_call2(Stdlib[17],cst$23,_du_);
         else
          var _dv_=cst$30;
         if(args$0)
          var
           _dw_=encode_arguments(args$0),
           _dx_=caml_call2(Stdlib[17],cst$24,_dw_);
         else
          var _dx_=cst$29;
         var
          _dy_=caml_call2(Stdlib[17],_dx_,_dv_),
          _dz_=function(x){return urlencode(0,x)},
          _dA_=caml_call2(Stdlib_list[17],_dz_,path$0),
          _dB_=caml_call2(Stdlib_string[7],cst$25,_dA_),
          _dC_=caml_call2(Stdlib[17],_dB_,_dy_),
          _dD_=caml_call2(Stdlib[17],cst$26,_dC_);
         if(443 === port$0)
          var _dE_=cst$27;
         else
          var
           _dI_=caml_call1(Stdlib[22],port$0),
           _dE_=caml_call2(Stdlib[17],cst$28,_dI_);
         var
          _dF_=caml_call2(Stdlib[17],_dE_,_dD_),
          _dG_=urlencode(0,host$0),
          _dH_=caml_call2(Stdlib[17],_dG_,_dF_);
         return caml_call2(Stdlib[17],cst_https$1,_dH_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$31))
          var
           _dJ_=urlencode(0,frag$1),
           _dK_=caml_call2(Stdlib[17],cst$32,_dJ_);
         else
          var _dK_=cst$36;
         if(args$1)
          var
           _dL_=encode_arguments(args$1),
           _dM_=caml_call2(Stdlib[17],cst$33,_dL_);
         else
          var _dM_=cst$35;
         var
          _dN_=caml_call2(Stdlib[17],_dM_,_dK_),
          _dO_=function(x){return urlencode(0,x)},
          _dP_=caml_call2(Stdlib_list[17],_dO_,path$1),
          _dQ_=caml_call2(Stdlib_string[7],cst$34,_dP_),
          _dR_=caml_call2(Stdlib[17],_dQ_,_dN_);
         return caml_call2(Stdlib[17],cst_file$2,_dR_)}}
    var _q_=caml_call1(Optdef[2],_g_.location);
    if(caml_call1(Optdef[5],_q_))
     var _r_=_g_.location;
    else
     var
      t29="",
      t40=function(param,_de_){return 0},
      t39=function(param,_dd_){return 0},
      t38=function(param){return 0},
      _r_=
       {"href":t29,
        "protocol":t29,
        "host":t29,
        "hostname":t29,
        "port":t29,
        "pathname":t29,
        "search":t29,
        "hash":t29,
        "origin":t37,
        "reload":caml_js_wrap_meth_callback(t38),
        "replace":caml_js_wrap_meth_callback(t39),
        "assign":caml_js_wrap_meth_callback(t40)};
    var
     host=urldecode_js_string_string(_r_.hostname),
     protocol=urldecode_js_string_string(_r_.protocol),
     _s_=0,
     port=
      function(param)
        {try
          {var _db_=[0,caml_int_of_string(caml_js_to_byte_string(_r_.port))];
           return _db_}
         catch(_dc_)
          {_dc_ = caml_wrap_exception(_dc_);
           if(_dc_[1] === Failure)return 0;
           throw _dc_}}
       (_s_),
     path_string=urldecode_js_string_string(_r_.pathname),
     path=path_of_path_string(path_string),
     _t_=_r_.search.charAt(0) === "?"?_r_.search.slice(1):_r_.search,
     arguments$0=decode_arguments_js_string(_t_);
    function get_fragment(param)
     {function _c9_(res){return caml_js_to_string(res[1])}
      function _c__(param){return cst$37}
      var _c$_=new regExp_withFlags("#(.*)"),_da_=_r_.href.match(_c$_);
      return caml_call3(Opt[7],_da_,_c__,_c9_)}
    function set_fragment(s)
     {return _r_.hash = caml_jsbytes_of_string(urlencode(0,s))}
    function get$2(param){return url_of_js_string(_r_.href)}
    function set$0(u)
     {return _r_.href = caml_jsbytes_of_string(string_of_url(u))}
    var
     as_string=urldecode_js_string_string(_r_.href),
     Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$0,
        as_string]];
    caml_register_global(1629,Url,"Url");
    var Lib_version=[0,js_of_ocaml_version,git_version];
    caml_register_global(1630,Lib_version,"Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Stdlib[49],name);
      caml_call2(Stdlib[55],oc,content);
      return caml_call1(Stdlib[65],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_js_to_string(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    var
     unmount=runtime.caml_unmount,
     _u_=runtime.caml_create_file,
     _v_=runtime.caml_read_file_content,
     Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_c8_){return runtime.caml_list_mount_point(_c8_)},
       unmount,
       mount,
       _v_,
       _u_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1631,Sys_js,"Sys_js");
    function empty_mutation_observer_init(param){return {}}
    var mutationObserver=Unsafe[1].MutationObserver;
    function is_supported$0(param)
     {return caml_call1(Optdef[5],mutationObserver)}
    function observe
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var obs=new mutationObserver(caml_js_wrap_callback(f)),cfg={};
      opt_iter(child_list,function(v){return cfg.childList = v});
      opt_iter(attributes,function(v){return cfg.attributes = v});
      opt_iter(character_data,function(v){return cfg.characterData = v});
      opt_iter(subtree,function(v){return cfg.subtree = v});
      opt_iter
       (attribute_old_value,function(v){return cfg.attributeOldValue = v});
      opt_iter
       (character_data_old_value,
        function(v){return cfg.characterDataOldValue = v});
      opt_iter
       (attribute_filter,
        function(l)
         {return cfg.attributeFilter
                 =
                 caml_js_from_array(caml_call1(Stdlib_array[12],l))});
      obs.observe(node,cfg);
      return obs}
    var
     MutationObserver=
      [0,empty_mutation_observer_init,mutationObserver,is_supported$0,observe];
    caml_register_global(1632,MutationObserver,"MutationObserver");
    var obj=Unsafe[1].Object;
    function create$1(param){return new obj()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       key_array=Unsafe[1].Object.keys(t),
       res=[0,0],
       _c4_=key_array.length - 1 | 0,
       _c3_=0;
      if(! (_c4_ < 0))
       {var i=_c3_;
        for(;;)
         {var
           _c5_=function(param){return caml_call1(Stdlib[3],cst_Jstable_keys)},
           key=caml_call2(Optdef[8],key_array[i],_c5_),
           _c6_=res[1];
          res[1] = [0,key.substring(0,key.length - 1 | 0),_c6_];
          var _c7_=i + 1 | 0;
          if(_c4_ !== i){var i=_c7_;continue}
          break}}
      return caml_call1(Stdlib_list[9],res[1])}
    var Jstable=[0,create$1,add$0,remove,find,keys];
    caml_register_global(1633,Jstable,"Jstable");
    var json=runtime.caml_json(0);
    function reviver(this$0,key,value)
     {return typeof value == typeof "foo"?caml_js_to_byte_string(value):value}
    var input_reviver=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(s){return json.parse(s,input_reviver)}
    var mlString_constr=dummy_string.constructor;
    function output_reviver(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value}
    function output(obj){return json.stringify(obj,output_reviver)}
    var Json=[0,output,unsafe_input];
    caml_register_global(1634,Json,"Json");
    function string_of_name(param)
     {var _c2_=param;
      if(74 <= _c2_)
       {if(111 <= _c2_)
         switch(_c2_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_c2_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _c2_)
       switch(_c2_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_c2_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      throw [0,
             Invalid_argument,
             caml_call2(Stdlib[17],s,cst_is_not_a_valid_color_name)]}
    function rgb_of_name(param)
     {var _c1_=param;
      if(74 <= _c1_)
       {if(111 <= _c1_)
         switch(_c1_)
          {case 111:return _bp_;
           case 112:return _bq_;
           case 113:return _br_;
           case 114:return _bs_;
           case 115:return _bt_;
           case 116:return _bu_;
           case 117:return _bv_;
           case 118:return _bw_;
           case 119:return _bx_;
           case 120:return _by_;
           case 121:return _bz_;
           case 122:return _bA_;
           case 123:return _bB_;
           case 124:return _bC_;
           case 125:return _bD_;
           case 126:return _bE_;
           case 127:return _bF_;
           case 128:return _bG_;
           case 129:return _bH_;
           case 130:return _bI_;
           case 131:return _bJ_;
           case 132:return _bK_;
           case 133:return _bL_;
           case 134:return _bM_;
           case 135:return _bN_;
           case 136:return _bO_;
           case 137:return _bP_;
           case 138:return _bQ_;
           case 139:return _bR_;
           case 140:return _bS_;
           case 141:return _bT_;
           case 142:return _bU_;
           case 143:return _bV_;
           case 144:return _bW_;
           case 145:return _bX_;
           default:return _bY_}
        switch(_c1_)
         {case 74:return _aQ_;
          case 75:return _aR_;
          case 76:return _aS_;
          case 77:return _aT_;
          case 78:return _aU_;
          case 79:return _aV_;
          case 80:return _aW_;
          case 81:return _aX_;
          case 82:return _aY_;
          case 83:return _aZ_;
          case 84:return _a0_;
          case 85:return _a1_;
          case 86:return _a2_;
          case 87:return _a3_;
          case 88:return _a4_;
          case 89:return _a5_;
          case 90:return _a6_;
          case 91:return _a7_;
          case 92:return _a8_;
          case 93:return _a9_;
          case 94:return _a__;
          case 95:return _a$_;
          case 96:return _ba_;
          case 97:return _bb_;
          case 98:return _bc_;
          case 99:return _bd_;
          case 100:return _be_;
          case 101:return _bf_;
          case 102:return _bg_;
          case 103:return _bh_;
          case 104:return _bi_;
          case 105:return _bj_;
          case 106:return _bk_;
          case 107:return _bl_;
          case 108:return _bm_;
          case 109:return _bn_;
          default:return _bo_}}
      if(37 <= _c1_)
       switch(_c1_)
        {case 37:return _af_;
         case 38:return _ag_;
         case 39:return _ah_;
         case 40:return _ai_;
         case 41:return _aj_;
         case 42:return _ak_;
         case 43:return _al_;
         case 44:return _am_;
         case 45:return _an_;
         case 46:return _ao_;
         case 47:return _ap_;
         case 48:return _aq_;
         case 49:return _ar_;
         case 50:return _as_;
         case 51:return _at_;
         case 52:return _au_;
         case 53:return _av_;
         case 54:return _aw_;
         case 55:return _ax_;
         case 56:return _ay_;
         case 57:return _az_;
         case 58:return _aA_;
         case 59:return _aB_;
         case 60:return _aC_;
         case 61:return _aD_;
         case 62:return _aE_;
         case 63:return _aF_;
         case 64:return _aG_;
         case 65:return _aH_;
         case 66:return _aI_;
         case 67:return _aJ_;
         case 68:return _aK_;
         case 69:return _aL_;
         case 70:return _aM_;
         case 71:return _aN_;
         case 72:return _aO_;
         default:return _aP_}
      switch(_c1_)
       {case 0:return _w_;
        case 1:return _x_;
        case 2:return _y_;
        case 3:return _z_;
        case 4:return _A_;
        case 5:return _B_;
        case 6:return _C_;
        case 7:return _D_;
        case 8:return _E_;
        case 9:return _F_;
        case 10:return _G_;
        case 11:return _H_;
        case 12:return _I_;
        case 13:return _J_;
        case 14:return _K_;
        case 15:return _L_;
        case 16:return _M_;
        case 17:return _N_;
        case 18:return _O_;
        case 19:return _P_;
        case 20:return _Q_;
        case 21:return _R_;
        case 22:return _S_;
        case 23:return _T_;
        case 24:return _U_;
        case 25:return _V_;
        case 26:return _W_;
        case 27:return _X_;
        case 28:return _Y_;
        case 29:return _Z_;
        case 30:return ___;
        case 31:return _$_;
        case 32:return _aa_;
        case 33:return _ab_;
        case 34:return _ac_;
        case 35:return _ad_;
        default:return _ae_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Stdlib_printf[4],_bZ_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Stdlib_printf[4],_b0_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Stdlib_printf[4],_b1_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Stdlib_printf[4],_b2_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Stdlib_printf[4],_b3_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Stdlib_printf[4],_b4_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var _cY_=i < 0?1:0,_cZ_=_cY_ || (255 < i?1:0);
        if(_cZ_)
         {var _c0_=caml_call1(Stdlib[22],i);
          throw [0,
                 Invalid_argument,
                 caml_call2(Stdlib[17],_c0_,cst_is_out_of_valid_range)]}
        return _cZ_}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Stdlib_printf[4],_b5_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       rgb_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d)),
       rgb_pct_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0)),
       rgba_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d)),
       rgba_pct_re=
        new
         regExp_withFlags
         (caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0)),
       hsl_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d)),
       hsla_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d));
      if(! (rgb_re.test(s) | 0))
       if(! (rgba_re.test(s) | 0))
        if(! (rgb_pct_re.test(s) | 0))
         if(! (rgba_pct_re.test(s) | 0))
          if(! (hsl_re.test(s) | 0))
           if(! (hsla_re.test(s) | 0))
            {if(caml_call2(Stdlib_list[31],caml_js_to_string(s),_b6_))
              return s;
             throw [0,
                    Invalid_argument,
                    caml_call2
                     (Stdlib[17],caml_js_to_string(s),cst_is_not_a_valid_color)]}
      return s}
    function js(c)
     {if(0 === c[0]){var n=c[1];return string_of_name(n).toString()}
      return string_of_t(c).toString()}
    function ml(c)
     {var s=caml_js_to_string(c);
      try
       {var _cO_=[0,name_of_string(s)];return _cO_}
      catch(_cP_)
       {_cP_ = caml_wrap_exception(_cP_);
        if(_cP_[1] === Invalid_argument)
         {var
           fail=
            function(param)
             {throw [0,
                     Invalid_argument,
                     caml_call2(Stdlib[17],s,cst_is_not_a_valid_color$0)]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _cW_=caml_int_of_string(i);return _cW_}
                catch(_cX_)
                 {_cX_ = caml_wrap_exception(_cX_);
                  if(_cX_[1] === Invalid_argument)
                   var s=_cX_[2];
                  else
                   {if(_cX_[1] !== Failure)throw _cX_;var s=_cX_[2]}
                  var
                   _cU_=caml_call2(Stdlib[17],cst$38,s),
                   _cV_=caml_call2(Stdlib[17],i,_cU_);
                  throw [0,
                         Invalid_argument,
                         caml_call2(Stdlib[17],cst_color_conversion_error,_cV_)]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _cS_=caml_float_of_string(f);return _cS_}
              catch(_cT_)
               {_cT_ = caml_wrap_exception(_cT_);
                if(_cT_[1] === Invalid_argument)
                 var s=_cT_[2];
                else
                 {if(_cT_[1] !== Failure)throw _cT_;var s=_cT_[2]}
                var
                 _cQ_=caml_call2(Stdlib[17],cst$39,s),
                 _cR_=caml_call2(Stdlib[17],f,_cQ_);
                throw [0,
                       Invalid_argument,
                       caml_call2(Stdlib[17],cst_color_conversion_error$0,_cR_)]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _cw_=match$0[1];
              if(! caml_string_notequal(_cw_,cst_rgb))
               {if(alpha)return fail(0);
                var _cA_=i_of_s_o(blue),_cB_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_cB_,_cA_]]}
              if(! caml_string_notequal(_cw_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _cx_=f_of_s(a),
                   _cy_=i_of_s_o(blue),
                   _cz_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_cz_,_cy_,_cx_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _cC_=match$2[1];
              if(! caml_string_notequal(_cC_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _cG_=i_of_s_o(blue$0),_cH_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_cH_,_cG_]]}
              if(! caml_string_notequal(_cC_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _cD_=f_of_s(a$0),
                   _cE_=i_of_s_o(blue$0),
                   _cF_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_cF_,_cE_,_cD_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _cI_=match$4[1];
              if(! caml_string_notequal(_cI_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _cM_=i_of_s_o(blue$1),_cN_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_cN_,_cM_]]}
              if(! caml_string_notequal(_cI_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _cJ_=f_of_s(a$1),
                   _cK_=i_of_s_o(blue$1),
                   _cL_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_cL_,_cK_,_cJ_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _cP_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:
          var f=param[1];return caml_call3(Stdlib_printf[4],_b7_,f,cst_em$0);
         case 1:
          var f$0=param[1];
          return caml_call3(Stdlib_printf[4],_b8_,f$0,cst_ex);
         case 2:
          var f$1=param[1];
          return caml_call3(Stdlib_printf[4],_b9_,f$1,cst_px);
         case 3:
          var f$2=param[1];
          return caml_call3(Stdlib_printf[4],_b__,f$2,cst_gd);
         case 4:
          var f$3=param[1];
          return caml_call3(Stdlib_printf[4],_b$_,f$3,cst_rem);
         case 5:
          var f$4=param[1];
          return caml_call3(Stdlib_printf[4],_ca_,f$4,cst_vw);
         case 6:
          var f$5=param[1];
          return caml_call3(Stdlib_printf[4],_cb_,f$5,cst_vh);
         case 7:
          var f$6=param[1];
          return caml_call3(Stdlib_printf[4],_cc_,f$6,cst_vm);
         case 8:
          var f$7=param[1];
          return caml_call3(Stdlib_printf[4],_cd_,f$7,cst_ch);
         case 9:
          var f$8=param[1];
          return caml_call3(Stdlib_printf[4],_ce_,f$8,cst_mm);
         case 10:
          var f$9=param[1];
          return caml_call3(Stdlib_printf[4],_cf_,f$9,cst_cm);
         case 11:
          var f$10=param[1];
          return caml_call3(Stdlib_printf[4],_cg_,f$10,cst_in);
         case 12:
          var f$11=param[1];
          return caml_call3(Stdlib_printf[4],_ch_,f$11,cst_pt);
         default:
          var f$12=param[1];
          return caml_call3(Stdlib_printf[4],_ci_,f$12,cst_pc)}}
    function js$0(t){return string_of_t$0(t).toString()}
    function ml$0(t)
     {var s=caml_js_to_string(t);
      if(runtime.caml_string_equal(s,cst_0$0))return 0;
      function fail(param)
       {throw [0,
               Invalid_argument,
               caml_call2(Stdlib[17],s,cst_is_not_a_valid_length)]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cu_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Invalid_argument)
             {var s$0=exn[2];
              throw [0,
                     Invalid_argument,
                     caml_call2(Stdlib[17],cst_length_conversion_error,s$0)]}
            throw exn}
          var f$0=_cu_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cv_=match$1[1],switch$0=caml_string_compare(_cv_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_cv_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_cv_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_cv_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_cv_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_cv_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_cv_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_cv_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_cv_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_cv_,cst_em$1))return [0,f$0];
            if(! caml_string_notequal(_cv_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_cv_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_cv_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_cv_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:
         var f=param[1];return caml_call3(Stdlib_printf[4],_cj_,f,cst_deg);
        case 1:
         var f$0=param[1];
         return caml_call3(Stdlib_printf[4],_ck_,f$0,cst_grad);
        case 2:
         var f$1=param[1];
         return caml_call3(Stdlib_printf[4],_cl_,f$1,cst_rad);
        default:
         var f$2=param[1];
         return caml_call3(Stdlib_printf[4],_cm_,f$2,cst_turns)}}
    function js$1(t){return string_of_t$1(t).toString()}
    function ml$1(j)
     {var s=caml_js_to_string(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {throw [0,
               Invalid_argument,
               caml_call2(Stdlib[17],s,cst_is_not_a_valid_length$0)]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cs_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Invalid_argument)
             {var s$0=exn[2];
              throw [0,
                     Invalid_argument,
                     caml_call2(Stdlib[17],cst_length_conversion_error$0,s$0)]}
            throw exn}
          var f$0=_cs_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _ct_=match$1[1];
          if(! caml_string_notequal(_ct_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_ct_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_ct_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_ct_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1636,CSS,"CSS");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _cr_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _cr_)}
    var Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global(1637,Dom_events,"Dom_events");
    var
     xmlns="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Dom_svg_SVGError,caml_fresh_oo_id(0)];
    function createElement$0(doc,name)
     {return doc.createElementNS(xmlns,name.toString())}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignobject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createParttern(doc)
     {return unsafeCreateElement$0(doc,cst_parttern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text$0)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$1=Unsafe[1].document;
    function getElementById$0(id)
     {function _co_(e){if(e instanceof svg_element)return e;throw Not_found}
      function _cp_(param){throw Not_found}
      var _cq_=Unsafe[1].document.getElementById(id.toString());
      return caml_call3(Opt[7],_cq_,_cp_,_co_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var _cn_=tag.toString();
      return e.tagName.toLowerCase() === _cn_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject$0)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path$0(e){return unsafeCoerce$0(e,cst_path$0)}
    function parttern(e){return unsafeCoerce$0(e,cst_parttern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$1(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$1)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Dom_svg=
      [0,
       xmlns,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createParttern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$1,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path$0,
        parttern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$1,
        stop,
        style$0,
        svg,
        switch$0,
        symbol,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1638,Dom_svg,"Dom_svg");
    function withCredentials(b)
     {var init={};init.withCredentials = ! ! b;return init}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global(1639,EventSource,"EventSource");
    var console=runtime.caml_js_get_console(0),Firebug=[0,console];
    caml_register_global(1640,Firebug,"Firebug");
    function empty_position_options(param){return {}}
    var
     x=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],x)?x.geolocation:x;
    function is_supported$1(param){return caml_call1(Optdef[5],geolocation)}
    var Geolocation=[0,empty_position_options,geolocation,is_supported$1];
    caml_register_global(1641,Geolocation,"Geolocation");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":false$0,
              "numeric":false$0,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t37,
              "hour12":t37,
              "hourCycle":t37,
              "formatMatcher":"best fit",
              "weekday":t37,
              "era":t37,
              "year":t37,
              "month":t37,
              "day":t37,
              "hour":t37,
              "minute":t37,
              "second":t37,
              "timeZoneName":t37}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t37,
              "currencyDisplay":t37,
              "useGrouping":true$0,
              "minimumIntegerDigits":t37,
              "minimumFractionDigits":t37,
              "maximumFractionDigits":t37,
              "minimumSignificantDigits":t37,
              "maximumSignificantDigits":t37}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     collator_constr=Unsafe[1].Intl.Collator,
     dateTimeFormat_constr=Unsafe[1].Intl.DateTimeFormat,
     numberFormat_constr=Unsafe[1].Intl.NumberFormat,
     pluralRules_constr=Unsafe[1].Intl.PluralRules;
    function is_supported$2(param){return caml_call1(Optdef[5],intl)}
    var
     Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$2];
    caml_register_global(1642,Intl,"Intl");
    var Js_of_ocaml=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    caml_register_global(1643,Js_of_ocaml,"Js_of_ocaml");
    return}
  (function(){return this}()));


//# 1 "../.js/bisect_ppx.runtime/bisect.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_new_string=runtime.caml_new_string,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     value=caml_new_string("1.3.4"),
     cst_exception_reading_data=caml_new_string("exception reading data: "),
     cst_unexpected_end_of_file_while_reading_magic_number=
      caml_new_string("unexpected end of file while reading magic number"),
     cst_bad_magic_number=caml_new_string("bad magic number"),
     cst_Bisect_Common_Invalid_file=
      caml_new_string("Bisect.Common.Invalid_file"),
     cst_Bisect_Common_Unsupported_version=
      caml_new_string("Bisect.Common.Unsupported_version"),
     cst_Bisect_Common_Modified_file=
      caml_new_string("Bisect.Common.Modified_file"),
     cst_BISECT_RTD=caml_new_string("BISECT-RTD"),
     supported_versions=[0,[0,2,0],0],
     format_version=[0,2,0],
     value$0=caml_new_string("out"),
     cst_bisect=caml_new_string("bisect"),
     cst_BISECT_FILE=caml_new_string("BISECT_FILE"),
     cst_bisect_log=caml_new_string("bisect.log"),
     cst_BISECT_SILENT=caml_new_string("BISECT_SILENT"),
     cst_ERR=caml_new_string("ERR"),
     cst_ON=caml_new_string("ON"),
     cst_YES=caml_new_string("YES"),
     cst_Bisect_runtime_was_unable_to_write_file=
      caml_new_string(" *** Bisect runtime was unable to write file."),
     cst_Bisect_runtime_was_unable_to_create_file=
      caml_new_string(" *** Bisect runtime was unable to create file."),
     Stdlib_filename=global_data.Stdlib__filename,
     Stdlib_hashtbl=global_data.Stdlib__hashtbl,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_marshal=global_data.Stdlib__marshal,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib=global_data.Stdlib,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Assert_failure=global_data.Assert_failure,
     End_of_file=global_data.End_of_file,
     Stdlib_bytes=global_data.Stdlib__bytes,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Sys_error=global_data.Sys_error,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_string=global_data.Stdlib__string,
     Not_found=global_data.Not_found,
     Bisect=[0,0,0,0,0];
    caml_register_global(24,Bisect,"Bisect");
    var Bisect_Version=[0,value];
    caml_register_global(25,Bisect_Version,"Bisect__Version");
    var
     _a_=[0,caml_new_string("src/runtime/common.ml"),109,13],
     _e_=[0,1,[0,6,[0,3,[0,5,0]]]],
     _d_=
      [0,[2,0,[4,0,[0,2,4],0,[12,46,[2,0,0]]]],caml_new_string("%s%04d.%s")],
     _b_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")];
    function try_finally(x,f,h)
     {try
       {var res=caml_call1(f,x)}
      catch(e)
       {e = caml_wrap_exception(e);try {caml_call1(h,x)}catch(_P_){}throw e}
      try {caml_call1(h,x)}catch(_O_){}
      return res}
    function try_in_channel(bin,x,f)
     {var open_ch=bin?Stdlib[69]:Stdlib[68],_N_=Stdlib[83];
      return try_finally(caml_call1(open_ch,x),f,_N_)}
    function try_out_channel(bin,x,f)
     {var open_ch=bin?Stdlib[50]:Stdlib[49],_M_=Stdlib[66];
      return try_finally(caml_call1(open_ch,x),f,_M_)}
    var
     Invalid_file=[248,cst_Bisect_Common_Invalid_file,caml_fresh_oo_id(0)],
     Unsupported_version=
      [248,cst_Bisect_Common_Unsupported_version,caml_fresh_oo_id(0)],
     Modified_file=[248,cst_Bisect_Common_Modified_file,caml_fresh_oo_id(0)],
     magic=caml_call1(Stdlib_bytes[5],cst_BISECT_RTD);
    function write_runtime_data(channel,content)
     {var x=caml_call1(Stdlib_array[12],content);
      caml_call2(Stdlib[56],channel,magic);
      caml_call2(Stdlib[61],channel,format_version);
      return caml_call2(Stdlib[61],channel,x)}
    function write_points(points)
     {var points_array=caml_call1(Stdlib_array[12],points);
      caml_call2(Stdlib_array[25],caml_compare,points_array);
      return runtime.caml_output_value_to_string(points_array,0)}
    function read_runtime_data(filename)
     {return try_in_channel
              (1,
               filename,
               function(channel)
                {var
                  magic_length=runtime.caml_ml_bytes_length(magic),
                  file_magic=runtime.caml_create_bytes(magic_length);
                 try
                  {caml_call4(Stdlib[74],channel,file_magic,0,magic_length)}
                 catch(_L_)
                  {_L_ = caml_wrap_exception(_L_);
                   if(_L_ === End_of_file)
                    throw [0,
                           Invalid_file,
                           filename,
                           cst_unexpected_end_of_file_while_reading_magic_number];
                   throw _L_}
                 if(runtime.caml_bytes_equal(file_magic,magic))
                  {var version=caml_call1(Stdlib[78],channel);
                   if(caml_call2(Stdlib_list[31],version,supported_versions))
                    {if(2 === version[1])
                      if(0 === version[2])
                       {try
                         {var file_content=caml_call1(Stdlib[78],channel)}
                        catch(e)
                         {e = caml_wrap_exception(e);
                          var _K_=caml_call1(Stdlib_printexc[1],e);
                          throw [0,
                                 Invalid_file,
                                 filename,
                                 caml_call2(Stdlib[17],cst_exception_reading_data,_K_)]}
                        return caml_call1(Stdlib_array[11],file_content)}
                     throw [0,Assert_failure,_a_]}
                   throw [0,Unsupported_version,filename]}
                 throw [0,Invalid_file,filename,cst_bad_magic_number]})}
    function read_points(s)
     {var points_array=caml_call2(Stdlib_marshal[5],s,0);
      caml_call2(Stdlib_array[25],caml_compare,points_array);
      return caml_call1(Stdlib_array[11],points_array)}
    var points=caml_call2(Stdlib_hashtbl[1],0,17);
    function read_runtime_data$0(filename)
     {var data=read_runtime_data(filename);
      function _I_(param)
       {var
         match=param[2],
         file_points=match[2],
         counts=match[1],
         source_file=param[1],
         basename=caml_call1(Stdlib_filename[12],source_file),
         _J_=read_points(file_points);
        caml_call3(Stdlib_hashtbl[11],points,basename,_J_);
        return [0,source_file,counts]}
      return caml_call2(Stdlib_list[17],_I_,data)}
    function read_points$0(filename)
     {var _H_=caml_call1(Stdlib_filename[12],filename);
      return caml_call2(Stdlib_hashtbl[6],points,_H_)}
    var
     Bisect_Common=
      [0,
       try_finally,
       try_in_channel,
       try_out_channel,
       Invalid_file,
       Unsupported_version,
       Modified_file,
       write_runtime_data,
       write_points,
       read_runtime_data,
       read_points,
       read_runtime_data$0,
       read_points$0];
    caml_register_global(37,Bisect_Common,"Bisect__Common");
    var Bisect_Extension=[0,value$0];
    caml_register_global(38,Bisect_Extension,"Bisect__Extension");
    function string_of_message(param)
     {return 0 === param
              ?cst_Bisect_runtime_was_unable_to_create_file
              :cst_Bisect_runtime_was_unable_to_write_file}
    function full_path(fname)
     {return caml_call1(Stdlib_filename[6],fname)
              ?caml_call2(Stdlib_filename[4],Stdlib_filename[1],fname)
              :fname}
    function env_to_fname(env,default$0)
     {try
       {var _F_=runtime.caml_sys_getenv(env);return _F_}
      catch(_G_)
       {_G_ = caml_wrap_exception(_G_);
        if(_G_ === Not_found)return default$0;
        throw _G_}}
    var
     _c_=
      [246,
       function(_x_)
        {var
          fname=env_to_fname(cst_BISECT_SILENT,cst_bisect_log),
          uc_fname=caml_call1(Stdlib_string[25],fname);
         if(caml_string_notequal(uc_fname,cst_ERR))
          {if(caml_string_notequal(uc_fname,cst_ON))
            if(caml_string_notequal(uc_fname,cst_YES))
             {var
               oc_l=
                [246,
                 function(_C_)
                  {var _D_=full_path(fname),oc=caml_call1(Stdlib[50],_D_);
                   function _E_(param){return caml_call1(Stdlib[66],oc)}
                   caml_call1(Stdlib[89],_E_);
                   return oc}];
              return function(msg)
               {var
                 _A_=caml_obj_tag(oc_l),
                 _z_=string_of_message(msg),
                 _B_=
                  250 === _A_
                   ?oc_l[1]
                   :246 === _A_?caml_call1(CamlinternalLazy[2],oc_l):oc_l;
                return caml_call3(Stdlib_printf[1],_B_,_b_,_z_)}}
           return function(param){return 0}}
         return function(msg)
          {var _y_=string_of_message(msg);return caml_call1(Stdlib[42],_y_)}}];
    function verbose(message)
     {var
       _v_=caml_obj_tag(_c_),
       _w_=
        250 === _v_?_c_[1]:246 === _v_?caml_call1(CamlinternalLazy[2],_c_):_c_;
      return caml_call1(_w_,message)}
    var table=[246,function(_u_){return caml_call2(Stdlib_hashtbl[1],0,17)}];
    function file_channel(param)
     {var
       base_name=full_path(env_to_fname(cst_BISECT_FILE,cst_bisect)),
       suffix=[0,0];
      function next_name(param)
       {suffix[1]++;
        return caml_call4(Stdlib_printf[4],_d_,base_name,suffix[1],value$0)}
      function ic_opt_loop(actual_name)
       {var actual_name$0=actual_name;
        for(;;)
         try
          {var _s_=[0,caml_call3(Stdlib[51],_e_,420,actual_name$0)];
           return _s_}
         catch(_t_)
          {_t_ = caml_wrap_exception(_t_);
           if(_t_[1] === Sys_error)
            {var actual_name$1=next_name(0),actual_name$0=actual_name$1;
             continue}
           verbose(0);
           return 0}}
      var channel_opt=ic_opt_loop(next_name(0));
      return channel_opt}
    function dump_counters_exn(channel)
     {var
       _p_=caml_obj_tag(table),
       _o_=0,
       _q_=
        250 === _p_
         ?table[1]
         :246 === _p_?caml_call1(CamlinternalLazy[2],table):table;
      function _r_(k,v,acc){return [0,[0,k,v],acc]}
      var content=caml_call3(Stdlib_hashtbl[14],_r_,_q_,_o_);
      return write_runtime_data(channel,content)}
    function reset_counters(param)
     {var
       _k_=caml_obj_tag(table),
       _l_=
        250 === _k_
         ?table[1]
         :246 === _k_?caml_call1(CamlinternalLazy[2],table):table;
      function _m_(param,_n_)
       {var point_state=_n_[1],n=point_state.length - 1;
        return 0 === n?0:caml_call4(Stdlib_array[9],point_state,0,n - 1 | 0,0)}
      return caml_call2(Stdlib_hashtbl[12],_m_,_l_)}
    function dump(param)
     {var match=file_channel(0);
      if(match)
       {var channel=match[1];
        try {dump_counters_exn(channel)}catch(_j_){verbose(1)}
        return caml_call1(Stdlib[66],channel)}
      return 0}
    var register_dump=[246,function(_i_){return caml_call1(Stdlib[89],dump)}];
    function register_file(file,point_count,point_definitions)
     {var _f_=caml_obj_tag(register_dump);
      if(250 !== _f_)
       if(246 === _f_)caml_call1(CamlinternalLazy[2],register_dump);
      var
       point_state=runtime.caml_make_vect(point_count,0),
       _g_=caml_obj_tag(table),
       table$0=
        250 === _g_
         ?table[1]
         :246 === _g_?caml_call1(CamlinternalLazy[2],table):table;
      if(1 - caml_call2(Stdlib_hashtbl[9],table$0,file))
       caml_call3
        (Stdlib_hashtbl[5],table$0,file,[0,point_state,point_definitions]);
      return [0,
              981889030,
              function(point_index)
               {var
                 current_count=
                  caml_check_bound(point_state,point_index)[point_index + 1],
                 _h_=
                  current_count < Stdlib[1][7]
                   ?current_count + 1 | 0
                   :current_count;
                return caml_check_bound(point_state,point_index)
                        [point_index + 1]
                       =
                       _h_}]}
    var Bisect_Runtime=[0,register_file,dump_counters_exn,reset_counters];
    caml_register_global(44,Bisect_Runtime,"Bisect__Runtime");
    return}
  (function(){return this}()));


//# 1 "../.js/num.core/nums.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_neg=runtime.caml_int64_neg,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_to_float=runtime.caml_int64_to_float,
     caml_int64_to_int32=runtime.caml_int64_to_int32,
     caml_ldexp_float=runtime.caml_ldexp_float,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_get=runtime.caml_string_get,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_invalid_digit=caml_new_string("invalid digit"),
     cst_number_too_long=caml_new_string("number too long"),
     cst_power_base_int=caml_new_string("power_base_int"),
     cst_nat_of_int=caml_new_string("nat_of_int"),
     cst_int_of_nat=caml_new_string("int_of_nat"),
     cst_make_nat=caml_new_string("make_nat"),
     cst_xor_big_int=caml_new_string("xor_big_int"),
     cst_or_big_int=caml_new_string("or_big_int"),
     cst_and_big_int=caml_new_string("and_big_int"),
     cst_extract_big_int=caml_new_string("extract_big_int"),
     cst_shift_right_big_int=caml_new_string("shift_right_big_int"),
     cst_two_power_m1_big_int=caml_new_string("two_power_m1_big_int"),
     cst_shift_right_towards_zero_big_int=
      caml_new_string("shift_right_towards_zero_big_int"),
     cst_shift_left_big_int=caml_new_string("shift_left_big_int"),
     cst_100000000=caml_new_string("100000000"),
     cst_963295986=caml_new_string("963295986"),
     cst$0=caml_new_string("-"),
     sign=caml_new_string(""),
     cst_e=caml_new_string("e"),
     cst_1=caml_new_string("1."),
     cst_e$0=caml_new_string("e"),
     cst$1=caml_new_string("."),
     cst_sqrt_big_int=caml_new_string("sqrt_big_int"),
     cst_base_power_big_int=caml_new_string("base_power_big_int"),
     cst_base_power_big_int$0=caml_new_string("base_power_big_int"),
     cst_base_power_big_int$1=caml_new_string("base_power_big_int"),
     cst_power_big_int_positive_big_int=
      caml_new_string("power_big_int_positive_big_int"),
     cst_power_int_positive_big_int=
      caml_new_string("power_int_positive_big_int"),
     cst_power_big_int_positive_int=
      caml_new_string("power_big_int_positive_int"),
     cst_power_int_positive_int=caml_new_string("power_int_positive_int"),
     cst_sys_big_int_of_string$1=caml_new_string("sys_big_int_of_string"),
     cst_sys_big_int_of_string$0=caml_new_string("sys_big_int_of_string"),
     cst_sys_big_int_of_string=caml_new_string("sys_big_int_of_string"),
     cst=caml_new_string("-"),
     cst_nat_of_big_int=caml_new_string("nat_of_big_int"),
     cst_int64_of_big_int$1=caml_new_string("int64_of_big_int"),
     cst_int64_of_big_int=caml_new_string("int64_of_big_int"),
     cst_int64_of_big_int$0=caml_new_string("int64_of_big_int"),
     cst_int32_of_big_int=caml_new_string("int32_of_big_int"),
     cst_nativeint_of_big_int=caml_new_string("nativeint_of_big_int"),
     cst_nativeint_of_big_int$0=caml_new_string("nativeint_of_big_int"),
     cst_nativeint_of_big_int$1=caml_new_string("nativeint_of_big_int"),
     cst_int_of_big_int=caml_new_string("int_of_big_int"),
     cst_create_big_int=caml_new_string("create_big_int"),
     cst$5=caml_new_string("/"),
     cst_approx_ratio_exp=caml_new_string("approx_ratio_exp"),
     cst_approx_ratio_exp$0=caml_new_string("approx_ratio_exp"),
     cst_0$0=caml_new_string("+0."),
     cst$4=caml_new_string(""),
     cst_1$1=caml_new_string("-1."),
     cst_1$2=caml_new_string("+1."),
     cst_0$1=caml_new_string("-0."),
     cst_0$2=caml_new_string("+0."),
     cst_approx_ratio_fix=caml_new_string("approx_ratio_fix"),
     cst_0=caml_new_string("+0"),
     cst_1$0=caml_new_string("1"),
     cst_msd_ratio=caml_new_string("msd_ratio"),
     cst_big_int_of_ratio=caml_new_string("big_int_of_ratio"),
     cst_nat_of_ratio$0=caml_new_string("nat_of_ratio"),
     cst_nat_of_ratio=caml_new_string("nat_of_ratio"),
     cst_integer_argument_required=
      caml_new_string("integer argument required"),
     cst_integer_ratio=caml_new_string("integer_ratio"),
     cst_inverse_ratio=caml_new_string("inverse_ratio"),
     cst_create_normalized_ratio=caml_new_string("create_normalized_ratio"),
     cst_create_ratio=caml_new_string("create_ratio"),
     cst$3=caml_new_string(""),
     s=caml_new_string("infinite or undefined rational number"),
     cst$2=caml_new_string(" "),
     cst_num_of_string=caml_new_string("num_of_string"),
     cst_power_num=caml_new_string("power_num"),
     cst_Normalization_during_computation=
      caml_new_string("Normalization during computation"),
     cst_returned_by_get_normalize_ratio=
      caml_new_string("     (returned by get_normalize_ratio ())"),
     cst_modifiable_with_set_normalize_ratio_your_choice=
      caml_new_string
       ("     (modifiable with set_normalize_ratio <your choice>)"),
     cst_Normalization_when_printing=
      caml_new_string("Normalization when printing"),
     cst_returned_by_get_normalize_ratio_when_printing=
      caml_new_string
       ("     (returned by get_normalize_ratio_when_printing ())"),
     cst_modifiable_with_set_normalize_ratio_when_printing_your_choice=
      caml_new_string
       ("     (modifiable with set_normalize_ratio_when_printing <your choice>)"),
     cst_Floating_point_approximation_when_printing_rational_numbers=
      caml_new_string
       ("Floating point approximation when printing rational numbers"),
     cst_returned_by_get_approx_printing=
      caml_new_string("     (returned by get_approx_printing ())"),
     cst_modifiable_with_set_approx_printing_your_choice=
      caml_new_string
       ("     (modifiable with set_approx_printing <your choice>)"),
     cst_Default_precision=caml_new_string("  Default precision = "),
     cst_returned_by_get_floating_precision=
      caml_new_string("     (returned by get_floating_precision ())"),
     cst_modifiable_with_set_floating_precision_your_choice=
      caml_new_string
       ("     (modifiable with set_floating_precision <your choice>)"),
     cst_Error_when_a_rational_denominator_is_null=
      caml_new_string("Error when a rational denominator is null"),
     cst_returned_by_get_error_when_null_denominator=
      caml_new_string("     (returned by get_error_when_null_denominator ())"),
     cst_modifiable_with_set_error_when_null_denominator_your_choice=
      caml_new_string
       ("     (modifiable with set_error_when_null_denominator <your choice>)"),
     cst_ON=caml_new_string("ON"),
     cst_OFF=caml_new_string("OFF"),
     cst$6=caml_new_string(" --> "),
     Stdlib=global_data.Stdlib,
     Stdlib_sys=global_data.Stdlib__sys,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib_char=global_data.Stdlib__char,
     Assert_failure=global_data.Assert_failure,
     Failure=global_data.Failure,
     Out_of_memory=global_data.Out_of_memory,
     Stdlib_int64=global_data.Stdlib__int64,
     Stdlib_nativeint=global_data.Stdlib__nativeint,
     Division_by_zero=global_data.Division_by_zero,
     Not_found=global_data.Not_found,
     _A_=[0,caml_new_string("nat.ml"),273,9],
     _z_=[255,6553600,11973543,3552],
     _y_=[0,caml_new_string("nat.ml"),280,9],
     _x_=[0,caml_new_string("nat.ml"),287,9],
     _w_=[0,caml_new_string("nat.ml"),293,9],
     _v_=[255,6553600,11973543,3552],
     _l_=[0,caml_new_string("big_int.ml"),879,2],
     _k_=[255,1,0,0],
     _j_=[255,16777215,255,0],
     _g_=[255,16777215,255,0],
     _h_=[255,0,0,0],
     _i_=[255,0,0,0],
     _d_=[255,0,0,0],
     _e_=[255,0,0,0],
     _f_=[255,0,0,0],
     _n_=[0,caml_new_string("ratio.ml"),575,11],
     _m_=[0,caml_new_string("e0"),0],
     _r_=[0,1],
     _s_=[0,1],
     _t_=[0,1],
     _o_=[0,1],
     _p_=[0,1],
     _q_=[0,1];
    function gcd_int(i1,i2)
     {var i1$0=i1,i2$0=i2;
      for(;;)
       {if(0 === i2$0)return caml_call1(Stdlib[7],i1$0);
        var i2$1=caml_mod(i1$0,i2$0),i1$0=i2$0,i2$0=i2$1;
        continue}}
    function num_bits_int_aux(n)
     {return 0 === n?0:num_bits_int_aux(n >>> 1 | 0) + 1 | 0}
    function num_bits_int(n){return num_bits_int_aux(caml_call1(Stdlib[7],n))}
    function sign_int(i){return 0 === i?0:0 < i?1:-1}
    var
     length_of_int=Stdlib_sys[10] - 2 | 0,
     monster_int=1 << length_of_int,
     biggest_int=monster_int - 1 | 0,
     least_int=- biggest_int | 0;
    function compare_int(n1,n2)
     {return n1 === n2?0:caml_greaterthan(n1,n2)?1:-1}
    var
     Int_misc=
      [0,
       gcd_int,
       num_bits_int,
       compare_int,
       sign_int,
       length_of_int,
       biggest_int,
       least_int,
       monster_int];
    caml_register_global(122,Int_misc,"Int_misc");
    runtime.initialize_nat(0);
    function length_nat(n){return n.length - 1 - 1 | 0}
    var _a_=Stdlib_sys[10];
    function make_nat(len)
     {if(0 <= len)
       {var res=runtime.create_nat(len);
        runtime.set_to_zero_nat(res,0,len);
        return res}
      return caml_call1(Stdlib[2],cst_make_nat)}
    var a_2=make_nat(2),a_1=make_nat(1),b_2=make_nat(2);
    function copy_nat(nat,off_set,length)
     {var res=runtime.create_nat(length);
      runtime.blit_nat(res,0,nat,off_set,length);
      return res}
    function is_zero_nat(n,off,len)
     {var _dm_=runtime.num_digits_nat(n,off,len);
      return 0 === runtime.compare_nat(make_nat(1),0,1,n,off,_dm_)?1:0}
    function is_nat_int(nat,off,len)
     {var
       _dk_=1 === runtime.num_digits_nat(nat,off,len)?1:0,
       _dl_=_dk_?runtime.is_digit_int(nat,off):_dk_;
      return _dl_}
    function int_of_nat(nat)
     {var len=length_nat(nat);
      return is_nat_int(nat,0,len)
              ?runtime.nth_digit_nat(nat,0)
              :caml_call1(Stdlib[3],cst_int_of_nat)}
    function nat_of_int(i)
     {if(0 <= i)
       {var res=make_nat(1);
        return 0 === i?res:(runtime.set_digit_nat(res,0,i),res)}
      return caml_call1(Stdlib[2],cst_nat_of_int)}
    function eq_nat(nat1,off1,len1,nat2,off2,len2)
     {var _dj_=runtime.num_digits_nat(nat2,off2,len2);
      return 0
              ===
              runtime.compare_nat
               (nat1,
                off1,
                runtime.num_digits_nat(nat1,off1,len1),
                nat2,
                off2,
                _dj_)
              ?1
              :0}
    function le_nat(nat1,off1,len1,nat2,off2,len2)
     {var _di_=runtime.num_digits_nat(nat2,off2,len2);
      return runtime.compare_nat
               (nat1,
                off1,
                runtime.num_digits_nat(nat1,off1,len1),
                nat2,
                off2,
                _di_)
              <=
              0
              ?1
              :0}
    function lt_nat(nat1,off1,len1,nat2,off2,len2)
     {var _dh_=runtime.num_digits_nat(nat2,off2,len2);
      return runtime.compare_nat
               (nat1,
                off1,
                runtime.num_digits_nat(nat1,off1,len1),
                nat2,
                off2,
                _dh_)
              <
              0
              ?1
              :0}
    function ge_nat(nat1,off1,len1,nat2,off2,len2)
     {var _dg_=runtime.num_digits_nat(nat2,off2,len2);
      return 0
              <=
              runtime.compare_nat
               (nat1,
                off1,
                runtime.num_digits_nat(nat1,off1,len1),
                nat2,
                off2,
                _dg_)
              ?1
              :0}
    function gt_nat(nat1,off1,len1,nat2,off2,len2)
     {var _df_=runtime.num_digits_nat(nat2,off2,len2);
      return 0
              <
              runtime.compare_nat
               (nat1,
                off1,
                runtime.num_digits_nat(nat1,off1,len1),
                nat2,
                off2,
                _df_)
              ?1
              :0}
    function exchange(r1,r2)
     {var old1=r1[1];r1[1] = r2[1];r2[1] = old1;return 0}
    function gcd_nat(nat1,off1,len1,nat2,off2,len2)
     {if(is_zero_nat(nat1,off1,len1))
       {runtime.blit_nat(nat1,off1,nat2,off2,len2);return len2}
      var
       copy1=[0,runtime.create_nat(len1 + 1 | 0)],
       copy2=[0,runtime.create_nat(len2 + 1 | 0)];
      runtime.blit_nat(copy1[1],0,nat1,off1,len1);
      runtime.blit_nat(copy2[1],0,nat2,off2,len2);
      runtime.set_digit_nat(copy1[1],len1,0);
      runtime.set_digit_nat(copy2[1],len2,0);
      if(lt_nat(copy1[1],0,len1,copy2[1],0,len2))exchange(copy1,copy2);
      var
       _dd_=length_nat(copy1[1]),
       real_len1=[0,runtime.num_digits_nat(copy1[1],0,_dd_)],
       _de_=length_nat(copy2[1]),
       real_len2=[0,runtime.num_digits_nat(copy2[1],0,_de_)];
      for(;;)
       {if(is_zero_nat(copy2[1],0,real_len2[1]))
         {runtime.blit_nat(nat1,off1,copy1[1],0,real_len1[1]);
          return real_len1[1]}
        runtime.set_digit_nat(copy1[1],real_len1[1],0);
        runtime.div_nat
         (copy1[1],0,real_len1[1] + 1 | 0,copy2[1],0,real_len2[1]);
        exchange(copy1,copy2);
        real_len1[1] = real_len2[1];
        real_len2[1] = runtime.num_digits_nat(copy2[1],0,real_len2[1]);
        continue}}
    function sqrt_nat(rad,off,len)
     {var
       len$0=runtime.num_digits_nat(rad,off,len),
       len_parity=len$0 % 2 | 0,
       rad_len=(len$0 + 1 | 0) + len_parity | 0,
       rad$0=runtime.create_nat(rad_len);
      runtime.blit_nat(rad$0,0,rad,off,len$0);
      runtime.set_digit_nat(rad$0,len$0,0);
      runtime.set_digit_nat(rad$0,rad_len - 1 | 0,0);
      var
       cand_len=(len$0 + 1 | 0) / 2 | 0,
       cand_rest=rad_len - cand_len | 0,
       cand=make_nat(cand_len),
       _dc_=caml_mul(Stdlib_sys[10],len_parity),
       shift_cand=
        (runtime.num_leading_zero_bits_in_digit(rad$0,len$0 - 1 | 0)
         +
         _dc_
         |
         0)
        /
        2
        |
        0;
      if(shift_cand === Stdlib_sys[10])return cand;
      runtime.complement_nat(cand,0,cand_len);
      runtime.shift_right_nat(cand,0,1,a_1,0,shift_cand);
      var next_cand=runtime.create_nat(rad_len);
      for(;;)
       {runtime.blit_nat(next_cand,0,rad$0,0,rad_len);
        runtime.div_nat(next_cand,0,rad_len,cand,0,cand_len);
        runtime.add_nat(next_cand,cand_len,cand_rest,cand,0,cand_len,0);
        runtime.shift_right_nat(next_cand,cand_len,cand_rest,a_1,0,1);
        if(lt_nat(next_cand,cand_len,cand_rest,cand,0,cand_len))
         {runtime.blit_nat(cand,0,next_cand,cand_len,cand_len);continue}
        return cand}}
    var power_base_max=make_nat(2);
    if(32 === _a_)
     runtime.set_digit_nat(power_base_max,0,1e9);
    else
     {if(64 !== _a_)throw [0,Assert_failure,_A_];
      runtime.set_digit_nat(power_base_max,0,caml_int64_to_int32(_z_));
      runtime.mult_digit_nat
       (power_base_max,0,2,power_base_max,0,1,nat_of_int(9),0)}
    if(32 === _a_)
     var _b_=9;
    else
     {if(64 !== _a_)throw [0,Assert_failure,_y_];var _b_=19}
    if(32 === _a_)
     var _c_=9;
    else
     {if(64 !== _a_)throw [0,Assert_failure,_x_];var _c_=18}
    if(32 === _a_)
     var max_power_10_power_in_int=nat_of_int(1e9);
    else
     {if(64 !== _a_)throw [0,Assert_failure,_w_];
      var max_power_10_power_in_int=nat_of_int(caml_int64_to_int32(_v_))}
    function raw_string_of_digit(nat,off)
     {if(is_nat_int(nat,off,1))
       {var _c$_=runtime.nth_digit_nat(nat,off);
        return caml_call1(Stdlib[22],_c$_)}
      runtime.blit_nat(b_2,0,nat,off,1);
      runtime.div_digit_nat(a_2,0,a_1,0,b_2,0,2,max_power_10_power_in_int,0);
      var
       leading_digits=runtime.nth_digit_nat(a_2,0),
       _da_=runtime.nth_digit_nat(a_1,0),
       s1=caml_call1(Stdlib[22],_da_),
       len=caml_ml_string_length(s1);
      if(10 <= leading_digits)
       {var
         result=caml_call2(Stdlib_bytes[1],_c_ + 2 | 0,48),
         _db_=caml_call1(Stdlib[22],leading_digits);
        caml_call5(Stdlib_string[6],_db_,0,result,0,2);
        caml_call5
         (Stdlib_string[6],
          s1,
          0,
          result,
          caml_ml_bytes_length(result) - len | 0,
          len);
        return caml_call1(Stdlib_bytes[6],result)}
      var result$0=caml_call2(Stdlib_bytes[1],_c_ + 1 | 0,48);
      caml_bytes_set
       (result$0,0,caml_call1(Stdlib_char[1],48 + leading_digits | 0));
      caml_call5
       (Stdlib_string[6],
        s1,
        0,
        result$0,
        caml_ml_bytes_length(result$0) - len | 0,
        len);
      return caml_call1(Stdlib_bytes[6],result$0)}
    function make_power_base(base,power_base)
     {var i=[0,0],j=[0,0];
      runtime.set_digit_nat(power_base,0,base);
      for(;;)
       {i[1]++;
        if(runtime.is_digit_zero(power_base,i[1]))
         {runtime.mult_digit_nat
           (power_base,i[1],2,power_base,i[1] - 1 | 0,1,power_base,0);
          continue}
        for(;;)
         {if(j[1] < (i[1] - 1 | 0))
           if(runtime.is_digit_int(power_base,j[1])){j[1]++;continue}
          return [0,i[1] - 2 | 0,j[1]]}}}
    function power_base_int(base,i)
     {if(0 !== i)
       if(1 !== base)
        {if(0 === base)return nat_of_int(0);
         if(0 <= i)
          {var
            power_base=make_nat(_a_ + 1 | 0),
            match=make_power_base(base,power_base),
            pmax=match[1],
            n=caml_div(i,pmax + 1 | 0),
            rem=caml_mod(i,pmax + 1 | 0);
           if(0 < n)
            {var
              newn=i === biggest_int?n:n + 1 | 0,
              res=make_nat(newn),
              res2=make_nat(newn),
              l=num_bits_int(n) - 2 | 0;
             runtime.blit_nat(res,0,power_base,pmax,1);
             if(! (l < 0))
              {var i$0=l;
               for(;;)
                {var
                  len=runtime.num_digits_nat(res,0,newn),
                  len2=caml_call2(Stdlib[5],n,2 * len | 0),
                  succ_len2=len2 + 1 | 0;
                 runtime.square_nat(res2,0,len2,res,0,len);
                 if(0 < (n & 1 << i$0))
                  {runtime.set_to_zero_nat(res,0,len);
                   runtime.mult_digit_nat
                    (res,0,succ_len2,res2,0,len2,power_base,pmax)}
                 else
                  runtime.blit_nat(res,0,res2,0,len2);
                 runtime.set_to_zero_nat(res2,0,len2);
                 var _c__=i$0 - 1 | 0;
                 if(0 !== i$0){var i$0=_c__;continue}
                 break}}
             return 0 < rem
                     ?(runtime.mult_digit_nat
                        (res2,0,newn,res,0,n,power_base,rem - 1 | 0),
                       res2)
                     :res}
           return copy_nat(power_base,rem - 1 | 0,1)}
         return caml_call1(Stdlib[2],cst_power_base_int)}
      return nat_of_int(1)}
    function unadjusted_string_of_nat(nat,off,len_nat)
     {var len=runtime.num_digits_nat(nat,off,len_nat);
      if(1 === len)return raw_string_of_digit(nat,off);
      var
       len_copy=[0,len + 1 | 0],
       copy1=runtime.create_nat(len_copy[1]),
       copy2=make_nat(len_copy[1]),
       rest_digit=make_nat(2);
      if(caml_div(biggest_int,_b_ + 1 | 0) < len)
       return caml_call1(Stdlib[3],cst_number_too_long);
      var
       len_s=caml_mul(_b_ + 1 | 0,len),
       s=caml_call2(Stdlib_bytes[1],len_s,48),
       pos_ref=[0,len_s];
      len_copy[1] = len_copy[1] - 1 | 0;
      runtime.blit_nat(copy1,0,nat,off,len);
      runtime.set_digit_nat(copy1,len,0);
      for(;;)
       {if(is_zero_nat(copy1,0,len_copy[1]))
         return caml_call1(Stdlib_bytes[42],s);
        runtime.div_digit_nat
         (copy2,0,rest_digit,0,copy1,0,len_copy[1] + 1 | 0,power_base_max,0);
        var str=raw_string_of_digit(rest_digit,0);
        caml_call5
         (Stdlib_string[6],
          str,
          0,
          s,
          pos_ref[1] - caml_ml_string_length(str) | 0,
          caml_ml_string_length(str));
        pos_ref[1] = pos_ref[1] - _b_ | 0;
        len_copy[1] = runtime.num_digits_nat(copy2,0,len_copy[1]);
        runtime.blit_nat(copy1,0,copy2,0,len_copy[1]);
        runtime.set_digit_nat(copy1,len_copy[1],0);
        continue}}
    function string_of_nat(nat)
     {var s=unadjusted_string_of_nat(nat,0,length_nat(nat)),index=[0,0];
      try
       {var _c7_=caml_ml_string_length(s) - 2 | 0,_c6_=0;
        if(! (_c7_ < 0))
         {var i=_c6_;
          for(;;)
           {if(48 !== caml_string_get(s,i)){index[1] = i;throw Stdlib[4]}
            var _c8_=i + 1 | 0;
            if(_c7_ !== i){var i=_c8_;continue}
            break}}}
      catch(_c9_)
       {_c9_ = caml_wrap_exception(_c9_);if(_c9_ !== Stdlib[4])throw _c9_}
      return caml_call3
              (Stdlib_string[4],
               s,
               index[1],
               caml_ml_string_length(s) - index[1] | 0)}
    function sys_nat_of_string(base,s,off,len)
     {var
       power_base=make_nat(_a_ + 1 | 0),
       match=make_power_base(base,power_base),
       pint=match[2],
       pmax=match[1],
       _cY_=1 + caml_div(len,pmax + 1 | 0) | 0,
       current_len=[0,1],
       possible_len=[0,caml_call2(Stdlib[5],2,_cY_)],
       nat1=make_nat(_cY_),
       nat2=make_nat(_cY_),
       digits_read=[0,0],
       bound=(off + len | 0) - 1 | 0,
       int$0=[0,0];
      if(! (bound < off))
       {var i=off;
        for(;;)
         {var
           n=caml_string_get(s,i),
           switch$0=
            32 <= n
             ?93 <= n?95 === n?off < i?2:0:0:58 < (n - 33 | 0) >>> 0?1:0
             :11 <= n?13 === n?1:0:9 <= n?1:0;
          switch(switch$0)
           {case 0:
             if(48 <= n)
              if(n <= (47 + caml_call2(Stdlib[5],base,10) | 0))
               var _c5_=n - 48 | 0,switch$1=1;
              else
               var switch$1=0;
             else
              var switch$1=0;
             if(! switch$1)
              {if(65 <= n)
                if(n <= ((65 + base | 0) - 11 | 0))
                 var _c5_=n - 55 | 0,switch$2=1;
                else
                 var switch$2=0;
               else
                var switch$2=0;
               if(! switch$2)
                {if(97 <= n)
                  if(n <= ((97 + base | 0) - 11 | 0))
                   var _c5_=n - 87 | 0,switch$3=1;
                  else
                   var switch$3=0;
                 else
                  var switch$3=0;
                 if(! switch$3)
                  var _c5_=caml_call1(Stdlib[3],cst_invalid_digit)}}
             int$0[1] = caml_mul(int$0[1],base) + _c5_ | 0;
             digits_read[1]++;
             break;
            case 1:break
            }
          var
           _cZ_=digits_read[1] === pint?1:0,
           _c0_=_cZ_ || (i === bound?1:0),
           _c1_=_c0_?1 - (0 === digits_read[1]?1:0):_c0_;
          if(_c1_)
           {runtime.set_digit_nat(nat1,0,int$0[1]);
            var
             erase_len=
              _cY_ === current_len[1]?current_len[1] - 1 | 0:current_len[1],
             _c2_=1;
            if(! (erase_len < 1))
             {var j=_c2_;
              for(;;)
               {runtime.set_digit_nat(nat1,j,0);
                var _c4_=j + 1 | 0;
                if(erase_len !== j){var j=_c4_;continue}
                break}}
            runtime.mult_digit_nat
             (nat1,
              0,
              possible_len[1],
              nat2,
              0,
              current_len[1],
              power_base,
              digits_read[1] - 1 | 0);
            runtime.blit_nat(nat2,0,nat1,0,possible_len[1]);
            current_len[1] = runtime.num_digits_nat(nat1,0,possible_len[1]);
            possible_len[1]
            =
            caml_call2(Stdlib[5],_cY_,current_len[1] + 1 | 0);
            int$0[1] = 0;
            digits_read[1] = 0}
          var _c3_=i + 1 | 0;
          if(bound !== i){var i=_c3_;continue}
          break}}
      var nat=runtime.create_nat(current_len[1]);
      runtime.blit_nat(nat,0,nat1,0,current_len[1]);
      return nat}
    function nat_of_string(s)
     {return sys_nat_of_string(10,s,0,caml_ml_string_length(s))}
    function float_of_nat(nat)
     {return runtime.caml_float_of_string(string_of_nat(nat))}
    var
     Nat=
      [0,
       make_nat,
       copy_nat,
       length_nat,
       is_zero_nat,
       is_nat_int,
       int_of_nat,
       nat_of_int,
       eq_nat,
       le_nat,
       lt_nat,
       ge_nat,
       gt_nat,
       gcd_nat,
       sqrt_nat,
       string_of_nat,
       nat_of_string,
       sys_nat_of_string,
       float_of_nat,
       make_power_base,
       power_base_int,
       _a_];
    caml_register_global(127,Nat,"Nat");
    function sign_big_int(bi){return bi[1]}
    var zero_big_int=[0,0,make_nat(1)],unit_big_int=[0,1,nat_of_int(1)];
    function num_digits_big_int(bi)
     {var _cX_=length_nat(bi[2]);return runtime.num_digits_nat(bi[2],0,_cX_)}
    function num_bits_big_int(bi)
     {var
       _cW_=length_nat(bi[2]),
       nd=runtime.num_digits_nat(bi[2],0,_cW_),
       lz=runtime.num_leading_zero_bits_in_digit(bi[2],nd - 1 | 0);
      return caml_mul(nd,_a_) - lz | 0}
    function minus_big_int(bi)
     {var _cU_=num_digits_big_int(bi),_cV_=copy_nat(bi[2],0,_cU_);
      return [0,- bi[1] | 0,_cV_]}
    function abs_big_int(bi)
     {var
       _cR_=num_digits_big_int(bi),
       _cS_=copy_nat(bi[2],0,_cR_),
       _cT_=0 === bi[1]?0:1;
      return [0,_cT_,_cS_]}
    function compare_big_int(bi1,bi2)
     {if(0 === bi1[1])if(0 === bi2[1])return 0;
      if(bi1[1] < bi2[1])return -1;
      if(bi2[1] < bi1[1])return 1;
      if(1 === bi1[1])
       {var
         _cL_=num_digits_big_int(bi2),
         _cM_=bi2[2],
         _cN_=num_digits_big_int(bi1);
        return runtime.compare_nat(bi1[2],0,_cN_,_cM_,0,_cL_)}
      var
       _cO_=num_digits_big_int(bi1),
       _cP_=bi1[2],
       _cQ_=num_digits_big_int(bi2);
      return runtime.compare_nat(bi2[2],0,_cQ_,_cP_,0,_cO_)}
    function eq_big_int(bi1,bi2){return 0 === compare_big_int(bi1,bi2)?1:0}
    function le_big_int(bi1,bi2){return compare_big_int(bi1,bi2) <= 0?1:0}
    function ge_big_int(bi1,bi2){return 0 <= compare_big_int(bi1,bi2)?1:0}
    function lt_big_int(bi1,bi2){return compare_big_int(bi1,bi2) < 0?1:0}
    function gt_big_int(bi1,bi2){return 0 < compare_big_int(bi1,bi2)?1:0}
    function max_big_int(bi1,bi2){return lt_big_int(bi1,bi2)?bi2:bi1}
    function min_big_int(bi1,bi2){return gt_big_int(bi1,bi2)?bi2:bi1}
    function pred_big_int(bi)
     {var _cJ_=bi[1];
      if(0 === _cJ_)return [0,-1,nat_of_int(1)];
      if(1 === _cJ_)
       {var size_bi=num_digits_big_int(bi),copy_bi=copy_nat(bi[2],0,size_bi);
        runtime.decr_nat(copy_bi,0,size_bi,0);
        var _cK_=is_zero_nat(copy_bi,0,size_bi)?0:1;
        return [0,_cK_,copy_bi]}
      var
       size_bi$0=num_digits_big_int(bi),
       size_res=size_bi$0 + 1 | 0,
       copy_bi$0=runtime.create_nat(size_res);
      runtime.blit_nat(copy_bi$0,0,bi[2],0,size_bi$0);
      runtime.set_digit_nat(copy_bi$0,size_bi$0,0);
      runtime.incr_nat(copy_bi$0,0,size_res,1);
      return [0,-1,copy_bi$0]}
    function succ_big_int(bi)
     {var _cH_=bi[1];
      if(-1 === _cH_)
       {var size_bi=num_digits_big_int(bi),copy_bi=copy_nat(bi[2],0,size_bi);
        runtime.decr_nat(copy_bi,0,size_bi,0);
        var _cI_=is_zero_nat(copy_bi,0,size_bi)?0:-1;
        return [0,_cI_,copy_bi]}
      if(0 === _cH_)return [0,1,nat_of_int(1)];
      var
       size_bi$0=num_digits_big_int(bi),
       size_res=size_bi$0 + 1 | 0,
       copy_bi$0=runtime.create_nat(size_res);
      runtime.blit_nat(copy_bi$0,0,bi[2],0,size_bi$0);
      runtime.set_digit_nat(copy_bi$0,size_bi$0,0);
      runtime.incr_nat(copy_bi$0,0,size_res,1);
      return [0,1,copy_bi$0]}
    function add_big_int(bi1,bi2)
     {var size_bi1=num_digits_big_int(bi1),size_bi2=num_digits_big_int(bi2);
      if(bi1[1] === bi2[1])
       {var match=runtime.compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
        if(-1 === match)
         {var res=runtime.create_nat(size_bi2 + 1 | 0);
          runtime.blit_nat(res,0,bi2[2],0,size_bi2);
          runtime.set_digit_nat(res,size_bi2,0);
          runtime.add_nat(res,0,size_bi2 + 1 | 0,bi1[2],0,size_bi1,0);
          var res$0=res}
        else
         {var res$1=runtime.create_nat(size_bi1 + 1 | 0);
          runtime.blit_nat(res$1,0,bi1[2],0,size_bi1);
          runtime.set_digit_nat(res$1,size_bi1,0);
          runtime.add_nat(res$1,0,size_bi1 + 1 | 0,bi2[2],0,size_bi2,0);
          var res$0=res$1}
        return [0,bi1[1],res$0]}
      var match$0=runtime.compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(0 === match$0)return zero_big_int;
      if(1 === match$0)
       {var res$2=copy_nat(bi1[2],0,size_bi1);
        runtime.sub_nat(res$2,0,size_bi1,bi2[2],0,size_bi2,1);
        return [0,bi1[1],res$2]}
      var res$3=copy_nat(bi2[2],0,size_bi2);
      runtime.sub_nat(res$3,0,size_bi2,bi1[2],0,size_bi1,1);
      return [0,bi2[1],res$3]}
    function big_int_of_int(i)
     {var res=runtime.create_nat(1);
      if(i === monster_int)
       {runtime.set_digit_nat(res,0,biggest_int);runtime.incr_nat(res,0,1,1)}
      else
       runtime.set_digit_nat(res,0,caml_call1(Stdlib[7],i));
      return [0,sign_int(i),res]}
    function add_int_big_int(i,bi){return add_big_int(big_int_of_int(i),bi)}
    function sub_big_int(bi1,bi2){return add_big_int(bi1,minus_big_int(bi2))}
    function mult_int_big_int(i,bi)
     {var size_bi=num_digits_big_int(bi),size_res=size_bi + 1 | 0;
      if(i === monster_int)
       {var res=runtime.create_nat(size_res);
        runtime.blit_nat(res,0,bi[2],0,size_bi);
        runtime.set_digit_nat(res,size_bi,0);
        var _cE_=nat_of_int(biggest_int);
        runtime.mult_digit_nat(res,0,size_res,bi[2],0,size_bi,_cE_,0);
        return [0,- bi[1] | 0,res]}
      var res$0=make_nat(size_res),_cF_=nat_of_int(caml_call1(Stdlib[7],i));
      runtime.mult_digit_nat(res$0,0,size_res,bi[2],0,size_bi,_cF_,0);
      var _cG_=bi[1];
      return [0,caml_mul(sign_int(i),_cG_),res$0]}
    function mult_big_int(bi1,bi2)
     {var
       size_bi1=num_digits_big_int(bi1),
       size_bi2=num_digits_big_int(bi2),
       size_res=size_bi1 + size_bi2 | 0,
       res=make_nat(size_res);
      if(size_bi1 < size_bi2)
       runtime.mult_nat(res,0,size_res,bi2[2],0,size_bi2,bi1[2],0,size_bi1);
      else
       runtime.mult_nat(res,0,size_res,bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      return [0,caml_mul(bi1[1],bi2[1]),res]}
    function quomod_big_int(bi1,bi2)
     {if(0 === bi2[1])throw Division_by_zero;
      var
       size_bi1=num_digits_big_int(bi1),
       size_bi2=num_digits_big_int(bi2),
       match=runtime.compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(-1 === match)
       {if(0 <= bi1[1])return [0,big_int_of_int(0),bi1];
        if(0 <= bi2[1])
         {var _cx_=add_big_int(bi2,bi1);return [0,big_int_of_int(-1),_cx_]}
        var _cy_=sub_big_int(bi1,bi2);
        return [0,big_int_of_int(1),_cy_]}
      if(0 === match)
       return [0,big_int_of_int(caml_mul(bi1[1],bi2[1])),zero_big_int];
      var
       bi1_negatif=-1 === bi1[1]?1:0,
       _cz_=
        bi1_negatif
         ?caml_call2(Stdlib[6],(size_bi1 - size_bi2 | 0) + 1 | 0,1) + 1 | 0
         :caml_call2(Stdlib[6],(size_bi1 - size_bi2 | 0) + 1 | 0,1),
       size_r=caml_call2(Stdlib[6],size_bi1,size_bi2) + 1 | 0,
       q=runtime.create_nat(_cz_),
       r=runtime.create_nat(size_r);
      runtime.blit_nat(r,0,bi1[2],0,size_bi1);
      runtime.set_to_zero_nat(r,size_bi1,size_r - size_bi1 | 0);
      runtime.div_nat(r,0,size_r,bi2[2],0,size_bi2);
      runtime.blit_nat(q,0,r,size_bi2,size_r - size_bi2 | 0);
      var not_null_mod=1 - is_zero_nat(r,0,size_bi2);
      if(bi1_negatif)
       if(not_null_mod)
        {var new_r=copy_nat(bi2[2],0,size_bi2);
         runtime.sub_nat(new_r,0,size_bi2,r,0,size_bi2,1);
         runtime.set_digit_nat(q,_cz_ - 1 | 0,0);
         runtime.incr_nat(q,0,_cz_,1);
         return [0,[0,- bi2[1] | 0,q],[0,1,new_r]]}
      if(bi1_negatif)runtime.set_digit_nat(q,_cz_ - 1 | 0,0);
      var
       _cA_=copy_nat(r,0,size_bi2),
       _cB_=not_null_mod?1:0,
       _cC_=[0,_cB_,_cA_],
       _cD_=is_zero_nat(q,0,_cz_)?0:caml_mul(bi1[1],bi2[1]);
      return [0,[0,_cD_,q],_cC_]}
    function div_big_int(bi1,bi2){return quomod_big_int(bi1,bi2)[1]}
    function mod_big_int(bi1,bi2){return quomod_big_int(bi1,bi2)[2]}
    function gcd_big_int(bi1,bi2)
     {var size_bi1=num_digits_big_int(bi1),size_bi2=num_digits_big_int(bi2);
      if(is_zero_nat(bi1[2],0,size_bi1))return abs_big_int(bi2);
      if(is_zero_nat(bi2[2],0,size_bi2))return [0,1,bi1[2]];
      var match=runtime.compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(0 === match)
       var _cw_=bi1[2];
      else
       if(1 === match)
        var
         res=copy_nat(bi1[2],0,size_bi1),
         len=gcd_nat(res,0,size_bi1,bi2[2],0,size_bi2),
         _cw_=copy_nat(res,0,len);
       else
        var
         res$0=copy_nat(bi2[2],0,size_bi2),
         len$0=gcd_nat(res$0,0,size_bi2,bi1[2],0,size_bi1),
         _cw_=copy_nat(res$0,0,len$0);
      return [0,1,_cw_]}
    var
     monster_big_int=big_int_of_int(monster_int),
     monster_nat=monster_big_int[2];
    function is_int_big_int(bi)
     {var _cu_=1 === num_digits_big_int(bi)?1:0;
      if(_cu_)
       {var match=runtime.compare_nat(bi[2],0,1,monster_nat,0,1);
        if(-1 !== match)return 0 === match?-1 === bi[1]?1:0:0;
        var _cv_=1}
      else
       var _cv_=_cu_;
      return _cv_}
    function int_of_big_int(bi)
     {try
       {var n=int_of_nat(bi[2]),_cs_=-1 === bi[1]?- n | 0:n;return _cs_}
      catch(_ct_)
       {_ct_ = caml_wrap_exception(_ct_);
        if(_ct_[1] === Failure)
         return eq_big_int(bi,monster_big_int)
                 ?monster_int
                 :caml_call1(Stdlib[3],cst_int_of_big_int);
        throw _ct_}}
    function int_of_big_int_opt(bi)
     {try
       {var _cq_=[0,int_of_big_int(bi)];return _cq_}
      catch(_cr_)
       {_cr_ = caml_wrap_exception(_cr_);
        if(_cr_[1] === Failure)return 0;
        throw _cr_}}
    function big_int_of_nativeint(i)
     {if(caml_equal(i,0))return zero_big_int;
      if(caml_greaterthan(i,0))
       {var res=runtime.create_nat(1);
        runtime.set_digit_nat_native(res,0,i);
        return [0,1,res]}
      var res$0=runtime.create_nat(1);
      runtime.set_digit_nat_native(res$0,0,- i | 0);
      return [0,-1,res$0]}
    function nativeint_of_big_int(bi)
     {if(1 < num_digits_big_int(bi))
       caml_call1(Stdlib[3],cst_nativeint_of_big_int);
      var i=runtime.nth_digit_nat_native(bi[2],0);
      if(0 <= bi[1])
       return caml_greaterequal(i,0)
               ?i
               :caml_call1(Stdlib[3],cst_nativeint_of_big_int$0);
      if(! caml_greaterequal(i,0))
       if(! caml_equal(i,Stdlib_nativeint[9]))
        return caml_call1(Stdlib[3],cst_nativeint_of_big_int$1);
      return - i | 0}
    function nativeint_of_big_int_opt(bi)
     {try
       {var _co_=[0,nativeint_of_big_int(bi)];return _co_}
      catch(_cp_)
       {_cp_ = caml_wrap_exception(_cp_);
        if(_cp_[1] === Failure)return 0;
        throw _cp_}}
    function big_int_of_int32(i){return big_int_of_nativeint(i)}
    function int32_of_big_int(bi)
     {var i=nativeint_of_big_int(bi);
      if(runtime.caml_lessequal(i,2147483647))
       if(caml_greaterequal(i,-2147483648))return i;
      return caml_call1(Stdlib[3],cst_int32_of_big_int)}
    function int32_of_big_int_opt(bi)
     {try
       {var _cm_=[0,int32_of_big_int(bi)];return _cm_}
      catch(_cn_)
       {_cn_ = caml_wrap_exception(_cn_);
        if(_cn_[1] === Failure)return 0;
        throw _cn_}}
    function big_int_of_int64(i)
     {if(64 === Stdlib_sys[10])
       return big_int_of_nativeint(caml_int64_to_int32(i));
      if(caml_equal(i,_d_))
       var sg=0,absi=_e_;
      else
       if(caml_greaterthan(i,_f_))
        var sg=1,absi=i;
       else
        var absi$0=caml_int64_neg(i),sg=-1,absi=absi$0;
      var res=runtime.create_nat(2);
      runtime.set_digit_nat_native(res,0,caml_int64_to_int32(absi));
      runtime.set_digit_nat_native
       (res,1,caml_int64_to_int32(runtime.caml_int64_shift_right(absi,32)));
      return [0,sg,res]}
    function int64_of_big_int(bi)
     {if(64 === Stdlib_sys[10])
       return caml_int64_of_int32(nativeint_of_big_int(bi));
      var match=num_digits_big_int(bi);
      if(1 === match)
       var
        i=
         caml_int64_and
          (caml_int64_of_int32(runtime.nth_digit_nat_native(bi[2],0)),_g_);
      else
       if(2 === match)
        var
         _cl_=
          runtime.caml_int64_shift_left
           (caml_int64_of_int32(runtime.nth_digit_nat_native(bi[2],1)),32),
         i=
          caml_int64_or
           (caml_int64_and
             (caml_int64_of_int32(runtime.nth_digit_nat_native(bi[2],0)),_j_),
            _cl_);
       else
        var i=caml_call1(Stdlib[3],cst_int64_of_big_int$1);
      if(0 <= bi[1])
       return caml_greaterequal(i,_h_)
               ?i
               :caml_call1(Stdlib[3],cst_int64_of_big_int);
      if(! caml_greaterequal(i,_i_))
       if(! caml_equal(i,Stdlib_int64[8]))
        return caml_call1(Stdlib[3],cst_int64_of_big_int$0);
      return caml_int64_neg(i)}
    function int64_of_big_int_opt(bi)
     {try
       {var _cj_=[0,int64_of_big_int(bi)];return _cj_}
      catch(_ck_)
       {_ck_ = caml_wrap_exception(_ck_);
        if(_ck_[1] === Failure)return 0;
        throw _ck_}}
    function nat_of_big_int(bi)
     {if(-1 === bi[1])return caml_call1(Stdlib[3],cst_nat_of_big_int);
      var _ci_=num_digits_big_int(bi);
      return copy_nat(bi[2],0,_ci_)}
    function sys_big_int_of_nat(nat,off,len)
     {var
       length=runtime.num_digits_nat(nat,off,len),
       _cg_=copy_nat(nat,off,length),
       _ch_=is_zero_nat(nat,off,length)?0:1;
      return [0,_ch_,_cg_]}
    function big_int_of_nat(nat)
     {return sys_big_int_of_nat(nat,0,length_nat(nat))}
    function string_of_big_int(bi)
     {if(-1 === bi[1])
       {var _cf_=string_of_nat(bi[2]);return caml_call2(Stdlib[17],cst,_cf_)}
      return string_of_nat(bi[2])}
    function sys_big_int_of_string_aux(s,ofs,len,sgn,base)
     {if(len < 1)caml_call1(Stdlib[3],cst_sys_big_int_of_string);
      var n=sys_nat_of_string(base,s,ofs,len);
      return is_zero_nat(n,0,length_nat(n))?zero_big_int:[0,sgn,n]}
    function sys_big_int_of_string_base(s,ofs,len,sgn)
     {if(len < 1)caml_call1(Stdlib[3],cst_sys_big_int_of_string$0);
      if(2 <= len)
       {var
         match=caml_string_get(s,ofs),
         match$0=caml_string_get(s,ofs + 1 | 0);
        if(48 === match)
         {var
           switch$0=
            89 <= match$0
             ?98 === match$0?3:111 === match$0?2:120 === match$0?1:0
             :66 === match$0?3:79 === match$0?2:88 <= match$0?1:0;
          switch(switch$0)
           {case 0:break;
            case 1:
             return sys_big_int_of_string_aux
                     (s,ofs + 2 | 0,len - 2 | 0,sgn,16);
            case 2:
             return sys_big_int_of_string_aux(s,ofs + 2 | 0,len - 2 | 0,sgn,8);
            default:
             return sys_big_int_of_string_aux(s,ofs + 2 | 0,len - 2 | 0,sgn,2)}}
        return sys_big_int_of_string_aux(s,ofs,len,sgn,10)}
      return sys_big_int_of_string_aux(s,ofs,len,sgn,10)}
    function sys_big_int_of_string(s,ofs,len)
     {if(len < 1)caml_call1(Stdlib[3],cst_sys_big_int_of_string$1);
      var match=caml_string_get(s,ofs),switcher=match - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return sys_big_int_of_string_base(s,ofs + 1 | 0,len - 1 | 0,1);
         case 1:break;
         default:
          return sys_big_int_of_string_base(s,ofs + 1 | 0,len - 1 | 0,-1)}
      return sys_big_int_of_string_base(s,ofs,len,1)}
    function big_int_of_string(s)
     {return sys_big_int_of_string(s,0,caml_ml_string_length(s))}
    function big_int_of_string_opt(s)
     {try
       {var _cd_=[0,big_int_of_string(s)];return _cd_}
      catch(_ce_)
       {_ce_ = caml_wrap_exception(_ce_);
        if(_ce_[1] === Failure)return 0;
        throw _ce_}}
    function power_int_positive_int(i,n)
     {var match=sign_int(n);
      if(-1 === match)return caml_call1(Stdlib[2],cst_power_int_positive_int);
      if(0 === match)return unit_big_int;
      var
       nat=power_base_int(caml_call1(Stdlib[7],i),n),
       _cc_=0 <= i?sign_int(i):0 === (n & 1)?1:-1;
      return [0,_cc_,nat]}
    function power_big_int_positive_int(bi,n)
     {var match=sign_int(n);
      if(-1 === match)
       return caml_call1(Stdlib[2],cst_power_big_int_positive_int);
      if(0 === match)return unit_big_int;
      var
       bi_len=num_digits_big_int(bi),
       res_len=caml_mul(bi_len,n),
       res=make_nat(res_len),
       res2=make_nat(res_len),
       l=num_bits_int(n) - 2 | 0;
      runtime.blit_nat(res,0,bi[2],0,bi_len);
      if(! (l < 0))
       {var i=l;
        for(;;)
         {var
           len=runtime.num_digits_nat(res,0,res_len),
           len2=caml_call2(Stdlib[5],res_len,2 * len | 0);
          runtime.set_to_zero_nat(res2,0,len2);
          runtime.square_nat(res2,0,len2,res,0,len);
          if(0 < (n & 1 << i))
           {var lenp=caml_call2(Stdlib[5],res_len,len2 + bi_len | 0);
            runtime.set_to_zero_nat(res,0,lenp);
            runtime.mult_nat(res,0,lenp,res2,0,len2,bi[2],0,bi_len)}
          else
           runtime.blit_nat(res,0,res2,0,len2);
          var _cb_=i - 1 | 0;
          if(0 !== i){var i=_cb_;continue}
          break}}
      var _ca_=0 <= bi[1]?bi[1]:0 === (n & 1)?1:-1;
      return [0,_ca_,res]}
    function power_int_positive_big_int(i$0,bi)
     {var match$1=bi[1];
      if(-1 === match$1)
       return caml_call1(Stdlib[2],cst_power_int_positive_big_int);
      if(0 === match$1)return unit_big_int;
      var
       len$0=num_digits_big_int(bi),
       _b__=bi[2],
       base=caml_call1(Stdlib[7],i$0),
       off=0;
      if(0 === base)
       var nat=nat_of_int(0);
      else
       {if(is_zero_nat(_b__,off,len$0))
         var switch$0=0;
        else
         if(1 === base)
          var switch$0=0;
         else
          {var
            power_base=make_nat(_a_ + 1 | 0),
            match=make_power_base(base,power_base),
            pmax=match[1],
            _b8_=big_int_of_int(pmax + 1 | 0),
            match$0=quomod_big_int(sys_big_int_of_nat(_b__,off,len$0),_b8_),
            y=match$0[2],
            x=match$0[1],
            rem=int_of_big_int(y),
            n=int_of_big_int(x);
           if(0 === n)
            var nat=copy_nat(power_base,rem - 1 | 0,1),switch$0=1;
           else
            {var
              res=make_nat(n),
              res2=make_nat(n + 1 | 0),
              l=num_bits_int(n) - 2 | 0;
             runtime.blit_nat(res,0,power_base,pmax,1);
             if(! (l < 0))
              {var i=l;
               for(;;)
                {var
                  len=runtime.num_digits_nat(res,0,n),
                  len2=caml_call2(Stdlib[5],n,2 * len | 0),
                  succ_len2=len2 + 1 | 0;
                 runtime.square_nat(res2,0,len2,res,0,len);
                 if(0 < (n & 1 << i))
                  {runtime.set_to_zero_nat(res,0,len);
                   runtime.mult_digit_nat
                    (res,0,succ_len2,res2,0,len2,power_base,pmax)}
                 else
                  runtime.blit_nat(res,0,res2,0,len2);
                 runtime.set_to_zero_nat(res2,0,len2);
                 var _b9_=i - 1 | 0;
                 if(0 !== i){var i=_b9_;continue}
                 break}}
             if(0 < rem)
              {runtime.mult_digit_nat
                (res2,0,n + 1 | 0,res,0,n,power_base,rem - 1 | 0);
               var nat=res2,switch$0=1}
             else
              var nat=res,switch$0=1}}
        if(! switch$0)var nat=nat_of_int(1)}
      var _b$_=0 <= i$0?sign_int(i$0):runtime.is_digit_odd(bi[2],0)?-1:1;
      return [0,_b$_,nat]}
    function power_big_int_positive_big_int(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       return caml_call1(Stdlib[2],cst_power_big_int_positive_big_int);
      if(0 === match)return unit_big_int;
      try
       {var _b5_=power_big_int_positive_int(bi1,int_of_big_int(bi2));
        return _b5_}
      catch(_b6_)
       {_b6_ = caml_wrap_exception(_b6_);
        if(_b6_[1] === Failure)
         try
          {var _b4_=power_int_positive_big_int(int_of_big_int(bi1),bi2);
           return _b4_}
         catch(_b7_)
          {_b7_ = caml_wrap_exception(_b7_);
           if(_b7_[1] === Failure)throw Out_of_memory;
           throw _b7_}
        throw _b6_}}
    function base_power_big_int(base,n,bi)
     {var match=sign_int(n);
      if(-1 === match)
       {var
         nat=power_base_int(base,- n | 0),
         len_nat=runtime.num_digits_nat(nat,0,length_nat(nat)),
         len_bi=num_digits_big_int(bi);
        if(len_bi < len_nat)
         return caml_call1(Stdlib[2],cst_base_power_big_int);
        if(len_bi === len_nat)
         if(-1 === runtime.compare_digits_nat(bi[2],len_bi,nat,len_nat))
          return caml_call1(Stdlib[2],cst_base_power_big_int$0);
        var copy=runtime.create_nat(len_bi + 1 | 0);
        runtime.blit_nat(copy,0,bi[2],0,len_bi);
        runtime.set_digit_nat(copy,len_bi,0);
        runtime.div_nat(copy,0,len_bi + 1 | 0,nat,0,len_nat);
        if(is_zero_nat(copy,0,len_nat))
         {var _b2_=copy_nat(copy,len_nat,1);return [0,bi[1],_b2_]}
        return caml_call1(Stdlib[2],cst_base_power_big_int$1)}
      if(0 === match)return bi;
      var
       nat$0=power_base_int(base,n),
       len_nat$0=runtime.num_digits_nat(nat$0,0,length_nat(nat$0)),
       len_bi$0=num_digits_big_int(bi),
       new_len=len_bi$0 + len_nat$0 | 0,
       nat$1=make_nat(new_len);
      if(len_nat$0 < len_bi$0)
       runtime.mult_nat(nat$1,0,new_len,bi[2],0,len_bi$0,nat$0,0,len_nat$0);
      else
       runtime.mult_nat(nat$1,0,new_len,nat$0,0,len_nat$0,bi[2],0,len_bi$0);
      if(is_zero_nat(nat$1,0,new_len))return zero_big_int;
      var _b3_=bi[1];
      if(1 !== _b3_)
       if(-1 !== _b3_)
        {var
          switch$0=
           0 === _b3_
            ?is_zero_nat
               (nat$1,0,runtime.num_digits_nat(nat$1,0,length_nat(nat$1)))
              ?0
              :1
            :1;
         if(switch$0)return caml_call1(Stdlib[2],cst_create_big_int)}
      return [0,_b3_,nat$1]}
    function sqrt_big_int(bi)
     {var _b0_=bi[1];
      if(-1 === _b0_)return caml_call1(Stdlib[2],cst_sqrt_big_int);
      if(0 === _b0_)return zero_big_int;
      var _b1_=num_digits_big_int(bi);
      return [0,1,sqrt_nat(bi[2],0,_b1_)]}
    function square_big_int(bi)
     {if(0 === bi[1])return zero_big_int;
      var
       len_bi=num_digits_big_int(bi),
       len_res=2 * len_bi | 0,
       res=make_nat(len_res);
      runtime.square_nat(res,0,len_res,bi[2],0,len_bi);
      return [0,1,res]}
    function round_futur_last_digit(s,off_set,length)
     {var l=(length + off_set | 0) - 1 | 0;
      if(53 <= caml_bytes_get(s,l))
       {var l$2=l - 1 | 0,l$0=l$2;
        for(;;)
         {if(l$0 < off_set)return 1;
          var current_char=caml_bytes_get(s,l$0);
          if(57 === current_char)
           {caml_bytes_set(s,l$0,48);var l$1=l$0 - 1 | 0,l$0=l$1;continue}
          caml_bytes_set
           (s,l$0,caml_call1(Stdlib_char[1],current_char + 1 | 0));
          return 0}}
      return 0}
    function approx_big_int(prec,bi)
     {var
       len_bi=num_digits_big_int(bi),
       _bK_=big_int_of_string(cst_100000000),
       _bL_=big_int_of_string(cst_963295986),
       _bM_=
        int_of_big_int
         (add_int_big_int
           (- prec | 0,
            div_big_int
             (mult_big_int(big_int_of_int(len_bi - 1 | 0),_bL_),_bK_))),
       n=caml_call2(Stdlib[6],0,_bM_),
       _bN_=string_of_big_int(div_big_int(bi,power_int_positive_int(10,n))),
       s=caml_call1(Stdlib_bytes[43],_bN_);
      if(45 === caml_bytes_get(s,0))
       var sign$0=cst$0,off=1;
      else
       var sign$0=sign,off=0;
      if(round_futur_last_digit(s,off,prec + 1 | 0))
       {var
         _bO_=
          caml_call1
           (Stdlib[22],((n + 1 | 0) - off | 0) + caml_ml_bytes_length(s) | 0),
         _bP_=caml_call2(Stdlib[17],cst_e,_bO_),
         _bQ_=caml_call2(Stdlib_string[1],prec,48),
         _bR_=caml_call2(Stdlib[17],_bQ_,_bP_),
         _bS_=caml_call2(Stdlib[17],cst_1,_bR_);
        return caml_call2(Stdlib[17],sign$0,_bS_)}
      var
       _bT_=
        caml_call1
         (Stdlib[22],(n - (off + 1 | 0) | 0) + caml_ml_bytes_length(s) | 0),
       _bU_=caml_call2(Stdlib[17],cst_e$0,_bT_),
       _bV_=caml_call3(Stdlib_bytes[8],s,off + 1 | 0,prec - 1 | 0),
       _bW_=caml_call2(Stdlib[17],_bV_,_bU_),
       _bX_=caml_call2(Stdlib[17],cst$1,_bW_),
       _bY_=caml_call3(Stdlib_bytes[8],s,off,1),
       _bZ_=caml_call2(Stdlib[17],_bY_,_bX_);
      return caml_call2(Stdlib[17],sign$0,_bZ_)}
    function shift_left_big_int(bi,n)
     {if(0 <= n)
       {if(0 === n)return bi;
        if(0 === bi[1])return bi;
        var
         size_bi=num_digits_big_int(bi),
         size_res=size_bi + caml_div((n + _a_ | 0) - 1 | 0,_a_) | 0,
         res=runtime.create_nat(size_res),
         ndigits=caml_div(n,_a_);
        runtime.set_to_zero_nat(res,0,ndigits);
        runtime.blit_nat(res,ndigits,bi[2],0,size_bi);
        var nbits=caml_mod(n,_a_);
        if(0 < nbits)
         runtime.shift_left_nat
          (res,ndigits,size_bi,res,ndigits + size_bi | 0,nbits);
        return [0,bi[1],res]}
      return caml_call1(Stdlib[2],cst_shift_left_big_int)}
    function shift_right_towards_zero_big_int(bi,n)
     {if(0 <= n)
       {if(0 === n)return bi;
        if(0 === bi[1])return bi;
        var
         size_bi=num_digits_big_int(bi),
         ndigits=caml_div(n,_a_),
         nbits=caml_mod(n,_a_);
        if(size_bi <= ndigits)return zero_big_int;
        var size_res=size_bi - ndigits | 0,res=runtime.create_nat(size_res);
        runtime.blit_nat(res,0,bi[2],ndigits,size_res);
        if(0 < nbits)
         {var tmp=runtime.create_nat(1);
          runtime.shift_right_nat(res,0,size_res,tmp,0,nbits)}
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,bi[1],res]}
      return caml_call1(Stdlib[2],cst_shift_right_towards_zero_big_int)}
    function shift_right_big_int(bi,n)
     {if(0 <= n)
       {if(0 <= bi[1])return shift_right_towards_zero_big_int(bi,n);
        if(0 <= n)
         if(0 === n)
          var _bJ_=zero_big_int;
         else
          {var
            idx=caml_div(n,_a_),
            size_res=idx + 1 | 0,
            res=make_nat(size_res);
           runtime.set_digit_nat_native(res,idx,1 << caml_mod(n,_a_));
           runtime.decr_nat(res,0,size_res,0);
           var _bJ_=[0,1,res]}
        else
         var _bJ_=caml_call1(Stdlib[2],cst_two_power_m1_big_int);
        return shift_right_towards_zero_big_int(sub_big_int(bi,_bJ_),n)}
      return caml_call1(Stdlib[2],cst_shift_right_big_int)}
    function extract_big_int(bi,ofs,n)
     {if(0 <= ofs)
       if(0 <= n)
        {if(0 === bi[1])return bi;
         var
          size_bi=num_digits_big_int(bi),
          size_res=caml_div((n + _a_ | 0) - 1 | 0,_a_),
          ndigits=caml_div(ofs,_a_),
          nbits=caml_mod(ofs,_a_),
          res=make_nat(size_res);
         if(ndigits < size_bi)
          {var _bE_=caml_call2(Stdlib[5],size_res,size_bi - ndigits | 0);
           runtime.blit_nat(res,0,bi[2],ndigits,_bE_)}
         if(bi[1] < 0)
          {runtime.complement_nat(res,0,size_res);
           var i=0;
           for(;;)
            {var _bF_=ndigits <= i?1:0;
             if(_bF_)
              var _bG_=_bF_;
             else
              {var _bH_=size_bi <= i?1:0;
               if(_bH_)
                var _bG_=_bH_;
               else
                {var _bI_=runtime.is_digit_zero(bi[2],i);
                 if(_bI_){var i$0=i + 1 | 0,i=i$0;continue}
                 var _bG_=_bI_}}
             if(_bG_)runtime.incr_nat(res,0,size_res,1);
             break}}
         if(0 < nbits)
          {var tmp=runtime.create_nat(1);
           runtime.shift_right_nat(res,0,size_res,tmp,0,nbits)}
         var n$0=caml_mod(n,_a_);
         if(0 < n$0)
          {var tmp$0=runtime.create_nat(1);
           runtime.set_digit_nat_native(tmp$0,0,-1 >>> (_a_ - n$0 | 0) | 0);
           runtime.land_digit_nat(res,size_res - 1 | 0,tmp$0,0)}
         return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[2],cst_extract_big_int)}
    function and_big_int(a,b)
     {if(0 <= a[1])
       if(0 <= b[1])
        {if(0 !== a[1])
          if(0 !== b[1])
           {var
             size_a=num_digits_big_int(a),
             size_b=num_digits_big_int(b),
             size_res=caml_call2(Stdlib[5],size_a,size_b),
             res=runtime.create_nat(size_res);
            runtime.blit_nat(res,0,a[2],0,size_res);
            var _bC_=size_res - 1 | 0,_bB_=0;
            if(! (_bC_ < 0))
             {var i=_bB_;
              for(;;)
               {runtime.land_digit_nat(res,i,b[2],i);
                var _bD_=i + 1 | 0;
                if(_bC_ !== i){var i=_bD_;continue}
                break}}
            return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
         return zero_big_int}
      return caml_call1(Stdlib[2],cst_and_big_int)}
    function or_big_int(a,b)
     {if(0 <= a[1])
       if(0 <= b[1])
        {if(0 === a[1])return b;
         if(0 === b[1])return a;
         var
          size_a=num_digits_big_int(a),
          size_b=num_digits_big_int(b),
          size_res=caml_call2(Stdlib[6],size_a,size_b),
          res=runtime.create_nat(size_res),
          or_aux=
           function(a,b,size_b)
            {runtime.blit_nat(res,0,a[2],0,size_res);
             var _bz_=size_b - 1 | 0,_by_=0;
             if(! (_bz_ < 0))
              {var i=_by_;
               for(;;)
                {runtime.lor_digit_nat(res,i,b[2],i);
                 var _bA_=i + 1 | 0;
                 if(_bz_ !== i){var i=_bA_;continue}
                 break}}
             return 0};
         if(size_b <= size_a)or_aux(a,b,size_b);else or_aux(b,a,size_a);
         return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[2],cst_or_big_int)}
    function xor_big_int(a,b)
     {if(0 <= a[1])
       if(0 <= b[1])
        {if(0 === a[1])return b;
         if(0 === b[1])return a;
         var
          size_a=num_digits_big_int(a),
          size_b=num_digits_big_int(b),
          size_res=caml_call2(Stdlib[6],size_a,size_b),
          res=runtime.create_nat(size_res),
          xor_aux=
           function(a,b,size_b)
            {runtime.blit_nat(res,0,a[2],0,size_res);
             var _bw_=size_b - 1 | 0,_bv_=0;
             if(! (_bw_ < 0))
              {var i=_bv_;
               for(;;)
                {runtime.lxor_digit_nat(res,i,b[2],i);
                 var _bx_=i + 1 | 0;
                 if(_bw_ !== i){var i=_bx_;continue}
                 break}}
             return 0};
         if(size_b <= size_a)xor_aux(a,b,size_b);else xor_aux(b,a,size_a);
         return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[2],cst_xor_big_int)}
    function round_big_int_to_float(x,exact)
     {var n=num_bits_big_int(x),_bt_=55 <= n?1:0,_bu_=_bt_?n <= 63?1:0:_bt_;
      if(_bu_)
       {var m=int64_of_big_int(x),m$0=exact?m:caml_int64_or(m,_k_);
        return caml_int64_to_float(m$0)}
      throw [0,Assert_failure,_l_]}
    function float_of_big_int(x)
     {var n=num_bits_big_int(x);
      if(63 < n)
       {var
         n$0=n - 55 | 0,
         top=shift_right_big_int(x,n$0),
         exact=eq_big_int(x,shift_left_big_int(top,n$0));
        return caml_ldexp_float(round_big_int_to_float(top,exact),n$0)}
      return caml_int64_to_float(int64_of_big_int(x))}
    var
     Big_int=
      [0,
       zero_big_int,
       unit_big_int,
       minus_big_int,
       abs_big_int,
       add_big_int,
       succ_big_int,
       add_int_big_int,
       sub_big_int,
       pred_big_int,
       mult_big_int,
       mult_int_big_int,
       square_big_int,
       sqrt_big_int,
       quomod_big_int,
       div_big_int,
       mod_big_int,
       gcd_big_int,
       power_int_positive_int,
       power_big_int_positive_int,
       power_int_positive_big_int,
       power_big_int_positive_big_int,
       sign_big_int,
       compare_big_int,
       eq_big_int,
       le_big_int,
       ge_big_int,
       lt_big_int,
       gt_big_int,
       max_big_int,
       min_big_int,
       num_digits_big_int,
       num_bits_big_int,
       string_of_big_int,
       big_int_of_string,
       big_int_of_string_opt,
       big_int_of_int,
       is_int_big_int,
       int_of_big_int,
       int_of_big_int_opt,
       big_int_of_int32,
       big_int_of_nativeint,
       big_int_of_int64,
       int32_of_big_int,
       int32_of_big_int_opt,
       nativeint_of_big_int,
       nativeint_of_big_int_opt,
       int64_of_big_int,
       int64_of_big_int_opt,
       float_of_big_int,
       and_big_int,
       or_big_int,
       xor_big_int,
       shift_left_big_int,
       shift_right_big_int,
       shift_right_towards_zero_big_int,
       extract_big_int,
       nat_of_big_int,
       big_int_of_nat,
       base_power_big_int,
       sys_big_int_of_string,
       round_futur_last_digit,
       approx_big_int,
       round_big_int_to_float];
    caml_register_global(133,Big_int,"Big_int");
    var
     error_when_null_denominator_flag=[0,1],
     normalize_ratio_flag=[0,0],
     normalize_ratio_when_printing_flag=[0,1],
     floating_precision=[0,12],
     approx_printing_flag=[0,0],
     Arith_flags=
      [0,
       error_when_null_denominator_flag,
       normalize_ratio_flag,
       normalize_ratio_when_printing_flag,
       floating_precision,
       approx_printing_flag];
    caml_register_global(134,Arith_flags,"Arith_flags");
    function failwith_zero(name)
     {if(0 === caml_ml_string_length(name))
       var s$0=s;
      else
       var
        _bs_=caml_call2(Stdlib[17],cst$2,s),
        s$0=caml_call2(Stdlib[17],name,_bs_);
      return caml_call1(Stdlib[3],s$0)}
    function numerator_ratio(r){return r[1]}
    function denominator_ratio(r){return r[2]}
    function null_denominator(r){return 0 === r[2][1]?1:0}
    function verify_null_denominator(r)
     {return 0 === r[2][1]
              ?error_when_null_denominator_flag[1]?failwith_zero(cst$3):1
              :0}
    function sign_ratio(r){return r[1][1]}
    function normalize_ratio(r)
     {if(r[3])return r;
      if(verify_null_denominator(r))
       {r[1] = big_int_of_int(r[1][1]);r[3] = 1;return r}
      var p=gcd_big_int(r[1],r[2]);
      return eq_big_int(p,unit_big_int)
              ?(r[3] = 1,r)
              :(r[1]
                =
                div_big_int(r[1],p),
                r[2]
                =
                div_big_int(r[2],p),
                r[3]
                =
                1,
                r)}
    function cautious_normalize_ratio(r)
     {return normalize_ratio_flag[1]?normalize_ratio(r):r}
    function cautious_normalize_ratio_when_printing(r)
     {return normalize_ratio_when_printing_flag[1]?normalize_ratio(r):r}
    function create_ratio(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       {var _br_=minus_big_int(bi2);
        return cautious_normalize_ratio([0,minus_big_int(bi1),_br_,0])}
      return 0 === match
              ?error_when_null_denominator_flag[1]
                ?failwith_zero(cst_create_ratio)
                :cautious_normalize_ratio([0,bi1,bi2,0])
              :cautious_normalize_ratio([0,bi1,bi2,0])}
    function create_normalized_ratio(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       {var _bq_=minus_big_int(bi2);return [0,minus_big_int(bi1),_bq_,1]}
      return 0 === match
              ?error_when_null_denominator_flag[1]
                ?failwith_zero(cst_create_normalized_ratio)
                :[0,bi1,bi2,1]
              :[0,bi1,bi2,1]}
    function is_normalized_ratio(r){return r[3]}
    function report_sign_ratio(r,bi)
     {return -1 === sign_ratio(r)?minus_big_int(bi):bi}
    function abs_ratio(r)
     {var _bo_=r[3],_bp_=r[2];return [0,abs_big_int(r[1]),_bp_,_bo_]}
    function is_integer_ratio(r)
     {return eq_big_int(normalize_ratio(r)[2],unit_big_int)}
    function add_ratio(r1,r2)
     {if(normalize_ratio_flag[1])
       {var
         _bh_=normalize_ratio(r2)[2],
         p=gcd_big_int(normalize_ratio(r1)[2],_bh_);
        if(eq_big_int(p,unit_big_int))
         {var _bi_=mult_big_int(r1[2],r2[2]),_bj_=mult_big_int(r2[1],r1[2]);
          return [0,add_big_int(mult_big_int(r1[1],r2[2]),_bj_),_bi_,1]}
        var
         d1=div_big_int(r1[2],p),
         d2=div_big_int(r2[2],p),
         _bk_=mult_big_int(d1,r2[1]),
         n=add_big_int(mult_big_int(r1[1],d2),_bk_),
         p$0=gcd_big_int(n,p),
         _bl_=mult_big_int(d1,div_big_int(r2[2],p$0));
        return [0,div_big_int(n,p$0),_bl_,1]}
      var _bm_=mult_big_int(r1[2],r2[2]),_bn_=mult_big_int(r1[2],r2[1]);
      return [0,add_big_int(mult_big_int(r1[1],r2[2]),_bn_),_bm_,0]}
    function minus_ratio(r)
     {var _bf_=r[3],_bg_=r[2];return [0,minus_big_int(r[1]),_bg_,_bf_]}
    function add_int_ratio(i,r)
     {cautious_normalize_ratio(r);
      var _bc_=r[3],_bd_=r[2],_be_=r[1];
      return [0,add_big_int(mult_int_big_int(i,r[2]),_be_),_bd_,_bc_]}
    function add_big_int_ratio(bi,r)
     {cautious_normalize_ratio(r);
      var _a$_=r[3],_ba_=r[2],_bb_=r[1];
      return [0,add_big_int(mult_big_int(bi,r[2]),_bb_),_ba_,_a$_]}
    function sub_ratio(r1,r2){return add_ratio(r1,minus_ratio(r2))}
    function mult_ratio(r1,r2)
     {if(normalize_ratio_flag[1])
       {var
         _a6_=normalize_ratio(r2)[2],
         p1=gcd_big_int(normalize_ratio(r1)[1],_a6_),
         p2=gcd_big_int(r2[1],r1[2]);
        if(eq_big_int(p1,unit_big_int))
         var _a8_=r1[1],_a7_=r2[2];
        else
         var d2=div_big_int(r2[2],p1),_a8_=div_big_int(r1[1],p1),_a7_=d2;
        if(eq_big_int(p2,unit_big_int))
         var n2=r2[1],d1=r1[2];
        else
         var
          d1$0=div_big_int(r1[2],p2),
          n2$0=div_big_int(r2[1],p2),
          n2=n2$0,
          d1=d1$0;
        var _a9_=mult_big_int(d1,_a7_);
        return [0,mult_big_int(_a8_,n2),_a9_,1]}
      var _a__=mult_big_int(r1[2],r2[2]);
      return [0,mult_big_int(r1[1],r2[1]),_a__,0]}
    function mult_int_ratio(i,r)
     {if(normalize_ratio_flag[1])
       {var _a0_=big_int_of_int(i),p=gcd_big_int(normalize_ratio(r)[2],_a0_);
        if(eq_big_int(p,unit_big_int))
         {var _a1_=r[2],_a2_=r[1];
          return [0,mult_big_int(big_int_of_int(i),_a2_),_a1_,1]}
        var _a3_=div_big_int(r[2],p),_a4_=r[1];
        return [0,mult_big_int(div_big_int(big_int_of_int(i),p),_a4_),_a3_,1]}
      var _a5_=r[2];
      return [0,mult_int_big_int(i,r[1]),_a5_,0]}
    function mult_big_int_ratio(bi,r)
     {if(normalize_ratio_flag[1])
       {var p=gcd_big_int(normalize_ratio(r)[2],bi);
        if(eq_big_int(p,unit_big_int))
         {var _aW_=r[2];return [0,mult_big_int(bi,r[1]),_aW_,1]}
        var _aX_=div_big_int(r[2],p),_aY_=r[1];
        return [0,mult_big_int(div_big_int(bi,p),_aY_),_aX_,1]}
      var _aZ_=r[2];
      return [0,mult_big_int(bi,r[1]),_aZ_,0]}
    function square_ratio(r)
     {cautious_normalize_ratio(r);
      var _aU_=r[3],_aV_=square_big_int(r[2]);
      return [0,square_big_int(r[1]),_aV_,_aU_]}
    function inverse_ratio(r)
     {if(error_when_null_denominator_flag[1])
       if(0 === r[1][1])return failwith_zero(cst_inverse_ratio);
      var _aS_=r[3],_aT_=abs_big_int(r[1]);
      return [0,report_sign_ratio(r,r[2]),_aT_,_aS_]}
    function div_ratio(r1,r2){return mult_ratio(r1,inverse_ratio(r2))}
    function integer_ratio(r)
     {if(null_denominator(r))return failwith_zero(cst_integer_ratio);
      if(0 === sign_ratio(r))return zero_big_int;
      var _aR_=abs_big_int(r[2]);
      return report_sign_ratio(r,div_big_int(abs_big_int(r[1]),_aR_))}
    function floor_ratio(r)
     {verify_null_denominator(r);return div_big_int(r[1],r[2])}
    function round_ratio(r)
     {verify_null_denominator(r);
      var
       abs_num=abs_big_int(r[1]),
       bi=div_big_int(abs_num,r[2]),
       _aQ_=r[2],
       bi$0=
        -1
         ===
         sub_big_int
           (mult_int_big_int(2,sub_big_int(abs_num,mult_big_int(r[2],bi))),
            _aQ_)
          [1]
         ?bi
         :succ_big_int(bi);
      return report_sign_ratio(r,bi$0)}
    function ceiling_ratio(r)
     {return is_integer_ratio(r)?r[1]:succ_big_int(floor_ratio(r))}
    function eq_ratio(r1,r2)
     {normalize_ratio(r1);
      normalize_ratio(r2);
      var _aP_=eq_big_int(r1[1],r2[1]);
      return _aP_?eq_big_int(r1[2],r2[2]):_aP_}
    function compare_ratio(r1,r2)
     {if(verify_null_denominator(r1))
       {var sign_num_r1=r1[1][1];
        if(verify_null_denominator(r2))
         {var sign_num_r2=r2[1][1];
          if(1 === sign_num_r1)if(-1 === sign_num_r2)return 1;
          if(-1 === sign_num_r1)if(1 === sign_num_r2)return -1;
          return 0}
        return sign_num_r1}
      if(verify_null_denominator(r2))return - r2[1][1] | 0;
      var match=compare_int(r1[1][1],r2[1][1]),switcher=match + 1 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher){case 0:return -1;case 1:break;default:return 1}
      if(eq_big_int(r1[2],r2[2]))return compare_big_int(r1[1],r2[1]);
      var _aO_=mult_big_int(r1[2],r2[1]);
      return compare_big_int(mult_big_int(r1[1],r2[2]),_aO_)}
    function lt_ratio(r1,r2){return compare_ratio(r1,r2) < 0?1:0}
    function le_ratio(r1,r2){return compare_ratio(r1,r2) <= 0?1:0}
    function gt_ratio(r1,r2){return 0 < compare_ratio(r1,r2)?1:0}
    function ge_ratio(r1,r2){return 0 <= compare_ratio(r1,r2)?1:0}
    function max_ratio(r1,r2){return lt_ratio(r1,r2)?r2:r1}
    function min_ratio(r1,r2){return gt_ratio(r1,r2)?r2:r1}
    function eq_big_int_ratio(bi,r)
     {var _aN_=is_integer_ratio(r);return _aN_?eq_big_int(bi,r[1]):_aN_}
    function compare_big_int_ratio(bi,r)
     {normalize_ratio(r);
      if(verify_null_denominator(r))return - r[1][1] | 0;
      var _aM_=r[1];
      return compare_big_int(mult_big_int(bi,r[2]),_aM_)}
    function lt_big_int_ratio(bi,r)
     {return compare_big_int_ratio(bi,r) < 0?1:0}
    function le_big_int_ratio(bi,r)
     {return compare_big_int_ratio(bi,r) <= 0?1:0}
    function gt_big_int_ratio(bi,r)
     {return 0 < compare_big_int_ratio(bi,r)?1:0}
    function ge_big_int_ratio(bi,r)
     {return 0 <= compare_big_int_ratio(bi,r)?1:0}
    function int_of_ratio(r)
     {if(is_integer_ratio(r))
       if(is_int_big_int(r[1]))return int_of_big_int(r[1]);
      return caml_call1(Stdlib[3],cst_integer_argument_required)}
    function ratio_of_int(i){return [0,big_int_of_int(i),unit_big_int,1]}
    function ratio_of_nat(nat){return [0,big_int_of_nat(nat),unit_big_int,1]}
    function nat_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?-1 < r[1][1]
                ?nat_of_big_int(r[1])
                :caml_call1(Stdlib[3],cst_nat_of_ratio)
              :caml_call1(Stdlib[3],cst_nat_of_ratio$0)}
    function ratio_of_big_int(bi){return [0,bi,unit_big_int,1]}
    function big_int_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?r[1]
              :caml_call1(Stdlib[3],cst_big_int_of_ratio)}
    function div_int_ratio(i,r)
     {verify_null_denominator(r);return mult_int_ratio(i,inverse_ratio(r))}
    function div_ratio_int(r,i){return div_ratio(r,ratio_of_int(i))}
    function div_big_int_ratio(bi,r)
     {verify_null_denominator(r);
      return mult_big_int_ratio(bi,inverse_ratio(r))}
    function div_ratio_big_int(r,bi){return div_ratio(r,ratio_of_big_int(bi))}
    function approx_ratio_fix(n,r)
     {if(null_denominator(r))return failwith_zero(cst_approx_ratio_fix);
      var sign_r=sign_ratio(r);
      if(0 === sign_r)return cst_0;
      if(0 <= n)
       {var
         _aH_=r[2],
         s1=
          string_of_nat
           (nat_of_big_int
             (div_big_int
               (base_power_big_int(10,n + 1 | 0,abs_big_int(r[1])),_aH_))),
         s2=
          round_futur_last_digit
            (caml_call1(Stdlib_bytes[43],s1),0,caml_ml_string_length(s1))
           ?caml_call2(Stdlib[17],cst_1$0,s1)
           :s1,
         l2=caml_ml_string_length(s2) - 1 | 0;
        if(n < l2)
         {var
           s=caml_call2(Stdlib_bytes[1],l2 + 2 | 0,48),
           _aI_=-1 === sign_r?45:43;
          caml_bytes_set(s,0,_aI_);
          caml_call5(Stdlib_string[6],s2,0,s,1,l2 - n | 0);
          caml_bytes_set(s,(l2 - n | 0) + 1 | 0,46);
          caml_call5(Stdlib_string[6],s2,l2 - n | 0,s,(l2 - n | 0) + 2 | 0,n);
          return caml_call1(Stdlib_bytes[42],s)}
        var
         s$0=caml_call2(Stdlib_bytes[1],n + 3 | 0,48),
         _aJ_=-1 === sign_r?45:43;
        caml_bytes_set(s$0,0,_aJ_);
        caml_bytes_set(s$0,2,46);
        caml_call5(Stdlib_string[6],s2,0,s$0,(n + 3 | 0) - l2 | 0,l2);
        return caml_call1(Stdlib_bytes[42],s$0)}
      var
       _aK_=base_power_big_int(10,- n | 0,r[2]),
       s$1=string_of_big_int(div_big_int(abs_big_int(r[1]),_aK_)),
       len=caml_ml_string_length(s$1) + 1 | 0,
       s$2=caml_call2(Stdlib_bytes[1],len,48),
       _aL_=-1 === sign_r?45:43;
      caml_bytes_set(s$2,0,_aL_);
      caml_call5(Stdlib_string[6],s$1,0,s$2,1,len - 1 | 0);
      return caml_call1(Stdlib_bytes[42],s$2)}
    function num_decimal_digits_int(n)
     {return caml_ml_string_length(caml_call1(Stdlib[22],n))}
    function approx_ratio_exp(n,r)
     {if(null_denominator(r))return failwith_zero(cst_approx_ratio_exp);
      if(0 < n)
       {var sign_r=sign_ratio(r),i$4=[0,n + 3 | 0];
        if(0 === sign_r)
         {var _as_=[0,cst_0$0,[0,caml_call2(Stdlib_string[1],n,48),_m_]];
          return caml_call2(Stdlib_string[7],cst$4,_as_)}
        var r$0=abs_ratio(r);
        cautious_normalize_ratio(r$0);
        if(null_denominator(r$0))
         var msd=failwith_zero(cst_msd_ratio);
        else
         if(0 === r$0[1][1])
          var msd=0;
         else
          {var
            s1=string_of_big_int(r$0[1]),
            s=string_of_big_int(r$0[2]),
            size_num=caml_ml_string_length(s1),
            lim=caml_ml_string_length(s),
            i$3=caml_call2(Stdlib[5],size_num,lim),
            m=size_num - lim | 0,
            i=0;
           for(;;)
            {if(i$3 <= i)
              var cmp=0;
             else
              {var
                c1=caml_string_get(s1,i),
                c2=caml_string_get(s,i),
                c=compare_int(c1,c2);
               if(0 === c){var i$0=i + 1 | 0,i=i$0;continue}
               var cmp=c}
             var switcher=cmp + 1 | 0;
             if(2 < switcher >>> 0)
              var switch$0=0;
             else
              switch(switcher)
               {case 0:var msd=m - 1 | 0,switch$0=1;break;
                case 1:var switch$0=0;break;
                default:var msd=m,switch$0=1}
             if(! switch$0)
              if(0 <= m)
               var msd=m;
              else
               {var i$1=i$3;
                for(;;)
                 {var _ap_=lim <= i$1?1:0;
                  if(_ap_)
                   var _aq_=_ap_;
                  else
                   {var _ar_=48 === caml_string_get(s,i$1)?1:0;
                    if(_ar_){var i$2=i$1 + 1 | 0,i$1=i$2;continue}
                    var _aq_=_ar_}
                  var msd=_aq_?m:m - 1 | 0;
                  break}}
             break}}
        var k=n - msd | 0;
        if(0 <= k)
         var
          _at_=r[2],
          _au_=div_big_int(base_power_big_int(10,k,abs_big_int(r[1])),_at_);
        else
         var
          _aG_=base_power_big_int(10,- k | 0,r[2]),
          _au_=div_big_int(abs_big_int(r[1]),_aG_);
        var nat=nat_of_big_int(_au_),s$0=string_of_nat(nat);
        if
         (round_futur_last_digit
           (caml_call1(Stdlib_bytes[43],s$0),0,caml_ml_string_length(s$0)))
         {var
           m$0=num_decimal_digits_int(msd + 1 | 0),
           str=caml_call2(Stdlib_bytes[1],(n + m$0 | 0) + 4 | 0,48),
           _av_=3,
           _aw_=0,
           _ax_=0,
           _ay_=-1 === sign_r?cst_1$1:cst_1$2;
          caml_call5(Stdlib_string[6],_ay_,_ax_,str,_aw_,_av_);
          caml_bytes_set(str,i$4[1],101);
          i$4[1]++;
          if(0 === m$0)
           caml_bytes_set(str,i$4[1],48);
          else
           {var _az_=i$4[1],_aA_=caml_call1(Stdlib[22],msd + 1 | 0);
            caml_call5(Stdlib_string[6],_aA_,0,str,_az_,m$0)}
          return caml_call1(Stdlib_bytes[42],str)}
        var
         m$1=num_decimal_digits_int(msd + 1 | 0),
         p=n + 3 | 0,
         str$0=caml_call2(Stdlib_bytes[1],(m$1 + p | 0) + 1 | 0,48),
         _aB_=3,
         _aC_=0,
         _aD_=0,
         _aE_=-1 === sign_r?cst_0$1:cst_0$2;
        caml_call5(Stdlib_string[6],_aE_,_aD_,str$0,_aC_,_aB_);
        caml_call5(Stdlib_string[6],s$0,0,str$0,3,n);
        caml_bytes_set(str$0,p,101);
        if(0 === m$1)
         caml_bytes_set(str$0,p + 1 | 0,48);
        else
         {var _aF_=caml_call1(Stdlib[22],msd + 1 | 0);
          caml_call5(Stdlib_string[6],_aF_,0,str$0,p + 1 | 0,m$1)}
        return caml_call1(Stdlib_bytes[42],str$0)}
      return caml_call1(Stdlib[2],cst_approx_ratio_exp$0)}
    function float_of_rational_string(r)
     {var s=approx_ratio_exp(floating_precision[1],r);
      return 43 === caml_string_get(s,0)
              ?caml_call3
                (Stdlib_string[4],s,1,caml_ml_string_length(s) - 1 | 0)
              :s}
    function string_of_ratio(r)
     {cautious_normalize_ratio_when_printing(r);
      if(approx_printing_flag[1])return float_of_rational_string(r);
      var
       _am_=string_of_big_int(r[2]),
       _an_=caml_call2(Stdlib[17],cst$5,_am_),
       _ao_=string_of_big_int(r[1]);
      return caml_call2(Stdlib[17],_ao_,_an_)}
    function ratio_of_string(s)
     {try
       {var
         n=caml_call2(Stdlib_string[14],s,47),
         _aj_=
          sys_big_int_of_string
           (s,n + 1 | 0,(caml_ml_string_length(s) - n | 0) - 1 | 0),
         _ak_=create_ratio(sys_big_int_of_string(s,0,n),_aj_);
        return _ak_}
      catch(_al_)
       {_al_ = caml_wrap_exception(_al_);
        if(_al_ === Not_found)return [0,big_int_of_string(s),unit_big_int,1];
        throw _al_}}
    function float_of_ratio(r)
     {var p=r[1],q=r[2];
      if(0 === q[1])
       {var match=p[1],switcher=match + 1 | 0;
        if(2 < switcher >>> 0)throw [0,Assert_failure,_n_];
        switch(switcher)
         {case 0:return Stdlib[12];
          case 1:return Stdlib[13];
          default:return Stdlib[11]}}
      if(0 === p[1])return 0;
      var np=num_bits_big_int(p),nq=num_bits_big_int(q);
      if(! (53 < np))
       if(! (53 < nq))
        {var _ai_=caml_int64_to_float(int64_of_big_int(q));
         return caml_int64_to_float(int64_of_big_int(p)) / _ai_}
      var ap=abs_big_int(p),n=55 - (np - nq | 0) | 0;
      if(0 <= n)
       var p$0=shift_left_big_int(ap,n),q$0=q;
      else
       var q$1=shift_left_big_int(q,- n | 0),p$0=ap,q$0=q$1;
      var
       match$0=quomod_big_int(p$0,q$0),
       rem=match$0[2],
       quo=match$0[1],
       f=round_big_int_to_float(quo,0 === rem[1]?1:0),
       f$0=caml_ldexp_float(f,- n | 0);
      return 0 <= p[1]?f$0:- f$0}
    function power_ratio_positive_int(r,n)
     {var _ah_=power_big_int_positive_int(r[2],n);
      return create_ratio(power_big_int_positive_int(r[1],n),_ah_)}
    function power_ratio_positive_big_int(r,bi)
     {var _ag_=power_big_int_positive_big_int(r[2],bi);
      return create_ratio(power_big_int_positive_big_int(r[1],bi),_ag_)}
    var
     Ratio=
      [0,
       null_denominator,
       numerator_ratio,
       denominator_ratio,
       sign_ratio,
       normalize_ratio,
       cautious_normalize_ratio,
       cautious_normalize_ratio_when_printing,
       create_ratio,
       create_normalized_ratio,
       is_normalized_ratio,
       report_sign_ratio,
       abs_ratio,
       is_integer_ratio,
       add_ratio,
       minus_ratio,
       add_int_ratio,
       add_big_int_ratio,
       sub_ratio,
       mult_ratio,
       mult_int_ratio,
       mult_big_int_ratio,
       square_ratio,
       inverse_ratio,
       div_ratio,
       integer_ratio,
       floor_ratio,
       round_ratio,
       ceiling_ratio,
       eq_ratio,
       compare_ratio,
       lt_ratio,
       le_ratio,
       gt_ratio,
       ge_ratio,
       max_ratio,
       min_ratio,
       eq_big_int_ratio,
       compare_big_int_ratio,
       lt_big_int_ratio,
       le_big_int_ratio,
       gt_big_int_ratio,
       ge_big_int_ratio,
       int_of_ratio,
       ratio_of_int,
       ratio_of_nat,
       nat_of_ratio,
       ratio_of_big_int,
       big_int_of_ratio,
       div_int_ratio,
       div_ratio_int,
       div_big_int_ratio,
       div_ratio_big_int,
       approx_ratio_fix,
       approx_ratio_exp,
       float_of_rational_string,
       string_of_ratio,
       ratio_of_string,
       float_of_ratio,
       power_ratio_positive_int,
       power_ratio_positive_big_int];
    caml_register_global(136,Ratio,"Ratio");
    var
     biggest_INT=big_int_of_int(biggest_int),
     least_INT=big_int_of_int(least_int);
    function num_of_big_int(bi)
     {if(le_big_int(bi,biggest_INT))
       if(ge_big_int(bi,least_INT))return [0,int_of_big_int(bi)];
      return [1,bi]}
    function num_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?is_int_big_int(r[1])?[0,int_of_big_int(r[1])]:[1,r[1]]
              :[2,r]}
    function add_num(a,match)
     {switch(a[0])
       {case 0:
         var _ac_=a[1];
         switch(match[0])
          {case 0:
            var int2=match[1],r=_ac_ + int2 | 0;
            if(0 <= (_ac_ ^ int2 | _ac_ ^ r ^ -1))
             {var _ad_=big_int_of_int(int2);
              return [1,add_big_int(big_int_of_int(_ac_),_ad_)]}
            return [0,r];
           case 1:
            var bi=match[1];return num_of_big_int(add_int_big_int(_ac_,bi));
           default:var r$0=match[1];return [2,add_int_ratio(_ac_,r$0)]}
        case 1:
         var _ae_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return num_of_big_int(add_int_big_int(i,_ae_));
           case 1:
            var bi2=match[1];return num_of_big_int(add_big_int(_ae_,bi2));
           default:var r$1=match[1];return [2,add_big_int_ratio(_ae_,r$1)]}
        default:
         var _af_=a[1];
         switch(match[0])
          {case 0:var i$0=match[1];return [2,add_int_ratio(i$0,_af_)];
           case 1:var bi$0=match[1];return [2,add_big_int_ratio(bi$0,_af_)];
           default:var r2=match[1];return num_of_ratio(add_ratio(_af_,r2))}}}
    function minus_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,minus_big_int(big_int_of_int(i))]
                 :[0,- i | 0];
        case 1:var bi=param[1];return [1,minus_big_int(bi)];
        default:var r=param[1];return [2,minus_ratio(r)]}}
    function sub_num(n1,n2){return add_num(n1,minus_num(n2))}
    function mult_num(a,match)
     {switch(a[0])
       {case 0:
         var _Z_=a[1];
         switch(match[0])
          {case 0:
            var int2=match[1],___=num_bits_int(int2);
            if((num_bits_int(_Z_) + ___ | 0) < length_of_int)
             return [0,caml_mul(_Z_,int2)];
            var _$_=big_int_of_int(int2);
            return num_of_big_int(mult_big_int(big_int_of_int(_Z_),_$_));
           case 1:
            var bi=match[1];return num_of_big_int(mult_int_big_int(_Z_,bi));
           default:var r=match[1];return num_of_ratio(mult_int_ratio(_Z_,r))}
        case 1:
         var _aa_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return num_of_big_int(mult_int_big_int(i,_aa_));
           case 1:
            var bi2=match[1];return num_of_big_int(mult_big_int(_aa_,bi2));
           default:
            var r$0=match[1];return num_of_ratio(mult_big_int_ratio(_aa_,r$0))}
        default:
         var _ab_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];return num_of_ratio(mult_int_ratio(i$0,_ab_));
           case 1:
            var bi$0=match[1];
            return num_of_ratio(mult_big_int_ratio(bi$0,_ab_));
           default:var r2=match[1];return num_of_ratio(mult_ratio(_ab_,r2))}}}
    function square_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return (2 * num_bits_int(i) | 0) < length_of_int
                 ?[0,caml_mul(i,i)]
                 :num_of_big_int(square_big_int(big_int_of_int(i)));
        case 1:var bi=param[1];return [1,square_big_int(bi)];
        default:var r=param[1];return [2,square_ratio(r)]}}
    function div_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var i1=n1[1];
         switch(n2[0])
          {case 0:
            var i2=n2[1],_Y_=big_int_of_int(i2);
            return num_of_ratio(create_ratio(big_int_of_int(i1),_Y_));
           case 1:
            var bi2=n2[1];
            return num_of_ratio(create_ratio(big_int_of_int(i1),bi2));
           default:var r2=n2[1];return num_of_ratio(div_int_ratio(i1,r2))}
        case 1:
         var bi1=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_ratio(create_ratio(bi1,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_ratio(create_ratio(bi1,bi2$0));
           default:
            var r2$0=n2[1];return num_of_ratio(div_big_int_ratio(bi1,r2$0))}
        default:
         var r1=n1[1];
         switch(n2[0])
          {case 0:var i2$1=n2[1];return num_of_ratio(div_ratio_int(r1,i2$1));
           case 1:
            var bi2$1=n2[1];return num_of_ratio(div_ratio_big_int(r1,bi2$1));
           default:var r2$1=n2[1];return num_of_ratio(div_ratio(r1,r2$1))}}}
    function floor_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(floor_ratio(r))}}
    function ratio_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return ratio_of_int(i);
        case 1:var bi=param[1];return ratio_of_big_int(bi);
        default:var r=param[1];return r}}
    function quo_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var _W_=n1[1];
         switch(n2[0])
          {case 0:
            var
             i2=n2[1],
             q=caml_div(_W_,i2),
             r=caml_mod(_W_,i2),
             q$0=0 <= r?q:0 < i2?q - 1 | 0:q + 1 | 0;
            return [0,q$0];
           case 1:
            var bi2=n2[1];
            return num_of_big_int(div_big_int(big_int_of_int(_W_),bi2));
           default:
            var r2=n2[1];
            return num_of_big_int
                    (report_sign_ratio
                      (r2,floor_ratio(div_int_ratio(_W_,abs_ratio(r2)))))}
        case 1:
         var _X_=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_big_int(div_big_int(_X_,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_big_int(div_big_int(_X_,bi2$0));
           default:
            var r2$0=n2[1];
            return num_of_big_int
                    (report_sign_ratio
                      (r2$0,floor_ratio(div_big_int_ratio(_X_,abs_ratio(r2$0)))))}
        default:
         var r1=n1[1],r2$1=ratio_of_num(n2);
         return num_of_big_int
                 (report_sign_ratio
                   (r2$1,floor_ratio(div_ratio(r1,abs_ratio(r2$1)))))}}
    function mod_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var _U_=n1[1];
         switch(n2[0])
          {case 0:
            var
             i2=n2[1],
             r=caml_mod(_U_,i2),
             r$0=0 <= r?r:0 < i2?r + i2 | 0:r - i2 | 0;
            return [0,r$0];
           case 1:
            var bi2=n2[1];
            return num_of_big_int(mod_big_int(big_int_of_int(_U_),bi2))
           }
         break;
        case 1:
         var _V_=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_big_int(mod_big_int(_V_,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_big_int(mod_big_int(_V_,bi2$0))
           }
         break
        }
      return sub_num(n1,mult_num(n2,quo_num(n1,n2)))}
    function power_num(n,match$5)
     {switch(match$5[0])
       {case 0:
         var i$1=match$5[1];
         switch(n[0])
          {case 0:
            var i=n[1],match=sign_int(i$1);
            return 0 === match
                    ?_o_
                    :1 === match
                      ?num_of_big_int(power_int_positive_int(i,i$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,power_int_positive_int(i,- i$1 | 0))];
           case 1:
            var bi=n[1],match$0=sign_int(i$1);
            return 0 === match$0
                    ?_p_
                    :1 === match$0
                      ?num_of_big_int(power_big_int_positive_int(bi,i$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,power_big_int_positive_int(bi,- i$1 | 0))];
           default:
            var r=n[1],match$1=sign_int(i$1);
            return 0 === match$1
                    ?_q_
                    :1 === match$1
                      ?[2,power_ratio_positive_int(r,i$1)]
                      :[2,power_ratio_positive_int(inverse_ratio(r),- i$1 | 0)]}
        case 1:
         var bi$1=match$5[1];
         switch(n[0])
          {case 0:
            var i$0=n[1],match$2=bi$1[1];
            return 0 === match$2
                    ?_r_
                    :1 === match$2
                      ?num_of_big_int(power_int_positive_big_int(i$0,bi$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,
                          power_int_positive_big_int(i$0,minus_big_int(bi$1)))];
           case 1:
            var bi$0=n[1],match$3=bi$1[1];
            return 0 === match$3
                    ?_s_
                    :1 === match$3
                      ?num_of_big_int(power_big_int_positive_big_int(bi$0,bi$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,
                          power_big_int_positive_big_int(bi$0,minus_big_int(bi$1)))];
           default:
            var r$0=n[1],match$4=bi$1[1];
            if(0 === match$4)return _t_;
            if(1 === match$4)
             return [2,power_ratio_positive_big_int(r$0,bi$1)];
            var _T_=minus_big_int(bi$1);
            return [2,power_ratio_positive_big_int(inverse_ratio(r$0),_T_)]}
        default:return caml_call1(Stdlib[2],cst_power_num)}}
    function is_integer_num(param)
     {switch(param[0])
       {case 0:return 1;
        case 1:return 1;
        default:var r=param[1];return is_integer_ratio(r)}}
    function integer_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(integer_ratio(r))}}
    function round_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(round_ratio(r))}}
    function ceiling_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(ceiling_ratio(r))}}
    function sign_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return sign_int(i);
        case 1:var bi=param[1];return bi[1];
        default:var r=param[1];return sign_ratio(r)}}
    function eq_num(a,match)
     {switch(a[0])
       {case 0:
         var _Q_=a[1];
         switch(match[0])
          {case 0:var int2=match[1];return _Q_ === int2?1:0;
           case 1:var bi=match[1];return eq_big_int(big_int_of_int(_Q_),bi);
           default:
            var r=match[1];return eq_big_int_ratio(big_int_of_int(_Q_),r)}
        case 1:
         var _R_=a[1];
         switch(match[0])
          {case 0:var i=match[1];return eq_big_int(big_int_of_int(i),_R_);
           case 1:var bi2=match[1];return eq_big_int(_R_,bi2);
           default:var r$0=match[1];return eq_big_int_ratio(_R_,r$0)}
        default:
         var _S_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];return eq_big_int_ratio(big_int_of_int(i$0),_S_);
           case 1:var bi$0=match[1];return eq_big_int_ratio(bi$0,_S_);
           default:var r2=match[1];return eq_ratio(_S_,r2)}}}
    function _u_(a,b){return 1 - eq_num(a,b)}
    function compare_num(a,match)
     {switch(a[0])
       {case 0:
         var _N_=a[1];
         switch(match[0])
          {case 0:var int2=match[1];return compare_int(_N_,int2);
           case 1:
            var bi=match[1];return compare_big_int(big_int_of_int(_N_),bi);
           default:
            var r=match[1];return compare_big_int_ratio(big_int_of_int(_N_),r)}
        case 1:
         var _O_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return compare_big_int(_O_,big_int_of_int(i));
           case 1:var bi2=match[1];return compare_big_int(_O_,bi2);
           default:var r$0=match[1];return compare_big_int_ratio(_O_,r$0)}
        default:
         var _P_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];
            return - compare_big_int_ratio(big_int_of_int(i$0),_P_) | 0;
           case 1:
            var bi$0=match[1];return - compare_big_int_ratio(bi$0,_P_) | 0;
           default:var r2=match[1];return compare_ratio(_P_,r2)}}}
    function lt_num(num1,num2){return compare_num(num1,num2) < 0?1:0}
    function le_num(num1,num2){return compare_num(num1,num2) <= 0?1:0}
    function gt_num(num1,num2){return 0 < compare_num(num1,num2)?1:0}
    function ge_num(num1,num2){return 0 <= compare_num(num1,num2)?1:0}
    function max_num(num1,num2){return lt_num(num1,num2)?num2:num1}
    function min_num(num1,num2){return gt_num(num1,num2)?num2:num1}
    function int_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return i;
        case 1:var bi=param[1];return int_of_big_int(bi);
        default:var r=param[1];return int_of_ratio(r)}}
    function int_of_num_opt(param)
     {switch(param[0])
       {case 0:var i=param[1];return [0,i];
        case 1:var bi=param[1];return int_of_big_int_opt(bi);
        default:
         var r=param[1];
         try
          {var _L_=[0,int_of_ratio(r)];return _L_}
         catch(_M_)
          {_M_ = caml_wrap_exception(_M_);
           if(_M_[1] === Failure)return 0;
           throw _M_}}}
    function num_of_int(i)
     {return i === monster_int?[1,big_int_of_int(i)]:[0,i]}
    function nat_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return nat_of_int(i);
        case 1:var bi=param[1];return nat_of_big_int(bi);
        default:var r=param[1];return nat_of_ratio(r)}}
    function num_of_nat(nat)
     {return is_nat_int(nat,0,length_nat(nat))
              ?[0,runtime.nth_digit_nat(nat,0)]
              :[1,big_int_of_nat(nat)]}
    function nat_of_num_opt(x)
     {try
       {var _J_=[0,nat_of_num(x)];return _J_}
      catch(_K_)
       {_K_ = caml_wrap_exception(_K_);
        if(_K_[1] === Failure)return 0;
        throw _K_}}
    function big_int_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return big_int_of_int(i);
        case 1:var bi=param[1];return bi;
        default:var r=param[1];return big_int_of_ratio(r)}}
    function big_int_of_num_opt(x)
     {try
       {var _H_=[0,big_int_of_num(x)];return _H_}
      catch(_I_)
       {_I_ = caml_wrap_exception(_I_);
        if(_I_[1] === Failure)return 0;
        throw _I_}}
    function string_of_num(n)
     {if(normalize_ratio_when_printing_flag[1])
       switch(n[0])
        {case 0:var i=n[1],_G_=[0,i];break;
         case 1:var bi=n[1],_G_=num_of_big_int(bi);break;
         default:var r=n[1],_G_=is_integer_ratio(r)?num_of_big_int(r[1]):[2,r]}
      else
       var _G_=n;
      switch(_G_[0])
       {case 0:var i$0=_G_[1];return caml_call1(Stdlib[22],i$0);
        case 1:
         var bi$0=_G_[1];
         return approx_printing_flag[1]
                 ?approx_big_int(floating_precision[1],bi$0)
                 :string_of_big_int(bi$0);
        default:var r$0=_G_[1];return string_of_ratio(r$0)}}
    function num_of_string(s)
     {try
       {var flag=normalize_ratio_flag[1];
        normalize_ratio_flag[1] = 1;
        var r=ratio_of_string(s);
        normalize_ratio_flag[1] = flag;
        var _E_=eq_big_int(r[2],unit_big_int)?num_of_big_int(r[1]):[2,r];
        return _E_}
      catch(_F_)
       {_F_ = caml_wrap_exception(_F_);
        if(_F_[1] === Failure)return caml_call1(Stdlib[3],cst_num_of_string);
        throw _F_}}
    function num_of_string_opt(s)
     {try
       {var _C_=[0,num_of_string(s)];return _C_}
      catch(_D_)
       {_D_ = caml_wrap_exception(_D_);
        if(_D_[1] === Failure)return 0;
        throw _D_}}
    function float_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return i;
        case 1:var bi=param[1];return float_of_big_int(bi);
        default:var r=param[1];return float_of_ratio(r)}}
    function succ_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === biggest_int
                 ?[1,succ_big_int(big_int_of_int(i))]
                 :[0,i + 1 | 0];
        case 1:var bi=param[1];return num_of_big_int(succ_big_int(bi));
        default:var r=param[1];return [2,add_int_ratio(1,r)]}}
    function pred_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,pred_big_int(big_int_of_int(i))]
                 :[0,i - 1 | 0];
        case 1:var bi=param[1];return num_of_big_int(pred_big_int(bi));
        default:var r=param[1];return [2,add_int_ratio(-1,r)]}}
    function abs_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,minus_big_int(big_int_of_int(i))]
                 :[0,caml_call1(Stdlib[7],i)];
        case 1:var bi=param[1];return [1,abs_big_int(bi)];
        default:var r=param[1];return [2,abs_ratio(r)]}}
    function approx_num_fix(n,num)
     {return approx_ratio_fix(n,ratio_of_num(num))}
    function approx_num_exp(n,num)
     {return approx_ratio_exp(n,ratio_of_num(num))}
    function incr_num(r){r[1] = succ_num(r[1]);return 0}
    function decr_num(r){r[1] = pred_num(r[1]);return 0}
    var
     Num=
      [0,
       add_num,
       add_num,
       minus_num,
       sub_num,
       sub_num,
       mult_num,
       mult_num,
       square_num,
       div_num,
       div_num,
       quo_num,
       mod_num,
       power_num,
       power_num,
       abs_num,
       succ_num,
       pred_num,
       incr_num,
       decr_num,
       is_integer_num,
       integer_num,
       floor_num,
       round_num,
       ceiling_num,
       sign_num,
       eq_num,
       lt_num,
       gt_num,
       le_num,
       ge_num,
       _u_,
       eq_num,
       lt_num,
       le_num,
       gt_num,
       ge_num,
       compare_num,
       max_num,
       min_num,
       string_of_num,
       approx_num_fix,
       approx_num_exp,
       num_of_string,
       num_of_string_opt,
       int_of_num,
       int_of_num_opt,
       num_of_int,
       nat_of_num,
       nat_of_num_opt,
       num_of_nat,
       num_of_big_int,
       big_int_of_num,
       big_int_of_num_opt,
       ratio_of_num,
       num_of_ratio,
       float_of_num];
    caml_register_global(137,Num,"Num");
    function get_error_when_null_denominator(param)
     {return error_when_null_denominator_flag[1]}
    function set_error_when_null_denominator(choice)
     {error_when_null_denominator_flag[1] = choice;return 0}
    function get_normalize_ratio(param){return normalize_ratio_flag[1]}
    function set_normalize_ratio(choice)
     {normalize_ratio_flag[1] = choice;return 0}
    function get_normalize_ratio_when_printing(param)
     {return normalize_ratio_when_printing_flag[1]}
    function set_normalize_ratio_when_printing(choice)
     {normalize_ratio_when_printing_flag[1] = choice;return 0}
    function get_floating_precision(param){return floating_precision[1]}
    function set_floating_precision(i){floating_precision[1] = i;return 0}
    function get_approx_printing(param){return approx_printing_flag[1]}
    function set_approx_printing(b){approx_printing_flag[1] = b;return 0}
    function arith_print_string(s)
     {caml_call1(Stdlib[31],s);return caml_call1(Stdlib[31],cst$6)}
    function arith_print_bool(param)
     {return 0 === param
              ?caml_call1(Stdlib[31],cst_OFF)
              :caml_call1(Stdlib[31],cst_ON)}
    function arith_status(param)
     {caml_call1(Stdlib[36],0);
      arith_print_string(cst_Normalization_during_computation);
      arith_print_bool(get_normalize_ratio(0));
      caml_call1(Stdlib[36],0);
      caml_call1(Stdlib[31],cst_returned_by_get_normalize_ratio);
      caml_call1(Stdlib[36],0);
      caml_call1
       (Stdlib[31],cst_modifiable_with_set_normalize_ratio_your_choice);
      caml_call1(Stdlib[36],0);
      caml_call1(Stdlib[36],0);
      arith_print_string(cst_Normalization_when_printing);
      arith_print_bool(get_normalize_ratio_when_printing(0));
      caml_call1(Stdlib[36],0);
      caml_call1(Stdlib[31],cst_returned_by_get_normalize_ratio_when_printing);
      caml_call1(Stdlib[36],0);
      caml_call1
       (Stdlib[31],
        cst_modifiable_with_set_normalize_ratio_when_printing_your_choice);
      caml_call1(Stdlib[36],0);
      caml_call1(Stdlib[36],0);
      arith_print_string
       (cst_Floating_point_approximation_when_printing_rational_numbers);
      arith_print_bool(get_approx_printing(0));
      caml_call1(Stdlib[36],0);
      caml_call1(Stdlib[31],cst_returned_by_get_approx_printing);
      caml_call1(Stdlib[36],0);
      caml_call1
       (Stdlib[31],cst_modifiable_with_set_approx_printing_your_choice);
      caml_call1(Stdlib[36],0);
      if(get_approx_printing(0))
       {caml_call1(Stdlib[31],cst_Default_precision);
        var _B_=get_floating_precision(0);
        caml_call1(Stdlib[33],_B_);
        caml_call1(Stdlib[36],0);
        caml_call1(Stdlib[31],cst_returned_by_get_floating_precision);
        caml_call1(Stdlib[36],0);
        caml_call1
         (Stdlib[31],cst_modifiable_with_set_floating_precision_your_choice);
        caml_call1(Stdlib[36],0);
        caml_call1(Stdlib[36],0)}
      else
       caml_call1(Stdlib[36],0);
      arith_print_string(cst_Error_when_a_rational_denominator_is_null);
      arith_print_bool(get_error_when_null_denominator(0));
      caml_call1(Stdlib[36],0);
      caml_call1(Stdlib[31],cst_returned_by_get_error_when_null_denominator);
      caml_call1(Stdlib[36],0);
      caml_call1
       (Stdlib[31],
        cst_modifiable_with_set_error_when_null_denominator_your_choice);
      return caml_call1(Stdlib[36],0)}
    var
     Arith_status=
      [0,
       arith_status,
       get_error_when_null_denominator,
       set_error_when_null_denominator,
       get_normalize_ratio,
       set_normalize_ratio,
       get_normalize_ratio_when_printing,
       set_normalize_ratio_when_printing,
       get_approx_printing,
       set_approx_printing,
       get_floating_precision,
       set_floating_precision];
    caml_register_global(138,Arith_status,"Arith_status");
    return}
  (function(){return this}()));


//# 1 "../.js/General/General.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_frexp_float=runtime.caml_frexp_float,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_ldexp_float=runtime.caml_ldexp_float,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string,
     caml_notequal=runtime.caml_notequal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_IsMaxHeap=caml_new_string("IsMaxHeap"),
     cst_HasBlackRoot=caml_new_string("HasBlackRoot"),
     cst_IsRedBlack=caml_new_string("IsRedBlack"),
     cst_IsBlackBalanced=caml_new_string("IsBlackBalanced"),
     cst_IsBinarySearchTree=caml_new_string("IsBinarySearchTree"),
     cst_Empty=caml_new_string("Empty"),
     cst_EmptyPlus=caml_new_string("EmptyPlus"),
     cst_def$0=caml_new_string("def"),
     cst_def$1=caml_new_string("def"),
     cst_def=caml_new_string("def"),
     cst_val$0=caml_new_string("val"),
     cst_val=caml_new_string("val"),
     cst_Option_value$0=caml_new_string("Option.value"),
     cst_Nope=caml_new_string("Nope"),
     cst_Nope$0=caml_new_string("Nope"),
     cst_None$0=caml_new_string("None"),
     cst_NativeInt_exponentiate_Negative_exponent_4=
      caml_new_string("NativeInt.exponentiate: Negative exponent: -4"),
     cst_nope=caml_new_string("nope"),
     cst_You_called_me=caml_new_string("You called me!"),
     cst_42=caml_new_string("42"),
     cst_2_7_5=caml_new_string("2 7 5"),
     cst_7_2_4=caml_new_string("7 2 4"),
     cst_2_7_5_9=caml_new_string("2 7 5 9"),
     cst_7_2_4_5=caml_new_string("7 2 4 5"),
     cst_2_7_5_9_3=caml_new_string("2 7 5 9 3"),
     cst_7_2_4_5_3=caml_new_string("7 2 4 5 3"),
     cst_Raised_by_primitive_operation_at_file_Implementation_CallStack_ml_line_3_characters_15_49=
      caml_new_string
       ('Raised by primitive operation at file "Implementation/CallStack.ml", line 3, characters 15-49'),
     cst_Called_from_file_Implementation_CallStack_ml_line_3_characters_15_49=
      caml_new_string
       ('Called from file "Implementation/CallStack.ml", line 3, characters 15-49'),
     cst_List_head=caml_new_string("List.head"),
     cst_List_tail=caml_new_string("List.tail"),
     cst_init=caml_new_string("init"),
     cst_init_3_4=caml_new_string("init-3-4"),
     cst_Int_exponentiate_Negative_exponent_4=
      caml_new_string("Int.exponentiate: Negative exponent: -4"),
     cst_BigInt_exponentiate_Negative_exponent_4=
      caml_new_string("BigInt.exponentiate: Negative exponent: -4"),
     cst_Int64_exponentiate_Negative_exponent_4=
      caml_new_string("Int64.exponentiate: Negative exponent: -4"),
     cst_Int32_exponentiate_Negative_exponent_4=
      caml_new_string("Int32.exponentiate: Negative exponent: -4"),
     cst_bar$0=caml_new_string("bar"),
     cst_Foo_bar_42=caml_new_string("Foo bar 42"),
     cst_baz=caml_new_string("baz"),
     cst_Grmbl_baz_43=caml_new_string("Grmbl baz 43"),
     cst_List_nth=caml_new_string("List.nth"),
     cst_foo$3=caml_new_string("foo"),
     cst_foo$4=caml_new_string("foo"),
     cst_Integer=caml_new_string("Integer"),
     cst_to_float_one=caml_new_string("to_float one"),
     cst_to_int_one=caml_new_string("to_int one"),
     cst_to_float_zero=caml_new_string("to_float zero"),
     cst_to_int_zero=caml_new_string("to_int zero"),
     cst_RealNumber=caml_new_string("RealNumber"),
     cst_1=caml_new_string("1"),
     cst_0=caml_new_string("0"),
     cst_Number=caml_new_string("Number"),
     cst_Able$4=caml_new_string("Able"),
     cst_Able$3=caml_new_string("Able"),
     cst_Able$2=caml_new_string("Able"),
     cst_Able$1=caml_new_string("Able"),
     cst_Able$0=caml_new_string("Able"),
     cst_Able=caml_new_string("Able"),
     cst_Identifiable$4=caml_new_string("Identifiable"),
     cst_Identifiable$3=caml_new_string("Identifiable"),
     cst_Identifiable$2=caml_new_string("Identifiable"),
     cst_Identifiable$1=caml_new_string("Identifiable"),
     cst_Identifiable$0=caml_new_string("Identifiable"),
     cst_Identifiable=caml_new_string("Identifiable"),
     cst_flat_map_acc=caml_new_string("flat_map_acc"),
     cst_flat_map_i=caml_new_string("flat_map_i"),
     cst_flat_map=caml_new_string("flat_map"),
     cst_filter_map_acc=caml_new_string("filter_map_acc"),
     cst_filter_map_i=caml_new_string("filter_map_i"),
     cst_filter_map=caml_new_string("filter_map"),
     cst_filter_acc=caml_new_string("filter_acc"),
     cst_filter_i=caml_new_string("filter_i"),
     cst_filter=caml_new_string("filter"),
     cst_map_acc=caml_new_string("map_acc"),
     cst_map_i=caml_new_string("map_i"),
     cst_map=caml_new_string("map"),
     cst_FilterMapable_ToContainer=
      caml_new_string("FilterMapable.ToContainer"),
     cst_Ringoid=caml_new_string("Ringoid"),
     cst_PredSucc=caml_new_string("PredSucc"),
     cst_Parsable=caml_new_string("Parsable"),
     cst_Displayable=caml_new_string("Displayable"),
     cst_Comparable=caml_new_string("Comparable"),
     cst_Equatable=caml_new_string("Equatable"),
     cst_Representable=caml_new_string("Representable"),
     cst_verbose=caml_new_string("--verbose"),
     cst$3=caml_new_string("  "),
     cst$4=caml_new_string(""),
     cst_OK=caml_new_string("OK"),
     cst_Success=caml_new_string("Success"),
     partial=[12,41,0],
     cst$2=caml_new_string("[]"),
     cst$1=caml_new_string(""),
     cst_Normal=caml_new_string("Normal"),
     cst_SubNormal=caml_new_string("SubNormal"),
     cst_Zero=caml_new_string("Zero"),
     cst_Infinite=caml_new_string("Infinite"),
     cst_NotANumber=caml_new_string("NotANumber"),
     cst=caml_new_string(""),
     cst$0=caml_new_string(""),
     cst_Option_value=caml_new_string("Option.value"),
     cst_None=caml_new_string("None"),
     zero$1=[0,0,0,0],
     cst_General_Testing_TestFailure=
      caml_new_string("General.Testing.TestFailure"),
     cst_js=caml_new_string(".js"),
     cst_General_Testing_NoExceptionRaised=
      caml_new_string("General.Testing.NoExceptionRaised"),
     cst_General_Exception_Tests_TestException=
      caml_new_string("General.Exception.Tests.TestException"),
     cst_foo=caml_new_string("foo"),
     cst_foo$0=caml_new_string("foo"),
     cst_foo$1=caml_new_string("foo"),
     cst_bar=caml_new_string("bar"),
     cst_foo$2=caml_new_string("foo"),
     cst_Division_by_zero=caml_new_string("Division_by_zero"),
     cst_Exit_Pervasives_Exit=caml_new_string("Exit = Pervasives.Exit"),
     cst_DivisionByZero_Division_by_zero=
      caml_new_string("DivisionByZero = Division_by_zero"),
     cst_StackOverflow_Stack_overflow=
      caml_new_string("StackOverflow = Stack_overflow"),
     cst_NotFound_Not_found=caml_new_string("NotFound = Not_found"),
     cst_Failure_Failure=caml_new_string("Failure = Failure"),
     cst_InvalidArgument_Invalid_argument=
      caml_new_string("InvalidArgument = Invalid_argument"),
     cst_AssertFailure_Assert_failure=
      caml_new_string("AssertFailure = Assert_failure"),
     cst_MatchFailure_Match_failure=
      caml_new_string("MatchFailure = Match_failure"),
     cst_Aliases=caml_new_string("Aliases"),
     cst_invalid_argument=caml_new_string("invalid_argument"),
     cst_failure=caml_new_string("failure"),
     cst_raise_without_backtrace=caml_new_string("raise_without_backtrace"),
     cst_raise=caml_new_string("raise"),
     cst_Exception=caml_new_string("Exception"),
     name$0=caml_new_string("Int32"),
     repr_suffix=caml_new_string("l"),
     of_string$4=
      [0,[0,caml_new_string("43"),43],[0,[0,caml_new_string("-12"),-12],0]],
     repr$23=
      [0,
       [0,-3,caml_new_string("-3l")],
       [0,
        [0,0,caml_new_string("0l")],
        [0,
         [0,0,caml_new_string("0l")],
         [0,[0,1,caml_new_string("1l")],[0,[0,15,caml_new_string("15l")],0]]]]],
     to_string$8=
      [0,
       [0,-3,caml_new_string("-3")],
       [0,
        [0,0,caml_new_string("0")],
        [0,
         [0,0,caml_new_string("0")],
         [0,[0,1,caml_new_string("1")],[0,[0,15,caml_new_string("15")],0]]]]],
     equal$31=[0,[0,0,0],[0,[0,1,0],[0,[0,2,0],0]]],
     different$22=[0,[0,0,1],[0,[0,1,-1],0]],
     ordered=[0,[0,-10,[0,-5,[0,-1,[0,0,[0,1,[0,2,[0,5,0]]]]]]],0],
     add_substract=[0,[0,4,3,7],[0,[0,4,-2,2],[0,[0,5,-7,-2],0]]],
     negate$1=[0,[0,4,-4],[0,[0,-7,7],0]],
     multiply$1=[0,[0,4,3,12],[0,[0,4,-3,-12],[0,[0,-4,-3,12],0]]],
     divide$1=
      [0,[0,5,2,2],[0,[0,4,2,2],[0,[0,4,3,1],[0,[0,4,4,1],[0,[0,4,5,0],0]]]]],
     exponentiate=[0,[0,3,3,27],[0,[0,2,7,128],0]],
     succ$2=[0,[0,1,2],[0,[0,42,43],[0,[0,-121,-120],0]]],
     cst_exponentiate_2l_4=caml_new_string("exponentiate 2l (-4)"),
     cst_Int32=caml_new_string("Int32"),
     name$1=caml_new_string("Int64"),
     repr_suffix$0=caml_new_string("L"),
     of_string$5=
      [0,
       [0,caml_new_string("43"),[255,43,0,0]],
       [0,[0,caml_new_string("-12"),[255,16777204,16777215,65535]],0]],
     repr$24=
      [0,
       [0,[255,16777213,16777215,65535],caml_new_string("-3L")],
       [0,
        [0,[255,0,0,0],caml_new_string("0L")],
        [0,
         [0,[255,0,0,0],caml_new_string("0L")],
         [0,
          [0,[255,1,0,0],caml_new_string("1L")],
          [0,[0,[255,15,0,0],caml_new_string("15L")],0]]]]],
     to_string$10=
      [0,
       [0,[255,16777213,16777215,65535],caml_new_string("-3")],
       [0,
        [0,[255,0,0,0],caml_new_string("0")],
        [0,
         [0,[255,0,0,0],caml_new_string("0")],
         [0,
          [0,[255,1,0,0],caml_new_string("1")],
          [0,[0,[255,15,0,0],caml_new_string("15")],0]]]]],
     equal$33=
      [0,[0,[255,0,0,0],0],[0,[0,[255,1,0,0],0],[0,[0,[255,2,0,0],0],0]]],
     different$23=
      [0,
       [0,[255,0,0,0],[255,1,0,0]],
       [0,[0,[255,1,0,0],[255,16777215,16777215,65535]],0]],
     ordered$0=
      [0,
       [0,
        [255,16777206,16777215,65535],
        [0,
         [255,16777211,16777215,65535],
         [0,
          [255,16777215,16777215,65535],
          [0,[255,0,0,0],[0,[255,1,0,0],[0,[255,2,0,0],[0,[255,5,0,0],0]]]]]]],
       0],
     add_substract$0=
      [0,
       [0,[255,4,0,0],[255,3,0,0],[255,7,0,0]],
       [0,
        [0,[255,4,0,0],[255,16777214,16777215,65535],[255,2,0,0]],
        [0,
         [0,
          [255,5,0,0],
          [255,16777209,16777215,65535],
          [255,16777214,16777215,65535]],
         0]]],
     negate$2=
      [0,
       [0,[255,4,0,0],[255,16777212,16777215,65535]],
       [0,[0,[255,16777209,16777215,65535],[255,7,0,0]],0]],
     multiply$2=
      [0,
       [0,[255,4,0,0],[255,3,0,0],[255,12,0,0]],
       [0,
        [0,
         [255,4,0,0],
         [255,16777213,16777215,65535],
         [255,16777204,16777215,65535]],
        [0,
         [0,
          [255,16777212,16777215,65535],
          [255,16777213,16777215,65535],
          [255,12,0,0]],
         0]]],
     divide$2=
      [0,
       [0,[255,5,0,0],[255,2,0,0],[255,2,0,0]],
       [0,
        [0,[255,4,0,0],[255,2,0,0],[255,2,0,0]],
        [0,
         [0,[255,4,0,0],[255,3,0,0],[255,1,0,0]],
         [0,
          [0,[255,4,0,0],[255,4,0,0],[255,1,0,0]],
          [0,[0,[255,4,0,0],[255,5,0,0],[255,0,0,0]],0]]]]],
     exponentiate$0=
      [0,[0,[255,3,0,0],3,[255,27,0,0]],[0,[0,[255,2,0,0],7,[255,128,0,0]],0]],
     succ$4=
      [0,
       [0,[255,1,0,0],[255,2,0,0]],
       [0,
        [0,[255,42,0,0],[255,43,0,0]],
        [0,[0,[255,16777095,16777215,65535],[255,16777096,16777215,65535]],0]]],
     cst_exponentiate_2L_4=caml_new_string("exponentiate 2L (-4)"),
     cst_Int64=caml_new_string("Int64"),
     repr$25=
      [0,
       [0,-3,caml_new_string("-3.")],
       [0,
        [0,-0,caml_new_string("-0.")],
        [0,
         [0,0,caml_new_string("0.")],
         [0,[0,1,caml_new_string("1.")],[0,[0,15,caml_new_string("15.")],0]]]]],
     of_string$6=
      [0,
       [0,caml_new_string("0"),0],
       [0,
        [0,caml_new_string("1"),1],
        [0,
         [0,caml_new_string("1.0"),1],
         [0,
          [0,caml_new_string("-1"),-1],
          [0,[0,caml_new_string("1_000"),1e3],0]]]]],
     ordered$1=
      [0,[0,-10,[0,-5,[0,-1,[0,-0.2,[0,0,[0,0.7,[0,1,[0,2,[0,5,0]]]]]]]]],0],
     add_substract$1=[0,[0,4,3,7],[0,[0,4,-2,2],[0,[0,5,-7,-2],0]]],
     negate$3=[0,[0,4,-4],[0,[0,-7,7],0]],
     multiply$3=[0,[0,4,3,12],[0,[0,4,-3,-12],[0,[0,-4,-3,12],0]]],
     divide$3=
      [0,
       [0,5,2,2.5],
       [0,[0,4,2,2],[0,[0,1,4,0.25],[0,[0,4,4,1],[0,[0,4,5,0.8],0]]]]],
     exponentiate$2=
      [0,
       [0,3,3,27],
       [0,[0,2,7,128],[0,[0,0.5,4,0.0625],[0,[0,2,-4,0.0625],0]]]],
     repr$26=
      [0,
       [0,0,caml_new_string("Normal")],
       [0,
        [0,1,caml_new_string("SubNormal")],
        [0,
         [0,2,caml_new_string("Zero")],
         [0,
          [0,3,caml_new_string("Infinite")],
          [0,[0,4,caml_new_string("NotANumber")],0]]]]],
     equal$35=[0,[0,0,0],[0,[0,1,0],[0,[0,2,0],[0,[0,3,0],[0,[0,4,0],0]]]]],
     different$25=[0,[0,0,1],0],
     ordered$2=[0,[0,0,[0,1,[0,2,[0,3,[0,4,0]]]]],0],
     cst_NotANumber$0=caml_new_string("NotANumber-"),
     cst_NotANumber$1=caml_new_string("NotANumber"),
     cst_NotANumber$2=caml_new_string("NotANumber"),
     cst_Infinite$0=caml_new_string("Infinite-"),
     cst_Infinite$1=caml_new_string("Infinite-"),
     cst_Infinite$2=caml_new_string("Infinite+"),
     cst_Infinite$3=caml_new_string("Infinite+"),
     cst_Zero$0=caml_new_string("Zero-"),
     cst_Zero$1=caml_new_string("Zero"),
     cst_SubNormal$0=caml_new_string("SubNormal"),
     cst_Normal$0=caml_new_string("Normal"),
     cst_of_float=caml_new_string("of_float"),
     cst_Class=caml_new_string("Class"),
     cst_ceil=caml_new_string("ceil"),
     cst_Float=caml_new_string("Float"),
     cst_10000000000000000000000000000000000000000=
      caml_new_string("10000000000000000000000000000000000000000"),
     cst_10000000000=caml_new_string("10000000000"),
     cst_10000000000000000000000000000000000000000$0=
      caml_new_string("10000000000000000000000000000000000000000"),
     cst_10000000000000000000000000000000000000000$1=
      caml_new_string("10000000000000000000000000000000000000000"),
     cst_10=caml_new_string("10"),
     cst_100000=caml_new_string("100000"),
     cst_89884656743115795386465259539451236680898848947115328636715040578866337902750481566354238661203768010560056939935696678829394884407208311246423715319737062188883946712432742638151109800623047059726541476042502884419075341171231440736956555270413618581675255342293149119973622969239858152417678164812112068608=
      caml_new_string
       ("89884656743115795386465259539451236680898848947115328636715040578866337902750481566354238661203768010560056939935696678829394884407208311246423715319737062188883946712432742638151109800623047059726541476042502884419075341171231440736956555270413618581675255342293149119973622969239858152417678164812112068608"),
     cst_6739986666787659948666753771754907668409286105635143120275902562304=
      caml_new_string
       ("6739986666787659948666753771754907668409286105635143120275902562304"),
     cst_3369993333393829974333376885877453834204643052817571560137951281152=
      caml_new_string
       ("3369993333393829974333376885877453834204643052817571560137951281152"),
     cst_1684996666696914987166688442938726917102321526408785780068975640576=
      caml_new_string
       ("1684996666696914987166688442938726917102321526408785780068975640576"),
     cst_842498333348457493583344221469363458551160763204392890034487820288=
      caml_new_string
       ("842498333348457493583344221469363458551160763204392890034487820288"),
     cst_421249166674228746791672110734681729275580381602196445017243910144=
      caml_new_string
       ("421249166674228746791672110734681729275580381602196445017243910144"),
     cst_210624583337114373395836055367340864637790190801098222508621955072=
      caml_new_string
       ("210624583337114373395836055367340864637790190801098222508621955072"),
     cst_105312291668557186697918027683670432318895095400549111254310977536=
      caml_new_string
       ("105312291668557186697918027683670432318895095400549111254310977536"),
     cst_52656145834278593348959013841835216159447547700274555627155488768=
      caml_new_string
       ("52656145834278593348959013841835216159447547700274555627155488768"),
     cst_26328072917139296674479506920917608079723773850137277813577744384=
      caml_new_string
       ("26328072917139296674479506920917608079723773850137277813577744384"),
     cst_13164036458569648337239753460458804039861886925068638906788872192=
      caml_new_string
       ("13164036458569648337239753460458804039861886925068638906788872192"),
     cst_6582018229284824168619876730229402019930943462534319453394436096=
      caml_new_string
       ("6582018229284824168619876730229402019930943462534319453394436096"),
     cst_3291009114642412084309938365114701009965471731267159726697218048=
      caml_new_string
       ("3291009114642412084309938365114701009965471731267159726697218048"),
     cst_1645504557321206042154969182557350504982735865633579863348609024=
      caml_new_string
       ("1645504557321206042154969182557350504982735865633579863348609024"),
     cst_822752278660603021077484591278675252491367932816789931674304512=
      caml_new_string
       ("822752278660603021077484591278675252491367932816789931674304512"),
     cst_411376139330301510538742295639337626245683966408394965837152256=
      caml_new_string
       ("411376139330301510538742295639337626245683966408394965837152256"),
     cst_205688069665150755269371147819668813122841983204197482918576128=
      caml_new_string
       ("205688069665150755269371147819668813122841983204197482918576128"),
     cst_102844034832575377634685573909834406561420991602098741459288064=
      caml_new_string
       ("102844034832575377634685573909834406561420991602098741459288064"),
     cst_51422017416287688817342786954917203280710495801049370729644032=
      caml_new_string
       ("51422017416287688817342786954917203280710495801049370729644032"),
     cst_25711008708143844408671393477458601640355247900524685364822016=
      caml_new_string
       ("25711008708143844408671393477458601640355247900524685364822016"),
     cst_12855504354071922204335696738729300820177623950262342682411008=
      caml_new_string
       ("12855504354071922204335696738729300820177623950262342682411008"),
     cst_6427752177035961102167848369364650410088811975131171341205504=
      caml_new_string
       ("6427752177035961102167848369364650410088811975131171341205504"),
     cst_3213876088517980551083924184682325205044405987565585670602752=
      caml_new_string
       ("3213876088517980551083924184682325205044405987565585670602752"),
     cst_1606938044258990275541962092341162602522202993782792835301376=
      caml_new_string
       ("1606938044258990275541962092341162602522202993782792835301376"),
     cst_803469022129495137770981046170581301261101496891396417650688=
      caml_new_string
       ("803469022129495137770981046170581301261101496891396417650688"),
     cst_401734511064747568885490523085290650630550748445698208825344=
      caml_new_string
       ("401734511064747568885490523085290650630550748445698208825344"),
     cst_200867255532373784442745261542645325315275374222849104412672=
      caml_new_string
       ("200867255532373784442745261542645325315275374222849104412672"),
     cst_100433627766186892221372630771322662657637687111424552206336=
      caml_new_string
       ("100433627766186892221372630771322662657637687111424552206336"),
     cst_50216813883093446110686315385661331328818843555712276103168=
      caml_new_string
       ("50216813883093446110686315385661331328818843555712276103168"),
     cst_25108406941546723055343157692830665664409421777856138051584=
      caml_new_string
       ("25108406941546723055343157692830665664409421777856138051584"),
     cst_12554203470773361527671578846415332832204710888928069025792=
      caml_new_string
       ("12554203470773361527671578846415332832204710888928069025792"),
     cst_6277101735386680763835789423207666416102355444464034512896=
      caml_new_string
       ("6277101735386680763835789423207666416102355444464034512896"),
     cst_3138550867693340381917894711603833208051177722232017256448=
      caml_new_string
       ("3138550867693340381917894711603833208051177722232017256448"),
     cst_1569275433846670190958947355801916604025588861116008628224=
      caml_new_string
       ("1569275433846670190958947355801916604025588861116008628224"),
     cst_784637716923335095479473677900958302012794430558004314112=
      caml_new_string
       ("784637716923335095479473677900958302012794430558004314112"),
     cst_392318858461667547739736838950479151006397215279002157056=
      caml_new_string
       ("392318858461667547739736838950479151006397215279002157056"),
     cst_196159429230833773869868419475239575503198607639501078528=
      caml_new_string
       ("196159429230833773869868419475239575503198607639501078528"),
     cst_98079714615416886934934209737619787751599303819750539264=
      caml_new_string
       ("98079714615416886934934209737619787751599303819750539264"),
     cst_49039857307708443467467104868809893875799651909875269632=
      caml_new_string
       ("49039857307708443467467104868809893875799651909875269632"),
     cst_24519928653854221733733552434404946937899825954937634816=
      caml_new_string
       ("24519928653854221733733552434404946937899825954937634816"),
     cst_12259964326927110866866776217202473468949912977468817408=
      caml_new_string
       ("12259964326927110866866776217202473468949912977468817408"),
     cst_6129982163463555433433388108601236734474956488734408704=
      caml_new_string
       ("6129982163463555433433388108601236734474956488734408704"),
     cst_3064991081731777716716694054300618367237478244367204352=
      caml_new_string
       ("3064991081731777716716694054300618367237478244367204352"),
     cst_1532495540865888858358347027150309183618739122183602176=
      caml_new_string
       ("1532495540865888858358347027150309183618739122183602176"),
     cst_766247770432944429179173513575154591809369561091801088=
      caml_new_string
       ("766247770432944429179173513575154591809369561091801088"),
     cst_383123885216472214589586756787577295904684780545900544=
      caml_new_string
       ("383123885216472214589586756787577295904684780545900544"),
     cst_191561942608236107294793378393788647952342390272950272=
      caml_new_string
       ("191561942608236107294793378393788647952342390272950272"),
     cst_95780971304118053647396689196894323976171195136475136=
      caml_new_string("95780971304118053647396689196894323976171195136475136"),
     cst_47890485652059026823698344598447161988085597568237568=
      caml_new_string("47890485652059026823698344598447161988085597568237568"),
     cst_23945242826029513411849172299223580994042798784118784=
      caml_new_string("23945242826029513411849172299223580994042798784118784"),
     cst_11972621413014756705924586149611790497021399392059392=
      caml_new_string("11972621413014756705924586149611790497021399392059392"),
     cst_5986310706507378352962293074805895248510699696029696=
      caml_new_string("5986310706507378352962293074805895248510699696029696"),
     cst_2993155353253689176481146537402947624255349848014848=
      caml_new_string("2993155353253689176481146537402947624255349848014848"),
     cst_1496577676626844588240573268701473812127674924007424=
      caml_new_string("1496577676626844588240573268701473812127674924007424"),
     cst_748288838313422294120286634350736906063837462003712=
      caml_new_string("748288838313422294120286634350736906063837462003712"),
     cst_374144419156711147060143317175368453031918731001856=
      caml_new_string("374144419156711147060143317175368453031918731001856"),
     cst_187072209578355573530071658587684226515959365500928=
      caml_new_string("187072209578355573530071658587684226515959365500928"),
     cst_93536104789177786765035829293842113257979682750464=
      caml_new_string("93536104789177786765035829293842113257979682750464"),
     cst_46768052394588893382517914646921056628989841375232=
      caml_new_string("46768052394588893382517914646921056628989841375232"),
     cst_23384026197294446691258957323460528314494920687616=
      caml_new_string("23384026197294446691258957323460528314494920687616"),
     cst_11692013098647223345629478661730264157247460343808=
      caml_new_string("11692013098647223345629478661730264157247460343808"),
     cst_5846006549323611672814739330865132078623730171904=
      caml_new_string("5846006549323611672814739330865132078623730171904"),
     cst_2923003274661805836407369665432566039311865085952=
      caml_new_string("2923003274661805836407369665432566039311865085952"),
     cst_1461501637330902918203684832716283019655932542976=
      caml_new_string("1461501637330902918203684832716283019655932542976"),
     cst_730750818665451459101842416358141509827966271488=
      caml_new_string("730750818665451459101842416358141509827966271488"),
     cst_365375409332725729550921208179070754913983135744=
      caml_new_string("365375409332725729550921208179070754913983135744"),
     cst_182687704666362864775460604089535377456991567872=
      caml_new_string("182687704666362864775460604089535377456991567872"),
     cst_91343852333181432387730302044767688728495783936=
      caml_new_string("91343852333181432387730302044767688728495783936"),
     cst_45671926166590716193865151022383844364247891968=
      caml_new_string("45671926166590716193865151022383844364247891968"),
     cst_22835963083295358096932575511191922182123945984=
      caml_new_string("22835963083295358096932575511191922182123945984"),
     cst_11417981541647679048466287755595961091061972992=
      caml_new_string("11417981541647679048466287755595961091061972992"),
     cst_5708990770823839524233143877797980545530986496=
      caml_new_string("5708990770823839524233143877797980545530986496"),
     cst_2854495385411919762116571938898990272765493248=
      caml_new_string("2854495385411919762116571938898990272765493248"),
     cst_1427247692705959881058285969449495136382746624=
      caml_new_string("1427247692705959881058285969449495136382746624"),
     cst_713623846352979940529142984724747568191373312=
      caml_new_string("713623846352979940529142984724747568191373312"),
     cst_356811923176489970264571492362373784095686656=
      caml_new_string("356811923176489970264571492362373784095686656"),
     cst_178405961588244985132285746181186892047843328=
      caml_new_string("178405961588244985132285746181186892047843328"),
     cst_89202980794122492566142873090593446023921664=
      caml_new_string("89202980794122492566142873090593446023921664"),
     cst_44601490397061246283071436545296723011960832=
      caml_new_string("44601490397061246283071436545296723011960832"),
     cst_22300745198530623141535718272648361505980416=
      caml_new_string("22300745198530623141535718272648361505980416"),
     cst_11150372599265311570767859136324180752990208=
      caml_new_string("11150372599265311570767859136324180752990208"),
     cst_5575186299632655785383929568162090376495104=
      caml_new_string("5575186299632655785383929568162090376495104"),
     cst_2787593149816327892691964784081045188247552=
      caml_new_string("2787593149816327892691964784081045188247552"),
     cst_1393796574908163946345982392040522594123776=
      caml_new_string("1393796574908163946345982392040522594123776"),
     cst_696898287454081973172991196020261297061888=
      caml_new_string("696898287454081973172991196020261297061888"),
     cst_348449143727040986586495598010130648530944=
      caml_new_string("348449143727040986586495598010130648530944"),
     cst_174224571863520493293247799005065324265472=
      caml_new_string("174224571863520493293247799005065324265472"),
     cst_87112285931760246646623899502532662132736=
      caml_new_string("87112285931760246646623899502532662132736"),
     cst_43556142965880123323311949751266331066368=
      caml_new_string("43556142965880123323311949751266331066368"),
     cst_21778071482940061661655974875633165533184=
      caml_new_string("21778071482940061661655974875633165533184"),
     cst_10889035741470030830827987437816582766592=
      caml_new_string("10889035741470030830827987437816582766592"),
     cst_5444517870735015415413993718908291383296=
      caml_new_string("5444517870735015415413993718908291383296"),
     cst_2722258935367507707706996859454145691648=
      caml_new_string("2722258935367507707706996859454145691648"),
     cst_1361129467683753853853498429727072845824=
      caml_new_string("1361129467683753853853498429727072845824"),
     cst_680564733841876926926749214863536422912=
      caml_new_string("680564733841876926926749214863536422912"),
     cst_340282366920938463463374607431768211456=
      caml_new_string("340282366920938463463374607431768211456"),
     cst_170141183460469231731687303715884105728=
      caml_new_string("170141183460469231731687303715884105728"),
     cst_85070591730234615865843651857942052864=
      caml_new_string("85070591730234615865843651857942052864"),
     cst_42535295865117307932921825928971026432=
      caml_new_string("42535295865117307932921825928971026432"),
     cst_21267647932558653966460912964485513216=
      caml_new_string("21267647932558653966460912964485513216"),
     cst_10633823966279326983230456482242756608=
      caml_new_string("10633823966279326983230456482242756608"),
     cst_5316911983139663491615228241121378304=
      caml_new_string("5316911983139663491615228241121378304"),
     cst_2658455991569831745807614120560689152=
      caml_new_string("2658455991569831745807614120560689152"),
     cst_1329227995784915872903807060280344576=
      caml_new_string("1329227995784915872903807060280344576"),
     cst_664613997892457936451903530140172288=
      caml_new_string("664613997892457936451903530140172288"),
     cst_332306998946228968225951765070086144=
      caml_new_string("332306998946228968225951765070086144"),
     cst_166153499473114484112975882535043072=
      caml_new_string("166153499473114484112975882535043072"),
     cst_83076749736557242056487941267521536=
      caml_new_string("83076749736557242056487941267521536"),
     cst_41538374868278621028243970633760768=
      caml_new_string("41538374868278621028243970633760768"),
     cst_20769187434139310514121985316880384=
      caml_new_string("20769187434139310514121985316880384"),
     cst_10384593717069655257060992658440192=
      caml_new_string("10384593717069655257060992658440192"),
     cst_5192296858534827628530496329220096=
      caml_new_string("5192296858534827628530496329220096"),
     cst_2596148429267413814265248164610048=
      caml_new_string("2596148429267413814265248164610048"),
     cst_1298074214633706907132624082305024=
      caml_new_string("1298074214633706907132624082305024"),
     cst_649037107316853453566312041152512=
      caml_new_string("649037107316853453566312041152512"),
     cst_324518553658426726783156020576256=
      caml_new_string("324518553658426726783156020576256"),
     cst_162259276829213363391578010288128=
      caml_new_string("162259276829213363391578010288128"),
     cst_81129638414606681695789005144064=
      caml_new_string("81129638414606681695789005144064"),
     cst_40564819207303340847894502572032=
      caml_new_string("40564819207303340847894502572032"),
     cst_20282409603651670423947251286016=
      caml_new_string("20282409603651670423947251286016"),
     cst_10141204801825835211973625643008=
      caml_new_string("10141204801825835211973625643008"),
     cst_5070602400912917605986812821504=
      caml_new_string("5070602400912917605986812821504"),
     cst_2535301200456458802993406410752=
      caml_new_string("2535301200456458802993406410752"),
     cst_1267650600228229401496703205376=
      caml_new_string("1267650600228229401496703205376"),
     cst_633825300114114700748351602688=
      caml_new_string("633825300114114700748351602688"),
     cst_316912650057057350374175801344=
      caml_new_string("316912650057057350374175801344"),
     cst_158456325028528675187087900672=
      caml_new_string("158456325028528675187087900672"),
     cst_79228162514264337593543950336=
      caml_new_string("79228162514264337593543950336"),
     cst_39614081257132168796771975168=
      caml_new_string("39614081257132168796771975168"),
     cst_19807040628566084398385987584=
      caml_new_string("19807040628566084398385987584"),
     cst_9903520314283042199192993792=
      caml_new_string("9903520314283042199192993792"),
     cst_4951760157141521099596496896=
      caml_new_string("4951760157141521099596496896"),
     cst_2475880078570760549798248448=
      caml_new_string("2475880078570760549798248448"),
     cst_1237940039285380274899124224=
      caml_new_string("1237940039285380274899124224"),
     cst_618970019642690137449562112=
      caml_new_string("618970019642690137449562112"),
     cst_309485009821345068724781056=
      caml_new_string("309485009821345068724781056"),
     cst_154742504910672534362390528=
      caml_new_string("154742504910672534362390528"),
     cst_77371252455336267181195264=
      caml_new_string("77371252455336267181195264"),
     cst_38685626227668133590597632=
      caml_new_string("38685626227668133590597632"),
     cst_19342813113834066795298816=
      caml_new_string("19342813113834066795298816"),
     cst_9671406556917033397649408=
      caml_new_string("9671406556917033397649408"),
     cst_4835703278458516698824704=
      caml_new_string("4835703278458516698824704"),
     cst_2417851639229258349412352=
      caml_new_string("2417851639229258349412352"),
     cst_1208925819614629174706176=
      caml_new_string("1208925819614629174706176"),
     cst_604462909807314587353088=caml_new_string("604462909807314587353088"),
     cst_302231454903657293676544=caml_new_string("302231454903657293676544"),
     cst_151115727451828646838272=caml_new_string("151115727451828646838272"),
     cst_75557863725914323419136=caml_new_string("75557863725914323419136"),
     cst_37778931862957161709568=caml_new_string("37778931862957161709568"),
     cst_18889465931478580854784=caml_new_string("18889465931478580854784"),
     cst_9444732965739290427392=caml_new_string("9444732965739290427392"),
     cst_4722366482869645213696=caml_new_string("4722366482869645213696"),
     cst_2361183241434822606848=caml_new_string("2361183241434822606848"),
     cst_1180591620717411303424=caml_new_string("1180591620717411303424"),
     cst_590295810358705651712=caml_new_string("590295810358705651712"),
     cst_295147905179352825856=caml_new_string("295147905179352825856"),
     cst_147573952589676412928=caml_new_string("147573952589676412928"),
     cst_73786976294838206464=caml_new_string("73786976294838206464"),
     cst_36893488147419103232=caml_new_string("36893488147419103232"),
     cst_18446744073709551616=caml_new_string("18446744073709551616"),
     cst_9223372036854775808=caml_new_string("9223372036854775808"),
     cst_4611686018427387904=caml_new_string("4611686018427387904"),
     cst_2305843009213693952=caml_new_string("2305843009213693952"),
     cst_1152921504606846976=caml_new_string("1152921504606846976"),
     cst_576460752303423488=caml_new_string("576460752303423488"),
     cst_288230376151711744=caml_new_string("288230376151711744"),
     cst_144115188075855872=caml_new_string("144115188075855872"),
     cst_72057594037927936=caml_new_string("72057594037927936"),
     cst_36028797018963968=caml_new_string("36028797018963968"),
     cst_18014398509481984=caml_new_string("18014398509481984"),
     cst_9007199254740992=caml_new_string("9007199254740992"),
     cst_4503599627370496=caml_new_string("4503599627370496"),
     cst_2251799813685248=caml_new_string("2251799813685248"),
     cst_1125899906842624=caml_new_string("1125899906842624"),
     cst_562949953421312=caml_new_string("562949953421312"),
     cst_281474976710656=caml_new_string("281474976710656"),
     cst_140737488355328=caml_new_string("140737488355328"),
     cst_70368744177664=caml_new_string("70368744177664"),
     cst_35184372088832=caml_new_string("35184372088832"),
     cst_17592186044416=caml_new_string("17592186044416"),
     cst_8796093022208=caml_new_string("8796093022208"),
     cst_4398046511104=caml_new_string("4398046511104"),
     cst_2199023255552=caml_new_string("2199023255552"),
     cst_1099511627776=caml_new_string("1099511627776"),
     cst_549755813888=caml_new_string("549755813888"),
     cst_274877906944=caml_new_string("274877906944"),
     cst_137438953472=caml_new_string("137438953472"),
     cst_68719476736=caml_new_string("68719476736"),
     cst_34359738368=caml_new_string("34359738368"),
     cst_17179869184=caml_new_string("17179869184"),
     cst_8589934592=caml_new_string("8589934592"),
     cst_4294967296=caml_new_string("4294967296"),
     cst_2147483648=caml_new_string("2147483648"),
     cst_1073741824=caml_new_string("1073741824"),
     cst_536870912=caml_new_string("536870912"),
     cst_268435456=caml_new_string("268435456"),
     cst_134217728=caml_new_string("134217728"),
     cst_67108864=caml_new_string("67108864"),
     cst_33554432=caml_new_string("33554432"),
     cst_16777216=caml_new_string("16777216"),
     cst_8388608=caml_new_string("8388608"),
     cst_4194304=caml_new_string("4194304"),
     cst_2097152=caml_new_string("2097152"),
     cst_1048576=caml_new_string("1048576"),
     cst_524288=caml_new_string("524288"),
     cst_262144=caml_new_string("262144"),
     cst_131072=caml_new_string("131072"),
     cst_65536=caml_new_string("65536"),
     cst_32768=caml_new_string("32768"),
     cst_16384=caml_new_string("16384"),
     cst_8192=caml_new_string("8192"),
     cst_4096=caml_new_string("4096"),
     cst_2048=caml_new_string("2048"),
     cst_1024=caml_new_string("1024"),
     cst_512=caml_new_string("512"),
     cst_256=caml_new_string("256"),
     cst_128=caml_new_string("128"),
     cst_64=caml_new_string("64"),
     cst_32=caml_new_string("32"),
     cst_16=caml_new_string("16"),
     cst_8=caml_new_string("8"),
     cst_4=caml_new_string("4"),
     cst_2=caml_new_string("2"),
     cst_39614081257132164398725464064=
      caml_new_string("39614081257132164398725464064"),
     cst_144115188075855856=caml_new_string("144115188075855856"),
     cst_72057594037927928=caml_new_string("72057594037927928"),
     cst_36028797018963964=caml_new_string("36028797018963964"),
     cst_18014398509481982=caml_new_string("18014398509481982"),
     cst_9007199254740991=caml_new_string("9007199254740991"),
     cst_4503599627370495=caml_new_string("4503599627370495"),
     cst_2251799813685247=caml_new_string("2251799813685247"),
     cst_1125899906842623=caml_new_string("1125899906842623"),
     cst_7=caml_new_string("7"),
     cst_3=caml_new_string("3"),
     cst_1$0=caml_new_string("1"),
     cst_0$0=caml_new_string("0"),
     cst_of_float$0=caml_new_string("of_float"),
     cst_exponentiate_of_int_2_4=
      caml_new_string("exponentiate (of_int 2) (-4)"),
     cst_BigInt=caml_new_string("BigInt"),
     repr$28=
      [0,[0,0,caml_new_string("false")],[0,[0,1,caml_new_string("true")],0]],
     of_string$9=
      [0,[0,caml_new_string("false"),0],[0,[0,caml_new_string("true"),1],0]],
     equal$38=[0,[0,1,0],[0,[0,0,0],0]],
     different$28=[0,[0,1,0],0],
     ordered$4=[0,[0,0,[0,1,0]],0],
     cst_xor_false_false=caml_new_string("xor false false"),
     cst_xor_true_false=caml_new_string("xor true false"),
     cst_xor_false_true=caml_new_string("xor false true"),
     cst_xor_true_true=caml_new_string("xor true true"),
     cst_false_false=caml_new_string("false || false"),
     cst_false_true=caml_new_string("false || true"),
     cst_true_whatever=caml_new_string("true || whatever"),
     cst_or_false_false=caml_new_string("or_ false false"),
     cst_or_true_false=caml_new_string("or_ true false"),
     cst_or_false_true=caml_new_string("or_ false true"),
     cst_or_true_true=caml_new_string("or_ true true"),
     cst_false_whatever=caml_new_string("false && whatever"),
     cst_true_false=caml_new_string("true && false"),
     cst_true_true=caml_new_string("true && true"),
     cst_and_false_false=caml_new_string("and_ false false"),
     cst_and_true_false=caml_new_string("and_ true false"),
     cst_and_false_true=caml_new_string("and_ false true"),
     cst_and_true_true=caml_new_string("and_ true true"),
     cst_not_false=caml_new_string("not false"),
     cst_not_true=caml_new_string("not true"),
     cst_Bool=caml_new_string("Bool"),
     repr$29=
      [0,
       [0,-3,caml_new_string("-3")],
       [0,
        [0,0,caml_new_string("0")],
        [0,
         [0,0,caml_new_string("0")],
         [0,[0,1,caml_new_string("1")],[0,[0,15,caml_new_string("15")],0]]]]],
     of_string$11=
      [0,
       [0,caml_new_string("0"),0],
       [0,
        [0,caml_new_string("1"),1],
        [0,
         [0,caml_new_string("-1"),-1],
         [0,[0,caml_new_string("1_000"),1e3],0]]]],
     equal$39=[0,[0,0,0],[0,[0,1,0],[0,[0,2,0],0]]],
     different$29=[0,[0,0,1],[0,[0,1,-1],0]],
     ordered$5=[0,[0,-10,[0,-5,[0,-1,[0,0,[0,1,[0,2,[0,5,0]]]]]]],0],
     add_substract$3=[0,[0,4,3,7],[0,[0,4,-2,2],[0,[0,5,-7,-2],0]]],
     negate$6=[0,[0,4,-4],[0,[0,-7,7],0]],
     multiply$6=[0,[0,4,3,12],[0,[0,4,-3,-12],[0,[0,-4,-3,12],0]]],
     divide$6=
      [0,[0,5,2,2],[0,[0,4,2,2],[0,[0,4,3,1],[0,[0,4,4,1],[0,[0,4,5,0],0]]]]],
     exponentiate$6=[0,[0,3,3,27],[0,[0,2,7,128],0]],
     succ$7=[0,[0,1,2],[0,[0,42,43],[0,[0,-121,-120],0]]],
     cst_exponentiate_2_4=caml_new_string("exponentiate 2 (-4)"),
     cst_Int=caml_new_string("Int"),
     repr$30=
      [0,
       [0,0,caml_new_string("[]")],
       [0,
        [0,[0,1,0],caml_new_string("[1]")],
        [0,[0,[0,1,[0,2,[0,3,0]]],caml_new_string("[1; 2; 3]")],0]]],
     different$31=
      [0,
       [0,0,[0,1,0]],
       [0,
        [0,[0,1,0],[0,2,0]],
        [0,
         [0,[0,1,[0,1,[0,1,0]]],[0,1,[0,1,[0,2,0]]]],
         [0,[0,[0,1,[0,1,[0,1,0]]],[0,1,[0,1,[0,1,[0,1,0]]]]],0]]]],
     cst_iter=caml_new_string("iter"),
     cst_try_reduce=caml_new_string("try_reduce []"),
     cst_try_reduce$0=caml_new_string("try_reduce"),
     cst_reduce=caml_new_string("reduce"),
     cst_reduce_0=caml_new_string("reduce [0]"),
     cst_fold=caml_new_string("fold"),
     cst_fold$0=caml_new_string("fold []"),
     cst_tail=caml_new_string("tail []"),
     cst_tail$0=caml_new_string("tail"),
     cst_head=caml_new_string("head []"),
     cst_head$0=caml_new_string("head"),
     cst_try_tail=caml_new_string("try_tail []"),
     cst_try_tail$0=caml_new_string("try_tail"),
     cst_try_head=caml_new_string("try_head []"),
     cst_try_head$0=caml_new_string("try_head"),
     cst_prepend=caml_new_string("prepend"),
     cst_concat=caml_new_string("concat"),
     cst_reverse=caml_new_string("reverse"),
     cst_List=caml_new_string("List"),
     cst$5=caml_new_string(""),
     cst_Raised_by_primitive_operation_at_file_Implementation_CallStack_ml_line_3_characters_15_49_Called_from_file_Implementation_CallStack_ml_line_4_characters_15_30_Called_from_file_Implementation_CallStack_ml_line_4_characters_15_30_Called_from_file_Implementation_CallStack_ml_line_7_characters_2_9=
      caml_new_string
       ('Raised by primitive operation at file "Implementation/CallStack.ml", line 3, characters 15-49\nCalled from file "Implementation/CallStack.ml", line 4, characters 15-30\nCalled from file "Implementation/CallStack.ml", line 4, characters 15-30\nCalled from file "Implementation/CallStack.ml", line 7, characters 2-9\n'),
     repr$31=
      [0,
       [0,
        [0,caml_new_string("Implementation/CallStack.ml"),3,15,49],
        caml_new_string
         ('{filename="Implementation/CallStack.ml"; line_number=3; start_char=15; end_char=49}')],
       0],
     cst_location=caml_new_string("location"),
     cst_format_1=caml_new_string("format 1"),
     cst_format_0=caml_new_string("format 0"),
     cst_Frame=caml_new_string("Frame"),
     cst_Location=caml_new_string("Location"),
     cst_frames=caml_new_string("frames"),
     cst_CallStack=caml_new_string("CallStack"),
     cst_uncurry=caml_new_string("uncurry"),
     cst_curry=caml_new_string("curry"),
     cst_flip=caml_new_string("flip"),
     cst_Function5=caml_new_string("Function5"),
     cst_uncurry$0=caml_new_string("uncurry"),
     cst_curry$0=caml_new_string("curry"),
     cst_flip$0=caml_new_string("flip"),
     cst_Function4=caml_new_string("Function4"),
     cst_uncurry$1=caml_new_string("uncurry"),
     cst_curry$1=caml_new_string("curry"),
     cst_flip$1=caml_new_string("flip"),
     cst_Function3=caml_new_string("Function3"),
     cst_uncurry$2=caml_new_string("uncurry"),
     cst_curry$2=caml_new_string("curry"),
     cst_flip$2=caml_new_string("flip"),
     cst_Function2=caml_new_string("Function2"),
     cst_compose=caml_new_string("compose"),
     cst_rev_apply=caml_new_string("rev_apply"),
     cst_apply=caml_new_string("apply"),
     cst_identity_42=caml_new_string("identity 42"),
     cst_Function1=caml_new_string("Function1"),
     cst_Functions=caml_new_string("Functions"),
     cst_3_to_23_step_4=caml_new_string("[3 to 23 step 4]"),
     cst_0_down_to_12_step_3=caml_new_string("[0 down to -12 step -3]"),
     cst_0_to_4_step_1=caml_new_string("[0 to 4 step 1]"),
     cst$6=caml_new_string("[]"),
     cst$7=caml_new_string("[]"),
     cst_with_step_0_and_start=caml_new_string("with step < 0 and start"),
     cst_with_step_0_and_start$0=caml_new_string("with step < 0 and start"),
     cst_with_step_0=caml_new_string("with step < 0"),
     cst_with_step_0$0=caml_new_string("with step < 0"),
     cst_with_step_0$1=caml_new_string("with step < 0"),
     cst_with_start_and_step=caml_new_string("with start and step"),
     cst_with_start_and_step$0=caml_new_string("with start and step"),
     cst_with_start_and_step$1=caml_new_string("with start and step"),
     cst_with_start_and_step$2=caml_new_string("with start and step"),
     cst_with_step_0$2=caml_new_string("with step = 0"),
     cst_with_step=caml_new_string("with step"),
     cst_with_step$0=caml_new_string("with step"),
     cst_with_stop_start=caml_new_string("with stop <= start"),
     cst_with_stop_start$0=caml_new_string("with stop <= start"),
     cst_with_stop_start$1=caml_new_string("with stop <= start"),
     cst_with_stop_0=caml_new_string("with stop < 0"),
     cst_with_start=caml_new_string("with start"),
     cst_simplest=caml_new_string("simplest"),
     cst_to_list=caml_new_string("to_list"),
     cst_IntRange=caml_new_string("IntRange"),
     cst_map_is_lazy=caml_new_string("map is lazy"),
     cst_map$0=caml_new_string("map"),
     cst_is_value=caml_new_string("is_value"),
     cst_value_exc=caml_new_string("value exc"),
     cst_value=caml_new_string("value"),
     cst_Lazy=caml_new_string("Lazy"),
     name$2=caml_new_string("NativeInt"),
     repr_suffix$1=caml_new_string("n"),
     of_string$12=
      [0,[0,caml_new_string("43"),43],[0,[0,caml_new_string("-12"),-12],0]],
     repr$33=
      [0,
       [0,-3,caml_new_string("-3n")],
       [0,
        [0,0,caml_new_string("0n")],
        [0,
         [0,0,caml_new_string("0n")],
         [0,[0,1,caml_new_string("1n")],[0,[0,15,caml_new_string("15n")],0]]]]],
     to_string$16=
      [0,
       [0,-3,caml_new_string("-3")],
       [0,
        [0,0,caml_new_string("0")],
        [0,
         [0,0,caml_new_string("0")],
         [0,[0,1,caml_new_string("1")],[0,[0,15,caml_new_string("15")],0]]]]],
     equal$43=[0,[0,0,0],[0,[0,1,0],[0,[0,2,0],0]]],
     different$33=[0,[0,0,1],[0,[0,1,-1],0]],
     ordered$6=[0,[0,-10,[0,-5,[0,-1,[0,0,[0,1,[0,2,[0,5,0]]]]]]],0],
     add_substract$4=[0,[0,4,3,7],[0,[0,4,-2,2],[0,[0,5,-7,-2],0]]],
     negate$7=[0,[0,4,-4],[0,[0,-7,7],0]],
     multiply$7=[0,[0,4,3,12],[0,[0,4,-3,-12],[0,[0,-4,-3,12],0]]],
     divide$7=
      [0,[0,5,2,2],[0,[0,4,2,2],[0,[0,4,3,1],[0,[0,4,4,1],[0,[0,4,5,0],0]]]]],
     exponentiate$7=[0,[0,3,3,27],[0,[0,2,7,128],0]],
     succ$9=[0,[0,1,2],[0,[0,42,43],[0,[0,-121,-120],0]]],
     cst_exponentiate_2n_4=caml_new_string("exponentiate 2n (-4)"),
     cst_NativeInt=caml_new_string("NativeInt"),
     repr$34=
      [0,
       [0,0,caml_new_string("None")],
       [0,[0,[0,42],caml_new_string("Some 42")],0]],
     equal$44=[0,[0,0,0],[0,[0,[0,42],0],0]],
     different$35=[0,[0,0,[0,42]],[0,[0,[0,42],[0,43]],0]],
     ordered$7=[0,[0,0,[0,[0,0],[0,[0,1],0]]],0],
     cst_filter_map_Some_false=caml_new_string("filter_map Some false"),
     cst_filter_map_Some_true=caml_new_string("filter_map Some true"),
     cst_filter_map_None=caml_new_string("filter_map None"),
     cst_filter_Some_false=caml_new_string("filter Some false"),
     cst_filter_Some_true=caml_new_string("filter Some true"),
     cst_filter_None=caml_new_string("filter None"),
     cst_iter_Some=caml_new_string("iter Some"),
     cst_iter_None=caml_new_string("iter None"),
     cst_value_map_Some=caml_new_string("value_map Some"),
     cst_value_map_None=caml_new_string("value_map None"),
     cst_map_Some=caml_new_string("map Some"),
     cst_map_None=caml_new_string("map None"),
     cst_repr_None=caml_new_string("repr None"),
     cst_value_exc_None=caml_new_string("value ~exc None"),
     cst_value_None=caml_new_string("value None"),
     cst_value_Some=caml_new_string("value Some"),
     cst_value_def_Some=caml_new_string("value_def Some"),
     cst_value_def_None=caml_new_string("value_def None"),
     cst_is_none_Some=caml_new_string("is_none Some"),
     cst_is_none_None=caml_new_string("is_none None"),
     cst_is_some_Some=caml_new_string("is_some Some"),
     cst_is_some_None=caml_new_string("is_some None"),
     cst_some_if_false=caml_new_string("some_if' false"),
     cst_some_if_true=caml_new_string("some_if' true"),
     cst_some_if_false$0=caml_new_string("some_if false"),
     cst_some_if_true$0=caml_new_string("some_if true"),
     cst_Option=caml_new_string("Option"),
     repr$35=[0,[0,[0,1,caml_new_string("a")],caml_new_string('(1, "a")')],0],
     equal$45=[0,[0,[0,1,caml_new_string("a")],0],0],
     different$36=
      [0,
       [0,[0,1,caml_new_string("a")],[0,1,caml_new_string("b")]],
       [0,[0,[0,1,caml_new_string("a")],[0,2,caml_new_string("a")]],0]],
     ordered$8=
      [0,
       [0,
        [0,0,caml_new_string("a")],
        [0,[0,0,caml_new_string("b")],[0,[0,1,caml_new_string("a")],0]]],
       0],
     repr$36=
      [0,[0,[0,1,caml_new_string("a"),2],caml_new_string('(1, "a", 2.)')],0],
     equal$46=[0,[0,[0,1,caml_new_string("a"),2],0],0],
     different$37=
      [0,
       [0,[0,1,caml_new_string("a"),2],[0,1,caml_new_string("a"),3]],
       [0,
        [0,[0,1,caml_new_string("a"),2],[0,1,caml_new_string("b"),2]],
        [0,[0,[0,1,caml_new_string("a"),2],[0,2,caml_new_string("a"),2]],0]]],
     ordered$9=
      [0,
       [0,
        [0,0,caml_new_string("a"),0],
        [0,
         [0,0,caml_new_string("a"),1],
         [0,[0,0,caml_new_string("b"),0],[0,[0,1,caml_new_string("a"),0],0]]]],
       0],
     repr$37=
      [0,
       [0,[0,1,caml_new_string("a"),2,3],caml_new_string('(1, "a", 2., 3)')],
       0],
     equal$47=[0,[0,[0,1,caml_new_string("a"),2,3],0],0],
     different$38=
      [0,
       [0,[0,1,caml_new_string("a"),2,3],[0,1,caml_new_string("a"),2,4]],
       [0,
        [0,[0,1,caml_new_string("a"),2,3],[0,1,caml_new_string("a"),3,3]],
        [0,
         [0,[0,1,caml_new_string("a"),2,3],[0,1,caml_new_string("b"),2,3]],
         [0,
          [0,[0,1,caml_new_string("a"),2,3],[0,0,caml_new_string("a"),2,3]],
          0]]]],
     ordered$10=
      [0,
       [0,
        [0,1,caml_new_string("a"),2,3],
        [0,
         [0,1,caml_new_string("a"),2,4],
         [0,
          [0,1,caml_new_string("a"),3,3],
          [0,
           [0,1,caml_new_string("b"),2,3],
           [0,[0,2,caml_new_string("a"),2,3],0]]]]],
       0],
     repr$38=
      [0,
       [0,
        [0,1,caml_new_string("a"),2,3,4],
        caml_new_string('(1, "a", 2., 3, 4)')],
       0],
     equal$48=[0,[0,[0,1,caml_new_string("a"),2,3,4],0],0],
     different$39=
      [0,
       [0,[0,1,caml_new_string("a"),2,3,4],[0,1,caml_new_string("a"),2,3,5]],
       [0,
        [0,[0,1,caml_new_string("a"),2,3,4],[0,1,caml_new_string("a"),2,4,4]],
        [0,
         [0,[0,1,caml_new_string("a"),2,3,4],[0,1,caml_new_string("a"),3,3,4]],
         [0,
          [0,
           [0,1,caml_new_string("a"),2,3,4],
           [0,1,caml_new_string("b"),2,3,4]],
          [0,
           [0,
            [0,1,caml_new_string("a"),2,3,4],
            [0,0,caml_new_string("a"),2,3,4]],
           0]]]]],
     ordered$11=
      [0,
       [0,
        [0,1,caml_new_string("a"),2,3,4],
        [0,
         [0,1,caml_new_string("a"),2,3,5],
         [0,
          [0,1,caml_new_string("a"),2,4,4],
          [0,
           [0,1,caml_new_string("a"),3,3,4],
           [0,
            [0,1,caml_new_string("b"),2,3,4],
            [0,[0,2,caml_new_string("a"),2,3,4],0]]]]]],
       0],
     cst_get_4=caml_new_string("get_4"),
     cst_get_3=caml_new_string("get_3"),
     cst_get_2=caml_new_string("get_2"),
     cst_get_1=caml_new_string("get_1"),
     cst_get_0=caml_new_string("get_0"),
     cst_flip$3=caml_new_string("flip"),
     cst_make=caml_new_string("make"),
     cst_Tuple5=caml_new_string("Tuple5"),
     cst_get_3$0=caml_new_string("get_3"),
     cst_get_2$0=caml_new_string("get_2"),
     cst_get_1$0=caml_new_string("get_1"),
     cst_get_0$0=caml_new_string("get_0"),
     cst_flip$4=caml_new_string("flip"),
     cst_make$0=caml_new_string("make"),
     cst_Tuple4=caml_new_string("Tuple4"),
     cst_get_2$1=caml_new_string("get_2"),
     cst_get_1$1=caml_new_string("get_1"),
     cst_get_0$1=caml_new_string("get_0"),
     cst_flip$5=caml_new_string("flip"),
     cst_make$1=caml_new_string("make"),
     cst_Tuple3=caml_new_string("Tuple3"),
     cst_get_1$2=caml_new_string("get_1"),
     cst_get_0$2=caml_new_string("get_0"),
     cst_flip$6=caml_new_string("flip"),
     cst_make$2=caml_new_string("make"),
     cst_Tuple2=caml_new_string("Tuple2"),
     cst_Tuples=caml_new_string("Tuples"),
     cst_General_RedBlackTree_Invariants_BrokenInvariants=
      caml_new_string("General.RedBlackTree.Invariants.BrokenInvariants"),
     b1=[0,[0,0,1,0]],
     b1r3=[0,[0,0,1,[2,[0,0,3,0]]]],
     br13=[0,[0,[2,[0,0,1,0]],3,0]],
     bb13b5=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],
     br13r5=[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],
     bb13b5r7=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,5,[2,[0,0,7,0]]]]]],
     bb13br57=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],7,0]]]],
     bb1r35b7=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,0,7,0]]]],
     bbr135b7=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,7,0]]]],
     bb13br57r9=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],7,[2,[0,0,9,0]]]]]],
     bb13rb57b9=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,9,0]]]]]],
     bb1r35b7r9=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     bb1r35br79=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     bbr135b7r9=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     bbr135br79=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     bbr13r57b9=[0,[0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     brb13b57b9=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     bb13rb57b9r11=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]]]],
     bb13rb57br911=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,[2,[0,0,9,0]],11,0]]]]]],
     bb13rb5r79b11=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,[2,[0,0,7,0]]]],9,[0,[0,0,11,0]]]]]],
     bb13rbr579b11=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,[2,[0,0,5,0]],7,0]],9,[0,[0,0,11,0]]]]]],
     bb1r35br79r11=
      [0,
       [0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],9,[2,[0,0,11,0]]]]]],
     bb1r35rb79b11=
      [0,
       [0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     bbr135br79r11=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,[2,[0,0,7,0]],9,[2,[0,0,11,0]]]]]],
     bbr135rb79b11=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,0]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     bbr13r57b9r11=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     bbr13r57br911=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],7,[0,[0,[2,[0,0,9,0]],11,0]]]],
     brb13b57b9r11=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     brb13b57br911=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],7,[0,[0,[2,[0,0,9,0]],11,0]]]],
     brb13b5r79b11=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,[2,[0,0,7,0]]]]]],9,[0,[0,0,11,0]]]],
     brb13br579b11=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],7,0]]]],9,[0,[0,0,11,0]]]],
     brb1r35b79b11=
      [0,
       [0,[2,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     brbr135b79b11=
      [0,
       [0,[2,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     cst_size=caml_new_string("size"),
     cst_to_list$0=caml_new_string("to_list"),
     cst_remove=caml_new_string("remove"),
     cst_try_get=caml_new_string("try_get"),
     cst_heterogeneous=caml_new_string("heterogeneous"),
     cst_remove$0=caml_new_string("remove"),
     cst_not_empty=caml_new_string("not empty"),
     cst_empty=caml_new_string("empty"),
     cst_is_empty=caml_new_string("is_empty"),
     cst_try_get$0=caml_new_string("try_get"),
     cst_replace=caml_new_string("replace"),
     cst_add=caml_new_string("add"),
     cst_validate=caml_new_string("validate"),
     cst_Invariants=caml_new_string("Invariants"),
     cst_RedBlackTree=caml_new_string("RedBlackTree"),
     cst_General_BinaryHeap_Invariants_BrokenInvariants=
      caml_new_string("General.BinaryHeap.Invariants.BrokenInvariants"),
     cst_pop_max=caml_new_string("pop_max"),
     cst_add$0=caml_new_string("add"),
     cst_empty$0=caml_new_string("empty"),
     cst_BinaryHeap=caml_new_string("BinaryHeap"),
     cst_Stream=caml_new_string("Stream"),
     repr$42=
      [0,
       [0,caml_new_string("foo"),caml_new_string('"foo"')],
       [0,[0,caml_new_string('bar"baz'),caml_new_string('"bar\\"baz"')],0]],
     equal$49=[0,[0,caml_new_string("foo"),0],0],
     different$40=[0,[0,caml_new_string("foo"),caml_new_string("bar")],0],
     ordered$12=
      [0,
       [0,
        caml_new_string("aaaa"),
        [0,
         caml_new_string("aaaaa"),
         [0,
          caml_new_string("aaaab"),
          [0,caml_new_string("ab"),[0,caml_new_string("b"),0]]]]],
       0],
     cst_xabxxcdx=caml_new_string("xabxxcdx"),
     cst_abcdefghfj=caml_new_string("abcdefghfj"),
     cst_split=caml_new_string("split'"),
     cst_String=caml_new_string("String"),
     cst_General_TestingTests_Tests_TestException0=
      caml_new_string("General.TestingTests.Tests.TestException0"),
     cst_General_TestingTests_Tests_TestException0$0=
      caml_new_string("General.TestingTests.Tests.TestException0'"),
     cst_General_TestingTests_Tests_TestException1=
      caml_new_string("General.TestingTests.Tests.TestException1"),
     cst_Single_label_foo_status_Error_TestingTests_Tests_TestException0_None=
      caml_new_string
       ('Single {label="foo"; status=Error (TestingTests.Tests.TestException0, None)}'),
     cst_foo$5=caml_new_string("foo"),
     cst_Single_label_foo_status_Failure_WrongExceptionNamed_Foo_TestingTests_Tests_TestException0_None=
      caml_new_string
       ('Single {label="foo"; status=Failure (WrongExceptionNamed ("Foo", TestingTests.Tests.TestException0\', None))}'),
     cst_Foo=caml_new_string("Foo"),
     cst_foo$6=caml_new_string("foo"),
     cst_Single_label_foo_status_Failure_WrongException_TestingTests_Tests_TestException0_TestingTests_Tests_TestException0_None=
      caml_new_string
       ('Single {label="foo"; status=Failure (WrongException (TestingTests.Tests.TestException0, TestingTests.Tests.TestException0\', None))}'),
     cst_foo$7=caml_new_string("foo"),
     cst_Single_label_foo_status_Failure_NoException_TestingTests_Tests_TestException0=
      caml_new_string
       ('Single {label="foo"; status=Failure (NoException TestingTests.Tests.TestException0)}'),
     cst_foo$8=caml_new_string("foo"),
     cst_error=caml_new_string("error"),
     cst_error$0=caml_new_string("error"),
     cst_custom_failure=caml_new_string("custom failure"),
     cst_wrong_exception=caml_new_string("wrong exception"),
     cst_wrong_exception$0=caml_new_string("wrong exception"),
     cst_no_exception=caml_new_string("no exception"),
     cst_no_exception$0=caml_new_string("no exception"),
     cst_not_equal_failure=caml_new_string("not equal failure"),
     cst_child=caml_new_string("child"),
     cst_group_success=caml_new_string("group success"),
     cst_single_success=caml_new_string("single success"),
     cst_n=caml_new_string("n"),
     cst_Test=caml_new_string("Test"),
     cst_bar$1=caml_new_string("bar"),
     cst_foo$9=caml_new_string("foo"),
     cst_bad=caml_new_string("bad"),
     cst_bar_7=caml_new_string("bar 7"),
     cst_bar_7_ERROR_exception_TestingTests_Tests_TestException1_bad_raised=
      caml_new_string
       ('"bar 7": ERROR: exception TestingTests.Tests.TestException1("bad") raised\n'),
     cst_bar_7_ERROR_exception_TestingTests_Tests_TestException1_bad_raised_Raised_by_primitive_operation_at_file_Implementation_TestingTests_ml_line_2_characters_16_36=
      caml_new_string
       ('"bar 7": ERROR: exception TestingTests.Tests.TestException1("bad") raised\nRaised by primitive operation at file "Implementation/TestingTests.ml", line 2, characters 16-36\n'),
     cst_bar_6=caml_new_string("bar 6"),
     cst_too_bad=caml_new_string("too bad"),
     cst_Foo$0=caml_new_string("Foo"),
     cst_bar_4=caml_new_string("bar 4'"),
     cst_bar_4_FAILED_expected_exception_Foo_not_raised_but_exception_TestingTests_Tests_TestException1_too_bad_raised=
      caml_new_string
       ('"bar 4\'": FAILED: expected exception Foo not raised, but exception TestingTests.Tests.TestException1("too bad") raised\n'),
     cst_bar_4_FAILED_expected_exception_Foo_not_raised_but_exception_TestingTests_Tests_TestException1_too_bad_raised_Raised_by_primitive_operation_at_file_Implementation_TestingTests_ml_line_2_characters_16_36=
      caml_new_string
       ('"bar 4\'": FAILED: expected exception Foo not raised, but exception TestingTests.Tests.TestException1("too bad") raised\nRaised by primitive operation at file "Implementation/TestingTests.ml", line 2, characters 16-36\n'),
     cst_too_bad$0=caml_new_string("too bad"),
     cst_bad$0=caml_new_string("bad"),
     cst_bar_4$0=caml_new_string("bar 4"),
     cst_bar_4_FAILED_expected_exception_TestingTests_Tests_TestException1_bad_not_raised_but_exception_TestingTests_Tests_TestException1_too_bad_raised=
      caml_new_string
       ('"bar 4": FAILED: expected exception TestingTests.Tests.TestException1("bad") not raised, but exception TestingTests.Tests.TestException1("too bad") raised\n'),
     cst_bar_4_FAILED_expected_exception_TestingTests_Tests_TestException1_bad_not_raised_but_exception_TestingTests_Tests_TestException1_too_bad_raised_Raised_by_primitive_operation_at_file_Implementation_TestingTests_ml_line_2_characters_16_36=
      caml_new_string
       ('"bar 4": FAILED: expected exception TestingTests.Tests.TestException1("bad") not raised, but exception TestingTests.Tests.TestException1("too bad") raised\nRaised by primitive operation at file "Implementation/TestingTests.ml", line 2, characters 16-36\n'),
     cst_Foo$1=caml_new_string("Foo"),
     cst_bar_3=caml_new_string("bar 3'"),
     cst_bar_3$0=caml_new_string("bar 3"),
     cst_bar_2=caml_new_string("bar 2"),
     cst_to_indented_strings=caml_new_string("to_indented_strings"),
     cst_Result=caml_new_string("Result"),
     cst_Testing=caml_new_string("Testing"),
     cst_General=caml_new_string("General"),
     Stdlib_arrayLabels=global_data.Stdlib__arrayLabels,
     Stdlib=global_data.Stdlib,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_string=global_data.Stdlib__string,
     Big_int$1=global_data.Big_int,
     InvalidArgument=global_data.Invalid_argument,
     Stdlib_list=global_data.Stdlib__list,
     AssertFailure=global_data.Assert_failure,
     MatchFailure=global_data.Match_failure,
     Stdlib_stream=global_data.Stdlib__stream,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Stdlib_listLabels=global_data.Stdlib__listLabels,
     Failure=global_data.Failure,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Stdlib_scanf=global_data.Stdlib__scanf,
     Stdlib_lazy=global_data.Stdlib__lazy,
     NotFound=global_data.Not_found,
     OutOfMemory=global_data.Out_of_memory,
     StackOverflow=global_data.Stack_overflow,
     SysError=global_data.Sys_error,
     EndOfFile=global_data.End_of_file,
     DivisionByZero=global_data.Division_by_zero,
     SysBlockedIO=global_data.Sys_blocked_io,
     UndefinedRecursiveModule=global_data.Undefined_recursive_module,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib_sys=global_data.Stdlib__sys,
     Stdlib_int32=global_data.Stdlib__int32,
     Stdlib_int64=global_data.Stdlib__int64,
     Stdlib_nativeint=global_data.Stdlib__nativeint,
     LargeFile=
      [0,-414304121,-926482075,-414100528,828514740,-766829352,828718333],
     ResetPervasives=
      [0,
       603653176,
       -158992896,
       883015737,
       -463930730,
       434128324,
       -1043620471,
       767157169,
       -196902948,
       795263144,
       858345043,
       801400975,
       87663740,
       87661966,
       921347838,
       -279436349,
       -649727666,
       995400973,
       -649677289,
       995400973,
       -649677289,
       109194772,
       -914302928,
       -201814058,
       549754812,
       254970070,
       221552629,
       -673853555,
       121605421,
       409656632,
       -873366131,
       -843939126,
       -673853986,
       245122605,
       599754995,
       -977353436,
       168959862,
       -976209432,
       -976706720,
       170944887,
       -684135316,
       280038311,
       40945859,
       549754812,
       -564105088,
       -194910624,
       -535499931,
       -630606214,
       686359289,
       -1041121119,
       -563901700,
       -563555613,
       -395461502,
       -426139360,
       -395461438,
       -564003162,
       -563208841,
       -563160896,
       906053447,
       906847768,
       906895713,
       374281137,
       561420099,
       928830210,
       -1041519855,
       -1030828120,
       928330694,
       -233773589,
       -564105519,
       62025702,
       -601179209,
       -244378275,
       -583946759,
       68393955,
       -152104568,
       -152104568,
       -624372664,
       -624372664,
       535896105,
       -1024968751,
       -136251436,
       -345401568,
       -700033958,
       -33730743,
       -1052814517,
       -95094752,
       -750489640,
       27817532,
       -682072047,
       351322320,
       -210521932,
       812312304,
       105382081,
       -456462171,
       459240289,
       -772978216,
       -211133964,
       -929963500,
       586122818,
       586122819,
       993358829,
       -988860586,
       444809757,
       98093158,
       -304763129,
       -304763129,
       -304763129,
       -304763129,
       -304763129,
       -304763129,
       -304763129,
       -4988656,
       -4988656,
       -4988656,
       -4988656,
       -4988656,
       -4988656,
       -4988656,
       -1562623,
       -1562623,
       -1562623,
       -1562623,
       -1562623,
       945861926,
       945861926,
       945861926,
       627890996,
       -1562623,
       -346238819,
       -346238819,
       -520554351,
       -520554351,
       -520554351,
       -520554351,
       -520554351,
       -520554351,
       -414304121,
       -926482075,
       -414100528,
       945861926,
       -1562623,
       -1562623,
       781150425,
       781150425,
       781150425,
       -1562623,
       -1562623,
       -1562623,
       -1562623,
       -1562623,
       -1562623,
       -1562623,
       -1562623,
       828514740,
       -766829352,
       828718333,
       781150425,
       -1562623,
       -1562623,
       LargeFile,
       -609162286,
       56633290,
       -741647137,
       -852524488,
       733114908,
       -400010717,
       -961854969,
       817443974,
       -556125065,
       131255665,
       -980596598,
       1006759384,
       -295440787],
     OCamlStandard=
      [0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0],
     Pervasives=[0],
     Arg=[0],
     _D8_=[0,caml_new_string("\n")],
     _DU_=[0,[11,caml_new_string("bad"),0],caml_new_string("bad")],
     _DR_=[0,0],
     _DH_=[0,caml_new_string("TestingTests.Tests.TestException0")],
     _DI_=[0,caml_new_string("TestingTests.Tests.TestException0'")],
     _DJ_=
      [0,
       [11,
        caml_new_string("TestingTests.Tests.TestException1("),
        [3,0,[12,41,0]]],
       caml_new_string("TestingTests.Tests.TestException1(%S)")],
     _DA_=[0,[3,0,[12,32,[3,0,0]]],caml_new_string("%S %S")],
     _Dy_=[0,0,0],
     _Dw_=[0,0,caml_new_string("")],
     _Dv_=[0,0,caml_new_string("")],
     _CD_=[0,caml_new_string(", ")],
     _CE_=
      [0,
       [11,caml_new_string("Broken binary heap invariants: "),[2,0,0]],
       caml_new_string("Broken binary heap invariants: %s")],
     _yu_=
      [0,
       [11,caml_new_string("add "),[2,0,[12,32,[4,3,0,0,0]]]],
       caml_new_string("add %s %i")],
     _xJ_=
      [0,
       [11,caml_new_string("replace "),[2,0,[12,32,[4,3,0,0,0]]]],
       caml_new_string("replace %s %i")],
     _xv_=
      [0,
       [11,caml_new_string("try_get "),[2,0,[12,32,[4,3,0,0,0]]]],
       caml_new_string("try_get %s %i")],
     _ph_=
      [0,
       [11,caml_new_string("remove "),[2,0,[12,32,[4,3,0,0,0]]]],
       caml_new_string("remove %s %i")],
     _pe_=[0,3654863,42],
     _pf_=[0,[0,0,42,0]],
     _pa_=[0,3654863,42],
     _pb_=[0,[0,0,42,0]],
     _pc_=[0,1,0],
     _o4_=
      [0,
       [11,caml_new_string("broken invariants"),0],
       caml_new_string("broken invariants")],
     _o3_=
      [0,
       [11,caml_new_string("broken invariants"),0],
       caml_new_string("broken invariants")],
     _oW_=
      [0,
       [11,caml_new_string("broken invariants"),0],
       caml_new_string("broken invariants")],
     _oX_=[0,0,0],
     _oZ_=[0,1,1],
     _o0_=
      [0,
       [11,caml_new_string("broken invariants"),0],
       caml_new_string("broken invariants")],
     _o1_=
      [0,
       [11,caml_new_string("broken invariants"),0],
       caml_new_string("broken invariants")],
     _o2_=
      [0,
       [11,caml_new_string("broken invariants"),0],
       caml_new_string("broken invariants")],
     _oY_=
      [0,
       [11,caml_new_string("broken invariants"),0],
       caml_new_string("broken invariants")],
     _oV_=
      [0,
       [11,caml_new_string("broken invariants"),0],
       caml_new_string("broken invariants")],
     _oU_=
      [0,
       [11,caml_new_string("broken invariants"),0],
       caml_new_string("broken invariants")],
     _oT_=
      [0,
       [11,caml_new_string("broken invariants"),0],
       caml_new_string("broken invariants")],
     _oS_=
      [0,
       [11,caml_new_string("broken invariants"),0],
       caml_new_string("broken invariants")],
     _oQ_=[0,0],
     _oR_=[0,1],
     _oO_=[0,caml_new_string(", ")],
     _oP_=
      [0,
       [11,caml_new_string("Broken red-black tree invariants: "),[2,0,0]],
       caml_new_string("Broken red-black tree invariants: %s")],
     _oL_=
      [0,
       [11,
        caml_new_string("Black {l="),
        [2,
         0,
         [11,
          caml_new_string("; v="),
          [2,0,[11,caml_new_string("; r="),[2,0,[12,125,0]]]]]]],
       caml_new_string("Black {l=%s; v=%s; r=%s}")],
     _oM_=
      [0,
       [11,
        caml_new_string("BlackPlus {l="),
        [2,
         0,
         [11,
          caml_new_string("; v="),
          [2,0,[11,caml_new_string("; r="),[2,0,[12,125,0]]]]]]],
       caml_new_string("BlackPlus {l=%s; v=%s; r=%s}")],
     _oN_=
      [0,
       [11,
        caml_new_string("Red {l="),
        [2,
         0,
         [11,
          caml_new_string("; v="),
          [2,0,[11,caml_new_string("; r="),[2,0,[12,125,0]]]]]]],
       caml_new_string("Red {l=%s; v=%s; r=%s}")],
     _oJ_=[0,1,2],
     _oG_=[0,2,1],
     _oH_=[0,1,2],
     _oE_=[0,42,0],
     _oC_=[0,0,42],
     _oy_=[0,1,2,3],
     _ov_=[0,3,2,1],
     _ow_=[0,1,2,3],
     _ot_=[0,42,0,0],
     _or_=[0,0,42,0],
     _op_=[0,0,0,42],
     _ol_=[0,1,2,3,4],
     _oi_=[0,4,3,2,1],
     _oj_=[0,1,2,3,4],
     _og_=[0,42,0,0,0],
     _oe_=[0,0,42,0,0],
     _oc_=[0,0,0,42,0],
     _oa_=[0,0,0,0,42],
     _n8_=[0,1,2,3,4,5],
     _n5_=[0,5,4,3,2,1],
     _n6_=[0,1,2,3,4,5],
     _n3_=[0,42,0,0,0,0],
     _n1_=[0,0,42,0,0,0],
     _nZ_=[0,0,0,42,0,0],
     _nX_=[0,0,0,0,42,0],
     _nV_=[0,0,0,0,0,42],
     _nQ_=
      [0,
       [11,caml_new_string("Don't call me"),0],
       caml_new_string("Don't call me")],
     _nL_=[0,42],
     _nI_=[0,42],
     _nF_=[0,caml_new_string("val")],
     _nD_=[0,caml_new_string("val")],
     _nz_=
      [0,
       [11,caml_new_string("Don't call me"),0],
       caml_new_string("Don't call me")],
     _nx_=
      [0,
       [11,caml_new_string("Don't call me"),0],
       caml_new_string("Don't call me")],
     _nv_=[0,21],
     _nt_=
      [0,
       [11,caml_new_string("Don't call me"),0],
       caml_new_string("Don't call me")],
     _nr_=[0,21],
     _np_=
      [0,
       [11,caml_new_string("Don't call me"),0],
       caml_new_string("Don't call me")],
     _nn_=[0,42],
     _nl_=
      [0,
       [11,caml_new_string("Don't call me"),0],
       caml_new_string("Don't call me")],
     _nj_=[0,42],
     _nh_=[0,42],
     _nf_=
      [0,
       [11,caml_new_string("Don't call me"),0],
       caml_new_string("Don't call me")],
     _nc_=[0,57],
     _nd_=[0,42],
     _na_=[0,42],
     _mM_=[0,[11,caml_new_string("nope"),0],caml_new_string("nope")],
     _mI_=
      [0,
       [11,caml_new_string("Don't call me"),0],
       caml_new_string("Don't call me")],
     _mH_=
      [0,
       [11,caml_new_string("You called me!"),0],
       caml_new_string("You called me!")],
     _mD_=[0,0,[0,1,[0,2,[0,3,[0,4,0]]]]],
     _mA_=[0,2],
     _mB_=[0,2,[0,3,[0,4,0]]],
     _mv_=[0,5],
     _ms_=[0,2],
     _mt_=[0,0,[0,2,[0,4,0]]],
     _mp_=[0,2],
     _mq_=[0,0,[0,2,[0,4,0]]],
     _mn_=[0,0],
     _mj_=[0,2],
     _mk_=[0,2],
     _ml_=[0,2,[0,4,[0,6,0]]],
     _mf_=[0,2],
     _mg_=[0,2],
     _mh_=[0,2,[0,4,[0,6,0]]],
     _mb_=[0,2],
     _mc_=[0,3],
     _md_=[0,3,[0,5,[0,7,0]]],
     _l9_=[0,2],
     _l__=[0,3],
     _l$_=[0,3,[0,5,[0,7,0]]],
     _l7_=[0,-1],
     _l4_=[0,-1],
     _l5_=[0,0,[0,-1,[0,-2,[0,-3,[0,-4,[0,-5,0]]]]]],
     _l1_=[0,-2],
     _l2_=[0,0,[0,-2,[0,-4,0]]],
     _lX_=[0,-2],
     _lY_=[0,-3],
     _lZ_=[0,-3,[0,-5,[0,-7,[0,-9,0]]]],
     _lT_=[0,-2],
     _lU_=[0,-3],
     _lV_=[0,-3,[0,-5,[0,-7,[0,-9,0]]]],
     _ld_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _k__=[0,7,2],
     _k7_=
      [0,
       [4,0,0,0,[12,32,[4,0,0,0,[12,32,[4,0,0,0,0]]]]],
       caml_new_string("%d %d %d")],
     _k3_=[0,7,2,4],
     _k4_=
      [0,
       [4,0,0,0,[12,32,[4,0,0,0,[12,32,[4,0,0,0,0]]]]],
       caml_new_string("%d %d %d")],
     _k0_=
      [0,
       [4,0,0,0,[12,32,[4,0,0,0,[12,32,[4,0,0,0,[12,32,[4,0,0,0,0]]]]]]],
       caml_new_string("%d %d %d %d")],
     _kW_=[0,7,2,4,5],
     _kX_=
      [0,
       [4,0,0,0,[12,32,[4,0,0,0,[12,32,[4,0,0,0,[12,32,[4,0,0,0,0]]]]]]],
       caml_new_string("%d %d %d %d")],
     _kT_=
      [0,
       [4,
        0,
        0,
        0,
        [12,
         32,
         [4,0,0,0,[12,32,[4,0,0,0,[12,32,[4,0,0,0,[12,32,[4,0,0,0,0]]]]]]]]],
       caml_new_string("%d %d %d %d %d")],
     _kP_=[0,7,2,4,5,3],
     _kQ_=
      [0,
       [4,
        0,
        0,
        0,
        [12,
         32,
         [4,0,0,0,[12,32,[4,0,0,0,[12,32,[4,0,0,0,[12,32,[4,0,0,0,0]]]]]]]]],
       caml_new_string("%d %d %d %d %d")],
     _kF_=[0,caml_new_string("Implementation/CallStack.ml"),3,15,49],
     _kv_=
      [0,
       caml_new_string("1"),
       [0,caml_new_string("2"),[0,caml_new_string("3"),0]]],
     _kw_=
      [0,
       caml_new_string("3"),
       [0,caml_new_string("2"),[0,caml_new_string("1"),0]]],
     _kr_=[0,4,[0,5,[0,6,0]]],
     _ks_=[0,1,[0,2,[0,3,0]]],
     _kt_=[0,1,[0,2,[0,3,[0,4,[0,5,[0,6,0]]]]]],
     _ko_=[0,2,[0,3,0]],
     _kp_=[0,1,[0,2,[0,3,0]]],
     _km_=[0,1,[0,2,[0,3,0]]],
     _ki_=[0,1,[0,2,[0,3,0]]],
     _kj_=[0,2,[0,3,0]],
     _kf_=[0,1,[0,2,[0,3,0]]],
     _kb_=[0,1,[0,2,[0,3,0]]],
     _kc_=[0,2,[0,3,0]],
     _j__=
      [0,
       [11,caml_new_string("Don't call me"),0],
       caml_new_string("Don't call me")],
     _j7_=[0,[2,0,[12,45,[4,0,0,0,0]]],caml_new_string("%s-%d")],
     _j8_=[0,3,[0,4,0]],
     _j4_=
      [0,
       [11,caml_new_string("Don't call me"),0],
       caml_new_string("Don't call me")],
     _j5_=[0,0,0],
     _j2_=[0,2,[0,3,[0,4,0]]],
     _j0_=[0,2,[0,3,[0,4,0]]],
     _jX_=[0,3,[0,4,0]],
     _jQ_=
      [0,
       [11,
        caml_new_string("Int.exponentiate: Negative exponent: "),
        [4,3,0,0,0]],
       caml_new_string("Int.exponentiate: Negative exponent: %i")],
     _fK_=
      [0,
       [11,
        caml_new_string("2 ^ "),
        [4,3,0,0,[11,caml_new_string(" - 2 ^ "),[4,3,0,0,0]]]],
       caml_new_string("2 ^ %i - 2 ^ %i")],
     _fJ_=
      [0,[11,caml_new_string("2 ^ "),[4,3,0,0,0]],caml_new_string("2 ^ %i")],
     _e7_=
      [0,
       [11,
        caml_new_string("BigInt.exponentiate: Negative exponent: "),
        [4,3,0,0,0]],
       caml_new_string("BigInt.exponentiate: Negative exponent: %i")],
     _eY_=[0,[8,0,0,0,0],caml_new_string("%f")],
     _ez_=[255,2,0,0],
     _d2_=
      [0,
       [2,
        0,
        [11,caml_new_string(".exponentiate: Negative exponent: "),[4,3,0,0,0]]],
       caml_new_string("%s.exponentiate: Negative exponent: %i")],
     _d1_=[0,[2,0,[2,0,0]],caml_new_string("%s%s")],
     _dW_=
      [0,
       [11,caml_new_string("Foo "),[2,0,[12,32,[21,1,0]]]],
       caml_new_string("Foo %s %n")],
     _dU_=
      [0,
       [11,caml_new_string("Grmbl "),[2,0,[12,32,[21,1,0]]]],
       caml_new_string("Grmbl %s %n")],
     _dS_=[0,caml_new_string("Implementation/Exception.ml"),3,30],
     _dQ_=[0,caml_new_string("Implementation/Exception.ml"),5,26],
     _dH_=[0,caml_new_string("Implementation/Exception.ml"),5,26],
     _dG_=[0,caml_new_string("Implementation/Exception.ml"),3,30],
     _dE_=[0,[11,caml_new_string("abs "),[2,0,0]],caml_new_string("abs %s")],
     _dF_=[0,[11,caml_new_string("abs "),[2,0,0]],caml_new_string("abs %s")],
     _dl_=[0,1,[0,6,[0,3,[0,-1,0]]]],
     _dm_=[0,2,[0,7,[0,4,[0,0,0]]]],
     _dj_=[0,1,[0,6,[0,3,[0,-1,0]]]],
     _dk_=[0,1,[0,7,[0,5,[0,2,0]]]],
     _dh_=[0,1,[0,6,[0,3,[0,-1,0]]]],
     _di_=[0,43,[0,48,[0,255,[0,755,0]]]],
     _df_=[0,1,[0,3,[0,4,[0,15,[0,9,[0,7,0]]]]]],
     _dg_=[0,3,[0,15,[0,9,0]]],
     _dd_=[0,3,[0,4,[0,15,[0,9,[0,7,0]]]]],
     _de_=[0,3,[0,15,0]],
     _db_=[0,2,[0,3,[0,4,[0,15,[0,9,[0,7,0]]]]]],
     _dc_=[0,3,[0,9,0]],
     _c$_=[0,1,[0,3,[0,4,[0,15,[0,9,[0,7,0]]]]]],
     _da_=[0,4,[0,16,[0,10,0]]],
     _c9_=[0,3,[0,4,[0,15,[0,9,[0,7,0]]]]],
     _c__=[0,4,[0,16,0]],
     _c7_=[0,2,[0,3,[0,4,[0,15,[0,9,[0,7,0]]]]]],
     _c8_=[0,4,[0,10,0]],
     _c5_=[0,1,[0,2,[0,0,[0,3,[0,4,0]]]]],
     _c6_=[0,1,[0,2,[0,4,[0,3,[0,6,[0,9,[0,4,[0,8,[0,12,[0,16,0]]]]]]]]]],
     _c3_=[0,1,[0,2,[0,0,[0,3,[0,4,0]]]]],
     _c4_=[0,1,[0,3,[0,6,[0,6,[0,12,[0,18,[0,8,[0,16,[0,24,[0,32,0]]]]]]]]]],
     _c1_=[0,1,[0,2,[0,0,[0,3,[0,4,0]]]]],
     _c2_=
      [0,
       43,
       [0,
        86,
        [0,88,[0,255,[0,258,[0,261,[0,1012,[0,1016,[0,1020,[0,1024,0]]]]]]]]]],
     _cT_=
      [0,[2,0,[11,caml_new_string(" - "),[2,0,0]]],caml_new_string("%s - %s")],
     _cU_=
      [0,
       [11,caml_new_string("sub "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("sub %s %s")],
     _cV_=
      [0,[2,0,[11,caml_new_string(" - "),[2,0,0]]],caml_new_string("%s - %s")],
     _cW_=
      [0,
       [11,caml_new_string("sub "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("sub %s %s")],
     _cX_=
      [0,[2,0,[11,caml_new_string(" + "),[2,0,0]]],caml_new_string("%s + %s")],
     _cY_=
      [0,[2,0,[11,caml_new_string(" + "),[2,0,0]]],caml_new_string("%s + %s")],
     _cZ_=
      [0,
       [11,caml_new_string("add "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("add %s %s")],
     _c0_=
      [0,
       [11,caml_new_string("add "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("add %s %s")],
     _cF_=
      [0,[11,caml_new_string("square "),[2,0,0]],caml_new_string("square %s")],
     _cG_=
      [0,[11,caml_new_string("square "),[2,0,0]],caml_new_string("square %s")],
     _cH_=
      [0,[2,0,[11,caml_new_string(" + "),[2,0,0]]],caml_new_string("%s + %s")],
     _cI_=
      [0,[2,0,[11,caml_new_string(" + "),[2,0,0]]],caml_new_string("%s + %s")],
     _cJ_=
      [0,
       [11,caml_new_string("add "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("add %s %s")],
     _cK_=
      [0,
       [11,caml_new_string("add "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("add %s %s")],
     _cL_=
      [0,[11,caml_new_string("zero - "),[2,0,0]],caml_new_string("zero - %s")],
     _cM_=
      [0,[11,caml_new_string("zero - "),[2,0,0]],caml_new_string("zero - %s")],
     _cN_=
      [0,
       [11,caml_new_string("substract zero "),[2,0,0]],
       caml_new_string("substract zero %s")],
     _cO_=
      [0,
       [11,caml_new_string("substract zero "),[2,0,0]],
       caml_new_string("substract zero %s")],
     _cP_=[0,[12,45,[2,0,0]],caml_new_string("-%s")],
     _cQ_=[0,[12,45,[2,0,0]],caml_new_string("-%s")],
     _cR_=
      [0,[11,caml_new_string("negate "),[2,0,0]],caml_new_string("negate %s")],
     _cS_=
      [0,[11,caml_new_string("negate "),[2,0,0]],caml_new_string("negate %s")],
     _cD_=
      [0,[2,0,[11,caml_new_string(" * "),[2,0,0]]],caml_new_string("%s * %s")],
     _cE_=
      [0,
       [11,caml_new_string("multiply "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("multiply %s %s")],
     _cB_=
      [0,[2,0,[11,caml_new_string(" / "),[2,0,0]]],caml_new_string("%s / %s")],
     _cC_=
      [0,
       [11,caml_new_string("divide "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("divide %s %s")],
     _cz_=
      [0,
       [2,0,[11,caml_new_string(" ** "),[21,1,0]]],
       caml_new_string("%s ** %n")],
     _cA_=
      [0,
       [11,caml_new_string("exponentiate "),[2,0,[12,32,[21,1,0]]]],
       caml_new_string("exponentiate %s %n")],
     _cx_=[0,[11,caml_new_string("pred "),[2,0,0]],caml_new_string("pred %s")],
     _cy_=[0,[11,caml_new_string("succ "),[2,0,0]],caml_new_string("succ %s")],
     _cv_=
      [0,
       [11,caml_new_string("try_of_string "),[3,0,0]],
       caml_new_string("try_of_string %S")],
     _cw_=
      [0,
       [11,caml_new_string("of_string "),[3,0,0]],
       caml_new_string("of_string %S")],
     _cu_=
      [0,
       [11,caml_new_string("to_string "),[2,0,0]],
       caml_new_string("to_string %s")],
     _b5_=
      [0,
       [11,caml_new_string("min_max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min_max %s %s")],
     _b6_=
      [0,
       [11,caml_new_string("max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("max %s %s")],
     _b7_=
      [0,
       [11,caml_new_string("min "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min %s %s")],
     _b8_=
      [0,[2,0,[11,caml_new_string(" > "),[2,0,0]]],caml_new_string("%s > %s")],
     _b9_=
      [0,
       [2,0,[11,caml_new_string(" >= "),[2,0,0]]],
       caml_new_string("%s >= %s")],
     _b__=
      [0,
       [2,0,[11,caml_new_string(" <= "),[2,0,0]]],
       caml_new_string("%s <= %s")],
     _b$_=
      [0,[2,0,[11,caml_new_string(" < "),[2,0,0]]],caml_new_string("%s < %s")],
     _ca_=
      [0,
       [11,caml_new_string("greater_than "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("greater_than %s %s")],
     _cb_=
      [0,
       [11,caml_new_string("greater_or_equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("greater_or_equal %s %s")],
     _cc_=
      [0,
       [11,caml_new_string("less_or_equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("less_or_equal %s %s")],
     _cd_=
      [0,
       [11,caml_new_string("less_than "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("less_than %s %s")],
     _ce_=
      [0,
       [11,caml_new_string("min_max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min_max %s %s")],
     _cf_=
      [0,
       [11,caml_new_string("max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("max %s %s")],
     _cg_=
      [0,
       [11,caml_new_string("min "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min %s %s")],
     _ch_=
      [0,[2,0,[11,caml_new_string(" > "),[2,0,0]]],caml_new_string("%s > %s")],
     _ci_=
      [0,
       [2,0,[11,caml_new_string(" >= "),[2,0,0]]],
       caml_new_string("%s >= %s")],
     _cj_=
      [0,
       [2,0,[11,caml_new_string(" <= "),[2,0,0]]],
       caml_new_string("%s <= %s")],
     _ck_=
      [0,[2,0,[11,caml_new_string(" < "),[2,0,0]]],caml_new_string("%s < %s")],
     _cl_=
      [0,
       [11,caml_new_string("greater_than "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("greater_than %s %s")],
     _cm_=
      [0,
       [11,caml_new_string("greater_or_equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("greater_or_equal %s %s")],
     _cn_=
      [0,
       [11,caml_new_string("less_or_equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("less_or_equal %s %s")],
     _co_=
      [0,
       [11,caml_new_string("less_than "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("less_than %s %s")],
     _bz_=
      [0,
       [11,caml_new_string("min_max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min_max %s %s")],
     _bA_=
      [0,
       [11,caml_new_string("min_max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min_max %s %s")],
     _bB_=
      [0,
       [11,caml_new_string("min_max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min_max %s %s")],
     _bC_=
      [0,
       [11,caml_new_string("min_max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min_max %s %s")],
     _bD_=
      [0,
       [11,caml_new_string("max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("max %s %s")],
     _bE_=
      [0,
       [11,caml_new_string("max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("max %s %s")],
     _bF_=
      [0,
       [11,caml_new_string("min "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min %s %s")],
     _bG_=
      [0,
       [11,caml_new_string("min "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min %s %s")],
     _bH_=
      [0,[2,0,[11,caml_new_string(" > "),[2,0,0]]],caml_new_string("%s > %s")],
     _bI_=
      [0,
       [2,0,[11,caml_new_string(" >= "),[2,0,0]]],
       caml_new_string("%s >= %s")],
     _bJ_=
      [0,
       [2,0,[11,caml_new_string(" <= "),[2,0,0]]],
       caml_new_string("%s <= %s")],
     _bK_=
      [0,[2,0,[11,caml_new_string(" < "),[2,0,0]]],caml_new_string("%s < %s")],
     _bL_=
      [0,
       [11,caml_new_string("greater_than "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("greater_than %s %s")],
     _bM_=
      [0,
       [11,caml_new_string("greater_or_equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("greater_or_equal %s %s")],
     _bN_=
      [0,
       [11,caml_new_string("less_or_equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("less_or_equal %s %s")],
     _bO_=
      [0,
       [11,caml_new_string("less_than "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("less_than %s %s")],
     _bP_=
      [0,
       [11,caml_new_string("min_max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min_max %s %s")],
     _bQ_=
      [0,
       [11,caml_new_string("min_max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min_max %s %s")],
     _bR_=
      [0,
       [11,caml_new_string("min_max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min_max %s %s")],
     _bS_=
      [0,
       [11,caml_new_string("min_max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min_max %s %s")],
     _bT_=
      [0,
       [11,caml_new_string("max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("max %s %s")],
     _bU_=
      [0,
       [11,caml_new_string("max "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("max %s %s")],
     _bV_=
      [0,
       [11,caml_new_string("min "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min %s %s")],
     _bW_=
      [0,
       [11,caml_new_string("min "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("min %s %s")],
     _bX_=
      [0,[2,0,[11,caml_new_string(" > "),[2,0,0]]],caml_new_string("%s > %s")],
     _bY_=
      [0,
       [2,0,[11,caml_new_string(" >= "),[2,0,0]]],
       caml_new_string("%s >= %s")],
     _bZ_=
      [0,
       [2,0,[11,caml_new_string(" <= "),[2,0,0]]],
       caml_new_string("%s <= %s")],
     _b0_=
      [0,[2,0,[11,caml_new_string(" < "),[2,0,0]]],caml_new_string("%s < %s")],
     _b1_=
      [0,
       [11,caml_new_string("greater_than "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("greater_than %s %s")],
     _b2_=
      [0,
       [11,caml_new_string("greater_or_equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("greater_or_equal %s %s")],
     _b3_=
      [0,
       [11,caml_new_string("less_or_equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("less_or_equal %s %s")],
     _b4_=
      [0,
       [11,caml_new_string("less_than "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("less_than %s %s")],
     _bn_=
      [0,
       [2,0,[11,caml_new_string(" <> "),[2,0,0]]],
       caml_new_string("%s <> %s")],
     _bo_=
      [0,[2,0,[11,caml_new_string(" = "),[2,0,0]]],caml_new_string("%s = %s")],
     _bp_=
      [0,
       [11,caml_new_string("different "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("different %s %s")],
     _bq_=
      [0,
       [11,caml_new_string("equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("equal %s %s")],
     _br_=
      [0,
       [2,0,[11,caml_new_string(" <> "),[2,0,0]]],
       caml_new_string("%s <> %s")],
     _bs_=
      [0,[2,0,[11,caml_new_string(" = "),[2,0,0]]],caml_new_string("%s = %s")],
     _bt_=
      [0,
       [11,caml_new_string("different "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("different %s %s")],
     _bu_=
      [0,
       [11,caml_new_string("equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("equal %s %s")],
     _bf_=
      [0,
       [2,0,[11,caml_new_string(" <> "),[2,0,0]]],
       caml_new_string("%s <> %s")],
     _bg_=
      [0,[2,0,[11,caml_new_string(" = "),[2,0,0]]],caml_new_string("%s = %s")],
     _bh_=
      [0,
       [11,caml_new_string("different "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("different %s %s")],
     _bi_=
      [0,
       [11,caml_new_string("equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("equal %s %s")],
     _bj_=
      [0,
       [2,0,[11,caml_new_string(" <> "),[2,0,0]]],
       caml_new_string("%s <> %s")],
     _bk_=
      [0,[2,0,[11,caml_new_string(" = "),[2,0,0]]],caml_new_string("%s = %s")],
     _bl_=
      [0,
       [11,caml_new_string("different "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("different %s %s")],
     _bm_=
      [0,
       [11,caml_new_string("equal "),[2,0,[12,32,[2,0,0]]]],
       caml_new_string("equal %s %s")],
     _be_=[0,[11,caml_new_string("repr "),[2,0,0]],caml_new_string("repr %s")],
     _bd_=[5,caml_new_string("not in")],
     _a9_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _a__=[0,1],
     _a4_=
      [0,
       [11,
        caml_new_string("Single {label="),
        [3,0,[11,caml_new_string("; status="),[2,0,[12,125,0]]]]],
       caml_new_string("Single {label=%S; status=%s}")],
     _a5_=
      [0,
       [11,
        caml_new_string("Group {name="),
        [3,
         0,
         [11,
          caml_new_string("; children="),
          [2,0,[11,caml_new_string("; counts="),[2,0,[12,125,0]]]]]]],
       caml_new_string("Group {name=%S; children=%s; counts=%s}")],
     _a6_=
      [0,
       [2,0,[3,0,[11,caml_new_string(": "),[2,0,0]]]],
       caml_new_string("%s%S: %s")],
     _a7_=
      [0,
       [2,0,[3,0,[11,caml_new_string(" (Successes: "),[4,3,0,0,[12,41,0]]]]],
       caml_new_string("%s%S (Successes: %i)")],
     _a8_=
      [0,
       [2,
        0,
        [3,
         0,
         [11,
          caml_new_string(" (Successes: "),
          [4,
           3,
           0,
           0,
           [11,
            caml_new_string(", failures: "),
            [4,3,0,0,[11,caml_new_string(", errors: "),[4,3,0,0,[12,41,0]]]]]]]]],
       caml_new_string("%s%S (Successes: %i, failures: %i, errors: %i)")],
     _a3_=
      [0,
       [11,
        caml_new_string("{successes="),
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string("; failures="),
          [4,3,0,0,[11,caml_new_string("; errors="),[4,3,0,0,[12,125,0]]]]]]],
       caml_new_string("{successes=%i; failures=%i; errors=%i}")],
     _a0_=[0,1,0,0],
     _a1_=[0,0,1,0],
     _a2_=[0,0,0,1],
     _aQ_=
      [0,
       [11,
        caml_new_string("FAILED: expected "),
        [2,0,[11,caml_new_string(", but got "),[2,0,0]]]],
       caml_new_string("FAILED: expected %s, but got %s")],
     _aR_=
      [0,
       [11,
        caml_new_string("FAILED: expected exception "),
        [2,0,[11,caml_new_string(" not raised"),0]]],
       caml_new_string("FAILED: expected exception %s not raised")],
     _aS_=
      [0,
       [11,
        caml_new_string("FAILED: expected exception "),
        [2,0,[11,caml_new_string(" not raised"),0]]],
       caml_new_string("FAILED: expected exception %s not raised")],
     _aT_=
      [0,
       [11,
        caml_new_string("FAILED: expected exception "),
        [2,
         0,
         [11,
          caml_new_string(" not raised, but exception "),
          [2,0,[11,caml_new_string(" raised\n"),[2,0,0]]]]]],
       caml_new_string
        ("FAILED: expected exception %s not raised, but exception %s raised\n%s")],
     _aU_=
      [0,
       [11,
        caml_new_string("FAILED: expected exception "),
        [2,
         0,
         [11,
          caml_new_string(" not raised, but exception "),
          [2,0,[11,caml_new_string(" raised (no backtrace)"),0]]]]],
       caml_new_string
        ("FAILED: expected exception %s not raised, but exception %s raised (no backtrace)")],
     _aV_=
      [0,
       [11,
        caml_new_string("FAILED: expected exception "),
        [2,
         0,
         [11,
          caml_new_string(" not raised, but exception "),
          [2,0,[11,caml_new_string(" raised\n"),[2,0,0]]]]]],
       caml_new_string
        ("FAILED: expected exception %s not raised, but exception %s raised\n%s")],
     _aW_=
      [0,
       [11,
        caml_new_string("FAILED: expected exception "),
        [2,
         0,
         [11,
          caml_new_string(" not raised, but exception "),
          [2,0,[11,caml_new_string(" raised (no backtrace)"),0]]]]],
       caml_new_string
        ("FAILED: expected exception %s not raised, but exception %s raised (no backtrace)")],
     _aX_=
      [0,
       [11,caml_new_string("FAILED: "),[2,0,0]],
       caml_new_string("FAILED: %s")],
     _aY_=
      [0,
       [11,
        caml_new_string("ERROR: exception "),
        [2,0,[11,caml_new_string(" raised\n"),[2,0,0]]]],
       caml_new_string("ERROR: exception %s raised\n%s")],
     _aZ_=
      [0,
       [11,
        caml_new_string("ERROR: exception "),
        [2,0,[11,caml_new_string(" raised (no backtrace)"),0]]],
       caml_new_string("ERROR: exception %s raised (no backtrace)")],
     _aO_=
      [0,
       [11,caml_new_string("Failure ("),[2,0,[12,41,0]]],
       caml_new_string("Failure (%s)")],
     _aP_=
      [0,
       [11,
        caml_new_string("Error ("),
        [2,0,[11,caml_new_string(", "),[2,0,[12,41,0]]]]],
       caml_new_string("Error (%s, %s)")],
     _aI_=
      [0,
       [11,
        caml_new_string("NotEqual ("),
        [3,0,[11,caml_new_string(", "),[3,0,[12,41,0]]]]],
       caml_new_string("NotEqual (%S, %S)")],
     _aJ_=
      [0,
       [11,caml_new_string("NoException "),[2,0,0]],
       caml_new_string("NoException %s")],
     _aK_=
      [0,
       [11,caml_new_string("NoExceptionNamed "),[3,0,0]],
       caml_new_string("NoExceptionNamed %S")],
     _aL_=
      [0,
       [11,
        caml_new_string("WrongException ("),
        [2,
         0,
         [11,
          caml_new_string(", "),
          [2,0,[11,caml_new_string(", "),[2,0,[12,41,0]]]]]]],
       caml_new_string("WrongException (%s, %s, %s)")],
     _aM_=
      [0,
       [11,
        caml_new_string("WrongExceptionNamed ("),
        [3,
         0,
         [11,
          caml_new_string(", "),
          [2,0,[11,caml_new_string(", "),[2,0,[12,41,0]]]]]]],
       caml_new_string("WrongExceptionNamed (%S, %s, %s)")],
     _aN_=
      [0,[11,caml_new_string("Custom "),[3,0,0]],caml_new_string("Custom %S")],
     _ar_=
      [0,
       [12,
        40,
        [2,
         0,
         [11,
          caml_new_string(", "),
          [2,
           0,
           [11,
            caml_new_string(", "),
            [2,
             0,
             [11,
              caml_new_string(", "),
              [2,0,[11,caml_new_string(", "),[2,0,partial]]]]]]]]]],
       caml_new_string("(%s, %s, %s, %s, %s)")],
     _aq_=
      [0,
       [12,
        40,
        [2,
         0,
         [11,
          caml_new_string(", "),
          [2,
           0,
           [11,
            caml_new_string(", "),
            [2,0,[11,caml_new_string(", "),[2,0,[12,41,0]]]]]]]]],
       caml_new_string("(%s, %s, %s, %s)")],
     _ap_=
      [0,
       [12,
        40,
        [2,
         0,
         [11,
          caml_new_string(", "),
          [2,0,[11,caml_new_string(", "),[2,0,[12,41,0]]]]]]],
       caml_new_string("(%s, %s, %s)")],
     _ao_=
      [0,
       [12,40,[2,0,[11,caml_new_string(", "),[2,0,[12,41,0]]]]],
       caml_new_string("(%s, %s)")],
     _an_=[0,caml_new_string("Foundations/IntRange.ml"),54,6],
     _am_=[0,caml_new_string("Foundations/IntRange.ml"),48,6],
     _ak_=
      [0,
       [12,
        91,
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string(" to "),
          [4,3,0,0,[11,caml_new_string(" step "),[4,3,0,0,[12,93,0]]]]]]],
       caml_new_string("[%i to %i step %i]")],
     _al_=
      [0,
       [12,
        91,
        [4,
         3,
         0,
         0,
         [11,
          caml_new_string(" down to "),
          [4,3,0,0,[11,caml_new_string(" step -"),[4,3,0,0,[12,93,0]]]]]]],
       caml_new_string("[%i down to %i step -%i]")],
     _ai_=[0,caml_new_string("Foundations/IntRange.ml"),25,4],
     _aj_=[0,caml_new_string("Foundations/IntRange.ml"),31,4],
     _ah_=
      [0,
       [11,caml_new_string("String.split: empty separator"),0],
       caml_new_string("String.split: empty separator")],
     _ag_=
      [0,
       [11,caml_new_string("String.drop_prefix"),0],
       caml_new_string("String.drop_prefix")],
     _af_=
      [0,
       [11,caml_new_string("String.drop_suffix"),0],
       caml_new_string("String.drop_suffix")],
     _aa_=[0,[3,0,0],caml_new_string("%S")],
     _D_=
      [0,
       [11,
        caml_new_string("{filename="),
        [3,
         0,
         [11,
          caml_new_string("; line_number="),
          [21,
           1,
           [11,
            caml_new_string("; start_char="),
            [21,1,[11,caml_new_string("; end_char="),[21,1,[12,125,0]]]]]]]]],
       caml_new_string
        ("{filename=%S; line_number=%n; start_char=%n; end_char=%n}")],
     _C_=
      [0,
       [11,caml_new_string("List.Two.to_pair_list"),0],
       caml_new_string("List.Two.to_pair_list")],
     _A_=[0,[12,91,[2,0,[12,93,0]]],caml_new_string("[%s]")],
     _B_=[0,caml_new_string("; ")],
     _z_=[0,[2,0,[2,0,[2,0,0]]],caml_new_string("%s%s%s")],
     _y_=
      [0,
       [11,caml_new_string("List.reduce_short_i"),0],
       caml_new_string("List.reduce_short_i")],
     _x_=
      [0,
       [11,caml_new_string("List.reduce_short"),0],
       caml_new_string("List.reduce_short")],
     _w_=
      [0,
       [11,caml_new_string("List.reduce_short_acc"),0],
       caml_new_string("List.reduce_short_acc")],
     _v_=
      [0,
       [11,caml_new_string("List.reduce_i"),0],
       caml_new_string("List.reduce_i")],
     _u_=
      [0,[11,caml_new_string("List.reduce"),0],caml_new_string("List.reduce")],
     _t_=
      [0,
       [11,caml_new_string("List.reduce_acc"),0],
       caml_new_string("List.reduce_acc")],
     _s_=[0,[11,caml_new_string("List.tail"),0],caml_new_string("List.tail")],
     _r_=[0,[11,caml_new_string("List.head"),0],caml_new_string("List.head")],
     _q_=[0,[11,caml_new_string("Some "),[2,0,0]],caml_new_string("Some %s")],
     _eC_=[0,2,0],
     _eD_=[0,1,0],
     _eE_=[0,0,0],
     _eF_=[0,1,-1],
     _eG_=[0,0,1],
     _jU_=[0,[0,[0,1,0],0],[0,[0,[0,1,[0,2,[0,3,0]]],0],0]],
     _jV_=[0,0,0],
     _lh_=[0,4],
     _li_=[0,3],
     _lk_=[0,-3],
     _lo_=[0,3],
     _lp_=[0,5],
     _lr_=[0,3],
     _ls_=[0,5],
     _lu_=[0,3],
     _lv_=[0,5],
     _lx_=[0,1],
     _ly_=[0,0],
     _lB_=[0,5],
     _lD_=[0,-1],
     _lF_=[0,0],
     _lI_=[0,2],
     _lK_=[0,3],
     _lL_=[0,5],
     _lN_=[0,3],
     _lO_=[0,5],
     _o8_=[0,1,[0,3,[0,5,[0,7,[0,9,0]]]]],
     _pj_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _pm_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,[2,[0,0,7,0]],11,0]]]],
     _pp_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],9,[0,[0,0,11,0]]]],
     _ps_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _pv_=[0,[0,[2,[0,[0,[0,0,1,0]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _py_=[0,[0,[2,[0,[0,[0,0,3,0]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _pC_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _pF_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],11,0]]]],
     _pI_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],9,[0,[0,0,11,0]]]],
     _pL_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _pO_=[0,[0,[2,[0,[0,[0,0,1,0]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _pR_=[0,[0,[2,[0,[0,[0,0,3,0]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _pV_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,9,0]]]]]],
     _pY_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,11,0]]]]]],
     _p1_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],9,[0,[0,0,11,0]]]],
     _p4_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _p7_=[0,[0,[2,[0,[0,[0,0,1,0]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _p__=[0,[0,[2,[0,[0,[0,0,3,0]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _qc_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,9,0]]]]]],
     _qf_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,11,0]]]]]],
     _qi_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],9,[0,[0,0,11,0]]]],
     _ql_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _qo_=[0,[0,[2,[0,[0,[0,0,1,0]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _qr_=[0,[0,[2,[0,[0,[0,0,3,0]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _qv_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     _qy_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],7,[0,[0,0,11,0]]]],
     _qB_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],9,[0,[0,0,11,0]]]],
     _qE_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],7,[0,[0,[2,[0,0,9,0]],11,0]]]],
     _qH_=[0,[0,[0,[0,[2,[0,0,1,0]],5,0]],7,[0,[0,[2,[0,0,9,0]],11,0]]]],
     _qK_=[0,[0,[0,[0,0,3,[2,[0,0,5,0]]]],7,[0,[0,[2,[0,0,9,0]],11,0]]]],
     _qO_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     _qR_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],7,[0,[0,0,11,0]]]],
     _qU_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],9,[0,[0,0,11,0]]]],
     _qX_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _q0_=[0,[0,[0,[0,[2,[0,0,1,0]],5,0]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _q3_=[0,[0,[0,[0,0,3,[2,[0,0,5,0]]]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _q7_=[0,[0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     _q__=[0,[0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],7,[0,[0,0,11,0]]]],
     _rb_=[0,[0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],9,[0,[0,0,11,0]]]],
     _re_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],7,[0,[0,[2,[0,0,9,0]],11,0]]]],
     _rh_=[0,[0,[0,[0,[2,[0,0,1,0]],5,0]],7,[0,[0,[2,[0,0,9,0]],11,0]]]],
     _rk_=[0,[0,[0,[0,0,3,[2,[0,0,5,0]]]],7,[0,[0,[2,[0,0,9,0]],11,0]]]],
     _ro_=[0,[0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     _rr_=[0,[0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],7,[0,[0,0,11,0]]]],
     _ru_=[0,[0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],9,[0,[0,0,11,0]]]],
     _rx_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _rA_=[0,[0,[0,[0,[2,[0,0,1,0]],5,0]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _rD_=[0,[0,[0,[0,0,3,[2,[0,0,5,0]]]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _rH_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _rK_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,[2,[0,0,7,0]],11,0]]]],
     _rN_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _rQ_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _rT_=[0,[0,[0,[0,0,1,0]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _rW_=[0,[0,[0,[0,0,3,0]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _r0_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _r3_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,[2,[0,0,7,0]],11,0]]]],
     _r6_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _r9_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _sa_=[0,[0,[0,[0,0,1,0]],5,[0,[0,[2,[0,0,7,0]],9,[2,[0,0,11,0]]]]]],
     _sd_=[0,[0,[0,[0,0,3,0]],5,[0,[0,[2,[0,0,7,0]],9,[2,[0,0,11,0]]]]]],
     _sh_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _sk_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],11,0]]]],
     _sn_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _sq_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _st_=[0,[0,[0,[0,0,1,0]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _sw_=[0,[0,[0,[0,0,3,0]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _sA_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _sD_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],11,0]]]],
     _sG_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _sJ_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _sM_=[0,[0,[0,[0,0,1,0]],5,[0,[0,[2,[0,0,7,0]],9,[2,[0,0,11,0]]]]]],
     _sP_=[0,[0,[0,[0,0,3,0]],5,[0,[0,[2,[0,0,7,0]],9,[2,[0,0,11,0]]]]]],
     _sT_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,9,0]]]]]],
     _sW_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,11,0]]]]]],
     _sZ_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],9,[0,[0,0,11,0]]]]]],
     _s2_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _s5_=[0,[0,[0,[0,0,1,0]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _s8_=[0,[0,[2,[0,[0,[0,0,3,0]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _ta_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,9,0]]]]]],
     _td_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,11,0]]]]]],
     _tg_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],9,[0,[0,0,11,0]]]]]],
     _tj_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _tm_=[0,[0,[0,[0,0,1,0]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _tp_=[0,[0,[2,[0,[0,[0,0,3,0]],5,[0,[0,0,7,0]]]],9,[0,[0,0,11,0]]]],
     _tt_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,9,0]]]]]],
     _tw_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,11,0]]]]]],
     _tz_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],9,[0,[0,0,11,0]]]]]],
     _tC_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _tF_=[0,[0,[0,[0,0,1,0]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _tI_=[0,[0,[0,[0,0,3,[2,[0,0,5,0]]]],7,[0,[0,[2,[0,0,9,0]],11,0]]]],
     _tM_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,9,0]]]]]],
     _tP_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,11,0]]]]]],
     _tS_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],9,[0,[0,0,11,0]]]]]],
     _tV_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _tY_=[0,[0,[0,[0,0,1,0]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,11,0]]]]]],
     _t1_=[0,[0,[0,[0,0,3,[2,[0,0,5,0]]]],7,[0,[0,0,9,[2,[0,0,11,0]]]]]],
     _t5_=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],7,0]]]],
     _t8_=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],9,0]]]],
     _t$_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],7,[0,[0,0,9,0]]]],
     _uc_=[0,[0,[0,[0,[2,[0,0,1,0]],5,0]],7,[0,[0,0,9,0]]]],
     _uf_=[0,[0,[0,[0,0,3,[2,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     _uj_=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],7,0]]]],
     _um_=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],9,0]]]],
     _up_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],7,[0,[0,0,9,0]]]],
     _us_=[0,[0,[0,[0,[2,[0,0,1,0]],5,0]],7,[0,[0,0,9,0]]]],
     _uv_=[0,[0,[0,[0,0,3,[2,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     _uz_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,7,0]]]],
     _uC_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,9,0]]]],
     _uF_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],7,[0,[0,0,9,0]]]],
     _uI_=[0,[0,[0,[0,0,1,0]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _uL_=[0,[0,[0,[0,0,3,0]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _uP_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,7,0]]]],
     _uS_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,9,0]]]],
     _uV_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],7,[0,[0,0,9,0]]]],
     _uY_=[0,[0,[0,[0,0,1,0]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _u1_=[0,[0,[0,[0,0,3,0]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _u5_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,0,7,0]]]],
     _u8_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,0,9,0]]]],
     _u$_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],7,[0,[0,0,9,0]]]],
     _vc_=[0,[0,[0,[0,0,1,0]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _vf_=[0,[0,[0,[0,0,3,0]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _vj_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,0,7,0]]]],
     _vm_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,0,9,0]]]],
     _vp_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],7,[0,[0,0,9,0]]]],
     _vs_=[0,[0,[0,[0,0,1,0]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _vv_=[0,[0,[0,[0,0,3,0]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _vz_=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],7,0]]]],
     _vC_=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],9,0]]]],
     _vF_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _vI_=[0,[0,[0,[0,0,1,0]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _vL_=[0,[0,[0,[0,0,3,[2,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     _vP_=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],7,0]]]],
     _vS_=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],9,0]]]],
     _vV_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _vY_=[0,[0,[0,[0,0,1,0]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _v1_=[0,[0,[0,[0,0,3,0]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _v5_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],
     _v8_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,7,0]]]],
     _v$_=[0,[0,[0,[0,0,1,0]],5,[0,[0,0,7,0]]]],
     _wc_=[0,[0,[0,[0,0,3,0]],5,[0,[0,0,7,0]]]],
     _wg_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],
     _wj_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,7,0]]]],
     _wm_=[0,[0,[0,[0,0,1,0]],5,[0,[0,0,7,0]]]],
     _wp_=[0,[0,[0,[0,0,3,0]],5,[0,[0,0,7,0]]]],
     _wt_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],
     _ww_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,7,0]]]],
     _wz_=[0,[0,[0,[0,0,1,0]],5,[0,[0,0,7,0]]]],
     _wC_=[0,[0,[0,[0,0,3,0]],5,[0,[0,0,7,0]]]],
     _wG_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],
     _wJ_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,7,0]]]],
     _wM_=[0,[0,[0,[0,0,1,0]],5,[0,[0,0,7,0]]]],
     _wP_=[0,[0,[0,[0,0,3,0]],5,[0,[0,0,7,0]]]],
     _wT_=[0,[0,[2,[0,0,1,0]],3,0]],
     _wW_=[0,[0,[2,[0,0,1,0]],5,0]],
     _wZ_=[0,[0,0,3,[2,[0,0,5,0]]]],
     _w3_=[0,[0,[2,[0,0,1,0]],3,0]],
     _w6_=[0,[0,[2,[0,0,1,0]],5,0]],
     _w9_=[0,[0,0,3,[2,[0,0,5,0]]]],
     _xb_=[0,[0,0,1,0]],
     _xe_=[0,[0,0,3,0]],
     _xi_=[0,[0,0,1,0]],
     _xl_=[0,[0,0,3,0]],
     _xK_=[0,[0,[2,[0,0,1,0]],3,[2,[0,0,4,0]]]],
     _xM_=[0,[0,[2,[0,0,1,0]],3,0]],
     _xO_=[0,[0,[0,[0,0,1,0]],2,[0,[0,0,3,0]]]],
     _xQ_=[0,[0,[2,[0,0,1,0]],3,0]],
     _xS_=[0,[0,[0,[0,0,0,0]],1,[0,[0,0,3,0]]]],
     _xU_=[0,[0,[2,[0,0,-1,0]],3,0]],
     _xW_=[0,[0,[0,[0,0,1,0]],-2,[0,[0,0,3,0]]]],
     _xY_=[0,[0,[2,[0,0,1,0]],-3,0]],
     _x0_=[0,[0,[2,[0,0,1,0]],3,[2,[0,0,-4,0]]]],
     _x2_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,4,0]]]],
     _x4_=[0,[0,0,1,[2,[0,0,3,0]]]],
     _x6_=[0,[0,[0,[0,0,1,0]],2,[0,[0,0,3,0]]]],
     _x8_=[0,[0,0,1,[2,[0,0,3,0]]]],
     _x__=[0,[0,[2,[0,0,0,0]],1,[2,[0,0,3,0]]]],
     _ya_=[0,[0,0,-1,[2,[0,0,3,0]]]],
     _yc_=[0,[0,[0,[0,0,1,0]],-2,[0,[0,0,3,0]]]],
     _ye_=[0,[0,0,1,[2,[0,0,-3,0]]]],
     _yg_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,-4,0]]]],
     _yi_=[0,[0,0,1,[2,[0,0,2,0]]]],
     _yk_=[0,[0,0,1,0]],
     _ym_=[0,[0,[2,[0,0,0,0]],1,0]],
     _yo_=[0,[0,0,-1,0]],
     _yq_=[0,[0,0,1,[2,[0,0,-2,0]]]],
     _ys_=[0,[0,0,0,0]],
     _yv_=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],7,[0,[0,0,9,[2,[0,0,10,0]]]]]],
     _yy_=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,0]]]],7,[0,[0,[2,[0,0,8,0]],9,0]]]],
     _yB_=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,5,[2,[0,0,6,0]]]]]],7,[0,[0,0,9,0]]]],
     _yE_=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,4,0]],5,0]]]],7,[0,[0,0,9,0]]]],
     _yH_=
      [0,
       [0,[2,[0,[0,[0,0,1,[2,[0,0,2,0]]]],3,[0,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     _yK_=
      [0,
       [0,[2,[0,[0,[0,[2,[0,0,0,0]],1,0]],3,[0,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     _yM_=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],7,[0,[0,0,9,[2,[0,0,10,0]]]]]],
     _yP_=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,5,0]]]],7,[0,[0,[2,[0,0,8,0]],9,0]]]],
     _yS_=
      [0,
       [0,[2,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,6,0]]]],7,[0,[0,0,9,0]]]],
     _yV_=
      [0,
       [0,[2,[0,[0,[0,[2,[0,0,1,0]],3,0]],4,[0,[0,0,5,0]]]],7,[0,[0,0,9,0]]]],
     _yY_=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],2,[0,[0,0,3,[2,[0,0,5,0]]]]]],7,[0,[0,0,9,0]]]],
     _y1_=
      [0,
       [0,[2,[0,[0,[0,0,0,0]],1,[0,[0,0,3,[2,[0,0,5,0]]]]]],7,[0,[0,0,9,0]]]],
     _y3_=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,[2,[0,0,7,0]],9,[2,[0,0,10,0]]]]]],
     _y6_=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,0]],5,[2,[0,[0,[0,0,7,0]],8,[0,[0,0,9,0]]]]]],
     _y9_=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,0]],5,[2,[0,[0,[0,0,6,0]],7,[0,[0,0,9,0]]]]]],
     _za_=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,4,0]]]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _zd_=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],2,[0,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _zg_=
      [0,
       [0,[2,[0,[0,[0,0,0,0]],1,[0,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _zi_=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,0]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,10,0]]]]]],
     _zl_=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,0]],5,[2,[0,[0,[0,0,7,0]],8,[0,[0,0,9,0]]]]]],
     _zo_=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,[2,[0,0,6,0]],7,[2,[0,0,9,0]]]]]],
     _zr_=
      [0,
       [0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,4,0]]]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _zu_=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],2,[0,[0,0,3,0]]]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _zx_=
      [0,
       [0,[2,[0,[0,[0,0,0,0]],1,[0,[0,0,3,0]]]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _zz_=
      [0,
       [0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],9,[2,[0,0,10,0]]]]]],
     _zC_=
      [0,
       [0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[2,[0,[0,[0,0,7,0]],8,[0,[0,0,9,0]]]]]],
     _zF_=
      [0,
       [0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[2,[0,[0,[0,0,6,0]],7,[0,[0,0,9,0]]]]]],
     _zI_=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,4,0]]]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _zL_=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],2,[0,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _zO_=
      [0,
       [0,[0,[0,[2,[0,0,0,0]],1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,7,0]],9,0]]]],
     _zQ_=
      [0,
       [0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[2,[0,[0,[0,0,7,0]],9,[0,[0,0,10,0]]]]]],
     _zT_=
      [0,
       [0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[2,[0,[0,[0,0,7,0]],8,[0,[0,0,9,0]]]]]],
     _zW_=
      [0,
       [0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,6,0]],7,[2,[0,0,9,0]]]]]],
     _zZ_=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,4,0]]]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _z2_=
      [0,
       [0,[2,[0,[0,[0,0,1,0]],2,[0,[0,0,3,0]]]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _z5_=
      [0,
       [0,[0,[0,[2,[0,0,0,0]],1,[2,[0,0,3,0]]]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]],
     _z7_=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,9,[2,[0,0,10,0]]]]]]]],
     _z__=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,[2,[0,0,8,0]],9,0]]]]]],
     _Ab_=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,[2,[0,0,6,0]]]],7,[0,[0,0,9,0]]]]]],
     _Ae_=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,[2,[0,0,4,0]],5,0]],7,[0,[0,0,9,0]]]]]],
     _Ah_=
      [0,
       [0,[0,[0,0,1,[2,[0,0,2,0]]]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,9,0]]]]]],
     _Ak_=
      [0,
       [0,[0,[0,[2,[0,0,0,0]],1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,9,0]]]]]],
     _Am_=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,[2,[0,0,5,0]],7,0]],9,[0,[0,0,10,0]]]]]],
     _Ap_=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,[2,[0,0,5,0]],7,0]],8,[0,[0,0,9,0]]]]]],
     _As_=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],6,[0,[0,0,7,[2,[0,0,9,0]]]]]]]],
     _Av_=
      [0,
       [0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,4,0]],5,[0,[0,0,7,[2,[0,0,9,0]]]]]]]],
     _Ay_=
      [0,
       [0,[0,[0,0,1,[2,[0,0,2,0]]]],3,[0,[0,[2,[0,0,5,0]],7,[2,[0,0,9,0]]]]]],
     _AB_=
      [0,
       [0,[0,[0,[2,[0,0,0,0]],1,0]],3,[0,[0,[2,[0,0,5,0]],7,[2,[0,0,9,0]]]]]],
     _AD_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,7,[2,[0,0,8,0]]]]]],
     _AG_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,[2,[0,0,6,0]],7,0]]]],
     _AJ_=[0,[0,[0,[0,[2,[0,0,1,0]],3,[2,[0,0,4,0]]]],5,[0,[0,0,7,0]]]],
     _AM_=[0,[0,[2,[0,[0,[0,0,1,0]],2,[0,[0,0,3,0]]]],5,[0,[0,0,7,0]]]],
     _AP_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,0,7,[2,[0,0,8,0]]]]]],
     _AS_=[0,[0,[0,[0,0,1,[2,[0,0,3,0]]]],5,[0,[0,[2,[0,0,6,0]],7,0]]]],
     _AV_=[0,[0,[2,[0,[0,[0,0,1,0]],3,[0,[0,0,4,0]]]],5,[0,[0,0,7,0]]]],
     _AY_=[0,[0,[2,[0,[0,[0,0,1,0]],2,[0,[0,0,3,0]]]],5,[0,[0,0,7,0]]]],
     _A1_=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,5,0]],7,[2,[0,0,8,0]]]]]],
     _A4_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],6,[0,[0,0,7,0]]]]]],
     _A7_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,4,0]],5,[0,[0,0,7,0]]]]]],
     _A__=[0,[0,[0,[0,0,1,[2,[0,0,2,0]]]],3,[0,[0,[2,[0,0,5,0]],7,0]]]],
     _Bb_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],7,[0,[0,0,8,0]]]]]],
     _Be_=[0,[0,[0,[0,0,1,0]],3,[2,[0,[0,[0,0,5,0]],6,[0,[0,0,7,0]]]]]],
     _Bh_=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,4,0]],5,[2,[0,0,7,0]]]]]],
     _Bk_=[0,[0,[0,[0,0,1,[2,[0,0,2,0]]]],3,[0,[0,0,5,[2,[0,0,7,0]]]]]],
     _Bn_=[0,[0,[0,[0,[2,[0,0,0,0]],1,0]],3,[0,[0,0,5,[2,[0,0,7,0]]]]]],
     _Bp_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],5,[0,[0,0,6,0]]]],
     _Bs_=[0,[0,[0,[0,[2,[0,0,1,0]],3,0]],4,[0,[0,0,5,0]]]],
     _Bv_=[0,[0,[0,[0,0,1,0]],2,[0,[0,0,3,[2,[0,0,5,0]]]]]],
     _By_=[0,[0,[0,[0,0,0,0]],1,[0,[0,0,3,[2,[0,0,5,0]]]]]],
     _BA_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,5,[2,[0,0,6,0]]]]]],
     _BD_=[0,[0,[0,[0,0,1,0]],3,[0,[0,[2,[0,0,4,0]],5,0]]]],
     _BG_=[0,[0,[0,[0,0,1,[2,[0,0,2,0]]]],3,[0,[0,0,5,0]]]],
     _BJ_=[0,[0,[0,[0,[2,[0,0,0,0]],1,0]],3,[0,[0,0,5,0]]]],
     _BL_=[0,[0,[2,[0,0,1,0]],3,[2,[0,0,4,0]]]],
     _BO_=[0,[0,[0,[0,0,1,0]],2,[0,[0,0,3,0]]]],
     _BR_=[0,[0,[0,[0,0,0,0]],1,[0,[0,0,3,0]]]],
     _BT_=[0,[0,[0,[0,0,1,0]],3,[0,[0,0,4,0]]]],
     _BW_=[0,[0,[0,[0,0,1,0]],2,[0,[0,0,3,0]]]],
     _BZ_=[0,[0,[2,[0,0,0,0]],1,[2,[0,0,3,0]]]],
     _B1_=[0,[0,0,1,[2,[0,0,2,0]]]],
     _B4_=[0,[0,[2,[0,0,0,0]],1,0]],
     _B6_=[0,[0,0,0,0]],
     _B9_=[0,2,0],
     _B__=[0,[0,[0,[0,0,0,0]],1,[2,[0,0,2,0]]]],
     _Ca_=[0,2,0],
     _Cb_=[0,[0,[2,[0,0,0,0]],1,[0,[0,0,2,0]]]],
     _Cd_=[0,3,0],
     _Ce_=[0,[0,[2,[0,0,0,0]],1,[2,[0,0,1,0]]]],
     _Cg_=[0,3,0],
     _Ch_=[0,[0,[2,[0,0,1,0]],1,[2,[0,0,2,0]]]],
     _Cj_=[0,[0,[2,[0,0,0,0]],1,[2,[0,0,2,0]]]],
     _Cl_=[0,0,[0,1,0]],
     _Cm_=[2,[0,0,0,[2,[0,0,1,0]]]],
     _Co_=[0,0,[0,1,0]],
     _Cp_=[2,[0,[2,[0,0,0,0]],1,0]],
     _Cr_=[0,[0,[2,[0,0,0,0]],1,0]],
     _Ct_=[0,0,0],
     _Cu_=[2,[0,0,0,0]],
     _Cw_=[0,0,[0,1,0]],
     _Cx_=[1,[0,0,0,0]],
     _Cz_=[0,[0,0,0,0]],
     _CB_=[0,0,[0,1,0]],
     _CG_=[0,3,[0,2,[0,1,0]]],
     _CH_=[0,4,[0,2,[0,3,[0,1,0]]]],
     _CJ_=[0,3,[0,2,[0,1,0]]],
     _CK_=[0,4,[0,3,[0,1,[0,2,0]]]],
     _CM_=[0,3,[0,1,[0,2,0]]],
     _CN_=[0,4,[0,3,[0,2,[0,1,0]]]],
     _CP_=[0,2,[0,1,0]],
     _CQ_=[0,3,[0,1,[0,2,0]]],
     _CS_=[0,2,[0,1,0]],
     _CT_=[0,3,[0,2,[0,1,0]]],
     _CV_=[0,1,0],
     _CW_=[0,2,[0,1,0]],
     _CY_=[0,1,0],
     _C0_=[0,1,[0,0,[0,0,[0,0,[0,0,[0,0,[0,0,[0,0,0]]]]]]]],
     _C1_=[0,1,[0,0,[0,0,[0,0,[0,0,[0,0,[0,0,[0,0,0]]]]]]]],
     _C3_=[0,1,[0,0,[0,0,[0,0,[0,0,[0,0,[0,0,[0,0,0]]]]]]]],
     _C4_=[0,0,[0,0,[0,0,[0,0,[0,0,[0,0,[0,0,[0,1,0]]]]]]]],
     _C6_=[0,2,[0,1,[0,0,0]]],
     _C7_=[0,2,[0,1,[0,0,0]]],
     _C9_=[0,2,[0,0,[0,1,0]]],
     _C__=[0,2,[0,0,[0,1,0]]],
     _Da_=[0,2,[0,1,[0,0,0]]],
     _Db_=[0,1,[0,2,[0,0,0]]],
     _Dd_=[0,2,[0,0,[0,1,0]]],
     _De_=[0,1,[0,0,[0,2,0]]],
     _Dg_=[0,2,[0,0,[0,1,0]]],
     _Dh_=[0,0,[0,2,[0,1,0]]],
     _Dj_=[0,2,[0,0,[0,1,0]]],
     _Dk_=[0,0,[0,1,[0,2,0]]],
     _Dm_=[0,1,[0,0,0]],
     _Dn_=[0,1,[0,0,0]],
     _Dp_=[0,1,[0,0,0]],
     _Dq_=[0,0,[0,1,0]],
     _Ds_=[0,0,0],
     _Dt_=[0,0,0],
     _DB_=
      [0,
       caml_new_string(""),
       [0,
        caml_new_string("ab"),
        [0,
         caml_new_string(""),
         [0,caml_new_string("cd"),[0,caml_new_string(""),0]]]]],
     _DC_=[0,120,0],
     _DE_=
      [0,
       caml_new_string("ab"),
       [0,
        caml_new_string("de"),
        [0,caml_new_string("gh"),[0,caml_new_string("j"),0]]]],
     _DF_=[0,99,[0,102,0]],
     _DK_=
      [0,
       [0,
        [1,
         [0,
          caml_new_string("bar"),
          [0,[0,[0,caml_new_string("foo"),0]],0],
          [0,1,2,3]]],
        caml_new_string
         ('Group {name="bar"; children=[Single {label="foo"; status=Success}]; counts={successes=1; failures=2; errors=3}}')],
       0],
     _DL_=
      [0,
       [0,[0,caml_new_string("foo"),[0,[5,caml_new_string("bad")]]]],
       caml_new_string('Single {label="foo"; status=Failure (Custom "bad")}')],
     _DM_=
      [0,
       [0,[0,caml_new_string("foo"),[0,[2,caml_new_string("Foo")]]]],
       caml_new_string
        ('Single {label="foo"; status=Failure (NoExceptionNamed "Foo")}')],
     _DN_=
      [0,
       [0,
        [0,
         caml_new_string("foo"),
         [0,[0,[0,caml_new_string("a"),caml_new_string("b")]]]]],
       caml_new_string
        ('Single {label="foo"; status=Failure (NotEqual ("a", "b"))}')],
     _DO_=
      [0,
       [0,[0,caml_new_string("foo"),0]],
       caml_new_string('Single {label="foo"; status=Success}')],
     _DV_=
      [0,[0,caml_new_string("custom failure"),[0,[5,caml_new_string("bad")]]]],
     _DZ_=
      [0,
       [0,
        caml_new_string("not equal failure"),
        [0,[0,[0,caml_new_string("42"),caml_new_string("43")]]]]],
     _D1_=
      [1,
       [0,
        caml_new_string("group success"),
        [0,[0,[0,caml_new_string("child"),0]],0],
        [0,1,0,0]]],
     _D3_=[0,[0,caml_new_string("single success"),0]],
     _D5_=[0,[11,caml_new_string("ru"),[2,0,0]],caml_new_string("ru%s")],
     _D9_=[0,0,0,1],
     _D__=
      [0,
       caml_new_string('"foo" (Successes: 0, failures: 0, errors: 1)'),
       [0,
        caml_new_string
         ('  "bar": ERROR: exception TestingTests.Tests.TestException0 raised (no backtrace)'),
        0]],
     _Ea_=
      [1,
       [0,
        caml_new_string("foo"),
        [0,
         [0,[0,caml_new_string("bar"),[0,[5,caml_new_string("nope")]]]],
         [0,[0,[0,caml_new_string("baz"),0]],0]],
        [0,1,1,0]]],
     _Eb_=
      [0,
       caml_new_string('"foo" (Successes: 1, failures: 1, errors: 0)'),
       [0,caml_new_string('  "bar": FAILED: nope'),0]],
     _Ec_=[0,0],
     _Ee_=
      [1,
       [0,
        caml_new_string("foo"),
        [0,
         [0,[0,caml_new_string("bar"),[0,[5,caml_new_string("nope")]]]],
         [0,[0,[0,caml_new_string("baz"),0]],0]],
        [0,1,1,0]]],
     _Ef_=
      [0,
       caml_new_string('"foo" (Successes: 1, failures: 1, errors: 0)'),
       [0,
        caml_new_string('  "bar": FAILED: nope'),
        [0,caml_new_string('  "baz": OK'),0]]],
     _Eg_=[0,1],
     _Ei_=
      [1,
       [0,
        caml_new_string("foo"),
        [0,
         [0,[0,caml_new_string("bar"),0]],
         [0,[0,[0,caml_new_string("baz"),0]],0]],
        [0,2,0,0]]],
     _Ej_=[0,caml_new_string('"foo" (Successes: 2)'),0],
     _Ek_=[0,0],
     _Em_=
      [1,
       [0,
        caml_new_string("foo"),
        [0,
         [0,[0,caml_new_string("bar"),0]],
         [0,[0,[0,caml_new_string("baz"),0]],0]],
        [0,2,0,0]]],
     _En_=
      [0,
       caml_new_string('"foo" (Successes: 2)'),
       [0,caml_new_string('  "bar": OK'),[0,caml_new_string('  "baz": OK'),0]]],
     _Eo_=[0,1],
     _Eu_=
      [0,
       caml_new_string
        ('"bar 6": ERROR: exception TestingTests.Tests.TestException0 raised (no backtrace)'),
       0],
     _Ew_=[0,[0,caml_new_string("bar 5"),[0,[5,caml_new_string("too bad")]]]],
     _Ex_=[0,caml_new_string('"bar 5": FAILED: too bad'),0],
     _EH_=
      [0,
       caml_new_string
        ("\"bar 3'\": FAILED: expected exception Foo not raised, but exception TestingTests.Tests.TestException0' raised (no backtrace)"),
       0],
     _EJ_=
      [0,
       caml_new_string
        ('"bar 3": FAILED: expected exception TestingTests.Tests.TestException0 not raised, but exception TestingTests.Tests.TestException0\' raised (no backtrace)'),
       0],
     _EL_=[0,[0,caml_new_string("bar 2'"),[0,[2,caml_new_string("Foo")]]]],
     _EM_=
      [0,
       caml_new_string('"bar 2\'": FAILED: expected exception Foo not raised'),
       0],
     _EO_=
      [0,
       caml_new_string
        ('"bar 2": FAILED: expected exception TestingTests.Tests.TestException0 not raised'),
       0],
     _EQ_=
      [0,
       [0,
        caml_new_string("bar 1"),
        [0,[0,[0,caml_new_string("a"),caml_new_string("b")]]]]],
     _ER_=[0,caml_new_string('"bar 1": FAILED: expected a, but got b'),0],
     _ET_=[0,[0,caml_new_string("foo"),0]],
     _EU_=[0,caml_new_string('"foo": OK'),0],
     _EV_=[0,1];
    function get(_aen_,_aem_){return caml_check_bound(_aen_,_aem_)[_aem_ + 1]}
    function set(_ael_,_aek_,_aej_)
     {return caml_check_bound(_ael_,_aek_)[_aek_ + 1] = _aej_}
    var
     Array=[0,get,set],
     ArrayLabels=[0],
     Bigarray=[0],
     Buffer=[0],
     Bytes=[0],
     BytesLabels=[0],
     Callback=[0],
     Char=[0],
     Complex=[0],
     Digest=[0],
     Ephemeron=[0],
     Filename=[0],
     Float=[0],
     Format=[0],
     Gc=[0],
     Genlex=[0],
     Hashtbl=[0],
     Int32=[0],
     Int64=[0],
     Lazy=[0],
     Lexing=[0],
     List=[0],
     ListLabels=[0],
     Map=[0],
     Marshal=[0],
     MoreLabels=[0],
     Nativeint=[0],
     Oo=[0],
     Parsing=[0],
     Printexc=[0],
     Printf=[0],
     Queue=[0],
     Random=[0],
     Scanf=[0],
     Seq=[0],
     Set=[0],
     Sort=[0],
     Spacetime=[0],
     Stack=[0],
     StdLabels=[0],
     Stream=[0],
     get$0=caml_string_get,
     set$0=caml_bytes_set,
     String=[0,get$0,set$0],
     StringLabels=[0],
     Sys=[0],
     Uchar=[0],
     Weak=[0],
     Num=[0],
     Big_int=[0],
     Arith_status=[0],
     ResetStandardLibrary=
      [0,
       OCamlStandard,
       Pervasives,
       Arg,
       Array,
       ArrayLabels,
       Bigarray,
       Buffer,
       Bytes,
       BytesLabels,
       Callback,
       Char,
       Complex,
       Digest,
       Ephemeron,
       Filename,
       Float,
       Format,
       Gc,
       Genlex,
       Hashtbl,
       Int32,
       Int64,
       Lazy,
       Lexing,
       List,
       ListLabels,
       Map,
       Marshal,
       MoreLabels,
       Nativeint,
       Oo,
       Parsing,
       Printexc,
       Printf,
       Queue,
       Random,
       Scanf,
       Seq,
       Set,
       Sort,
       Spacetime,
       Stack,
       StdLabels,
       Stream,
       String,
       StringLabels,
       Sys,
       Uchar,
       Weak,
       Num,
       Big_int,
       Arith_status],
     Reset=[0,ResetPervasives,ResetStandardLibrary],
     equal=caml_equal,
     different=caml_notequal,
     O=[0,caml_equal,caml_notequal],
     Poly=[0,equal,different,O];
    function equal$0(_aei_,_aeh_){return _aei_ === _aeh_?1:0}
    function different$0(_aeg_,_aef_){return _aeg_ !== _aef_?1:0}
    var Phys=[0,equal$0,different$0],Equate=[0,Poly,Phys];
    function of_standard(compare,x,y)
     {var c=caml_call2(compare,x,y);return 0 === c?1:0 <= c?2:0}
    function compare(x,y){return of_standard(runtime.caml_compare,x,y)}
    var
     less_than=caml_lessthan,
     less_or_equal=caml_lessequal,
     greater_or_equal=caml_greaterequal,
     greater_than=caml_greaterthan;
    function between(x,low,high)
     {var _aee_=caml_lessthan(low,x);
      return _aee_?caml_greaterthan(high,x):_aee_}
    function between_or_equal(x,low,high)
     {var _aed_=caml_lessequal(low,x);
      return _aed_?caml_greaterequal(high,x):_aed_}
    var min=Stdlib[1][4],max=Stdlib[1][5];
    function min_max(x,y)
     {var match=compare(x,y);return 0 === match?[0,x,y]:[0,y,x]}
    var
     _a_=caml_lessthan,
     _b_=caml_lessequal,
     _c_=caml_greaterequal,
     _d_=caml_greaterthan,
     Shorten=[0];
    function with_result(format,f)
     {return caml_call2(Stdlib_printf[9],f,format)}
    function apply(format){return caml_call1(Stdlib_printf[4],format)}
    function of_string(_aec_){return _aec_}
    var to_string=Stdlib[1][85],concat=Stdlib[1][86];
    function with_scan_result(format,f,s)
     {return caml_call3(Stdlib_scanf[4],s,format,f)}
    function value(_aea_)
     {var _aeb_=runtime.caml_obj_tag(_aea_);
      return 250 === _aeb_
              ?_aea_[1]
              :246 === _aeb_?caml_call1(CamlinternalLazy[2],_aea_):_aea_}
    var is_value=Stdlib_lazy[5];
    function map(x,f)
     {return [246,function(_ad$_){return caml_call1(f,value(x))}]}
    var
     register_printer=Stdlib_printexc[8],
     include=Equate[1],
     equal$1=include[1],
     different$1=include[2],
     O$0=include[3],
     Exit=Stdlib[1][3];
    function raise(_ad__){throw _ad__}
    function raise_without_backtrace(_ad9_){throw _ad9_}
    function invalid_argument(format)
     {return with_result
              (format,
               function(message){return raise([0,InvalidArgument,message])})}
    function failure(format)
     {return with_result
              (format,function(message){return raise([0,Failure,message])})}
    var
     to_string$0=Stdlib_printexc[1],
     name=Stdlib_printexc[21],
     record_backtraces=Stdlib_printexc[6],
     recording_backtraces=Stdlib_printexc[7];
    function most_recent_backtrace(param)
     {return caml_call1(recording_backtraces,0)
              ?[0,caml_call1(Stdlib_printexc[9],0)]
              :0}
    function or_none(x)
     {try {var _ad7_=[0,value(x)];return _ad7_}catch(_ad8_){return 0}}
    function identity(x){return x}
    function apply$0(f,x){return caml_call1(f,x)}
    function rev_apply(x,f){return caml_call1(f,x)}
    function compose(f,g,x){return caml_call1(f,caml_call1(g,x))}
    var
     O$1=[0,apply$0,rev_apply,compose],
     Function1=[0,identity,apply$0,rev_apply,compose,O$1];
    function flip(f,x,y){return caml_call2(f,y,x)}
    function curry(f,x,y){return caml_call1(f,[0,x,y])}
    function uncurry(f,param)
     {var y=param[2],x=param[1];return caml_call2(f,x,y)}
    var Function2=[0,flip,curry,uncurry];
    function flip$0(f,x,y,z){return caml_call3(f,z,y,x)}
    function curry$0(f,x,y,z){return caml_call1(f,[0,x,y,z])}
    function uncurry$0(f,param)
     {var z=param[3],y=param[2],x=param[1];return caml_call3(f,x,y,z)}
    var Function3=[0,flip$0,curry$0,uncurry$0];
    function flip$1(f,x,y,z,u){return caml_call4(f,u,z,y,x)}
    function curry$1(f,x,y,z,u){return caml_call1(f,[0,x,y,z,u])}
    function uncurry$1(f,param)
     {var u=param[4],z=param[3],y=param[2],x=param[1];
      return caml_call4(f,x,y,z,u)}
    var Function4=[0,flip$1,curry$1,uncurry$1];
    function flip$2(f,x,y,z,u,v){return caml_call5(f,v,u,z,y,x)}
    function curry$2(f,x,y,z,u,v){return caml_call1(f,[0,x,y,z,u,v])}
    function uncurry$2(f,param)
     {var v=param[5],u=param[4],z=param[3],y=param[2],x=param[1];
      return caml_call5(f,x,y,z,u,v)}
    var
     Function5=[0,flip$2,curry$2,uncurry$2],
     smallest=Stdlib[1][8],
     greatest=Stdlib[1][7],
     of_int=Function1[1],
     to_int=Function1[1],
     zero=0,
     one=1;
    function of_float(_ad6_){return _ad6_ | 0}
    function to_float(_ad5_){return _ad5_}
    var of_string$0=caml_int_of_string;
    function try_of_string(s)
     {return or_none([246,function(_ad4_){return caml_int_of_string(s)}])}
    var to_string$1=Stdlib[1][21],repr=Stdlib[1][21];
    function add(_ad3_,_ad2_){return _ad3_ + _ad2_ | 0}
    function substract(_ad1_,_ad0_){return _ad1_ - _ad0_ | 0}
    function negate(_adZ_){return - _adZ_ | 0}
    function multiply(_adY_,_adX_){return caml_mul(_adY_,_adX_)}
    var divide=caml_div;
    function square(x){return caml_mul(x,x)}
    var abs=Stdlib[1][6],modulo=caml_mod;
    function pred(_adW_){return _adW_ - 1 | 0}
    function succ(_adV_){return _adV_ + 1 | 0}
    var include$0=Equate[1][3],_e_=include$0[1],_f_=include$0[2];
    function _g_(_adU_){return - _adU_ | 0}
    function _h_(_adT_){return _adT_}
    function _i_(_adS_,_adR_){return _adS_ + _adR_ | 0}
    function _j_(_adQ_,_adP_){return _adQ_ - _adP_ | 0}
    function _k_(_adO_,_adN_){return caml_mul(_adO_,_adN_)}
    var
     _l_=caml_div,
     mod=caml_mod,
     _m_=Equate[1],
     different$2=_m_[2],
     equal$2=_m_[1];
    function logical_and(_adM_,_adL_){return _adM_ & _adL_}
    function logical_or(_adK_,_adJ_){return _adK_ | _adJ_}
    function logical_xor(_adI_,_adH_){return _adI_ ^ _adH_}
    var logical_not=Stdlib[1][9];
    function logical_shift_left(n,shift){return n << shift}
    function logical_shift_right(n,shift){return n >>> shift | 0}
    function arithmetic_shift_right(n,shift){return n >> shift}
    var
     Bitwise=
      [0,
       logical_and,
       logical_or,
       logical_xor,
       logical_not,
       logical_shift_left,
       logical_shift_right,
       arithmetic_shift_right],
     of_string$1=Stdlib[1][19];
    function try_of_string$0(s)
     {return or_none([246,function(_adG_){return caml_call1(of_string$1,s)}])}
    var to_string$2=Stdlib[1][18],repr$0=Stdlib[1][18];
    function xor(x,y)
     {var switch$0=0 === x?0 === y?1:0:0 === y?0:1;return switch$0?0:1}
    var include$1=Equate[1][3],_n_=include$1[1],_o_=include$1[2];
    function not(_adF_){return 1 - _adF_}
    var _p_=Equate[1],different$3=_p_[2],equal$3=_p_[1];
    function not$0(_adE_){return 1 - _adE_}
    function and(_adC_,_adB_){var _adD_=_adC_?_adB_:_adC_;return _adD_}
    function or(_adz_,_ady_){var _adA_=_adz_ || _ady_;return _adA_}
    function equal$4(x,y,equal_a)
     {if(x)
       {if(y){var y$0=y[1],x$0=x[1];return caml_call2(equal_a,x$0,y$0)}}
      else
       if(! y)return 1;
      return 0}
    function compare$0(x,y,compare_a)
     {if(x)
       {var _adx_=x[1];
        if(y){var y$0=y[1];return caml_call2(compare_a,_adx_,y$0)}
        return 2}
      return y?0:1}
    function repr$1(x,repr_a)
     {if(x)
       {var x$0=x[1],_adw_=caml_call1(repr_a,x$0);
        return caml_call1(apply(_q_),_adw_)}
      return cst_None}
    var none=0;
    function try_of_string$1(x){return [0,x]}
    function some_if(condition,value$0){return condition?[0,value(value$0)]:0}
    function some_if$0(condition,value){return condition?[0,value]:0}
    function value_def(x,def){if(x){var x$0=x[1];return x$0}return def}
    function value$0(opt,x)
     {if(opt)var sth=opt[1],exc=sth;else var exc=[0,Failure,cst_Option_value];
      if(x){var x$0=x[1];return x$0}
      throw exc}
    function or_failure(format)
     {return with_result
              (format,
               function(message,param)
                {if(param){var x=param[1];return x}
                 return raise([0,Failure,message])})}
    function func(x,f)
     {if(x){var x$0=x[1];return [0,caml_call1(f,x$0)]}return 0}
    function value_map(x,def,f)
     {if(x){var x$0=x[1];return caml_call1(f,x$0)}return def}
    function is_some(param){return param?1:0}
    function is_none(param){return param?0:1}
    function iter(x,f){if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
    function filter(x,f)
     {if(x){var x$0=x[1];return some_if$0(caml_call1(f,x$0),x$0)}return 0}
    function filter_map(x,f)
     {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
    var OCSA=0,empty=0;
    function singleton(x){return [0,x,0]}
    function prepend(x,xs){return [0,x,xs]}
    var
     of_list=Function1[1],
     to_list=Function1[1],
     of_array=Stdlib_array[11],
     to_array=Stdlib_array[12];
    function is_empty(param){return param?0:1}
    function try_head(param){if(param){var x=param[1];return [0,x]}return 0}
    function try_tail(param){if(param){var xs=param[2];return [0,xs]}return 0}
    function head(xs)
     {var _adu_=or_failure(_r_),_adv_=try_head(xs);
      return caml_call2(Function1[5][2],_adv_,_adu_)}
    function tail(xs)
     {var _ads_=or_failure(_s_),_adt_=try_tail(xs);
      return caml_call2(Function1[5][2],_adt_,_ads_)}
    function reverse(param)
     {var ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           x=param$0[1],
           ys$0=[0,x,ys],
           ys=ys$0,
           param$0=param$1;
          continue}
        return ys}}
    function rev_concat(param,ys)
     {var ys$0=ys,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           x=param$0[1],
           ys$1=[0,x,ys$0],
           ys$0=ys$1,
           param$0=param$1;
          continue}
        return ys$0}}
    function concat$0(xs,ys){return rev_concat(reverse(xs),ys)}
    var O$2=[0,concat$0];
    function map$0(param,f)
     {var ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           y=caml_call1(f,x),
           ys$0=[0,y,ys],
           ys=ys$0,
           param$0=xs;
          continue}
        return reverse(ys)}}
    function map_acc(acc,param,f)
     {var acc$0=acc,ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call2(f,acc$0,x),
           y=match[2],
           acc$1=match[1],
           ys$0=[0,y,ys],
           acc$0=acc$1,
           ys=ys$0,
           param$0=xs;
          continue}
        return reverse(ys)}}
    function map_i(xs,f)
     {return map_acc
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function flat_map(param,f)
     {var ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           y=caml_call1(f,x),
           ys$0=rev_concat(y,ys),
           ys=ys$0,
           param$0=xs;
          continue}
        return reverse(ys)}}
    function flat_map_acc(acc,param,f)
     {var acc$0=acc,ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call2(f,acc$0,x),
           y=match[2],
           acc$1=match[1],
           ys$0=rev_concat(y,ys),
           acc$0=acc$1,
           ys=ys$0,
           param$0=xs;
          continue}
        return reverse(ys)}}
    function flat_map_i(xs,f)
     {return flat_map_acc
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function filter$0(param,f)
     {var ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           b=caml_call1(f,x),
           ys$0=b?[0,x,ys]:ys,
           ys=ys$0,
           param$0=xs;
          continue}
        return reverse(ys)}}
    function filter_acc(acc,param,f)
     {var acc$0=acc,ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call2(f,acc$0,x),
           b=match[2],
           acc$1=match[1],
           ys$0=b?[0,x,ys]:ys,
           acc$0=acc$1,
           ys=ys$0,
           param$0=xs;
          continue}
        return reverse(ys)}}
    function filter_i(xs,f)
     {return filter_acc
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function filter_map$0(param,f)
     {var ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var xs=param$0[2],x=param$0[1],y=caml_call1(f,x);
          if(y)var y$0=y[1],ys$0=[0,y$0,ys];else var ys$0=ys;
          var ys=ys$0,param$0=xs;
          continue}
        return reverse(ys)}}
    function filter_map_acc(acc,param,f)
     {var acc$0=acc,ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call2(f,acc$0,x),
           y=match[2],
           acc$1=match[1];
          if(y)var y$0=y[1],ys$0=[0,y$0,ys];else var ys$0=ys;
          var acc$0=acc$1,ys=ys$0,param$0=xs;
          continue}
        return reverse(ys)}}
    function filter_map_i(xs,f)
     {return filter_map_acc
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function fold(y,param,f)
     {var y$0=y,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           y$1=caml_call2(f,y$0,x),
           y$0=y$1,
           param$0=xs;
          continue}
        return y$0}}
    function fold_acc(acc,y,param,f)
     {var acc$0=acc,y$0=y,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call3(f,acc$0,y$0,x),
           y$1=match[2],
           acc$1=match[1],
           acc$0=acc$1,
           y$0=y$1,
           param$0=xs;
          continue}
        return y$0}}
    function fold_i(init,xs,f)
     {return fold_acc
              (0,
               init,
               xs,
               function(i,y,x){return [0,i + 1 | 0,caml_call3(f,i,y,x)]})}
    function try_reduce_acc(acc,xs,f)
     {if(xs){var xs$0=xs[2],init=xs[1];return [0,fold_acc(acc,init,xs$0,f)]}
      return 0}
    function try_reduce(xs,f)
     {if(xs){var xs$0=xs[2],init=xs[1];return [0,fold(init,xs$0,f)]}return 0}
    function try_reduce_i(xs,f)
     {if(xs){var xs$0=xs[2],init=xs[1];return [0,fold_i(init,xs$0,f)]}
      return 0}
    function reduce_acc(acc,xs,f)
     {var _adq_=or_failure(_t_),_adr_=try_reduce_acc(acc,xs,f);
      return caml_call2(Function1[5][2],_adr_,_adq_)}
    function reduce(xs,f)
     {var _ado_=or_failure(_u_),_adp_=try_reduce(xs,f);
      return caml_call2(Function1[5][2],_adp_,_ado_)}
    function reduce_i(xs,f)
     {var _adm_=or_failure(_v_),_adn_=try_reduce_i(xs,f);
      return caml_call2(Function1[5][2],_adn_,_adm_)}
    function scan(y,param,f)
     {var y$0=y,ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           y$1=caml_call2(f,y$0,x),
           ys$0=[0,y$1,ys],
           y$0=y$1,
           ys=ys$0,
           param$0=xs;
          continue}
        return reverse([0,y$0,ys])}}
    function scan_acc(acc,y,param,f)
     {var acc$0=acc,y$0=y,ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call3(f,acc$0,y$0,x),
           y$1=match[2],
           acc$1=match[1],
           ys$0=[0,y$1,ys],
           acc$0=acc$1,
           y$0=y$1,
           ys=ys$0,
           param$0=xs;
          continue}
        return reverse([0,y$0,ys])}}
    function scan_i(init,xs,f)
     {return scan_acc
              (0,
               init,
               xs,
               function(i,y,x){return [0,i + 1 | 0,caml_call3(f,i,y,x)]})}
    function iter$0(param,f)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var xs=param$0[2],x=param$0[1];
          caml_call1(f,x);
          var param$0=xs;
          continue}
        return 0}}
    function iter_acc(acc,param,f)
     {var acc$0=acc,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           param$0=xs;
          continue}
        return 0}}
    function iter_i(xs,f)
     {return iter_acc(0,xs,function(i,x){caml_call2(f,i,x);return i + 1 | 0})}
    function count(xs,f)
     {return fold
              (0,xs,function(n,x){var b=caml_call1(f,x);return b?n + 1 | 0:n})}
    function count_acc(acc,xs,f)
     {return fold_acc
              (acc,
               0,
               xs,
               function(acc,n,x)
                {var
                  match=caml_call2(f,acc,x),
                  b=match[2],
                  acc$0=match[1],
                  _adl_=b?n + 1 | 0:n;
                 return [0,acc$0,_adl_]})}
    function count_i(xs,f)
     {return fold_i
              (0,
               xs,
               function(i,n,x){var b=caml_call2(f,i,x);return b?n + 1 | 0:n})}
    function try_find(param,f)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var xs=param$0[2],x=param$0[1],b=caml_call1(f,x);
          if(b)return [0,x];
          var param$0=xs;
          continue}
        return 0}}
    function try_find_acc(acc,param,f)
     {var acc$0=acc,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call2(f,acc$0,x),
           b=match[2],
           acc$1=match[1];
          if(b)return [0,x];
          var acc$0=acc$1,param$0=xs;
          continue}
        return 0}}
    function try_find_i(xs,f)
     {return try_find_acc
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function find(xs,f)
     {var _adh_=[0,NotFound];
      function _adi_(_adk_){return value$0(_adh_,_adk_)}
      var _adj_=try_find(xs,f);
      return caml_call2(Function1[5][2],_adj_,_adi_)}
    function find_acc(acc,xs,f)
     {var _add_=[0,NotFound];
      function _ade_(_adg_){return value$0(_add_,_adg_)}
      var _adf_=try_find_acc(acc,xs,f);
      return caml_call2(Function1[5][2],_adf_,_ade_)}
    function find_i(xs,f)
     {var _ac$_=[0,NotFound];
      function _ada_(_adc_){return value$0(_ac$_,_adc_)}
      var _adb_=try_find_i(xs,f);
      return caml_call2(Function1[5][2],_adb_,_ada_)}
    function there_exists(xs,f)
     {var _ac__=try_find(xs,f);
      return caml_call2(Function1[5][2],_ac__,is_some)}
    function there_exists_acc(acc,xs,f)
     {var _ac9_=try_find_acc(acc,xs,f);
      return caml_call2(Function1[5][2],_ac9_,is_some)}
    function there_exists_i(xs,f)
     {var _ac8_=try_find_i(xs,f);
      return caml_call2(Function1[5][2],_ac8_,is_some)}
    function for_all(xs,f)
     {return 1 - there_exists(xs,caml_call2(Function1[5][3],not,f))}
    function for_all_acc(acc,xs,f)
     {return 1
             -
             there_exists_acc
              (acc,
               xs,
               function(acc,x)
                {var match=caml_call2(f,acc,x),b=match[2],acc$0=match[1];
                 return [0,acc$0,1 - b]})}
    function for_all_i(xs,f)
     {return 1
             -
             there_exists_i(xs,function(i,x){return 1 - caml_call2(f,i,x)})}
    function try_find_map(param,f)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var xs=param$0[2],x=param$0[1],b=caml_call1(f,x);
          if(is_some(b))return b;
          var param$0=xs;
          continue}
        return 0}}
    function try_find_map_acc(acc,param,f)
     {var acc$0=acc,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call2(f,acc$0,x),
           b=match[2],
           acc$1=match[1];
          if(is_some(b))return b;
          var acc$0=acc$1,param$0=xs;
          continue}
        return 0}}
    function try_find_map_i(xs,f)
     {return try_find_map_acc
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function find_map(xs,f)
     {var _ac4_=[0,NotFound];
      function _ac5_(_ac7_){return value$0(_ac4_,_ac7_)}
      var _ac6_=try_find_map(xs,f);
      return caml_call2(Function1[5][2],_ac6_,_ac5_)}
    function find_map_acc(acc,xs,f)
     {var _ac0_=[0,NotFound];
      function _ac1_(_ac3_){return value$0(_ac0_,_ac3_)}
      var _ac2_=try_find_map_acc(acc,xs,f);
      return caml_call2(Function1[5][2],_ac2_,_ac1_)}
    function find_map_i(xs,f)
     {var _acW_=[0,NotFound];
      function _acX_(_acZ_){return value$0(_acW_,_acZ_)}
      var _acY_=try_find_map_i(xs,f);
      return caml_call2(Function1[5][2],_acY_,_acX_)}
    function fold_short(y,param,f)
     {var y$0=y,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call2(f,y$0,x),
           y$1=match[2],
           s=match[1];
          if(0 === s){var y$0=y$1,param$0=xs;continue}
          return y$1}
        return y$0}}
    function fold_short_acc(acc,y,param,f)
     {var acc$0=acc,y$0=y,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call3(f,acc$0,y$0,x),
           y$1=match[3],
           s=match[2],
           acc$1=match[1];
          if(0 === s){var acc$0=acc$1,y$0=y$1,param$0=xs;continue}
          return y$1}
        return y$0}}
    function fold_short_i(init,xs,f)
     {return fold_short_acc
              (0,
               init,
               xs,
               function(i,y,x)
                {var match=caml_call3(f,i,y,x),y$0=match[2],s=match[1];
                 return [0,i + 1 | 0,s,y$0]})}
    function try_reduce_short_acc(acc,xs,f)
     {if(xs)
       {var xs$0=xs[2],init=xs[1];return [0,fold_short_acc(acc,init,xs$0,f)]}
      return 0}
    function try_reduce_short(xs,f)
     {if(xs){var xs$0=xs[2],init=xs[1];return [0,fold_short(init,xs$0,f)]}
      return 0}
    function try_reduce_short_i(xs,f)
     {if(xs){var xs$0=xs[2],init=xs[1];return [0,fold_short_i(init,xs$0,f)]}
      return 0}
    function reduce_short_acc(acc,xs,f)
     {var _acU_=or_failure(_w_),_acV_=try_reduce_short_acc(acc,xs,f);
      return caml_call2(Function1[5][2],_acV_,_acU_)}
    function reduce_short(xs,f)
     {var _acS_=or_failure(_x_),_acT_=try_reduce_short(xs,f);
      return caml_call2(Function1[5][2],_acT_,_acS_)}
    function reduce_short_i(xs,f)
     {var _acQ_=or_failure(_y_),_acR_=try_reduce_short_i(xs,f);
      return caml_call2(Function1[5][2],_acR_,_acQ_)}
    function scan_short(y,param,f)
     {var y$0=y,ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call2(f,y$0,x),
           y$1=match[2],
           s=match[1];
          if(0 === s){var ys$0=[0,y$1,ys],y$0=y$1,ys=ys$0,param$0=xs;continue}
          return reverse([0,y$1,ys])}
        return reverse([0,y$0,ys])}}
    function scan_short_acc(acc,y,param,f)
     {var acc$0=acc,y$0=y,ys=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call3(f,acc$0,y$0,x),
           y$1=match[3],
           s=match[2],
           acc$1=match[1];
          if(0 === s)
           {var ys$0=[0,y$1,ys],acc$0=acc$1,y$0=y$1,ys=ys$0,param$0=xs;
            continue}
          return reverse([0,y$1,ys])}
        return reverse([0,y$0,ys])}}
    function scan_short_i(init,xs,f)
     {return scan_short_acc
              (0,
               init,
               xs,
               function(i,y,x)
                {var match=caml_call3(f,i,y,x),y$0=match[2],s=match[1];
                 return [0,i + 1 | 0,s,y$0]})}
    function iter_short(param,f)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var xs=param$0[2],x=param$0[1],match=caml_call1(f,x);
          if(0 === match){var param$0=xs;continue}
          return 0}
        return 0}}
    function iter_short_acc(acc,param,f)
     {var acc$0=acc,param$0=param;
      for(;;)
       {if(param$0)
         {var
           xs=param$0[2],
           x=param$0[1],
           match=caml_call2(f,acc$0,x),
           s=match[2],
           acc$1=match[1];
          if(0 === s){var acc$0=acc$1,param$0=xs;continue}
          return 0}
        return 0}}
    function iter_short_i(xs,f)
     {return iter_short_acc
              (0,
               xs,
               function(i,x){var s=caml_call2(f,i,x);return [0,i + 1 | 0,s]})}
    function contains(xs,x,equal_a)
     {return there_exists(xs,caml_call1(equal_a,x))}
    function contains$0(param,x)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var xs=param$0[2],x$0=param$0[1];
          if(caml_call2(Equate[1][1],x$0,x))return 1;
          var param$0=xs;
          continue}
        return 0}}
    var Poly$0=[0,contains$0];
    function size(param)
     {var s=0,param$0=param;
      for(;;)
       {if(param$0){var xs=param$0[2],s$0=s + 1 | 0,s=s$0,param$0=xs;continue}
        return s}}
    function join(opt,xs)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cst$0;
      function _acK_(_acP_){return value_def(_acP_,cst)}
      function _acL_(a,b){return caml_call3(apply(_z_),a,sep,b)}
      function _acM_(_acO_){return try_reduce(_acO_,_acL_)}
      var _acN_=caml_call2(Function1[5][2],xs,_acM_);
      return caml_call2(Function1[5][2],_acN_,_acK_)}
    function repr$2(xs,repr_a)
     {var _acD_=apply(_A_);
      function _acE_(_acJ_){return join(_B_,_acJ_)}
      function _acF_(_acI_){return map$0(_acI_,repr_a)}
      var
       _acG_=caml_call2(Function1[5][2],xs,_acF_),
       _acH_=caml_call2(Function1[5][2],_acG_,_acE_);
      return caml_call2(Function1[5][2],_acH_,_acD_)}
    function to_pair_list(xs,ys)
     {var param$1=[0,xs,ys],zs=0,param=param$1;
      for(;;)
       {var _acB_=param[1];
        if(_acB_)
         {var _acC_=param[2];
          if(_acC_)
           {var
             ys$0=_acC_[2],
             y=_acC_[1],
             xs$0=_acB_[2],
             x=_acB_[1],
             param$0=[0,xs$0,ys$0],
             zs$0=[0,[0,x,y],zs],
             zs=zs$0,
             param=param$0;
            continue}}
        else
         if(! param[2])return reverse(zs);
        return invalid_argument(_C_)}}
    function to_pair_list_short(xs,ys)
     {var param$1=[0,xs,ys],zs=0,param=param$1;
      for(;;)
       {var _acz_=param[1];
        if(_acz_)
         {var _acA_=param[2];
          if(_acA_)
           {var
             ys$0=_acA_[2],
             y=_acA_[1],
             xs$0=_acz_[2],
             x=_acz_[1],
             param$0=[0,xs$0,ys$0],
             zs$0=[0,[0,x,y],zs],
             zs=zs$0,
             param=param$0;
            continue}}
        return reverse(zs)}}
    var Two=[0,to_pair_list,to_pair_list_short],OCLL=0;
    function equal$5(xs,ys,equal_a)
     {try
       {var _acx_=caml_call3(Stdlib_listLabels[29],equal_a,xs,ys);
        return _acx_}
      catch(_acy_)
       {_acy_ = caml_wrap_exception(_acy_);
        if(_acy_[1] === InvalidArgument)return 0;
        throw _acy_}}
    function cartesian_product(xs,ys)
     {if(xs)
       {var
         xs$0=xs[2],
         x=xs[1],
         _acu_=cartesian_product(xs$0,ys),
         _acv_=function(y){return [0,x,y]},
         _acw_=caml_call2(Stdlib_listLabels[17],_acv_,ys);
        return caml_call2(Stdlib_listLabels[11],_acw_,_acu_)}
      return 0}
    function current(opt,param)
     {if(opt)var sth=opt[1],max_size=sth;else var max_size=greatest;
      return caml_call1(Stdlib_printexc[12],max_size)}
    var to_string$3=Stdlib_printexc[11];
    function repr$3(param)
     {var
       end_char=param[4],
       start_char=param[3],
       line_number=param[2],
       filename=param[1];
      return caml_call4(apply(_D_),filename,line_number,start_char,end_char)}
    var
     _E_=Equate[1][3],
     _H_=Equate[1],
     different$4=_H_[2],
     equal$6=_H_[1],
     is_raise=Stdlib_printexc[15][1],
     location=Stdlib_printexc[15][3],
     format=Stdlib_printexc[15][4],
     Frame=[0,is_raise,location,format],
     _F_=_E_[1],
     _G_=_E_[2];
    function frames(bt)
     {var match=caml_call1(Stdlib_printexc[14],bt);
      if(match){var frames=match[1];return caml_call1(of_array,frames)}
      return 0}
    var
     smallest$0=Stdlib[1][14],
     greatest$0=Stdlib[1][13],
     epsilon=Stdlib[1][15],
     infinity=Stdlib[1][10],
     negative_infinity=Stdlib[1][11],
     not_a_number=Stdlib[1][12],
     zero$0=0,
     one$0=1,
     pi=3.14159265358979312,
     e=2.71828182845904509;
    function of_int$0(_act_){return _act_}
    function to_int$0(_acs_){return _acs_ | 0}
    var
     of_float$0=Function1[1],
     to_float$0=Function1[1],
     of_string$2=caml_float_of_string;
    function try_of_string$2(s)
     {return or_none([246,function(_acr_){return caml_float_of_string(s)}])}
    var
     to_string$4=Stdlib[1][23],
     of_parts=caml_ldexp_float,
     to_parts=caml_frexp_float,
     to_fractional_and_integral=runtime.caml_modf_float,
     repr$4=Stdlib[1][23];
    function add$0(_acq_,_acp_){return _acq_ + _acp_}
    function substract$0(_aco_,_acn_){return _aco_ - _acn_}
    function negate$0(_acm_){return - _acm_}
    function multiply$0(_acl_,_ack_){return _acl_ * _ack_}
    function divide$0(_acj_,_aci_){return _acj_ / _aci_}
    function square$0(x){return x * x}
    function abs$0(_ach_){return Math.abs(_ach_)}
    function modulo$0(_acg_,_acf_){return _acg_ % _acf_}
    function sqrt(_ace_){return Math.sqrt(_ace_)}
    function exp(_acd_){return Math.exp(_acd_)}
    function log(_acc_){return Math.log(_acc_)}
    var
     log10=runtime.caml_log10_float,
     expm1=runtime.caml_expm1_float,
     log1p=runtime.caml_log1p_float;
    function cos(_acb_){return Math.cos(_acb_)}
    function sin(_aca_){return Math.sin(_aca_)}
    function tan(_ab$_){return Math.tan(_ab$_)}
    function acos(_ab__){return Math.acos(_ab__)}
    function asin(_ab9_){return Math.asin(_ab9_)}
    function atan(_ab8_){return Math.atan(_ab8_)}
    function atan2(y,x){return Math.atan2(y,x)}
    var
     hypot=runtime.caml_hypot_float,
     cosh=runtime.caml_cosh_float,
     sinh=runtime.caml_sinh_float,
     tanh=runtime.caml_tanh_float;
    function ceil(_ab7_){return Math.ceil(_ab7_)}
    function floor(_ab6_){return Math.floor(_ab6_)}
    var
     copy_sign=runtime.caml_copysign_float,
     include$2=Equate[1][3],
     _I_=include$2[1],
     _J_=include$2[2];
    function _K_(_ab5_){return - _ab5_}
    function _L_(_ab4_){return _ab4_}
    function _M_(_ab3_,_ab2_){return _ab3_ + _ab2_}
    function _N_(_ab1_,_ab0_){return _ab1_ - _ab0_}
    function _O_(_abZ_,_abY_){return _abZ_ * _abY_}
    function _P_(_abX_,_abW_){return _abX_ / _abW_}
    function mod$0(_abV_,_abU_){return _abV_ % _abU_}
    var _Q_=Equate[1],different$5=_Q_[2],equal$7=_Q_[1];
    function approx_equal(opt,a,b)
     {if(opt)var sth=opt[1],precision=sth;else var precision=1e-10;
      return caml_lessthan(Math.abs(a - b),precision)}
    function _R_(_abT_){return - _abT_}
    function _S_(_abS_){return _abS_}
    function _T_(_abR_,_abQ_){return _abR_ + _abQ_}
    function _U_(_abP_,_abO_){return _abP_ - _abO_}
    function _V_(_abN_,_abM_){return _abN_ * _abM_}
    function _W_(_abL_,_abK_){return _abL_ / _abK_}
    function _X_(_abJ_,_abI_){return Math.pow(_abJ_,_abI_)}
    function of_float$1(x)
     {var match=runtime.caml_classify_float(x);
      switch(match)
       {case 0:return 0;
        case 1:return 1;
        case 2:return 2;
        case 3:return 3;
        default:return 4}}
    function repr$5(param)
     {switch(param)
       {case 0:return cst_Normal;
        case 1:return cst_SubNormal;
        case 2:return cst_Zero;
        case 3:return cst_Infinite;
        default:return cst_NotANumber}}
    var
     include$3=Equate[1][3],
     ___=Equate[1],
     different$6=___[2],
     equal$8=___[1],
     _Y_=include$3[1],
     _Z_=include$3[2];
    function of_contents(_abH_){return [0,_abH_]}
    function contents(_abG_){return _abG_[1]}
    function assign(_abF_,_abE_){_abF_[1] = _abE_;return 0}
    function ref(_abD_){return [0,_abD_]}
    function _$_(_abC_){return _abC_[1]}
    var O$3=[0,ref,_$_,function(_abB_,_abA_){_abB_[1] = _abA_;return 0}];
    function repr$6(x){return caml_call1(apply(_aa_),x)}
    var
     to_string$5=Function1[1],
     of_string$3=Function1[1],
     of_bytes=Stdlib_bytes[6],
     to_bytes=Stdlib_bytes[5],
     get$1=caml_string_get,
     set$1=caml_bytes_set,
     concat$1=Stdlib[1][16],
     include$4=Equate[1][3],
     _ab_=include$4[1],
     _ac_=include$4[2],
     _ad_=Stdlib[1][16],
     _ae_=Equate[1],
     different$7=_ae_[2],
     equal$9=_ae_[1],
     size$0=caml_ml_string_length;
    function of_char(c){return caml_call2(Stdlib_string[1],1,c)}
    function to_list$0(s)
     {var r=caml_call1(O$3[1],0),_abw_=caml_ml_string_length(s) - 1 | 0;
      if(! (_abw_ < 0))
       {var i=_abw_;
        for(;;)
         {var
           _abx_=caml_call1(O$3[2],r),
           _aby_=[0,caml_call2(Reset[2][45][1],s,i),_abx_];
          caml_call2(O$3[3],r,_aby_);
          var _abz_=i - 1 | 0;
          if(0 !== i){var i=_abz_;continue}
          break}}
      return caml_call1(O$3[2],r)}
    function of_list$0(xs)
     {var len=size(xs),r=caml_create_bytes(len);
      function _abt_(i,x){return caml_bytes_set(r,i,x)}
      function _abu_(_abv_){return iter_i(_abv_,_abt_)}
      caml_call2(Function1[5][2],xs,_abu_);
      return caml_call1(of_bytes,r)}
    function substring(s,pos,len)
     {return caml_call3(Stdlib_string[4],s,pos,len)}
    function prefix(s,len){return substring(s,0,len)}
    function suffix(s,len)
     {return substring(s,caml_ml_string_length(s) - len | 0,len)}
    function has_prefix(s,pre)
     {var
       _abs_=
        caml_greaterequal(caml_ml_string_length(s),caml_ml_string_length(pre));
      return _abs_
              ?caml_call2(_n_,pre,prefix(s,caml_ml_string_length(pre)))
              :_abs_}
    function has_suffix(s,suf)
     {var
       _abr_=
        caml_greaterequal(caml_ml_string_length(s),caml_ml_string_length(suf));
      return _abr_
              ?caml_call2(_n_,suf,suffix(s,caml_ml_string_length(suf)))
              :_abr_}
    function drop_prefix(s,len)
     {return substring(s,len,caml_ml_string_length(s) - len | 0)}
    function drop_suffix(s,len)
     {return substring(s,0,caml_ml_string_length(s) - len | 0)}
    function try_drop_suffix(s,suf)
     {var
       _abp_=
        [246,
         function(_abq_){return drop_suffix(s,caml_ml_string_length(suf))}];
      return some_if(has_suffix(s,suf),_abp_)}
    function try_drop_prefix(s,pre)
     {var
       _abn_=
        [246,
         function(_abo_){return drop_prefix(s,caml_ml_string_length(pre))}];
      return some_if(has_prefix(s,pre),_abn_)}
    function drop_suffix$0(s,suf)
     {var _abl_=or_failure(_af_),_abm_=try_drop_suffix(s,suf);
      return caml_call2(Function1[5][2],_abm_,_abl_)}
    function drop_prefix$0(s,pre)
     {var _abj_=or_failure(_ag_),_abk_=try_drop_prefix(s,pre);
      return caml_call2(Function1[5][2],_abk_,_abj_)}
    function split(s,sep)
     {var len=caml_ml_string_length(sep);
      if(caml_call2(_n_,len,0))invalid_argument(_ah_);
      var
       pos$2=caml_ml_string_length(s) - len | 0,
       last_pos$0=caml_ml_string_length(s),
       ret=0,
       last_pos=last_pos$0,
       pos=pos$2;
      for(;;)
       {var
         _abh_=caml_greaterequal(pos,0),
         _abi_=_abh_?caml_call2(_n_,substring(s,pos,len),sep):_abh_;
        if(_abi_)
         {var
           pos$0=pos - len | 0,
           ret$0=
            [0,substring(s,pos + len | 0,(last_pos - pos | 0) - len | 0),ret],
           ret=ret$0,
           last_pos=pos,
           pos=pos$0;
          continue}
        if(caml_lessequal(pos,0))
         {var parts=[0,substring(s,0,last_pos),ret];
          if(parts)
           if(! caml_string_notequal(parts[1],cst$1))if(! parts[2])return 0;
          return parts}
        var pos$1=pos - 1 | 0,pos=pos$1;
        continue}}
    function fold$0(init,s,f)
     {function _abe_(_abg_){return fold(init,_abg_,f)}
      var _abf_=caml_call2(Function1[5][2],s,to_list$0);
      return caml_call2(Function1[5][2],_abf_,_abe_)}
    function filter$1(s,f)
     {function _aba_(_abd_){return filter$0(_abd_,f)}
      var
       _abb_=caml_call2(Function1[5][2],s,to_list$0),
       _abc_=caml_call2(Function1[5][2],_abb_,_aba_);
      return caml_call2(Function1[5][2],_abc_,of_list$0)}
    var empty$0=0;
    function make(opt,_aa$_,stop)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(_aa$_)var sth$0=_aa$_[1],step=sth$0;else var step=1;
      if(caml_lessequal(caml_mul(stop - start | 0,step),0))return 0;
      if(caml_greaterthan(step,0))
       {var
         max=
          (stop - 1 | 0) - caml_mod((stop - 1 | 0) - start | 0,step) | 0;
        if(caml_call2(_n_,caml_mod(max - start | 0,step),0))
         return [0,[0,start,max,step]];
        throw [0,AssertFailure,_ai_]}
      var
       step$0=- step | 0,
       min=(stop + 1 | 0) - caml_mod((stop + 1 | 0) - start | 0,step$0) | 0;
      if(caml_call2(_n_,caml_mod(start - min | 0,step$0),0))
       return [1,[0,min,start,step$0]];
      throw [0,AssertFailure,_aj_]}
    function repr$7(param)
     {if(typeof param === "number")
       return cst$2;
      else
       {if(0 === param[0])
         {var match=param[1],step=match[3],max=match[2],min=match[1];
          return caml_call3(apply(_ak_),min,max,step)}
        var
         match$0=param[1],
         step$0=match$0[3],
         max$0=match$0[2],
         min$0=match$0[1];
        return caml_call3(apply(_al_),max$0,min$0,step$0)}}
    var
     include$5=Equate[1],
     equal$10=include$5[1],
     different$8=include$5[2],
     O$4=include$5[3];
    function to_list$1(param)
     {if(typeof param === "number")
       return 0;
      else
       {if(0 === param[0])
         {var
           match=param[1],
           step=match[3],
           max=match[2],
           min=match[1],
           xs=0,
           x=max;
          for(;;)
           {if(caml_greaterequal(x,min))
             {if(caml_call2(_n_,x,min))return [0,x,xs];
              var x$0=x - step | 0,xs$0=[0,x,xs],xs=xs$0,x=x$0;
              continue}
            throw [0,AssertFailure,_am_]}}
        var
         match$0=param[1],
         step$0=match$0[3],
         max$0=match$0[2],
         min$0=match$0[1],
         xs$1=0,
         x$1=min$0;
        for(;;)
         {if(caml_lessequal(x$1,max$0))
           {if(caml_call2(_n_,x$1,max$0))return [0,x$1,xs$1];
            var x$2=x$1 + step$0 | 0,xs$2=[0,x$1,xs$1],xs$1=xs$2,x$1=x$2;
            continue}
          throw [0,AssertFailure,_an_]}}}
    function to_array$0(r)
     {var _aa__=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aa__,to_array)}
    function fold$1(init,r,f)
     {function _aa7_(_aa9_){return fold(init,_aa9_,f)}
      var _aa8_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aa8_,_aa7_)}
    function fold_i$0(init,r,f)
     {function _aa4_(_aa6_){return fold_i(init,_aa6_,f)}
      var _aa5_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aa5_,_aa4_)}
    function fold_acc$0(acc,init,r,f)
     {function _aa1_(_aa3_){return fold_acc(acc,init,_aa3_,f)}
      var _aa2_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aa2_,_aa1_)}
    function reduce$0(r,f)
     {function _aaY_(_aa0_){return reduce(_aa0_,f)}
      var _aaZ_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aaZ_,_aaY_)}
    function reduce_i$0(r,f)
     {function _aaV_(_aaX_){return reduce_i(_aaX_,f)}
      var _aaW_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aaW_,_aaV_)}
    function reduce_acc$0(acc,r,f)
     {function _aaS_(_aaU_){return reduce_acc(acc,_aaU_,f)}
      var _aaT_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aaT_,_aaS_)}
    function try_reduce$0(r,f)
     {function _aaP_(_aaR_){return try_reduce(_aaR_,f)}
      var _aaQ_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aaQ_,_aaP_)}
    function try_reduce_i$0(r,f)
     {function _aaM_(_aaO_){return try_reduce_i(_aaO_,f)}
      var _aaN_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aaN_,_aaM_)}
    function try_reduce_acc$0(acc,r,f)
     {function _aaJ_(_aaL_){return try_reduce_acc(acc,_aaL_,f)}
      var _aaK_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aaK_,_aaJ_)}
    function iter$1(r,f)
     {function _aaG_(_aaI_){return iter$0(_aaI_,f)}
      var _aaH_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aaH_,_aaG_)}
    function iter_i$0(r,f)
     {function _aaD_(_aaF_){return iter_i(_aaF_,f)}
      var _aaE_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aaE_,_aaD_)}
    function iter_acc$0(acc,r,f)
     {function _aaA_(_aaC_){return iter_acc(acc,_aaC_,f)}
      var _aaB_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aaB_,_aaA_)}
    function count$0(r,f)
     {function _aax_(_aaz_){return count(_aaz_,f)}
      var _aay_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aay_,_aax_)}
    function count_i$0(r,f)
     {function _aau_(_aaw_){return count_i(_aaw_,f)}
      var _aav_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aav_,_aau_)}
    function count_acc$0(acc,r,f)
     {function _aar_(_aat_){return count_acc(acc,_aat_,f)}
      var _aas_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aas_,_aar_)}
    function fold_short$0(init,r,f)
     {function _aao_(_aaq_){return fold_short(init,_aaq_,f)}
      var _aap_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aap_,_aao_)}
    function fold_short_i$0(init,r,f)
     {function _aal_(_aan_){return fold_short_i(init,_aan_,f)}
      var _aam_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aam_,_aal_)}
    function fold_short_acc$0(acc,init,r,f)
     {function _aai_(_aak_){return fold_short_acc(acc,init,_aak_,f)}
      var _aaj_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aaj_,_aai_)}
    function reduce_short$0(r,f)
     {function _aaf_(_aah_){return reduce_short(_aah_,f)}
      var _aag_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aag_,_aaf_)}
    function reduce_short_i$0(r,f)
     {function _aac_(_aae_){return reduce_short_i(_aae_,f)}
      var _aad_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aad_,_aac_)}
    function reduce_short_acc$0(acc,r,f)
     {function _$$_(_aab_){return reduce_short_acc(acc,_aab_,f)}
      var _aaa_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_aaa_,_$$_)}
    function try_reduce_short$0(r,f)
     {function _$8_(_$__){return try_reduce_short(_$__,f)}
      var _$9_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$9_,_$8_)}
    function try_reduce_short_i$0(r,f)
     {function _$5_(_$7_){return try_reduce_short_i(_$7_,f)}
      var _$6_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$6_,_$5_)}
    function try_reduce_short_acc$0(acc,r,f)
     {function _$2_(_$4_){return try_reduce_short_acc(acc,_$4_,f)}
      var _$3_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$3_,_$2_)}
    function iter_short$0(r,f)
     {function _$Z_(_$1_){return iter_short(_$1_,f)}
      var _$0_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$0_,_$Z_)}
    function iter_short_i$0(r,f)
     {function _$W_(_$Y_){return iter_short_i(_$Y_,f)}
      var _$X_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$X_,_$W_)}
    function iter_short_acc$0(acc,r,f)
     {function _$T_(_$V_){return iter_short_acc(acc,_$V_,f)}
      var _$U_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$U_,_$T_)}
    function for_all$0(r,f)
     {function _$Q_(_$S_){return for_all(_$S_,f)}
      var _$R_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$R_,_$Q_)}
    function for_all_i$0(r,f)
     {function _$N_(_$P_){return for_all_i(_$P_,f)}
      var _$O_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$O_,_$N_)}
    function for_all_acc$0(acc,r,f)
     {function _$K_(_$M_){return for_all_acc(acc,_$M_,f)}
      var _$L_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$L_,_$K_)}
    function there_exists$0(r,f)
     {function _$H_(_$J_){return there_exists(_$J_,f)}
      var _$I_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$I_,_$H_)}
    function there_exists_i$0(r,f)
     {function _$E_(_$G_){return there_exists_i(_$G_,f)}
      var _$F_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$F_,_$E_)}
    function there_exists_acc$0(acc,r,f)
     {function _$B_(_$D_){return there_exists_acc(acc,_$D_,f)}
      var _$C_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$C_,_$B_)}
    function find$0(r,f)
     {function _$y_(_$A_){return find(_$A_,f)}
      var _$z_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$z_,_$y_)}
    function find_i$0(r,f)
     {function _$v_(_$x_){return find_i(_$x_,f)}
      var _$w_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$w_,_$v_)}
    function find_acc$0(acc,r,f)
     {function _$s_(_$u_){return find_acc(acc,_$u_,f)}
      var _$t_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$t_,_$s_)}
    function try_find$0(r,f)
     {function _$p_(_$r_){return try_find(_$r_,f)}
      var _$q_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$q_,_$p_)}
    function try_find_i$0(r,f)
     {function _$m_(_$o_){return try_find_i(_$o_,f)}
      var _$n_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$n_,_$m_)}
    function try_find_acc$0(acc,r,f)
     {function _$j_(_$l_){return try_find_acc(acc,_$l_,f)}
      var _$k_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$k_,_$j_)}
    function find_map$0(r,f)
     {function _$g_(_$i_){return find_map(_$i_,f)}
      var _$h_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$h_,_$g_)}
    function find_map_i$0(r,f)
     {function _$d_(_$f_){return find_map_i(_$f_,f)}
      var _$e_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$e_,_$d_)}
    function find_map_acc$0(acc,r,f)
     {function _$a_(_$c_){return find_map_acc(acc,_$c_,f)}
      var _$b_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],_$b_,_$a_)}
    function try_find_map$0(r,f)
     {function __9_(__$_){return try_find_map(__$_,f)}
      var ____=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],____,__9_)}
    function try_find_map_i$0(r,f)
     {function __6_(__8_){return try_find_map_i(__8_,f)}
      var __7_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__7_,__6_)}
    function try_find_map_acc$0(acc,r,f)
     {function __3_(__5_){return try_find_map_acc(acc,__5_,f)}
      var __4_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__4_,__3_)}
    function map$1(r,f)
     {function __0_(__2_){return map$0(__2_,f)}
      var __1_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__1_,__0_)}
    function map_i$0(r,f)
     {function __X_(__Z_){return map_i(__Z_,f)}
      var __Y_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__Y_,__X_)}
    function map_acc$0(acc,r,f)
     {function __U_(__W_){return map_acc(acc,__W_,f)}
      var __V_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__V_,__U_)}
    function filter$2(r,f)
     {function __R_(__T_){return filter$0(__T_,f)}
      var __S_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__S_,__R_)}
    function filter_i$0(r,f)
     {function __O_(__Q_){return filter_i(__Q_,f)}
      var __P_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__P_,__O_)}
    function filter_acc$0(acc,r,f)
     {function __L_(__N_){return filter_acc(acc,__N_,f)}
      var __M_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__M_,__L_)}
    function filter_map$1(r,f)
     {function __I_(__K_){return filter_map$0(__K_,f)}
      var __J_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__J_,__I_)}
    function filter_map_i$0(r,f)
     {function __F_(__H_){return filter_map_i(__H_,f)}
      var __G_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__G_,__F_)}
    function filter_map_acc$0(acc,r,f)
     {function __C_(__E_){return filter_map_acc(acc,__E_,f)}
      var __D_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__D_,__C_)}
    function flat_map$0(r,f)
     {function __z_(__B_){return flat_map(__B_,f)}
      var __A_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__A_,__z_)}
    function flat_map_i$0(r,f)
     {function __w_(__y_){return flat_map_i(__y_,f)}
      var __x_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__x_,__w_)}
    function flat_map_acc$0(acc,r,f)
     {function __t_(__v_){return flat_map_acc(acc,__v_,f)}
      var __u_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__u_,__t_)}
    function scan$0(init,r,f)
     {function __q_(__s_){return scan(init,__s_,f)}
      var __r_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__r_,__q_)}
    function scan_i$0(init,r,f)
     {function __n_(__p_){return scan_i(init,__p_,f)}
      var __o_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__o_,__n_)}
    function scan_acc$0(acc,init,r,f)
     {function __k_(__m_){return scan_acc(acc,init,__m_,f)}
      var __l_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__l_,__k_)}
    function scan_short$0(init,r,f)
     {function __h_(__j_){return scan_short(init,__j_,f)}
      var __i_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__i_,__h_)}
    function scan_short_i$0(init,r,f)
     {function __e_(__g_){return scan_short_i(init,__g_,f)}
      var __f_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__f_,__e_)}
    function scan_short_acc$0(acc,init,r,f)
     {function __b_(__d_){return scan_short_acc(acc,init,__d_,f)}
      var __c_=caml_call2(Function1[5][2],r,to_list$1);
      return caml_call2(Function1[5][2],__c_,__b_)}
    var
     ToList=
      [0,
       map$1,
       map_i$0,
       map_acc$0,
       filter$2,
       filter_i$0,
       filter_acc$0,
       filter_map$1,
       filter_map_i$0,
       filter_map_acc$0,
       flat_map$0,
       flat_map_i$0,
       flat_map_acc$0,
       scan$0,
       scan_i$0,
       scan_acc$0,
       scan_short$0,
       scan_short_i$0,
       scan_short_acc$0];
    function make$0(x,y){return [0,x,y]}
    function get_0(param){var x=param[1];return x}
    function get_1(param){var y=param[2];return y}
    function flip$3(param){var y=param[2],x=param[1];return [0,y,x]}
    function compare$1(param,__a_,compare_a,compare_b)
     {var
       y=__a_[2],
       x=__a_[1],
       y$0=param[2],
       x$0=param[1],
       match=caml_call2(compare_a,x$0,x);
      switch(match)
       {case 0:return 0;
        case 1:return caml_call2(compare_b,y$0,y);
        default:return 2}}
    function equal$11(param,_Z__,equal_a,equal_b)
     {var
       y=_Z__[2],
       x=_Z__[1],
       y$0=param[2],
       x$0=param[1],
       _Z$_=caml_call2(equal_a,x$0,x);
      return _Z$_?caml_call2(equal_b,y$0,y):_Z$_}
    function repr$8(param,repr_a,repr_b)
     {var
       y=param[2],
       x=param[1],
       _Z8_=caml_call1(repr_b,y),
       _Z9_=caml_call1(repr_a,x);
      return caml_call2(apply(_ao_),_Z9_,_Z8_)}
    function make$1(x,y,z){return [0,x,y,z]}
    function get_0$0(param){var x=param[1];return x}
    function get_1$0(param){var y=param[2];return y}
    function get_2(param){var z=param[3];return z}
    function flip$4(param)
     {var z=param[3],y=param[2],x=param[1];return [0,z,y,x]}
    function compare$2(param,_Z7_,compare_a,compare_b,compare_c)
     {var
       z=_Z7_[3],
       y=_Z7_[2],
       x=_Z7_[1],
       z$0=param[3],
       y$0=param[2],
       x$0=param[1],
       match=caml_call2(compare_a,x$0,x);
      switch(match)
       {case 0:return 0;
        case 1:
         var match$0=caml_call2(compare_b,y$0,y);
         switch(match$0)
          {case 0:return 0;
           case 1:return caml_call2(compare_c,z$0,z);
           default:return 2}
        default:return 2}}
    function equal$12(param,_Z3_,equal_a,equal_b,equal_c)
     {var
       z=_Z3_[3],
       y=_Z3_[2],
       x=_Z3_[1],
       z$0=param[3],
       y$0=param[2],
       x$0=param[1],
       _Z4_=caml_call2(equal_a,x$0,x);
      if(_Z4_)
       {var _Z5_=caml_call2(equal_b,y$0,y);
        if(_Z5_)return caml_call2(equal_c,z$0,z);
        var _Z6_=_Z5_}
      else
       var _Z6_=_Z4_;
      return _Z6_}
    function repr$9(param,repr_a,repr_b,repr_c)
     {var
       z=param[3],
       y=param[2],
       x=param[1],
       _Z0_=caml_call1(repr_c,z),
       _Z1_=caml_call1(repr_b,y),
       _Z2_=caml_call1(repr_a,x);
      return caml_call3(apply(_ap_),_Z2_,_Z1_,_Z0_)}
    function make$2(x,y,z,u){return [0,x,y,z,u]}
    function get_0$1(param){var x=param[1];return x}
    function get_1$1(param){var y=param[2];return y}
    function get_2$0(param){var z=param[3];return z}
    function get_3(param){var u=param[4];return u}
    function flip$5(param)
     {var u=param[4],z=param[3],y=param[2],x=param[1];return [0,u,z,y,x]}
    function compare$3(param,_ZZ_,compare_a,compare_b,compare_c,compare_d)
     {var
       u=_ZZ_[4],
       z=_ZZ_[3],
       y=_ZZ_[2],
       x=_ZZ_[1],
       u$0=param[4],
       z$0=param[3],
       y$0=param[2],
       x$0=param[1],
       match=caml_call2(compare_a,x$0,x);
      switch(match)
       {case 0:return 0;
        case 1:
         var match$0=caml_call2(compare_b,y$0,y);
         switch(match$0)
          {case 0:return 0;
           case 1:
            var match$1=caml_call2(compare_c,z$0,z);
            switch(match$1)
             {case 0:return 0;
              case 1:return caml_call2(compare_d,u$0,u);
              default:return 2}
           default:return 2}
        default:return 2}}
    function equal$13(param,_ZU_,equal_a,equal_b,equal_c,equal_d)
     {var
       u=_ZU_[4],
       z=_ZU_[3],
       y=_ZU_[2],
       x=_ZU_[1],
       u$0=param[4],
       z$0=param[3],
       y$0=param[2],
       x$0=param[1],
       _ZV_=caml_call2(equal_a,x$0,x);
      if(_ZV_)
       {var _ZW_=caml_call2(equal_b,y$0,y);
        if(_ZW_)
         {var _ZX_=caml_call2(equal_c,z$0,z);
          if(_ZX_)return caml_call2(equal_d,u$0,u);
          var _ZY_=_ZX_}
        else
         var _ZY_=_ZW_}
      else
       var _ZY_=_ZV_;
      return _ZY_}
    function repr$10(param,repr_a,repr_b,repr_c,repr_d)
     {var
       u=param[4],
       z=param[3],
       y=param[2],
       x=param[1],
       _ZQ_=caml_call1(repr_d,u),
       _ZR_=caml_call1(repr_c,z),
       _ZS_=caml_call1(repr_b,y),
       _ZT_=caml_call1(repr_a,x);
      return caml_call4(apply(_aq_),_ZT_,_ZS_,_ZR_,_ZQ_)}
    function make$3(x,y,z,u,v){return [0,x,y,z,u,v]}
    function get_0$2(param){var x=param[1];return x}
    function get_1$2(param){var y=param[2];return y}
    function get_2$1(param){var z=param[3];return z}
    function get_3$0(param){var u=param[4];return u}
    function get_4(param){var v=param[5];return v}
    function flip$6(param)
     {var v=param[5],u=param[4],z=param[3],y=param[2],x=param[1];
      return [0,v,u,z,y,x]}
    function compare$4
     (param,_ZP_,compare_a,compare_b,compare_c,compare_d,compare_e)
     {var
       v=_ZP_[5],
       u=_ZP_[4],
       z=_ZP_[3],
       y=_ZP_[2],
       x=_ZP_[1],
       v$0=param[5],
       u$0=param[4],
       z$0=param[3],
       y$0=param[2],
       x$0=param[1],
       match=caml_call2(compare_a,x$0,x);
      switch(match)
       {case 0:return 0;
        case 1:
         var match$0=caml_call2(compare_b,y$0,y);
         switch(match$0)
          {case 0:return 0;
           case 1:
            var match$1=caml_call2(compare_c,z$0,z);
            switch(match$1)
             {case 0:return 0;
              case 1:
               var match$2=caml_call2(compare_d,u$0,u);
               switch(match$2)
                {case 0:return 0;
                 case 1:return caml_call2(compare_e,v$0,v);
                 default:return 2}
              default:return 2}
           default:return 2}
        default:return 2}}
    function equal$14(param,_ZJ_,equal_a,equal_b,equal_c,equal_d,equal_e)
     {var
       v=_ZJ_[5],
       u=_ZJ_[4],
       z=_ZJ_[3],
       y=_ZJ_[2],
       x=_ZJ_[1],
       v$0=param[5],
       u$0=param[4],
       z$0=param[3],
       y$0=param[2],
       x$0=param[1],
       _ZK_=caml_call2(equal_a,x$0,x);
      if(_ZK_)
       {var _ZL_=caml_call2(equal_b,y$0,y);
        if(_ZL_)
         {var _ZM_=caml_call2(equal_c,z$0,z);
          if(_ZM_)
           {var _ZN_=caml_call2(equal_d,u$0,u);
            if(_ZN_)return caml_call2(equal_e,v$0,v);
            var _ZO_=_ZN_}
          else
           var _ZO_=_ZM_}
        else
         var _ZO_=_ZL_}
      else
       var _ZO_=_ZK_;
      return _ZO_}
    function repr$11(param,repr_a,repr_b,repr_c,repr_d,repr_e)
     {var
       v=param[5],
       u=param[4],
       z=param[3],
       y=param[2],
       x=param[1],
       _ZE_=caml_call1(repr_e,v),
       _ZF_=caml_call1(repr_d,u),
       _ZG_=caml_call1(repr_c,z),
       _ZH_=caml_call1(repr_b,y),
       _ZI_=caml_call1(repr_a,x);
      return caml_call5(apply(_ar_),_ZI_,_ZH_,_ZG_,_ZF_,_ZE_)}
    function of_int$1(n){return 0 === n?0:[0,n]}
    function exit(param)
     {if(param)var n=param[1],_ZD_=n;else var _ZD_=0;
      return caml_call1(Stdlib[1][87],_ZD_)}
    var
     at_exit=Stdlib[1][88],
     empty$1=Stdlib_stream[21],
     of_list$1=Stdlib_stream[4],
     singleton$0=Stdlib_stream[17];
    function to_list$2(xs)
     {var ys=caml_call1(O$3[1],0);
      function _ZB_(x)
       {var _ZC_=[0,x,caml_call1(O$3[2],ys)];
        return caml_call2(O$3[3],ys,_ZC_)}
      caml_call2(Stdlib_stream[8],_ZB_,xs);
      return reverse(caml_call1(O$3[2],ys))}
    var concat$2=Stdlib_stream[15],prepend$0=Stdlib_stream[16];
    function try_next(xs)
     {function _Zx_(x){caml_call1(Stdlib_stream[12],xs);return x}
      function _Zy_(_ZA_){return func(_ZA_,_Zx_)}
      var _Zz_=caml_call1(Stdlib_stream[11],xs);
      return caml_call2(Function1[5][2],_Zz_,_Zy_)}
    function map_next(xs,f)
     {function _Zt_(x)
       {caml_call1(Stdlib_stream[12],xs);return caml_call1(f,x)}
      function _Zu_(_Zw_){return func(_Zw_,_Zt_)}
      var _Zv_=caml_call1(Stdlib_stream[11],xs);
      return caml_call2(Function1[5][2],_Zv_,_Zu_)}
    function map$2(xs,f)
     {function aux(param){return map_next(xs,f)}
      return caml_call1(Stdlib_stream[3],aux)}
    function map_acc$1(acc,xs,f)
     {var acc$0=caml_call1(O$3[1],acc);
      function aux(param)
       {return map_next
                (xs,
                 function(x)
                  {var
                    match=caml_call2(f,caml_call1(O$3[2],acc$0),x),
                    y=match[2],
                    acc=match[1];
                   caml_call2(O$3[3],acc$0,acc);
                   return y})}
      return caml_call1(Stdlib_stream[3],aux)}
    function map_i$1(xs,f)
     {return map_acc$1
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function filter_next(xs,f)
     {function aux(param)
       {function _Zp_(x)
         {caml_call1(Stdlib_stream[12],xs);
          return caml_call1(f,x)?[0,x]:aux(0)}
        function _Zq_(_Zs_){return filter_map(_Zs_,_Zp_)}
        var _Zr_=caml_call1(Stdlib_stream[11],xs);
        return caml_call2(Function1[5][2],_Zr_,_Zq_)}
      return aux(0)}
    function filter$3(xs,f)
     {function aux(param){return filter_next(xs,f)}
      return caml_call1(Stdlib_stream[3],aux)}
    function filter_acc$1(acc,xs,f)
     {var acc$0=caml_call1(O$3[1],acc);
      function aux(param)
       {return filter_next
                (xs,
                 function(x)
                  {var
                    match=caml_call2(f,caml_call1(O$3[2],acc$0),x),
                    y=match[2],
                    acc=match[1];
                   caml_call2(O$3[3],acc$0,acc);
                   return y})}
      return caml_call1(Stdlib_stream[3],aux)}
    function filter_i$1(xs,f)
     {return filter_acc$1
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function filter_map_next(xs,f)
     {function aux(param)
       {function _Zl_(x)
         {caml_call1(Stdlib_stream[12],xs);
          var y=caml_call1(f,x);
          return y?y:aux(0)}
        function _Zm_(_Zo_){return filter_map(_Zo_,_Zl_)}
        var _Zn_=caml_call1(Stdlib_stream[11],xs);
        return caml_call2(Function1[5][2],_Zn_,_Zm_)}
      return aux(0)}
    function filter_map$2(xs,f)
     {function aux(param){return filter_map_next(xs,f)}
      return caml_call1(Stdlib_stream[3],aux)}
    function filter_map_acc$1(acc,xs,f)
     {var acc$0=caml_call1(O$3[1],acc);
      function aux(param)
       {return filter_map_next
                (xs,
                 function(x)
                  {var
                    match=caml_call2(f,caml_call1(O$3[2],acc$0),x),
                    y=match[2],
                    acc=match[1];
                   caml_call2(O$3[3],acc$0,acc);
                   return y})}
      return caml_call1(Stdlib_stream[3],aux)}
    function filter_map_i$1(xs,f)
     {return filter_map_acc$1
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function flat_map$1(xs,f)
     {var current=caml_call1(O$3[1],0);
      function aux(n)
       {for(;;)
         {if(is_none(caml_call1(O$3[2],current)))
           {var _Zk_=map_next(xs,f);caml_call2(O$3[3],current,_Zk_)}
          var match=caml_call1(O$3[2],current);
          if(match)
           {var ys=match[1],x=caml_call1(Stdlib_stream[11],ys);
            if(x){caml_call1(Stdlib_stream[12],ys);return x}
            caml_call2(O$3[3],current,0);
            continue}
          return 0}}
      return caml_call1(Stdlib_stream[3],aux)}
    function flat_map_acc$1(acc,xs,f)
     {var acc$0=caml_call1(O$3[1],acc),current=caml_call1(O$3[1],0);
      function aux(n)
       {for(;;)
         {if(is_none(caml_call1(O$3[2],current)))
           {var
             _Zj_=
              map_next
               (xs,
                function(x)
                 {var
                   match=caml_call2(f,caml_call1(O$3[2],acc$0),x),
                   y=match[2],
                   acc=match[1];
                  caml_call2(O$3[3],acc$0,acc);
                  return y});
            caml_call2(O$3[3],current,_Zj_)}
          var match=caml_call1(O$3[2],current);
          if(match)
           {var ys=match[1],x=caml_call1(Stdlib_stream[11],ys);
            if(x){caml_call1(Stdlib_stream[12],ys);return x}
            caml_call2(O$3[3],current,0);
            continue}
          return 0}}
      return caml_call1(Stdlib_stream[3],aux)}
    function flat_map_i$1(xs,f)
     {return flat_map_acc$1
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function map$3(xs,f)
     {var ys=0;
      for(;;)
       {var match=try_next(xs);
        if(match){var x=match[1],ys$0=[0,caml_call1(f,x),ys],ys=ys$0;continue}
        return reverse(ys)}}
    function map_acc$2(acc,xs,f)
     {var acc$0=acc,ys=0;
      for(;;)
       {var match=try_next(xs);
        if(match)
         {var
           x=match[1],
           match$0=caml_call2(f,acc$0,x),
           y=match$0[2],
           acc$1=match$0[1],
           ys$0=[0,y,ys],
           acc$0=acc$1,
           ys=ys$0;
          continue}
        return reverse(ys)}}
    function map_i$2(xs,f)
     {return map_acc$2
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function filter$4(xs,f)
     {var ys=0;
      for(;;)
       {var match=try_next(xs);
        if(match)
         {var x=match[1],ys$0=caml_call1(f,x)?[0,x,ys]:ys,ys=ys$0;continue}
        return reverse(ys)}}
    function filter_acc$2(acc,xs,f)
     {var acc$0=acc,ys=0;
      for(;;)
       {var match=try_next(xs);
        if(match)
         {var
           x=match[1],
           match$0=caml_call2(f,acc$0,x),
           b=match$0[2],
           acc$1=match$0[1],
           ys$0=b?[0,x,ys]:ys,
           acc$0=acc$1,
           ys=ys$0;
          continue}
        return reverse(ys)}}
    function filter_i$2(xs,f)
     {return filter_acc$2
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function filter_map$3(xs,f)
     {var ys=0;
      for(;;)
       {var match=try_next(xs);
        if(match)
         {var x=match[1],match$0=caml_call1(f,x);
          if(match$0)var y=match$0[1],ys$0=[0,y,ys];else var ys$0=ys;
          var ys=ys$0;
          continue}
        return reverse(ys)}}
    function filter_map_acc$2(acc,xs,f)
     {var acc$0=acc,ys=0;
      for(;;)
       {var match=try_next(xs);
        if(match)
         {var
           x=match[1],
           match$0=caml_call2(f,acc$0,x),
           y=match$0[2],
           acc$1=match$0[1];
          if(y)var y$0=y[1],ys$0=[0,y$0,ys];else var ys$0=ys;
          var acc$0=acc$1,ys=ys$0;
          continue}
        return reverse(ys)}}
    function filter_map_i$2(xs,f)
     {return filter_map_acc$2
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function flat_map$2(xs,f)
     {var ys=0;
      for(;;)
       {var match=try_next(xs);
        if(match)
         {var x=match[1],ys$0=rev_concat(caml_call1(f,x),ys),ys=ys$0;continue}
        return reverse(ys)}}
    function flat_map_acc$2(acc,xs,f)
     {var acc$0=acc,ys=0;
      for(;;)
       {var match=try_next(xs);
        if(match)
         {var
           x=match[1],
           match$0=caml_call2(f,acc$0,x),
           y=match$0[2],
           acc$1=match$0[1],
           ys$0=rev_concat(y,ys),
           acc$0=acc$1,
           ys=ys$0;
          continue}
        return reverse(ys)}}
    function flat_map_i$2(xs,f)
     {return flat_map_acc$2
              (0,xs,function(i,x){return [0,i + 1 | 0,caml_call2(f,i,x)]})}
    function ignore(_Zi_){return 0}
    var
     _as_=Function1[5],
     _at_=_as_[1],
     _au_=_as_[2],
     _av_=_as_[3],
     _aw_=O$2[1],
     ref$0=O$3[1],
     _ax_=O$3[2],
     _ay_=O$3[3],
     _az_=Equate[1][3],
     _aA_=_az_[1],
     _aB_=_az_[2],
     identity$0=Function1[1],
     _aC_=Reset[1],
     raise$0=_aC_[1],
     raise_notrace=_aC_[2],
     invalid_arg=_aC_[3],
     failwith=_aC_[4],
     compare$5=_aC_[11],
     min$0=_aC_[12],
     max$0=_aC_[13],
     or$0=_aC_[20],
     succ$0=_aC_[25],
     pred$0=_aC_[26],
     abs$1=_aC_[32],
     max_int=_aC_[33],
     min_int=_aC_[34],
     land=_aC_[35],
     lor=_aC_[36],
     lxor=_aC_[37],
     lnot=_aC_[38],
     lsl=_aC_[39],
     lsr=_aC_[40],
     asr=_aC_[41],
     sqrt$0=_aC_[49],
     exp$0=_aC_[50],
     log$0=_aC_[51],
     log10$0=_aC_[52],
     expm1$0=_aC_[53],
     log1p$0=_aC_[54],
     cos$0=_aC_[55],
     sin$0=_aC_[56],
     tan$0=_aC_[57],
     acos$0=_aC_[58],
     asin$0=_aC_[59],
     atan$0=_aC_[60],
     atan2$0=_aC_[61],
     hypot$0=_aC_[62],
     cosh$0=_aC_[63],
     sinh$0=_aC_[64],
     tanh$0=_aC_[65],
     ceil$0=_aC_[66],
     floor$0=_aC_[67],
     abs_float=_aC_[68],
     copysign=_aC_[69],
     mod_float=_aC_[70],
     frexp=_aC_[71],
     ldexp=_aC_[72],
     modf=_aC_[73],
     float$0=_aC_[74],
     float_of_int=_aC_[75],
     truncate=_aC_[76],
     int_of_float=_aC_[77],
     infinity$0=_aC_[78],
     neg_infinity=_aC_[79],
     nan=_aC_[80],
     max_float=_aC_[81],
     min_float=_aC_[82],
     epsilon_float=_aC_[83],
     classify_float=_aC_[84],
     int_of_char=_aC_[86],
     char_of_int=_aC_[87],
     string_of_bool=_aC_[89],
     bool_of_string=_aC_[90],
     bool_of_string_opt=_aC_[91],
     string_of_int=_aC_[92],
     int_of_string=_aC_[93],
     int_of_string_opt=_aC_[94],
     string_of_float=_aC_[95],
     float_of_string=_aC_[96],
     float_of_string_opt=_aC_[97],
     fst=_aC_[98],
     snd=_aC_[99],
     stdin=_aC_[101],
     stdout=_aC_[102],
     stderr=_aC_[103],
     print_char=_aC_[104],
     print_string=_aC_[105],
     print_bytes=_aC_[106],
     print_int=_aC_[107],
     print_float=_aC_[108],
     print_endline=_aC_[109],
     print_newline=_aC_[110],
     prerr_char=_aC_[111],
     prerr_string=_aC_[112],
     prerr_bytes=_aC_[113],
     prerr_int=_aC_[114],
     prerr_float=_aC_[115],
     prerr_endline=_aC_[116],
     prerr_newline=_aC_[117],
     read_line=_aC_[118],
     read_int=_aC_[119],
     read_int_opt=_aC_[120],
     read_float=_aC_[121],
     read_float_opt=_aC_[122],
     open_out=_aC_[123],
     open_out_bin=_aC_[124],
     open_out_gen=_aC_[125],
     flush=_aC_[126],
     flush_all=_aC_[127],
     output_char=_aC_[128],
     output_string=_aC_[129],
     output_bytes=_aC_[130],
     output=_aC_[131],
     output_substring=_aC_[132],
     output_byte=_aC_[133],
     output_binary_int=_aC_[134],
     output_value=_aC_[135],
     seek_out=_aC_[136],
     pos_out=_aC_[137],
     out_channel_length=_aC_[138],
     close_out=_aC_[139],
     close_out_noerr=_aC_[140],
     set_binary_mode_out=_aC_[141],
     open_in=_aC_[142],
     open_in_bin=_aC_[143],
     open_in_gen=_aC_[144],
     input_char=_aC_[145],
     input_line=_aC_[146],
     input=_aC_[147],
     really_input=_aC_[148],
     really_input_string=_aC_[149],
     input_byte=_aC_[150],
     input_binary_int=_aC_[151],
     input_value=_aC_[152],
     seek_in=_aC_[153],
     pos_in=_aC_[154],
     in_channel_length=_aC_[155],
     close_in=_aC_[156],
     close_in_noerr=_aC_[157],
     set_binary_mode_in=_aC_[158],
     LargeFile$0=_aC_[159],
     incr=_aC_[163],
     decr=_aC_[164],
     string_of_format=_aC_[165],
     format_of_string=_aC_[166],
     exit$0=_aC_[168],
     at_exit$0=_aC_[169],
     valid_float_lexem=_aC_[170],
     unsafe_really_input=_aC_[171],
     do_at_exit=_aC_[172],
     _aH_=Reset[2],
     OCamlStandard$0=_aH_[1],
     Pervasives$0=_aH_[2],
     Arg$0=_aH_[3],
     Array$0=_aH_[4],
     ArrayLabels$0=_aH_[5],
     Bigarray$0=_aH_[6],
     Buffer$0=_aH_[7],
     Bytes$0=_aH_[8],
     BytesLabels$0=_aH_[9],
     Callback$0=_aH_[10],
     Char$0=_aH_[11],
     Complex$0=_aH_[12],
     Digest$0=_aH_[13],
     Ephemeron$0=_aH_[14],
     Filename$0=_aH_[15],
     Float$0=_aH_[16],
     Format$0=_aH_[17],
     Gc$0=_aH_[18],
     Genlex$0=_aH_[19],
     Hashtbl$0=_aH_[20],
     Int32$0=_aH_[21],
     Int64$0=_aH_[22],
     Lazy$0=_aH_[23],
     Lexing$0=_aH_[24],
     List$0=_aH_[25],
     ListLabels$0=_aH_[26],
     Map$0=_aH_[27],
     Marshal$0=_aH_[28],
     MoreLabels$0=_aH_[29],
     Nativeint$0=_aH_[30],
     Oo$0=_aH_[31],
     Parsing$0=_aH_[32],
     Printexc$0=_aH_[33],
     Printf$0=_aH_[34],
     Queue$0=_aH_[35],
     Random$0=_aH_[36],
     Scanf$0=_aH_[37],
     Seq$0=_aH_[38],
     Set$0=_aH_[39],
     Sort$0=_aH_[40],
     Spacetime$0=_aH_[41],
     Stack$0=_aH_[42],
     StdLabels$0=_aH_[43],
     Stream$0=_aH_[44],
     String$0=_aH_[45],
     StringLabels$0=_aH_[46],
     Sys$0=_aH_[47],
     Uchar$0=_aH_[48],
     Weak$0=_aH_[49],
     Num$0=_aH_[50],
     Big_int$0=_aH_[51],
     Arith_status$0=_aH_[52],
     _aD_=_aC_[14],
     _aE_=_aC_[15],
     _aF_=_aC_[19],
     _aG_=_aC_[167];
    function to_string$6(param)
     {if(typeof param === "number")
       return cst_OK;
      else
       {if(0 === param[0])
         {var _YZ_=param[1];
          switch(_YZ_[0])
           {case 0:
             var match=_YZ_[1],actual=match[2],expected=match[1];
             return caml_call2(apply(_aQ_),expected,actual);
            case 1:
             var expected$0=_YZ_[1],_Y0_=caml_call1(to_string$0,expected$0);
             return caml_call1(apply(_aR_),_Y0_);
            case 2:
             var expected$1=_YZ_[1];return caml_call1(apply(_aS_),expected$1);
            case 3:
             var _Y1_=_YZ_[3],_Y2_=_YZ_[2],_Y3_=_YZ_[1];
             if(_Y1_)
              {var
                bt=_Y1_[1],
                _Y4_=caml_call1(to_string$3,bt),
                _Y5_=caml_call1(to_string$0,_Y2_),
                _Y6_=caml_call1(to_string$0,_Y3_);
               return caml_call3(apply(_aT_),_Y6_,_Y5_,_Y4_)}
             var
              _Y7_=caml_call1(to_string$0,_Y2_),
              _Y8_=caml_call1(to_string$0,_Y3_);
             return caml_call2(apply(_aU_),_Y8_,_Y7_);
            case 4:
             var _Y9_=_YZ_[3],_Y__=_YZ_[2],_Y$_=_YZ_[1];
             if(_Y9_)
              {var
                bt$0=_Y9_[1],
                _Za_=caml_call1(to_string$3,bt$0),
                _Zb_=caml_call1(to_string$0,_Y__);
               return caml_call3(apply(_aV_),_Y$_,_Zb_,_Za_)}
             var _Zc_=caml_call1(to_string$0,_Y__);
             return caml_call2(apply(_aW_),_Y$_,_Zc_);
            default:var message=_YZ_[1];return caml_call1(apply(_aX_),message)}}
        var _Zd_=param[2],_Ze_=param[1];
        if(_Zd_)
         {var
           bt$1=_Zd_[1],
           _Zf_=caml_call1(to_string$3,bt$1),
           _Zg_=caml_call1(to_string$0,_Ze_);
          return caml_call2(apply(_aY_),_Zg_,_Zf_)}
        var _Zh_=caml_call1(to_string$0,_Ze_);
        return caml_call1(apply(_aZ_),_Zh_)}}
    function repr$12(param)
     {if(0 === param[0])
       {var match$0=param[1],status=match$0[2],label=match$0[1];
        if(typeof status === "number")
         var _YX_=cst_Success;
        else
         if(0 === status[0])
          {var reason=status[1];
           switch(reason[0])
            {case 0:
              var
               match=reason[1],
               y=match[2],
               x=match[1],
               _YT_=caml_call2(apply(_aI_),x,y);
              break;
             case 1:
              var
               exc=reason[1],
               _YN_=caml_call1(to_string$0,exc),
               _YT_=caml_call1(apply(_aJ_),_YN_);
              break;
             case 2:
              var exc$0=reason[1],_YT_=caml_call1(apply(_aK_),exc$0);break;
             case 3:
              var
               bt=reason[3],
               exc$1=reason[2],
               expected=reason[1],
               _YO_=repr$1(bt,to_string$3),
               _YP_=caml_call1(to_string$0,exc$1),
               _YQ_=caml_call1(to_string$0,expected),
               _YT_=caml_call3(apply(_aL_),_YQ_,_YP_,_YO_);
              break;
             case 4:
              var
               bt$0=reason[3],
               exc$2=reason[2],
               expected$0=reason[1],
               _YR_=repr$1(bt$0,to_string$3),
               _YS_=caml_call1(to_string$0,exc$2),
               _YT_=caml_call3(apply(_aM_),expected$0,_YS_,_YR_);
              break;
             default:var x$0=reason[1],_YT_=caml_call1(apply(_aN_),x$0)}
           var _YX_=caml_call1(apply(_aO_),_YT_)}
         else
          var
           bt$1=status[2],
           exc$3=status[1],
           _YU_=repr$1(bt$1,to_string$3),
           _YV_=caml_call1(to_string$0,exc$3),
           _YX_=caml_call2(apply(_aP_),_YV_,_YU_);
        return caml_call2(apply(_a4_),label,_YX_)}
      var
       match$1=param[1],
       counts=match$1[3],
       children=match$1[2],
       name=match$1[1],
       errors=counts[3],
       failures=counts[2],
       successes=counts[1],
       _YW_=caml_call3(apply(_a3_),successes,failures,errors),
       _YY_=repr$2(children,repr$12);
      return caml_call3(apply(_a5_),name,_YY_,_YW_)}
    function equal$15(x,y){return caml_call2(Equate[1][1],x,y)}
    function to_indented_strings(verbose)
     {function aux(indent,param)
       {if(0 === param[0])
         {var match=param[1],status=match[2],label=match[1];
          if(! verbose)if(! caml_call2(_aB_,status,0))return 0;
          var _YH_=to_string$6(status);
          return [0,caml_call3(apply(_a6_),indent,label,_YH_),0]}
        var
         _YI_=param[1],
         match$0=_YI_[3],
         errors=match$0[3],
         failures=match$0[2],
         successes=match$0[1],
         children=_YI_[2],
         name=_YI_[1],
         _YJ_=caml_call2(_ad_,indent,cst$3);
        function _YK_(_YM_){return aux(_YJ_,_YM_)}
        var
         children$0=
          caml_call2(_au_,children,function(_YL_){return flat_map(_YL_,_YK_)}),
         line=
          caml_call2(_e_,failures + errors | 0,0)
           ?caml_call3(apply(_a7_),indent,name,successes)
           :caml_call5(apply(_a8_),indent,name,successes,failures,errors);
        if(! verbose)
         if(! caml_call2(_f_,failures + errors | 0,0))return [0,line,0];
        return [0,line,children$0]}
      return function(result)
       {return caml_call2(_au_,result,function(_YG_){return aux(cst$4,_YG_)})}}
    var TestFailure=[248,cst_General_Testing_TestFailure,caml_fresh_oo_id(0)];
    function run(opt,test)
     {if(opt)var sth=opt[1],record_backtrace=sth;else var record_backtrace=1;
      caml_call1(record_backtraces,record_backtrace);
      function aux(param)
       {if(0 === param[0])
         {var match=param[1],check=match[2],label=match[1];
          try
           {value(check);var _YC_=[0,[0,label,0]];return _YC_}
          catch(exc)
           {exc = caml_wrap_exception(exc);
            if(exc[1] === TestFailure)
             {var reason=exc[2];return [0,[0,label,[0,reason]]]}
            return [0,[0,label,[1,exc,most_recent_backtrace(0)]]]}}
        var
         match$0=param[1],
         tests=match$0[2],
         name=match$0[1],
         children=map$0(tests,aux);
        function _YD_(counts,result)
         {if(0 === result[0])
           var
            match=result[1],
            status=match[2],
            _YF_=typeof status === "number"?_a0_:0 === status[0]?_a1_:_a2_,
            counts$0=_YF_;
          else
           var match$0=result[1],counts$1=match$0[3],counts$0=counts$1;
          var
           errors=counts$0[3],
           failures=counts$0[2],
           successes=counts$0[1],
           errors$0=counts[3],
           failures$0=counts[2],
           successes$0=counts[1];
          return [0,
                  successes$0 + successes | 0,
                  failures$0 + failures | 0,
                  errors$0 + errors | 0]}
        var
         counts=
          caml_call2
           (_au_,children,function(_YE_){return fold(zero$1,_YE_,_YD_)});
        return [1,[0,name,children,counts]]}
      return aux(test)}
    var Test=[0,run];
    function command_line_main(argv,test)
     {if(argv)
       {var _Yx_=argv[2];
        if(_Yx_)
         if(caml_string_notequal(_Yx_[1],cst_verbose))
          var switch$0=0;
         else
          if(_Yx_[2])var switch$0=0;else var verbose=1,switch$0=1;
        else
         var switch$0=0}
      else
       var switch$0=0;
      if(! switch$0)var verbose=0;
      var
       result=caml_call2(Test[1],0,test),
       _Yy_=caml_call1(Stdlib_printf[2],_a9_);
      function _Yz_(_YB_){return iter$0(_YB_,_Yy_)}
      caml_call2
       (_au_,caml_call2(_au_,result,to_indented_strings(verbose)),_Yz_);
      if(0 === result[0])
       var switch$1=typeof result[1][2] === "number"?1:0;
      else
       var _YA_=result[1][3],switch$1=0 === _YA_[2]?0 === _YA_[3]?1:0:0;
      return switch$1?0:_a__}
    function _a$_(name,tests){return [1,[0,name,tests]]}
    function _ba_(label,check){return [0,[0,label,check]]}
    function _bb_(format){return with_result(format,_a$_)}
    function _bc_(format){return with_result(format,_ba_)}
    var
     javascript=
      has_suffix(caml_call2(Reset[2][4][1],Stdlib_sys[1],0),cst_js);
    function fail(format)
     {return with_result
              (format,
               function(message){return raise([0,TestFailure,[5,message]])})}
    var
     NoExceptionRaised=
      [248,cst_General_Testing_NoExceptionRaised,caml_fresh_oo_id(0)];
    function expect_exception(expected,x)
     {try
       {value(x);var _Yw_=raise(NoExceptionRaised);return _Yw_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        return exc === NoExceptionRaised
                ?raise([0,TestFailure,[1,expected]])
                :caml_call2(equal$1,exc,expected)
                  ?0
                  :raise
                    ([0,TestFailure,[3,expected,exc,most_recent_backtrace(0)]])}}
    function expect_exception_named(expected,x)
     {try
       {value(x);var _Yv_=raise(NoExceptionRaised);return _Yv_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        return exc === NoExceptionRaised
                ?raise([0,TestFailure,[2,expected]])
                :caml_call2(equal$9,caml_call1(name,exc),expected)
                  ?0
                  :raise
                    ([0,TestFailure,[4,expected,exc,most_recent_backtrace(0)]])}}
    function check(repr,equal,expected,actual)
     {var _Yt_=1 - caml_call2(equal,expected,actual);
      if(_Yt_)
       {var _Yu_=caml_call1(repr,actual);
        return raise([0,TestFailure,[0,[0,caml_call1(repr,expected),_Yu_]]])}
      return _Yt_}
    function check_poly(repr,expected,actual)
     {return check(repr,Equate[1][1],expected,actual)}
    function check_bool(expected,actual)
     {return check(repr$0,equal$3,expected,actual)}
    function check_true(actual){return check_bool(1,actual)}
    function check_false(actual){return check_bool(0,actual)}
    function check_string(expected,actual)
     {return check(repr$6,equal$9,expected,actual)}
    function check_int(expected,actual)
     {return check(repr,equal$2,expected,actual)}
    function check_42(actual){return check(repr,equal$2,42,actual)}
    function check_float(precision,expected,actual)
     {return check
              (repr$4,
               function(_Yr_,_Ys_){return approx_equal(precision,_Yr_,_Ys_)},
               expected,
               actual)}
    function check_float_in(low,high,actual)
     {var
       _Yp_=caml_lessthan(actual,low),
       _Yq_=_Yp_ || caml_greaterthan(actual,high);
      return _Yq_?raise([0,TestFailure,_bd_]):_Yq_}
    function check_float_exact(expected,actual)
     {return check(repr$4,equal$7,expected,actual)}
    function check_option(repr,equal,expected,actual)
     {function _Yl_(_Yn_)
       {return function(_Yo_){return equal$4(_Yn_,_Yo_,equal)}}
      return check
              (function(_Ym_){return repr$1(_Ym_,repr)},_Yl_,expected,actual)}
    function check_some(repr,equal,expected,actual)
     {return check_option(repr,equal,[0,expected],actual)}
    function check_none(repr,equal,actual)
     {return check_option(repr,equal,0,actual)}
    function check_option_poly(repr,expected,actual)
     {return check_option(repr,Equate[1][1],expected,actual)}
    function check_some_poly(repr,expected,actual)
     {return check_option_poly(repr,[0,expected],actual)}
    function check_none_poly(repr,actual)
     {return check_option_poly(repr,0,actual)}
    function check_int_option(expected,actual)
     {return check_option(repr,equal$2,expected,actual)}
    function check_some_int(expected,actual)
     {return check_int_option([0,expected],actual)}
    function check_some_42(actual){return check_some_int(42,actual)}
    function check_none_int(actual){return check_int_option(0,actual)}
    function check_string_option(expected,actual)
     {return check_option(repr$6,equal$9,expected,actual)}
    function check_some_string(expected,actual)
     {return check_string_option([0,expected],actual)}
    function check_none_string(actual){return check_string_option(0,actual)}
    function check_list(repr,equal,expected,actual)
     {function _Yh_(_Yj_)
       {return function(_Yk_){return equal$5(_Yj_,_Yk_,equal)}}
      return check
              (function(_Yi_){return repr$2(_Yi_,repr)},_Yh_,expected,actual)}
    function check_list_poly(repr,expected,actual)
     {return check_list(repr,Equate[1][1],expected,actual)}
    function check_string_list(expected,actual)
     {return check_list(repr$6,equal$9,expected,actual)}
    function check_int_list(expected,actual)
     {return check_list(repr,equal$2,expected,actual)}
    function check_int_tuple2(expected,actual)
     {function _Yd_(_Yf_)
       {return function(_Yg_){return equal$11(_Yf_,_Yg_,equal$2,equal$2)}}
      return check
              (function(_Ye_){return repr$8(_Ye_,repr,repr)},
               _Yd_,
               expected,
               actual)}
    function check_int_tuple3(expected,actual)
     {function _X$_(_Yb_)
       {return function(_Yc_)
         {return equal$12(_Yb_,_Yc_,equal$2,equal$2,equal$2)}}
      return check
              (function(_Ya_){return repr$9(_Ya_,repr,repr,repr)},
               _X$_,
               expected,
               actual)}
    function check_int_tuple4(expected,actual)
     {function _X7_(_X9_)
       {return function(_X__)
         {return equal$13(_X9_,_X__,equal$2,equal$2,equal$2,equal$2)}}
      return check
              (function(_X8_){return repr$10(_X8_,repr,repr,repr,repr)},
               _X7_,
               expected,
               actual)}
    function check_int_tuple5(expected,actual)
     {function _X3_(_X5_)
       {return function(_X6_)
         {return equal$14(_X5_,_X6_,equal$2,equal$2,equal$2,equal$2,equal$2)}}
      return check
              (function(_X4_){return repr$11(_X4_,repr,repr,repr,repr,repr)},
               _X3_,
               expected,
               actual)}
    function Specialize1(M,A)
     {function repr(x){return caml_call2(M[1],x,A[1])}return [0,repr]}
    function Specialize2(M,A,B)
     {function repr(x){return caml_call3(M[1],x,A[1],B[1])}return [0,repr]}
    function Specialize3(M,A,B,C)
     {function repr(x){return caml_call4(M[1],x,A[1],B[1],C[1])}
      return [0,repr]}
    function Specialize4(M,A,B,C,D)
     {function repr(x){return caml_call5(M[1],x,A[1],B[1],C[1],D[1])}
      return [0,repr]}
    function Specialize5(M,A,B,C,D,E)
     {function repr(x){return caml_call6(M[1],x,A[1],B[1],C[1],D[1],E[1])}
      return [0,repr]}
    function Make0(M,E)
     {function _XY_(param)
       {var
         expected=param[2],
         v=param[1],
         _X1_=
          [246,
           function(_X2_){return check_string(expected,caml_call1(M[1],v))}];
        return caml_call2(_bc_(_be_),expected,_X1_)}
      function _XZ_(_X0_){return map$0(_X0_,_XY_)}
      var test=_a$_(cst_Representable,caml_call2(_au_,E[1],_XZ_));
      return [0,test]}
    function Make1(_XW_,_XV_)
     {var _XX_=[0,_XV_[2]];return Make0(Specialize1(_XW_,_XV_[1]),_XX_)}
    function Specialize1$0(M,A)
     {function equal(x,y){return caml_call3(M[1],x,y,A[1])}return [0,equal]}
    function Specialize2$0(M,A,B)
     {function equal(x,y){return caml_call4(M[1],x,y,A[1],B[1])}
      return [0,equal]}
    function Specialize3$0(M,A,B,C)
     {function equal(x,y){return caml_call5(M[1],x,y,A[1],B[1],C[1])}
      return [0,equal]}
    function Specialize4$0(M,A,B,C,D)
     {function equal(x,y){return caml_call6(M[1],x,y,A[1],B[1],C[1],D[1])}
      return [0,equal]}
    function Specialize5$0(M,A,B,C,D,E)
     {function equal(x,y)
       {return caml_call7(M[1],x,y,A[1],B[1],C[1],D[1],E[1])}
      return [0,equal]}
    function Make0$0(M)
     {function _XU_(x,y){return caml_call2(M[1],x,y)}
      return [0,_XU_,function(x,y){return caml_call2(M[2],x,y)}]}
    function Make0$1(M)
     {function different(x,y){return 1 - caml_call2(M[1],x,y)}
      return [0,different]}
    function Make1$0(M)
     {function different(x,y,equal_a){return 1 - caml_call3(M[1],x,y,equal_a)}
      return [0,different]}
    function Make0$2(M,E)
     {function _W0_(param)
       {var
         y=param[2],
         x=param[1],
         rx=caml_call1(M[4],x),
         ry=caml_call1(M[4],y),
         _Xw_=0,
         _Xx_=[246,function(_XT_){return check_true(caml_call2(M[3][2],y,x))}],
         _Xy_=[0,caml_call3(_bc_(_bf_),ry,rx,_Xx_),_Xw_],
         _Xz_=
          [246,function(_XS_){return check_false(caml_call2(M[3][1],y,x))}],
         _XA_=[0,caml_call3(_bc_(_bg_),ry,rx,_Xz_),_Xy_],
         _XB_=[246,function(_XR_){return check_true(caml_call2(M[2],y,x))}],
         _XC_=[0,caml_call3(_bc_(_bh_),ry,rx,_XB_),_XA_],
         _XD_=[246,function(_XQ_){return check_false(caml_call2(M[1],y,x))}],
         _XE_=[0,caml_call3(_bc_(_bi_),ry,rx,_XD_),_XC_],
         _XF_=[246,function(_XP_){return check_true(caml_call2(M[3][2],x,y))}],
         _XG_=[0,caml_call3(_bc_(_bj_),rx,ry,_XF_),_XE_],
         _XH_=
          [246,function(_XO_){return check_false(caml_call2(M[3][1],x,y))}],
         _XI_=[0,caml_call3(_bc_(_bk_),rx,ry,_XH_),_XG_],
         _XJ_=[246,function(_XN_){return check_true(caml_call2(M[2],x,y))}],
         _XK_=[0,caml_call3(_bc_(_bl_),rx,ry,_XJ_),_XI_],
         _XL_=[246,function(_XM_){return check_false(caml_call2(M[1],x,y))}];
        return [0,caml_call3(_bc_(_bm_),rx,ry,_XL_),_XK_]}
      function _W1_(_Xv_){return flat_map(_Xv_,_W0_)}
      var _W2_=caml_call2(_au_,E[2],_W1_);
      function _W3_(xs)
       {function _W6_(param)
         {var
           y=param[2],
           x=param[1],
           rx=caml_call1(M[4],x),
           ry=caml_call1(M[4],y),
           _W9_=0,
           _W__=
            [246,function(_Xu_){return check_false(caml_call2(M[3][2],y,x))}],
           _W$_=[0,caml_call3(_bc_(_bn_),ry,rx,_W__),_W9_],
           _Xa_=
            [246,function(_Xt_){return check_true(caml_call2(M[3][1],y,x))}],
           _Xb_=[0,caml_call3(_bc_(_bo_),ry,rx,_Xa_),_W$_],
           _Xc_=[246,function(_Xs_){return check_false(caml_call2(M[2],y,x))}],
           _Xd_=[0,caml_call3(_bc_(_bp_),ry,rx,_Xc_),_Xb_],
           _Xe_=[246,function(_Xr_){return check_true(caml_call2(M[1],y,x))}],
           _Xf_=[0,caml_call3(_bc_(_bq_),ry,rx,_Xe_),_Xd_],
           _Xg_=
            [246,function(_Xq_){return check_false(caml_call2(M[3][2],x,y))}],
           _Xh_=[0,caml_call3(_bc_(_br_),rx,ry,_Xg_),_Xf_],
           _Xi_=
            [246,function(_Xp_){return check_true(caml_call2(M[3][1],x,y))}],
           _Xj_=[0,caml_call3(_bc_(_bs_),rx,ry,_Xi_),_Xh_],
           _Xk_=[246,function(_Xo_){return check_false(caml_call2(M[2],x,y))}],
           _Xl_=[0,caml_call3(_bc_(_bt_),rx,ry,_Xk_),_Xj_],
           _Xm_=[246,function(_Xn_){return check_true(caml_call2(M[1],x,y))}];
          return [0,caml_call3(_bc_(_bu_),rx,ry,_Xm_),_Xl_]}
        function _W7_(_W8_){return flat_map(_W8_,_W6_)}
        return caml_call2(_au_,cartesian_product(xs,xs),_W7_)}
      function _W4_(_W5_){return flat_map(_W5_,_W3_)}
      var
       test=
        _a$_(cst_Equatable,caml_call2(_aw_,caml_call2(_au_,E[1],_W4_),_W2_));
      return [0,test]}
    function Make1$1(M,E)
     {var
       A=[0,E[1][1]],
       _WY_=[0,E[2],E[3]],
       _WZ_=M[2],
       include$0=Specialize1$0([0,M[1]],A),
       equal=include$0[1];
      function different(x,y){return caml_call3(_WZ_,x,y,A[1])}
      var
       Self=[0,equal,different],
       O=Make0$0(Self),
       equal$0=Self[1],
       different$0=Self[2],
       include=Specialize1([0,M[3]],[0,E[1][2]]),
       repr=include[1];
      return Make0$2([0,equal$0,different$0,O,repr],_WY_)}
    function Make0$3(M)
     {function _WV_(x,y){return caml_call2(M[1],x,y)}
      function _WW_(x,y){return caml_call2(M[2],x,y)}
      function _WX_(x,y){return caml_call2(M[3],x,y)}
      return [0,_WV_,_WW_,_WX_,function(x,y){return caml_call2(M[4],x,y)}]}
    function Make0$4(M)
     {function between(x,low,high)
       {var _WU_=caml_call2(M[1],low,x);
        return _WU_?caml_call2(M[3],high,x):_WU_}
      function between_or_equal(x,low,high)
       {var _WT_=caml_call2(M[2],low,x);
        return _WT_?caml_call2(M[4],high,x):_WT_}
      return [0,between,between_or_equal]}
    function Make0$5(M)
     {function min(x,y){var match=caml_call2(M[1],x,y);return 0 === match?x:y}
      function max(x,y){var match=caml_call2(M[1],x,y);return 2 <= match?x:y}
      function min_max(x,y)
       {var match=caml_call2(M[1],x,y);return 0 === match?[0,x,y]:[0,y,x]}
      return [0,min,max,min_max]}
    function Make0$6(M,E)
     {var _TW_=M[13],_TX_=M[13];
      function _TY_(_WR_)
       {return function(_WS_){return equal$11(_WR_,_WS_,_TW_,_TX_)}}
      var _TZ_=M[12],_T0_=M[12];
      function _T1_(_WQ_){return repr$8(_WQ_,_TZ_,_T0_)}
      function check_pair(_WO_,_WP_){return check(_T1_,_TY_,_WO_,_WP_)}
      var _T2_=M[13],_T3_=M[12];
      function check$0(_WM_,_WN_){return check(_T3_,_T2_,_WM_,_WN_)}
      function _T4_(xs)
       {function _Vd_(param)
         {var
           y=param[2],
           x=param[1],
           rx=caml_call1(M[12],x),
           ry=caml_call1(M[12],y),
           _Vg_=0,
           _Vh_=
            [246,
             function(_WL_){return check_pair([0,y,y],caml_call2(M[10],y,x))}],
           _Vi_=[0,caml_call3(_bc_(_bz_),ry,rx,_Vh_),_Vg_],
           _Vj_=
            [246,
             function(_WK_){return check_pair([0,x,x],caml_call2(M[10],y,x))}],
           _Vk_=[0,caml_call3(_bc_(_bA_),ry,rx,_Vj_),_Vi_],
           _Vl_=
            [246,
             function(_WJ_){return check_pair([0,y,x],caml_call2(M[10],y,x))}],
           _Vm_=[0,caml_call3(_bc_(_bB_),ry,rx,_Vl_),_Vk_],
           _Vn_=
            [246,
             function(_WI_){return check_pair([0,x,y],caml_call2(M[10],y,x))}],
           _Vo_=[0,caml_call3(_bc_(_bC_),ry,rx,_Vn_),_Vm_],
           _Vp_=[246,function(_WH_){return check$0(y,caml_call2(M[9],y,x))}],
           _Vq_=[0,caml_call3(_bc_(_bD_),ry,rx,_Vp_),_Vo_],
           _Vr_=[246,function(_WG_){return check$0(x,caml_call2(M[9],y,x))}],
           _Vs_=[0,caml_call3(_bc_(_bE_),ry,rx,_Vr_),_Vq_],
           _Vt_=[246,function(_WF_){return check$0(y,caml_call2(M[8],y,x))}],
           _Vu_=[0,caml_call3(_bc_(_bF_),ry,rx,_Vt_),_Vs_],
           _Vv_=[246,function(_WE_){return check$0(x,caml_call2(M[8],y,x))}],
           _Vw_=[0,caml_call3(_bc_(_bG_),ry,rx,_Vv_),_Vu_],
           _Vx_=
            [246,function(_WD_){return check_false(caml_call2(M[11][3],y,x))}],
           _Vy_=[0,caml_call3(_bc_(_bH_),ry,rx,_Vx_),_Vw_],
           _Vz_=
            [246,function(_WC_){return check_true(caml_call2(M[11][4],y,x))}],
           _VA_=[0,caml_call3(_bc_(_bI_),ry,rx,_Vz_),_Vy_],
           _VB_=
            [246,function(_WB_){return check_true(caml_call2(M[11][2],y,x))}],
           _VC_=[0,caml_call3(_bc_(_bJ_),ry,rx,_VB_),_VA_],
           _VD_=
            [246,function(_WA_){return check_false(caml_call2(M[11][1],y,x))}],
           _VE_=[0,caml_call3(_bc_(_bK_),ry,rx,_VD_),_VC_],
           _VF_=[246,function(_Wz_){return check_false(caml_call2(M[4],y,x))}],
           _VG_=[0,caml_call3(_bc_(_bL_),ry,rx,_VF_),_VE_],
           _VH_=[246,function(_Wy_){return check_true(caml_call2(M[5],y,x))}],
           _VI_=[0,caml_call3(_bc_(_bM_),ry,rx,_VH_),_VG_],
           _VJ_=[246,function(_Wx_){return check_true(caml_call2(M[3],y,x))}],
           _VK_=[0,caml_call3(_bc_(_bN_),ry,rx,_VJ_),_VI_],
           _VL_=[246,function(_Ww_){return check_false(caml_call2(M[2],y,x))}],
           _VM_=[0,caml_call3(_bc_(_bO_),ry,rx,_VL_),_VK_],
           _VN_=
            [246,
             function(_Wv_){return check_pair([0,y,y],caml_call2(M[10],x,y))}],
           _VO_=[0,caml_call3(_bc_(_bP_),rx,ry,_VN_),_VM_],
           _VP_=
            [246,
             function(_Wu_){return check_pair([0,x,x],caml_call2(M[10],x,y))}],
           _VQ_=[0,caml_call3(_bc_(_bQ_),rx,ry,_VP_),_VO_],
           _VR_=
            [246,
             function(_Wt_){return check_pair([0,y,x],caml_call2(M[10],x,y))}],
           _VS_=[0,caml_call3(_bc_(_bR_),rx,ry,_VR_),_VQ_],
           _VT_=
            [246,
             function(_Ws_){return check_pair([0,x,y],caml_call2(M[10],x,y))}],
           _VU_=[0,caml_call3(_bc_(_bS_),rx,ry,_VT_),_VS_],
           _VV_=[246,function(_Wr_){return check$0(y,caml_call2(M[9],x,y))}],
           _VW_=[0,caml_call3(_bc_(_bT_),rx,ry,_VV_),_VU_],
           _VX_=[246,function(_Wq_){return check$0(x,caml_call2(M[9],x,y))}],
           _VY_=[0,caml_call3(_bc_(_bU_),rx,ry,_VX_),_VW_],
           _VZ_=[246,function(_Wp_){return check$0(y,caml_call2(M[8],x,y))}],
           _V0_=[0,caml_call3(_bc_(_bV_),rx,ry,_VZ_),_VY_],
           _V1_=[246,function(_Wo_){return check$0(x,caml_call2(M[8],x,y))}],
           _V2_=[0,caml_call3(_bc_(_bW_),rx,ry,_V1_),_V0_],
           _V3_=
            [246,function(_Wn_){return check_false(caml_call2(M[11][3],x,y))}],
           _V4_=[0,caml_call3(_bc_(_bX_),rx,ry,_V3_),_V2_],
           _V5_=
            [246,function(_Wm_){return check_true(caml_call2(M[11][4],x,y))}],
           _V6_=[0,caml_call3(_bc_(_bY_),rx,ry,_V5_),_V4_],
           _V7_=
            [246,function(_Wl_){return check_true(caml_call2(M[11][2],x,y))}],
           _V8_=[0,caml_call3(_bc_(_bZ_),rx,ry,_V7_),_V6_],
           _V9_=
            [246,function(_Wk_){return check_false(caml_call2(M[11][1],x,y))}],
           _V__=[0,caml_call3(_bc_(_b0_),rx,ry,_V9_),_V8_],
           _V$_=[246,function(_Wj_){return check_false(caml_call2(M[4],x,y))}],
           _Wa_=[0,caml_call3(_bc_(_b1_),rx,ry,_V$_),_V__],
           _Wb_=[246,function(_Wi_){return check_true(caml_call2(M[5],x,y))}],
           _Wc_=[0,caml_call3(_bc_(_b2_),rx,ry,_Wb_),_Wa_],
           _Wd_=[246,function(_Wh_){return check_true(caml_call2(M[3],x,y))}],
           _We_=[0,caml_call3(_bc_(_b3_),rx,ry,_Wd_),_Wc_],
           _Wf_=[246,function(_Wg_){return check_false(caml_call2(M[2],x,y))}];
          return [0,caml_call3(_bc_(_b4_),rx,ry,_Wf_),_We_]}
        function _Ve_(_Vf_){return flat_map(_Vf_,_Vd_)}
        return caml_call2(_au_,cartesian_product(xs,xs),_Ve_)}
      function _T5_(_Vc_){return flat_map(_Vc_,_T4_)}
      var _T6_=caml_call2(_au_,E[2],_T5_);
      function _T7_(xs)
       {function _T__(param,y)
         {var
           tests=param[2],
           x=param[1],
           rx=caml_call1(M[12],x),
           ry=caml_call1(M[12],y),
           _Ua_=0,
           _Ub_=
            [246,
             function(_Vb_){return check_pair([0,x,y],caml_call2(M[10],y,x))}],
           _Uc_=[0,caml_call3(_bc_(_b5_),ry,rx,_Ub_),_Ua_],
           _Ud_=[246,function(_Va_){return check$0(y,caml_call2(M[9],y,x))}],
           _Ue_=[0,caml_call3(_bc_(_b6_),ry,rx,_Ud_),_Uc_],
           _Uf_=[246,function(_U$_){return check$0(x,caml_call2(M[8],y,x))}],
           _Ug_=[0,caml_call3(_bc_(_b7_),ry,rx,_Uf_),_Ue_],
           _Uh_=
            [246,function(_U__){return check_true(caml_call2(M[11][3],y,x))}],
           _Ui_=[0,caml_call3(_bc_(_b8_),ry,rx,_Uh_),_Ug_],
           _Uj_=
            [246,function(_U9_){return check_true(caml_call2(M[11][4],y,x))}],
           _Uk_=[0,caml_call3(_bc_(_b9_),ry,rx,_Uj_),_Ui_],
           _Ul_=
            [246,function(_U8_){return check_false(caml_call2(M[11][2],y,x))}],
           _Um_=[0,caml_call3(_bc_(_b__),ry,rx,_Ul_),_Uk_],
           _Un_=
            [246,function(_U7_){return check_false(caml_call2(M[11][1],y,x))}],
           _Uo_=[0,caml_call3(_bc_(_b$_),ry,rx,_Un_),_Um_],
           _Up_=[246,function(_U6_){return check_true(caml_call2(M[4],y,x))}],
           _Uq_=[0,caml_call3(_bc_(_ca_),ry,rx,_Up_),_Uo_],
           _Ur_=[246,function(_U5_){return check_true(caml_call2(M[5],y,x))}],
           _Us_=[0,caml_call3(_bc_(_cb_),ry,rx,_Ur_),_Uq_],
           _Ut_=[246,function(_U4_){return check_false(caml_call2(M[3],y,x))}],
           _Uu_=[0,caml_call3(_bc_(_cc_),ry,rx,_Ut_),_Us_],
           _Uv_=[246,function(_U3_){return check_false(caml_call2(M[2],y,x))}],
           _Uw_=[0,caml_call3(_bc_(_cd_),ry,rx,_Uv_),_Uu_],
           _Ux_=
            [246,
             function(_U2_){return check_pair([0,x,y],caml_call2(M[10],x,y))}],
           _Uy_=[0,caml_call3(_bc_(_ce_),rx,ry,_Ux_),_Uw_],
           _Uz_=[246,function(_U1_){return check$0(y,caml_call2(M[9],x,y))}],
           _UA_=[0,caml_call3(_bc_(_cf_),rx,ry,_Uz_),_Uy_],
           _UB_=[246,function(_U0_){return check$0(x,caml_call2(M[8],x,y))}],
           _UC_=[0,caml_call3(_bc_(_cg_),rx,ry,_UB_),_UA_],
           _UD_=
            [246,function(_UZ_){return check_false(caml_call2(M[11][3],x,y))}],
           _UE_=[0,caml_call3(_bc_(_ch_),rx,ry,_UD_),_UC_],
           _UF_=
            [246,function(_UY_){return check_false(caml_call2(M[11][4],x,y))}],
           _UG_=[0,caml_call3(_bc_(_ci_),rx,ry,_UF_),_UE_],
           _UH_=
            [246,function(_UX_){return check_true(caml_call2(M[11][2],x,y))}],
           _UI_=[0,caml_call3(_bc_(_cj_),rx,ry,_UH_),_UG_],
           _UJ_=
            [246,function(_UW_){return check_true(caml_call2(M[11][1],x,y))}],
           _UK_=[0,caml_call3(_bc_(_ck_),rx,ry,_UJ_),_UI_],
           _UL_=[246,function(_UV_){return check_false(caml_call2(M[4],x,y))}],
           _UM_=[0,caml_call3(_bc_(_cl_),rx,ry,_UL_),_UK_],
           _UN_=[246,function(_UU_){return check_false(caml_call2(M[5],x,y))}],
           _UO_=[0,caml_call3(_bc_(_cm_),rx,ry,_UN_),_UM_],
           _UP_=[246,function(_UT_){return check_true(caml_call2(M[3],x,y))}],
           _UQ_=[0,caml_call3(_bc_(_cn_),rx,ry,_UP_),_UO_],
           _UR_=[246,function(_US_){return check_true(caml_call2(M[2],x,y))}],
           new_tests=[0,caml_call3(_bc_(_co_),rx,ry,_UR_),_UQ_];
          return [0,y,caml_call2(_aw_,new_tests,tests)]}
        var _T$_=tail(xs);
        return caml_call2(_au_,fold([0,head(xs),0],_T$_,_T__),get_1)}
      function _T8_(_T9_){return flat_map(_T9_,_T7_)}
      var
       test=
        _a$_(cst_Comparable,caml_call2(_aw_,caml_call2(_au_,E[1],_T8_),_T6_));
      return [0,test]}
    function Make0$7(M,E)
     {function _TR_(param)
       {var
         expected=param[2],
         v=param[1],
         _TU_=
          [246,
           function(_TV_){return check_string(expected,caml_call1(M[1],v))}];
        return caml_call2(_bc_(_cu_),expected,_TU_)}
      function _TS_(_TT_){return map$0(_TT_,_TR_)}
      var test=_a$_(cst_Displayable,caml_call2(_au_,E[1],_TS_));
      return [0,test]}
    function Make0$8(M,E)
     {function _TG_(param)
       {var
         expected=param[2],
         s=param[1],
         _TJ_=0,
         _TK_=
          [246,
           function(_TP_)
            {var _TQ_=caml_call1(M[1],s);
             return check_some(M[4],M[3],expected,_TQ_)}],
         _TL_=[0,caml_call2(_bc_(_cv_),s,_TK_),_TJ_],
         _TM_=
          [246,
           function(_TN_)
            {var _TO_=caml_call1(M[2],s);
             return check(M[4],M[3],expected,_TO_)}];
        return [0,caml_call2(_bc_(_cw_),s,_TM_),_TL_]}
      function _TH_(_TI_){return flat_map(_TI_,_TG_)}
      var test=_a$_(cst_Parsable,caml_call2(_au_,E[1],_TH_));
      return [0,test]}
    var Basic=[0];
    function Make0$9(M)
     {function _TA_(x){return caml_call1(identity$0,x)}
      function _TB_(x){return caml_call1(M[1],x)}
      function _TC_(x,y){return caml_call2(M[2],x,y)}
      function _TD_(x,y){return caml_call2(M[3],x,y)}
      function _TE_(x,y){return caml_call2(M[4],x,y)}
      function _TF_(x,y){return caml_call2(M[5],x,y)}
      return [0,
              _TA_,
              _TB_,
              _TC_,
              _TD_,
              _TE_,
              _TF_,
              function(x,n){return caml_call2(M[6],x,n)}]}
    function Make0$10(M)
     {function exponentiate(x,n)
       {function aux(y,x,n)
         {var y$0=y,x$0=x,n$0=n;
          for(;;)
           {if(caml_lessthan(n$0,0))
             {var
               _Tw_=M[1],
               _Tx_=function(_Ty_,_Tz_){return aux(_Tw_,_Ty_,_Tz_)};
              return caml_call3(M[4],_Tx_,x$0,n$0)}
            if(caml_call2(_e_,n$0,0))return y$0;
            if(caml_call2(_e_,n$0,1))return caml_call2(M[3],x$0,y$0);
            if(caml_call2(_e_,n$0 % 2 | 0,0))
             {var n$1=n$0 / 2 | 0,x$1=caml_call1(M[2],x$0),x$0=x$1,n$0=n$1;
              continue}
            var
             n$2=(n$0 - 1 | 0) / 2 | 0,
             x$2=caml_call1(M[2],x$0),
             y$1=caml_call2(M[3],x$0,y$0),
             y$0=y$1,
             x$0=x$2,
             n$0=n$2;
            continue}}
        return aux(M[1],x,n)}
      return [0,exponentiate]}
    function ToContainer(C)
     {function Make1(M,ToContainer,Container)
       {var
         _R0_=0,
         _R1_=
          [0,
           _ba_
            (cst_flat_map_acc,
             [246,
              function(param)
               {var _Tm_=Container[2],_Tn_=caml_call1(ToContainer[12],42);
                function _To_(acc,x)
                 {var
                   acc$0=caml_mul(acc,x + 1 | 0),
                   _Tr_=Container[1],
                   _Ts_=ToList[1];
                  function _Tt_(n){return acc + caml_mul(x,n + 1 | 0) | 0}
                  function _Tu_(_Tv_){return caml_call2(_Ts_,_Tv_,_Tt_)}
                  var
                   ys=
                    caml_call2(_au_,caml_call2(_au_,make(0,0,x),_Tu_),_Tr_);
                  return [0,acc$0,ys]}
                function _Tp_(_Tq_){return caml_call2(_Tn_,_Tq_,_To_)}
                return check_int_list
                        (_c2_,
                         caml_call2
                          (_au_,caml_call2(_au_,caml_call2(_au_,_c1_,M[1]),_Tp_),_Tm_))}]),
           _R0_],
         _R2_=
          [0,
           _ba_
            (cst_flat_map_i,
             [246,
              function(param)
               {var _Tc_=Container[2],_Td_=ToContainer[11];
                function _Te_(i,x)
                 {var _Th_=Container[1],_Ti_=ToList[1];
                  function _Tj_(n){return caml_mul(x + i | 0,n + 1 | 0)}
                  function _Tk_(_Tl_){return caml_call2(_Ti_,_Tl_,_Tj_)}
                  return caml_call2
                          (_au_,caml_call2(_au_,make(0,0,x),_Tk_),_Th_)}
                function _Tf_(_Tg_){return caml_call2(_Td_,_Tg_,_Te_)}
                return check_int_list
                        (_c4_,
                         caml_call2
                          (_au_,caml_call2(_au_,caml_call2(_au_,_c3_,M[1]),_Tf_),_Tc_))}]),
           _R1_],
         _R3_=
          [0,
           _ba_
            (cst_flat_map,
             [246,
              function(param)
               {var _S4_=Container[2],_S5_=ToContainer[10];
                function _S6_(x)
                 {var _S9_=Container[1],_S__=ToList[1];
                  function _S$_(n){return caml_mul(x,n + 1 | 0)}
                  function _Ta_(_Tb_){return caml_call2(_S__,_Tb_,_S$_)}
                  return caml_call2
                          (_au_,caml_call2(_au_,make(0,0,x),_Ta_),_S9_)}
                function _S7_(_S8_){return caml_call2(_S5_,_S8_,_S6_)}
                return check_int_list
                        (_c6_,
                         caml_call2
                          (_au_,caml_call2(_au_,caml_call2(_au_,_c5_,M[1]),_S7_),_S4_))}]),
           _R2_],
         _R4_=
          [0,
           _ba_
            (cst_filter_map_acc,
             [246,
              function(param)
               {var _SW_=Container[2],_SX_=caml_call1(ToContainer[9],42);
                function _SY_(acc,x)
                 {var
                   _S2_=caml_call2(_aA_,acc % 2 | 0,0),
                   _S1_=x + 1 | 0,
                   _S3_=_S2_?caml_call2(_aA_,x % 3 | 0,0):_S2_;
                  return [0,acc + x | 0,some_if$0(_S3_,_S1_)]}
                function _SZ_(_S0_){return caml_call2(_SX_,_S0_,_SY_)}
                return check_int_list
                        (_c8_,
                         caml_call2
                          (_au_,caml_call2(_au_,caml_call2(_au_,_c7_,M[1]),_SZ_),_SW_))}]),
           _R3_],
         _R5_=
          [0,
           _ba_
            (cst_filter_map_i,
             [246,
              function(param)
               {var _SO_=Container[2],_SP_=ToContainer[8];
                function _SQ_(i,x)
                 {var
                   _SU_=caml_call2(_aA_,i % 2 | 0,0),
                   _ST_=x + 1 | 0,
                   _SV_=_SU_?caml_call2(_aA_,x % 3 | 0,0):_SU_;
                  return some_if$0(_SV_,_ST_)}
                function _SR_(_SS_){return caml_call2(_SP_,_SS_,_SQ_)}
                return check_int_list
                        (_c__,
                         caml_call2
                          (_au_,caml_call2(_au_,caml_call2(_au_,_c9_,M[1]),_SR_),_SO_))}]),
           _R4_],
         _R6_=
          [0,
           _ba_
            (cst_filter_map,
             [246,
              function(param)
               {var _SJ_=Container[2],_SK_=ToContainer[7];
                function _SL_(x)
                 {return some_if$0(caml_call2(_aA_,x % 3 | 0,0),x + 1 | 0)}
                function _SM_(_SN_){return caml_call2(_SK_,_SN_,_SL_)}
                return check_int_list
                        (_da_,
                         caml_call2
                          (_au_,caml_call2(_au_,caml_call2(_au_,_c$_,M[1]),_SM_),_SJ_))}]),
           _R5_],
         _R7_=
          [0,
           _ba_
            (cst_filter_acc,
             [246,
              function(param)
               {var _SC_=Container[2],_SD_=caml_call1(ToContainer[6],42);
                function _SE_(acc,x)
                 {var
                   _SH_=caml_call2(_aA_,acc % 2 | 0,0),
                   _SI_=_SH_?caml_call2(_aA_,x % 3 | 0,0):_SH_;
                  return [0,acc + x | 0,_SI_]}
                function _SF_(_SG_){return caml_call2(_SD_,_SG_,_SE_)}
                return check_int_list
                        (_dc_,
                         caml_call2
                          (_au_,caml_call2(_au_,caml_call2(_au_,_db_,M[1]),_SF_),_SC_))}]),
           _R6_],
         _R8_=
          [0,
           _ba_
            (cst_filter_i,
             [246,
              function(param)
               {var _Sw_=Container[2],_Sx_=ToContainer[5];
                function _Sy_(i,x)
                 {var _SB_=caml_call2(_aA_,i % 2 | 0,0);
                  return _SB_?caml_call2(_aA_,x % 3 | 0,0):_SB_}
                function _Sz_(_SA_){return caml_call2(_Sx_,_SA_,_Sy_)}
                return check_int_list
                        (_de_,
                         caml_call2
                          (_au_,caml_call2(_au_,caml_call2(_au_,_dd_,M[1]),_Sz_),_Sw_))}]),
           _R7_],
         _R9_=
          [0,
           _ba_
            (cst_filter,
             [246,
              function(param)
               {var _Sr_=Container[2],_Ss_=ToContainer[4];
                function _St_(x){return caml_call2(_aA_,x % 3 | 0,0)}
                function _Su_(_Sv_){return caml_call2(_Ss_,_Sv_,_St_)}
                return check_int_list
                        (_dg_,
                         caml_call2
                          (_au_,caml_call2(_au_,caml_call2(_au_,_df_,M[1]),_Su_),_Sr_))}]),
           _R8_],
         _R__=
          [0,
           _ba_
            (cst_map_acc,
             [246,
              function(param)
               {var _Sm_=Container[2],_Sn_=caml_call1(ToContainer[3],42);
                function _So_(acc,x){return [0,caml_mul(acc,x),x + acc | 0]}
                function _Sp_(_Sq_){return caml_call2(_Sn_,_Sq_,_So_)}
                return check_int_list
                        (_di_,
                         caml_call2
                          (_au_,caml_call2(_au_,caml_call2(_au_,_dh_,M[1]),_Sp_),_Sm_))}]),
           _R9_],
         _R$_=
          [0,
           _ba_
            (cst_map_i,
             [246,
              function(param)
               {var _Sh_=Container[2],_Si_=ToContainer[2];
                function _Sj_(i,x){return i + x | 0}
                function _Sk_(_Sl_){return caml_call2(_Si_,_Sl_,_Sj_)}
                return check_int_list
                        (_dk_,
                         caml_call2
                          (_au_,caml_call2(_au_,caml_call2(_au_,_dj_,M[1]),_Sk_),_Sh_))}]),
           _R__],
         test=
          _a$_
           (cst_FilterMapable_ToContainer,
            [0,
             _ba_
              (cst_map,
               [246,
                function(_Sa_)
                 {var _Sb_=Container[2],_Sc_=ToContainer[1];
                  function _Sd_(_Sg_){return 1 + _Sg_ | 0}
                  function _Se_(_Sf_){return caml_call2(_Sc_,_Sf_,_Sd_)}
                  return check_int_list
                          (_dm_,
                           caml_call2
                            (_au_,caml_call2(_au_,caml_call2(_au_,_dl_,M[1]),_Se_),_Sb_))}]),
             _R$_]);
        return [0,test]}
      var Tests=[0,Make1];
      return [0,Tests]}
    var ToList$0=ToContainer([0]);
    function Make1$2(M)
     {var
       T=ToContainer([0]),
       _RY_=[0,M[14],M[13]],
       _RZ_=[0,M[1],M[2],M[3],M[4],M[5],M[6],M[7],M[8],M[9],M[10],M[11],M[12]],
       include=caml_call1(caml_call1(caml_call1(T[1][1],[0,M[14]]),_RZ_),_RY_),
       test=include[1];
      return [0,test]}
    var
     Basic$0=[0],
     Basic$1=[0],
     Right=[0,Basic$1],
     Basic$2=[0],
     Basic$3=[0],
     Right$0=[0,Basic$3],
     Short=[0,Basic$2,Right$0],
     Foldable=[0,Basic$0,Right,Short];
    function ToContainer$0(C){return [0]}
    var ToList$1=[0],ToArray=[0];
    function ToContainer$1(C){return [0]}
    var
     ToList$2=[0],
     ToArray$0=[0],
     Right$1=[0,ToContainer$1,ToList$2,ToArray$0];
    function ToContainer$2(C){return [0]}
    var ToList$3=[0],ToArray$1=[0];
    function ToContainer$3(C){return [0]}
    var
     ToList$4=[0],
     ToArray$2=[0],
     Right$2=[0,ToContainer$3,ToList$4,ToArray$2],
     Short$0=[0,ToContainer$2,ToList$3,ToArray$1,Right$2],
     Scanable=[0,ToContainer$0,ToList$1,ToArray,Right$1,Short$0],
     Operators=0;
    function Make0$11(_RW_,_RV_)
     {var
       _RX_=[0,Make0([0,_RW_[4]],[0,_RV_[3]])[1],0],
       test=
        _a$_(cst_Identifiable,[0,Make0$2(_RW_,[0,_RV_[1],_RV_[2]])[1],_RX_]);
      return [0,test]}
    var Operators$0=[0];
    function Make0$12(_RR_,_RQ_)
     {var
       _RS_=_RR_[1],
       _RT_=
        [0,
         Make0$6
           ([0,
             _RR_[5],
             _RR_[6],
             _RR_[7],
             _RR_[8],
             _RR_[9],
             _RR_[10],
             _RR_[11],
             _RR_[12],
             _RR_[13],
             _RR_[14],
             [0,_RS_[3],_RS_[4],_RS_[5],_RS_[6]],
             _RR_[4],
             _RR_[2]],
            [0,_RQ_[3],_RQ_[4]])
          [1],
         0],
       _RU_=_RR_[1],
       test=
        _a$_
         (cst_Able,
          [0,
           Make0$11
             ([0,_RR_[2],_RR_[3],[0,_RU_[1],_RU_[2]],_RR_[4]],
              [0,_RQ_[4],_RQ_[1],_RQ_[2]])
            [1],
           _RT_]);
      return [0,test]}
    var Operators$1=[0],Operators$2=[0];
    function Make0$13(M,_Po_)
     {var
       _Pu_=_Po_[6],
       _Py_=_Po_[11],
       _Pp_=_Po_[1],
       _Pq_=_Po_[2],
       _Pr_=_Po_[3],
       _Ps_=_Po_[4],
       _Pt_=_Po_[5],
       _Pv_=_Po_[7],
       _Pw_=_Po_[8],
       _Px_=_Po_[9],
       ordered=caml_call2(_aw_,_Po_[10],[0,[0,M[8],[0,M[9],0]],0]),
       _Pz_=M[3],
       _PA_=M[7];
      function check$1(_RO_,_RP_){return check(_PA_,_Pz_,_RO_,_RP_)}
      var
       _PB_=0,
       _PC_=
        [0,
         _ba_
          (cst_to_float_one,
           [246,
            function(_RN_){return check_float_exact(1,caml_call1(M[32],M[9]))}]),
         _PB_],
       _PD_=
        [0,
         _ba_
          (cst_to_int_one,
           [246,function(_RM_){return check_int(1,caml_call1(M[31],M[9]))}]),
         _PC_],
       _PE_=
        [0,
         _ba_
          (cst_to_float_zero,
           [246,
            function(_RL_){return check_float_exact(0,caml_call1(M[32],M[8]))}]),
         _PD_],
       _PF_=
        [0,
         _ba_
          (cst_to_int_zero,
           [246,function(_RK_){return check_int(0,caml_call1(M[31],M[8]))}]),
         _PE_];
      function _PG_(param)
       {var
         y=param[2],
         x=param[1],
         x$0=caml_call2(M[23],x,M[8])?x:y,
         abs_y=caml_call2(M[23],y,M[8])?y:x,
         _RC_=0,
         _RD_=[246,function(_RJ_){return check$1(abs_y,caml_call1(M[29],y))}],
         _RE_=caml_call1(M[7],y),
         _RF_=[0,caml_call2(_bc_(_dE_),_RE_,_RD_),_RC_],
         _RG_=[246,function(_RI_){return check$1(x$0,caml_call1(M[29],x))}],
         _RH_=caml_call1(M[7],x);
        return [0,caml_call2(_bc_(_dF_),_RH_,_RG_),_RF_]}
      var
       _PH_=
        caml_call2
         (_aw_,
          caml_call2(_au_,_Pu_,function(_RB_){return flat_map(_RB_,_PG_)}),
          _PF_),
       _PI_=M[1],
       _PJ_=
        [0,
         Make0$6
           ([0,
             M[19],
             M[20],
             M[21],
             M[22],
             M[23],
             M[24],
             M[25],
             M[26],
             M[27],
             M[28],
             [0,_PI_[10],_PI_[11],_PI_[12],_PI_[13]],
             M[7],
             M[3]],
            [0,ordered,_Py_])
          [1],
         0],
       _PK_=M[18],
       _PL_=M[17],
       _PN_=M[15],
       _PP_=M[13],
       _PQ_=M[12],
       _PR_=M[11],
       _PS_=M[10],
       _PT_=M[9],
       _PU_=M[8],
       _PV_=M[7],
       _PW_=M[6],
       _PZ_=M[3],
       _P1_=M[1],
       _P5_=_P1_[6],
       _P6_=_P1_[5],
       _P7_=_P1_[4],
       _PM_=M[16],
       _PO_=M[14],
       _PX_=M[5],
       _PY_=M[4],
       _P0_=M[2],
       _P2_=_P1_[9],
       _P3_=_P1_[8],
       _P4_=_P1_[7],
       _P8_=_P1_[2],
       _P9_=_P1_[1],
       _Pf_=[0,caml_call1(_PW_,cst_1),0],
       _Pg_=[0,caml_call1(_PK_,1),_Pf_],
       _Ph_=[0,[0,_PT_,[0,caml_call1(_PL_,1),_Pg_]],0],
       _Pi_=[0,caml_call1(_PW_,cst_0),0],
       _Pj_=[0,caml_call1(_PK_,0),_Pi_],
       equal=
        caml_call2(_aw_,_Py_,[0,[0,_PU_,[0,caml_call1(_PL_,0),_Pj_]],_Ph_]),
       different=caml_call2(_aw_,_Pq_,[0,[0,_PU_,_PT_],0]),
       add_substract=
        caml_call2(_aw_,_Pt_,[0,[0,_PU_,_PU_,_PU_],[0,[0,_PT_,_PU_,_PT_],0]]),
       negate=caml_call2(_aw_,_Pu_,[0,[0,_PU_,_PU_],0]),
       multiply=
        caml_call2(_aw_,_Pv_,[0,[0,_PU_,_PU_,_PU_],[0,[0,_PT_,_PU_,_PU_],0]]),
       divide=
        caml_call2(_aw_,_Pw_,[0,[0,_PU_,_PT_,_PU_],[0,[0,_PT_,_PT_,_PT_],0]]),
       exponentiate=
        caml_call2
         (_aw_,
          _Px_,
          [0,
           [0,_PU_,0,_PT_],
           [0,
            [0,_PU_,1,_PU_],
            [0,
             [0,_PU_,7,_PU_],
             [0,[0,_PT_,0,_PT_],[0,[0,_PT_,1,_PT_],[0,[0,_PT_,7,_PT_],0]]]]]]),
       _Pk_=0;
      function check$0(_Rz_,_RA_){return check(_PV_,_PZ_,_Rz_,_RA_)}
      function _O8_(param)
       {var
         expected=param[3],
         n=param[2],
         x=param[1],
         rx=caml_call1(_PV_,x),
         _Rt_=0,
         _Ru_=
          [246,function(_Ry_){return check$0(expected,caml_call2(_P2_,x,n))}],
         _Rv_=[0,caml_call3(_bc_(_cz_),rx,n,_Ru_),_Rt_],
         _Rw_=
          [246,function(_Rx_){return check$0(expected,caml_call2(_PM_,x,n))}];
        return [0,caml_call3(_bc_(_cA_),rx,n,_Rw_),_Rv_]}
      var
       _O9_=
        caml_call2
         (_au_,exponentiate,function(_Rs_){return flat_map(_Rs_,_O8_)});
      function _O__(param)
       {var
         expected=param[3],
         y=param[2],
         x=param[1],
         rx=caml_call1(_PV_,x),
         ry=caml_call1(_PV_,y),
         _Rm_=0,
         _Rn_=
          [246,function(_Rr_){return check$0(expected,caml_call2(_P3_,x,y))}],
         _Ro_=[0,caml_call3(_bc_(_cB_),rx,ry,_Rn_),_Rm_],
         _Rp_=
          [246,function(_Rq_){return check$0(expected,caml_call2(_PO_,x,y))}];
        return [0,caml_call3(_bc_(_cC_),rx,ry,_Rp_),_Ro_]}
      var
       _O$_=
        caml_call2
         (_aw_,
          caml_call2(_au_,divide,function(_Rl_){return flat_map(_Rl_,_O__)}),
          _O9_);
      function _Pa_(param)
       {var
         expected=param[3],
         y=param[2],
         x=param[1],
         rx=caml_call1(_PV_,x),
         ry=caml_call1(_PV_,y),
         _Rf_=0,
         _Rg_=
          [246,function(_Rk_){return check$0(expected,caml_call2(_P4_,x,y))}],
         _Rh_=[0,caml_call3(_bc_(_cD_),rx,ry,_Rg_),_Rf_],
         _Ri_=
          [246,function(_Rj_){return check$0(expected,caml_call2(_PP_,x,y))}];
        return [0,caml_call3(_bc_(_cE_),rx,ry,_Ri_),_Rh_]}
      var
       _Pb_=
        caml_call2
         (_aw_,
          caml_call2(_au_,multiply,function(_Re_){return flat_map(_Re_,_Pa_)}),
          _O$_);
      function _Pc_(param)
       {var
         y=param[2],
         x=param[1],
         rx=caml_call1(_PV_,x),
         ry=caml_call1(_PV_,y),
         _Qy_=0,
         _Qz_=
          [246,
           function(_Rc_)
            {var _Rd_=caml_call1(_PN_,y);
             return check$0(caml_call1(_PS_,caml_call2(_PP_,x,y)),_Rd_)}],
         _QA_=[0,caml_call2(_bc_(_cF_),ry,_Qz_),_Qy_],
         _QB_=
          [246,
           function(_Ra_)
            {var _Rb_=caml_call1(_PN_,x);
             return check$0(caml_call1(_PS_,caml_call2(_PP_,x,y)),_Rb_)}],
         _QC_=[0,caml_call2(_bc_(_cG_),rx,_QB_),_QA_],
         _QD_=[246,function(_Q$_){return check$0(_PU_,caml_call2(_P6_,y,x))}],
         _QE_=[0,caml_call3(_bc_(_cH_),ry,rx,_QD_),_QC_],
         _QF_=[246,function(_Q__){return check$0(_PU_,caml_call2(_P6_,x,y))}],
         _QG_=[0,caml_call3(_bc_(_cI_),rx,ry,_QF_),_QE_],
         _QH_=[246,function(_Q9_){return check$0(_PU_,caml_call2(_PR_,y,x))}],
         _QI_=[0,caml_call3(_bc_(_cJ_),ry,rx,_QH_),_QG_],
         _QJ_=[246,function(_Q8_){return check$0(_PU_,caml_call2(_PR_,x,y))}],
         _QK_=[0,caml_call3(_bc_(_cK_),rx,ry,_QJ_),_QI_],
         _QL_=[246,function(_Q7_){return check$0(x,caml_call2(_P5_,_PU_,y))}],
         _QM_=[0,caml_call2(_bc_(_cL_),ry,_QL_),_QK_],
         _QN_=[246,function(_Q6_){return check$0(y,caml_call2(_P5_,_PU_,x))}],
         _QO_=[0,caml_call2(_bc_(_cM_),rx,_QN_),_QM_],
         _QP_=[246,function(_Q5_){return check$0(x,caml_call2(_PQ_,_PU_,y))}],
         _QQ_=[0,caml_call2(_bc_(_cN_),ry,_QP_),_QO_],
         _QR_=[246,function(_Q4_){return check$0(y,caml_call2(_PQ_,_PU_,x))}],
         _QS_=[0,caml_call2(_bc_(_cO_),rx,_QR_),_QQ_],
         _QT_=[246,function(_Q3_){return check$0(x,caml_call1(_P7_,y))}],
         _QU_=[0,caml_call2(_bc_(_cP_),ry,_QT_),_QS_],
         _QV_=[246,function(_Q2_){return check$0(y,caml_call1(_P7_,x))}],
         _QW_=[0,caml_call2(_bc_(_cQ_),rx,_QV_),_QU_],
         _QX_=[246,function(_Q1_){return check$0(x,caml_call1(_PS_,y))}],
         _QY_=[0,caml_call2(_bc_(_cR_),ry,_QX_),_QW_],
         _QZ_=[246,function(_Q0_){return check$0(y,caml_call1(_PS_,x))}];
        return [0,caml_call2(_bc_(_cS_),rx,_QZ_),_QY_]}
      var
       _Pd_=
        caml_call2
         (_aw_,
          caml_call2(_au_,negate,function(_Qx_){return flat_map(_Qx_,_Pc_)}),
          _Pb_);
      function _Pe_(param)
       {var
         z=param[3],
         y=param[2],
         x=param[1],
         rx=caml_call1(_PV_,x),
         ry=caml_call1(_PV_,y),
         rz=caml_call1(_PV_,z),
         _P$_=0,
         _Qa_=[246,function(_Qw_){return check$0(y,caml_call2(_P5_,z,x))}],
         _Qb_=[0,caml_call3(_bc_(_cT_),rz,rx,_Qa_),_P$_],
         _Qc_=[246,function(_Qv_){return check$0(y,caml_call2(_PQ_,z,x))}],
         _Qd_=[0,caml_call3(_bc_(_cU_),rz,rx,_Qc_),_Qb_],
         _Qe_=[246,function(_Qu_){return check$0(x,caml_call2(_P5_,z,y))}],
         _Qf_=[0,caml_call3(_bc_(_cV_),rz,ry,_Qe_),_Qd_],
         _Qg_=[246,function(_Qt_){return check$0(x,caml_call2(_PQ_,z,y))}],
         _Qh_=[0,caml_call3(_bc_(_cW_),rz,ry,_Qg_),_Qf_],
         _Qi_=[246,function(_Qs_){return check$0(z,caml_call2(_P6_,y,x))}],
         _Qj_=[0,caml_call3(_bc_(_cX_),ry,rx,_Qi_),_Qh_],
         _Qk_=[246,function(_Qr_){return check$0(z,caml_call2(_P6_,x,y))}],
         _Ql_=[0,caml_call3(_bc_(_cY_),rx,ry,_Qk_),_Qj_],
         _Qm_=[246,function(_Qq_){return check$0(z,caml_call2(_PR_,y,x))}],
         _Qn_=[0,caml_call3(_bc_(_cZ_),ry,rx,_Qm_),_Ql_],
         _Qo_=[246,function(_Qp_){return check$0(z,caml_call2(_PR_,x,y))}];
        return [0,caml_call3(_bc_(_c0_),rx,ry,_Qo_),_Qn_]}
      var
       test=
        _a$_
         (cst_Ringoid,
          caml_call2
           (_aw_,
            caml_call2
             (_au_,add_substract,function(_P__){return flat_map(_P__,_Pe_)}),
            _Pd_)),
       _Pl_=[0,Make0([0,_PV_],[0,_Ps_])[1],[0,test,_Pk_]],
       _Pm_=[0,Make0$8([0,_PX_,_PW_,_PZ_,_PV_],[0,_Pr_])[1],_Pl_],
       _Pn_=
        [0,
         Make0$2([0,_PZ_,_PY_,[0,_P9_,_P8_],_PV_],[0,equal,different])[1],
         _Pm_],
       test$0=_a$_(cst_Number,[0,Make0$7([0,_P0_],[0,_Pp_])[1],_Pn_]),
       test$1=_a$_(cst_RealNumber,caml_call2(_aw_,[0,test$0,_PJ_],_PH_));
      return [0,test$1]}
    function Make0$14(M,_OK_)
     {var
       _OL_=_OK_[1],
       _OM_=_OK_[2],
       _ON_=_OK_[3],
       _OO_=_OK_[4],
       _OP_=_OK_[5],
       _OQ_=_OK_[6],
       _OR_=_OK_[7],
       _OS_=_OK_[8],
       _OT_=_OK_[9],
       _OU_=_OK_[10],
       _OV_=_OK_[11],
       succ=caml_call2(_aw_,_OK_[12],[0,[0,M[8],M[9]],0]),
       _OX_=M[7],
       _OY_=M[3],
       _OW_=0,
       _OZ_=M[34],
       _O0_=M[33];
      function _OJ_(param)
       {var
         s=param[2],
         p=param[1],
         rp=caml_call1(_OX_,p),
         rs=caml_call1(_OX_,s),
         _O2_=0,
         _O3_=
          [246,function(_O7_){return check(_OX_,_OY_,p,caml_call1(_OZ_,s))}],
         _O4_=[0,caml_call2(_bc_(_cx_),rs,_O3_),_O2_],
         _O5_=
          [246,function(_O6_){return check(_OX_,_OY_,s,caml_call1(_O0_,p))}];
        return [0,caml_call2(_bc_(_cy_),rp,_O5_),_O4_]}
      var
       test=
        _a$_
         (cst_PredSucc,
          caml_call2(_au_,succ,function(_O1_){return flat_map(_O1_,_OJ_)})),
       test$0=
        _a$_
         (cst_Integer,
          [0,
           Make0$13
             ([0,
               M[1],
               M[2],
               M[3],
               M[4],
               M[5],
               M[6],
               M[7],
               M[8],
               M[9],
               M[10],
               M[11],
               M[12],
               M[13],
               M[14],
               M[15],
               M[16],
               M[17],
               M[18],
               M[19],
               M[20],
               M[21],
               M[22],
               M[23],
               M[24],
               M[25],
               M[26],
               M[27],
               M[28],
               M[29],
               M[30],
               M[31],
               M[32]],
              [0,_OL_,_OM_,_ON_,_OO_,_OP_,_OQ_,_OR_,_OS_,_OT_,_OU_,_OV_])
            [1],
           [0,test,_OW_]]);
      return [0,test$0]}
    function get$2(_OI_,_OH_){return caml_check_bound(_OI_,_OH_)[_OH_ + 1]}
    function set$2(_OG_,_OF_,_OE_)
     {return caml_check_bound(_OG_,_OF_)[_OF_ + 1] = _OE_}
    function size$1(_OD_){return _OD_.length - 1}
    var
     match_failure=[246,function(_OC_){throw [0,MatchFailure,_dG_]}],
     assert_failure=[246,function(param){throw [0,AssertFailure,_dH_]}];
    function failure_if(condition,format)
     {return with_result
              (format,
               function(message)
                {return condition?raise([0,Failure,message]):condition})}
    function failure_unless(condition,format)
     {return with_result
              (format,
               function(message)
                {var _OB_=1 - condition;
                 return _OB_?raise([0,Failure,message]):_OB_})}
    var
     TestException=
      [248,cst_General_Exception_Tests_TestException,caml_fresh_oo_id(0)],
     equal$29=[0,[0,[0,Failure,cst_foo],0],0],
     different$21=
      [0,
       [0,[0,Failure,cst_foo$2],[0,Failure,cst_bar]],
       [0,[0,[0,Failure,cst_foo$1],[0,InvalidArgument,cst_foo$0]],0]],
     repr$22=[0,[0,DivisionByZero,cst_Division_by_zero],0],
     _dI_=0,
     _dJ_=0,
     _dK_=
      [0,
       _ba_
        (cst_Exit_Pervasives_Exit,
         [246,
          function(_Oz_)
           {return expect_exception
                    (Exit,[246,function(_OA_){return raise(Exit)}])}]),
       _dJ_],
     _dL_=
      [0,
       _ba_
        (cst_DivisionByZero_Division_by_zero,
         [246,
          function(_Ox_)
           {return expect_exception
                    (DivisionByZero,[246,function(_Oy_){return caml_div(1,0)}])}]),
       _dK_],
     _dM_=
      [0,
       _ba_
        (cst_StackOverflow_Stack_overflow,
         [246,
          function(_Ow_)
           {return expect_exception
                    (StackOverflow,
                     [246,
                      function(param)
                       {function f(x){return 1 + f(x) | 0}return f(0)}])}]),
       _dL_],
     _dN_=
      [0,
       _ba_
        (cst_NotFound_Not_found,
         [246,
          function(_Os_)
           {return expect_exception
                    (NotFound,
                     [246,
                      function(_Ot_)
                       {var _Ou_=0;
                        function _Ov_(param){return 1}
                        return caml_call2(Stdlib_list[33],_Ov_,_Ou_)}])}]),
       _dM_],
     _dO_=
      [0,
       _ba_
        (cst_Failure_Failure,
         [246,
          function(_Oq_)
           {return expect_exception
                    ([0,Failure,cst_foo$4],
                     [246,
                      function(_Or_){return caml_call1(Stdlib[1][2],cst_foo$3)}])}]),
       _dN_],
     _dP_=
      [0,
       _ba_
        (cst_InvalidArgument_Invalid_argument,
         [246,
          function(_Oo_)
           {return expect_exception
                    ([0,InvalidArgument,cst_List_nth],
                     [246,function(_Op_){return caml_call2(Stdlib_list[7],0,-1)}])}]),
       _dO_],
     _dR_=
      [0,
       _ba_
        (cst_AssertFailure_Assert_failure,
         [246,
          function(_On_)
           {return expect_exception([0,AssertFailure,_dQ_],assert_failure)}]),
       _dP_],
     _dT_=
      [0,
       _a$_
        (cst_Aliases,
         [0,
          _ba_
           (cst_MatchFailure_Match_failure,
            [246,
             function(_Om_)
              {return expect_exception([0,MatchFailure,_dS_],match_failure)}]),
          _dR_]),
       _dI_],
     _dV_=
      [0,
       _ba_
        (cst_invalid_argument,
         [246,
          function(_Ok_)
           {return expect_exception
                    ([0,InvalidArgument,cst_Grmbl_baz_43],
                     [246,
                      function(_Ol_)
                       {return caml_call2(invalid_argument(_dU_),cst_baz,43)}])}]),
       _dT_],
     _dX_=
      [0,
       _ba_
        (cst_failure,
         [246,
          function(_Oi_)
           {return expect_exception
                    ([0,Failure,cst_Foo_bar_42],
                     [246,
                      function(_Oj_)
                       {return caml_call2(failure(_dW_),cst_bar$0,42)}])}]),
       _dV_],
     _dY_=
      [0,
       _ba_
        (cst_raise_without_backtrace,
         [246,
          function(_Og_)
           {return expect_exception
                    (TestException,
                     [246,
                      function(_Oh_)
                       {return raise_without_backtrace(TestException)}])}]),
       _dX_],
     _dZ_=
      [0,
       _ba_
        (cst_raise,
         [246,
          function(_Oe_)
           {return expect_exception
                    (TestException,
                     [246,function(_Of_){return raise(TestException)}])}]),
       _dY_],
     _d0_=[0,Make0$7([0,to_string$0],[0,repr$22])[1],_dZ_],
     test$9=
      _a$_
       (cst_Exception,
        [0,
         Make0$11
           ([0,equal$1,different$1,O$0,to_string$0],
            [0,equal$29,different$21,repr$22])
          [1],
         _d0_]);
    function Make(M)
     {var
       zero=M[3],
       one=M[4],
       greatest=M[14],
       smallest=M[15],
       of_float=M[18],
       to_float=M[19],
       of_int=M[16],
       to_int=M[17],
       of_string=M[20];
      function try_of_string(s)
       {return or_none([246,function(_Od_){return caml_call1(of_string,s)}])}
      var to_string=M[21];
      function repr(n)
       {var _Ob_=M[2],_Oc_=caml_call1(to_string,n);
        return caml_call2(apply(_d1_),_Oc_,_Ob_)}
      var
       abs=M[13],
       succ=M[11],
       pred=M[12],
       negate=M[5],
       add=M[6],
       substract=M[7],
       multiply=M[8],
       divide=M[9],
       modulo=M[10],
       _NY_=M[22];
      function compare(_N$_,_Oa_){return of_standard(_NY_,_N$_,_Oa_)}
      var equal=M[23];
      function less_than(x,y){var match=compare(x,y);return 0 === match?1:0}
      function less_or_equal(x,y)
       {var match=compare(x,y);return 2 <= match?0:1}
      function greater_than(x,y){var match=compare(x,y);return 2 <= match?1:0}
      function greater_or_equal(x,y)
       {var match=compare(x,y);return 0 === match?0:1}
      var
       _NZ_=Make0$5([0,compare]),
       min=_NZ_[1],
       max=_NZ_[2],
       min_max=_NZ_[3],
       different=Make0$1([0,equal])[1];
      function square(x){return caml_call2(multiply,x,x)}
      function exponentiate_negative_exponent(param,_N9_,n)
       {var _N__=M[1];return caml_call2(invalid_argument(_d2_),_N__,n)}
      var
       exponentiate=
        Make0$10([0,one,square,multiply,exponentiate_negative_exponent])[1],
       _N0_=Make0$4([0,less_than,less_or_equal,greater_than,greater_or_equal]),
       between=_N0_[1],
       between_or_equal=_N0_[2],
       _N1_=Make0$3([0,less_than,less_or_equal,greater_than,greater_or_equal]),
       _N2_=_N1_[1],
       _N3_=_N1_[2],
       _N4_=_N1_[3],
       _N5_=_N1_[4],
       _N6_=Make0$0([0,equal,different]),
       _N7_=_N6_[1],
       _N8_=_N6_[2],
       include=Make0$9([0,negate,add,substract,multiply,divide,exponentiate]);
      return [0,
              [0,
               _N7_,
               _N8_,
               include[1],
               include[2],
               include[3],
               include[4],
               include[5],
               include[6],
               include[7],
               _N2_,
               _N3_,
               _N4_,
               _N5_,
               modulo],
              to_string,
              equal,
              different,
              try_of_string,
              of_string,
              repr,
              zero,
              one,
              negate,
              add,
              substract,
              multiply,
              divide,
              square,
              exponentiate,
              of_int,
              of_float,
              compare,
              less_than,
              less_or_equal,
              greater_than,
              greater_or_equal,
              between,
              between_or_equal,
              min,
              max,
              min_max,
              abs,
              modulo,
              to_int,
              to_float,
              succ,
              pred,
              smallest,
              greatest]}
    var
     zero$2=Stdlib_int32[1],
     one$1=Stdlib_int32[2],
     succ$1=Stdlib_int32[4],
     pred$1=Stdlib_int32[5],
     abs$2=Stdlib_int32[6],
     max_int$0=Stdlib_int32[7],
     min_int$0=Stdlib_int32[8],
     to_string$7=Stdlib_int32[11],
     compare$11=Stdlib_int32[12],
     equal$30=Stdlib_int32[13],
     _d3_=caml_int_of_string;
    function _d4_(_NX_){return _NX_}
    function _d5_(_NW_){return _NW_ | 0}
    function _d6_(_NV_){return _NV_}
    function _d7_(_NU_){return _NU_}
    var _d8_=caml_mod,_d9_=caml_div;
    function _d__(_NT_,_NS_){return caml_mul(_NT_,_NS_)}
    function _d$_(_NR_,_NQ_){return _NR_ - _NQ_ | 0}
    function _ea_(_NP_,_NO_){return _NP_ + _NO_ | 0}
    var
     include$6=
      Make
       ([0,
         name$0,
         repr_suffix,
         zero$2,
         one$1,
         function(_NN_){return - _NN_ | 0},
         _ea_,
         _d$_,
         _d__,
         _d9_,
         _d8_,
         succ$1,
         pred$1,
         abs$2,
         max_int$0,
         min_int$0,
         _d7_,
         _d6_,
         _d5_,
         _d4_,
         _d3_,
         to_string$7,
         compare$11,
         equal$30]),
     O$14=include$6[1],
     try_of_string$3=include$6[5],
     zero$3=include$6[8],
     one$2=include$6[9],
     add$1=include$6[11],
     substract$1=include$6[12],
     square$1=include$6[15],
     _ej_=include$6[16],
     of_int$2=include$6[17],
     of_float$2=include$6[18],
     compare$12=include$6[19],
     less_than$10=include$6[20],
     less_or_equal$10=include$6[21],
     greater_than$10=include$6[22],
     greater_or_equal$10=include$6[23],
     between$10=include$6[24],
     between_or_equal$10=include$6[25],
     min$11=include$6[26],
     max$11=include$6[27],
     min_max$10=include$6[28],
     abs$3=include$6[29],
     modulo$1=include$6[30],
     to_int$1=include$6[31],
     to_float$1=include$6[32],
     pred$2=include$6[34],
     smallest$1=include$6[35],
     greatest$1=include$6[36],
     _eb_=include$6[2],
     _ec_=include$6[3],
     _ed_=include$6[4],
     _ee_=include$6[6],
     _ef_=include$6[7],
     _eg_=include$6[10],
     _eh_=include$6[13],
     _ei_=include$6[14],
     _ek_=include$6[33],
     _el_=0,
     _em_=
      [0,
       _ba_
        (cst_exponentiate_2l_4,
         [246,
          function(_NL_)
           {return expect_exception
                    ([0,
                      InvalidArgument,
                      cst_Int32_exponentiate_Negative_exponent_4],
                     [246,function(_NM_){return caml_call2(_ej_,2,-4)}])}]),
       _el_],
     _en_=
      [0,
       Make0$8
         ([0,include$6[5],include$6[6],include$6[3],include$6[7]],
          [0,of_string$4])
        [1],
       _em_],
     test$10=
      _a$_
       (cst_Int32,
        [0,
         Make0$14
           ([0,
             include$6[1],
             include$6[2],
             include$6[3],
             include$6[4],
             include$6[5],
             include$6[6],
             include$6[7],
             include$6[8],
             include$6[9],
             include$6[10],
             include$6[11],
             include$6[12],
             include$6[13],
             include$6[14],
             include$6[15],
             include$6[16],
             include$6[17],
             include$6[18],
             include$6[19],
             include$6[20],
             include$6[21],
             include$6[22],
             include$6[23],
             include$6[24],
             include$6[25],
             include$6[26],
             include$6[27],
             include$6[28],
             include$6[29],
             include$6[30],
             include$6[31],
             include$6[32],
             include$6[33],
             include$6[34]],
            [0,
             to_string$8,
             different$22,
             of_string$4,
             repr$23,
             add_substract,
             negate$1,
             multiply$1,
             divide$1,
             exponentiate,
             ordered,
             equal$31,
             succ$2])
          [1],
         _en_]),
     zero$4=Stdlib_int64[1],
     one$3=Stdlib_int64[2],
     succ$3=Stdlib_int64[4],
     pred$3=Stdlib_int64[5],
     abs$4=Stdlib_int64[6],
     max_int$1=Stdlib_int64[7],
     min_int$1=Stdlib_int64[8],
     to_string$9=Stdlib_int64[11],
     compare$13=Stdlib_int64[12],
     equal$32=Stdlib_int64[13],
     include$7=
      Make
       ([0,
         name$1,
         repr_suffix$0,
         zero$4,
         one$3,
         runtime.caml_int64_neg,
         runtime.caml_int64_add,
         runtime.caml_int64_sub,
         runtime.caml_int64_mul,
         runtime.caml_int64_div,
         runtime.caml_int64_mod,
         succ$3,
         pred$3,
         abs$4,
         max_int$1,
         min_int$1,
         runtime.caml_int64_of_int32,
         runtime.caml_int64_to_int32,
         runtime.caml_int64_of_float,
         runtime.caml_int64_to_float,
         runtime.caml_int64_of_string,
         to_string$9,
         compare$13,
         equal$32]),
     O$15=include$7[1],
     try_of_string$4=include$7[5],
     zero$5=include$7[8],
     one$4=include$7[9],
     add$2=include$7[11],
     substract$2=include$7[12],
     square$2=include$7[15],
     _ew_=include$7[16],
     of_int$3=include$7[17],
     of_float$3=include$7[18],
     compare$14=include$7[19],
     less_than$11=include$7[20],
     less_or_equal$11=include$7[21],
     greater_than$11=include$7[22],
     greater_or_equal$11=include$7[23],
     between$11=include$7[24],
     between_or_equal$11=include$7[25],
     min$12=include$7[26],
     max$12=include$7[27],
     min_max$11=include$7[28],
     abs$5=include$7[29],
     modulo$2=include$7[30],
     to_int$2=include$7[31],
     to_float$2=include$7[32],
     pred$4=include$7[34],
     smallest$2=include$7[35],
     greatest$2=include$7[36],
     _eo_=include$7[2],
     _ep_=include$7[3],
     _eq_=include$7[4],
     _er_=include$7[6],
     _es_=include$7[7],
     _et_=include$7[10],
     _eu_=include$7[13],
     _ev_=include$7[14],
     _ex_=include$7[33],
     _ey_=0,
     _eA_=
      [0,
       _ba_
        (cst_exponentiate_2L_4,
         [246,
          function(_NJ_)
           {return expect_exception
                    ([0,
                      InvalidArgument,
                      cst_Int64_exponentiate_Negative_exponent_4],
                     [246,function(_NK_){return caml_call2(_ew_,_ez_,-4)}])}]),
       _ey_],
     _eB_=
      [0,
       Make0$8
         ([0,include$7[5],include$7[6],include$7[3],include$7[7]],
          [0,of_string$5])
        [1],
       _eA_],
     test$11=
      _a$_
       (cst_Int64,
        [0,
         Make0$14
           ([0,
             include$7[1],
             include$7[2],
             include$7[3],
             include$7[4],
             include$7[5],
             include$7[6],
             include$7[7],
             include$7[8],
             include$7[9],
             include$7[10],
             include$7[11],
             include$7[12],
             include$7[13],
             include$7[14],
             include$7[15],
             include$7[16],
             include$7[17],
             include$7[18],
             include$7[19],
             include$7[20],
             include$7[21],
             include$7[22],
             include$7[23],
             include$7[24],
             include$7[25],
             include$7[26],
             include$7[27],
             include$7[28],
             include$7[29],
             include$7[30],
             include$7[31],
             include$7[32],
             include$7[33],
             include$7[34]],
            [0,
             to_string$10,
             different$23,
             of_string$5,
             repr$24,
             add_substract$0,
             negate$2,
             multiply$2,
             divide$2,
             exponentiate$0,
             ordered$0,
             equal$33,
             succ$4])
          [1],
         _eB_]);
    function exponentiate_negative_exponent(exponentiate,x,n)
     {return caml_call2(exponentiate,1 / x,- n | 0)}
    var
     exponentiate$1=
      Make0$10([0,one$0,square$0,multiply$0,exponentiate_negative_exponent])
       [1],
     equal$34=
      [0,
       _eE_,
       [0,_eD_,[0,_eC_,[0,[0,infinity,0],[0,[0,negative_infinity,0],0]]]]],
     different$24=
      [0,
       _eG_,
       [0,
        _eF_,
        [0,
         [0,not_a_number,infinity],
         [0,
          [0,not_a_number,negative_infinity],
          [0,
           [0,not_a_number,1],
           [0,[0,not_a_number,0],[0,[0,not_a_number,not_a_number],0]]]]]]],
     _eH_=0,
     _eI_=0;
    function check$0(_NH_,_NI_){return check(repr$5,equal$8,_NH_,_NI_)}
    var
     _eJ_=0,
     _eK_=
      [0,
       _ba_
        (cst_NotANumber$0,
         [246,function(_NG_){return check$0(4,of_float$1(NaN))}]),
       _eJ_],
     _eL_=
      [0,
       _ba_
        (cst_NotANumber$1,
         [246,function(_NF_){return check$0(4,of_float$1(not_a_number))}]),
       _eK_],
     _eM_=
      [0,
       _ba_
        (cst_NotANumber$2,
         [246,function(_NE_){return check$0(4,of_float$1(NaN))}]),
       _eL_],
     _eN_=
      [0,
       _ba_
        (cst_Infinite$0,
         [246,function(_ND_){return check$0(3,of_float$1(negative_infinity))}]),
       _eM_],
     _eO_=
      [0,
       _ba_
        (cst_Infinite$1,
         [246,function(_NC_){return check$0(3,of_float$1(-Infinity))}]),
       _eN_],
     _eP_=
      [0,
       _ba_
        (cst_Infinite$2,
         [246,function(_NB_){return check$0(3,of_float$1(infinity))}]),
       _eO_],
     _eQ_=
      [0,
       _ba_
        (cst_Infinite$3,
         [246,function(_NA_){return check$0(3,of_float$1(Infinity))}]),
       _eP_],
     _eR_=
      [0,
       _ba_(cst_Zero$0,[246,function(_Nz_){return check$0(2,of_float$1(-0))}]),
       _eQ_],
     _eS_=
      [0,
       _ba_(cst_Zero$1,[246,function(_Ny_){return check$0(2,of_float$1(0))}]),
       _eR_],
     _eT_=
      [0,
       _ba_
        (cst_SubNormal$0,
         [246,function(_Nx_){return check$0(1,of_float$1(1 / greatest$0))}]),
       _eS_],
     _eU_=
      [0,
       _a$_
        (cst_of_float,
         [0,
          _ba_
           (cst_Normal$0,
            [246,function(_Nw_){return check$0(0,of_float$1(1))}]),
          _eT_]),
       _eI_],
     _eV_=[0,Make0([0,repr$5],[0,repr$26])[1],_eU_],
     _eW_=
      [0,
       Make0$2
         ([0,equal$8,different$6,[0,_Y_,_Z_],repr$5],
          [0,equal$35,different$25])
        [1],
       _eV_],
     _eX_=
      [0,
       _a$_
        (cst_Class,
         [0,
          Make0$6
            ([0,
              compare,
              less_than,
              less_or_equal,
              greater_than,
              greater_or_equal,
              between,
              between_or_equal,
              min,
              max,
              min_max,
              [0,_a_,_b_,_d_,_c_],
              repr$5,
              equal$8],
             [0,ordered$2,equal$35])
           [1],
          _eW_]),
       _eH_];
    function make$4(x,expected)
     {var
       _Nu_=
        [246,function(_Nv_){return check_float_exact(expected,Math.ceil(x))}];
      return caml_call2(_bc_(_eY_),x,_Nu_)}
    var
     _eZ_=[0,make$4(1,1),0],
     _e0_=[0,make$4(0.99,1),_eZ_],
     _e1_=[0,make$4(0.01,1),_e0_],
     _e2_=[0,make$4(0,0),_e1_],
     _e3_=[0,make$4(-0.1,0),_e2_],
     _e4_=[0,make$4(-0.99,0),_e3_],
     _e5_=[0,_a$_(cst_ceil,[0,make$4(-1,-1),_e4_]),_eX_],
     _e6_=
      [0,
       Make0$8([0,try_of_string$2,of_string$2,equal$7,repr$4],[0,of_string$6])
        [1],
       _e5_],
     test$12=
      _a$_
       (cst_Float,
        [0,
         Make0$13
           ([0,
             [0,
              _I_,
              _J_,
              _L_,
              _K_,
              _M_,
              _N_,
              _O_,
              _P_,
              exponentiate$1,
              _a_,
              _b_,
              _d_,
              _c_,
              mod$0],
             to_string$4,
             equal$7,
             different$5,
             try_of_string$2,
             of_string$2,
             repr$4,
             zero$0,
             one$0,
             negate$0,
             add$0,
             substract$0,
             multiply$0,
             divide$0,
             square$0,
             exponentiate$1,
             of_int$0,
             of_float$0,
             compare,
             less_than,
             less_or_equal,
             greater_than,
             greater_or_equal,
             between,
             between_or_equal,
             min,
             max,
             min_max,
             abs$0,
             modulo$0,
             to_int$0,
             to_float$0],
            [0,
             repr$25,
             different$24,
             of_string$6,
             repr$25,
             add_substract$1,
             negate$3,
             multiply$3,
             divide$3,
             exponentiate$2,
             ordered$1,
             equal$34])
          [1],
         _e6_]),
     zero$6=Big_int$1[1],
     one$5=Big_int$1[2],
     of_int$4=Big_int$1[36],
     to_int$3=Big_int$1[38];
    function of_float$4(x)
     {function of_small_float(x)
       {var _Nt_=Big_int$1[42];
        return caml_call2(_au_,caml_call2(_au_,x,of_float$3),_Nt_)}
      var match=caml_frexp_float(x),exponent=match[2],significand=match[1];
      if(caml_lessequal(exponent,58))return of_small_float(x);
      var _Ns_=of_small_float(caml_ldexp_float(significand,58));
      return caml_call2(Big_int$1[53],_Ns_,exponent - 58 | 0)}
    var to_float$3=Big_int$1[49],of_string$7=Big_int$1[34];
    function try_of_string$5(s)
     {return or_none([246,function(_Nr_){return caml_call1(of_string$7,s)}])}
    var
     repr$27=Big_int$1[33],
     abs$6=Big_int$1[4],
     negate$4=Big_int$1[3],
     add$3=Big_int$1[5],
     substract$3=Big_int$1[8],
     multiply$4=Big_int$1[10],
     divide$4=Big_int$1[15],
     modulo$3=Big_int$1[16],
     square$3=Big_int$1[12];
    function exponentiate$3(x,n)
     {return caml_lessthan(n,0)
              ?caml_call1(invalid_argument(_e7_),n)
              :caml_call2(Big_int$1[19],x,n)}
    var
     pred$5=Big_int$1[9],
     succ$5=Big_int$1[6],
     equal$36=Big_int$1[24],
     _e8_=Big_int$1[23];
    function compare$15(_Np_,_Nq_){return of_standard(_e8_,_Np_,_Nq_)}
    var
     less_than$12=Big_int$1[27],
     less_or_equal$12=Big_int$1[25],
     greater_than$12=Big_int$1[28],
     greater_or_equal$12=Big_int$1[26],
     _e9_=
      Make0$4
       ([0,less_than$12,less_or_equal$12,greater_than$12,greater_or_equal$12]),
     between$12=_e9_[1],
     between_or_equal$12=_e9_[2],
     _e__=Make0$5([0,compare$15]),
     min$13=_e__[1],
     max$13=_e__[2],
     min_max$12=_e__[3],
     include$8=Make0$1([0,equal$36]),
     different$26=include$8[1],
     _e$_=
      Make0$3
       ([0,less_than$12,less_or_equal$12,greater_than$12,greater_or_equal$12]),
     _fa_=_e$_[1],
     _fb_=_e$_[2],
     _fc_=_e$_[3],
     _fd_=_e$_[4],
     _fe_=Make0$0([0,equal$36,different$26]),
     _ff_=_fe_[1],
     _fg_=_fe_[2],
     include$9=
      Make0$9
       ([0,negate$4,add$3,substract$3,multiply$4,divide$4,exponentiate$3]),
     _fh_=include$9[1],
     _fi_=include$9[2],
     _fj_=include$9[3],
     _fk_=include$9[4],
     _fl_=include$9[5],
     _fm_=include$9[6],
     _fn_=include$9[7],
     _fo_=Big_int$1[36],
     _fp_=Big_int$1[34],
     _fq_=caml_call1(_fo_,-5),
     _fr_=[0,[0,caml_call1(_fo_,-6),_fq_],0],
     _fs_=caml_call1(_fo_,5),
     succ$6=[0,[0,caml_call1(_fo_,4),_fs_],_fr_],
     _ft_=[0,[0,caml_call1(_fo_,-10),0],0],
     equal$37=[0,[0,caml_call1(_fo_,4),0],_ft_],
     _fu_=[0,zero$6,[0,one$5,[0,caml_call1(_fo_,5),0]]],
     _fv_=[0,caml_call1(_fo_,-1),_fu_],
     ordered$3=[0,[0,caml_call1(_fo_,-3),_fv_],0],
     _fw_=caml_call1(_fp_,cst_10000000000000000000000000000000000000000),
     _fx_=[0,[0,caml_call1(_fo_,10),40,_fw_],0],
     _fy_=caml_call1(_fp_,cst_10000000000),
     exponentiate$4=[0,[0,caml_call1(_fo_,10),10,_fy_],_fx_],
     _fz_=caml_call1(_fo_,5),
     _fA_=caml_call1(_fo_,9),
     divide$5=[0,[0,caml_call1(_fo_,45),_fA_,_fz_],0],
     _fB_=caml_call1(_fo_,21),
     _fC_=caml_call1(_fo_,3),
     multiply$5=[0,[0,caml_call1(_fo_,7),_fC_,_fB_],0],
     _fD_=caml_call1(_fo_,12),
     negate$5=[0,[0,caml_call1(_fo_,-12),_fD_],0],
     _fE_=caml_call1(_fo_,127),
     _fF_=caml_call1(_fo_,27),
     add_substract$2=[0,[0,caml_call1(_fo_,100),_fF_,_fE_],0],
     _fG_=
      [0,
       [0,
        caml_call1(_fp_,cst_10000000000000000000000000000000000000000$1),
        cst_10000000000000000000000000000000000000000$0],
       0],
     to_string$11=[0,[0,caml_call1(_fo_,10),cst_10],_fG_],
     _fH_=caml_call1(_fo_,11),
     different$27=[0,[0,caml_call1(_fo_,10),_fH_],0],
     of_string$8=[0,[0,cst_100000,caml_call1(_fo_,1e5)],0],
     _fI_=0;
    function check$1(expected,x)
     {var _No_=of_float$4(x);
      return check(repr$27,equal$36,caml_call1(of_string$7,expected),_No_)}
    function make_2p(p,expected)
     {var _Nm_=[246,function(_Nn_){return check$1(expected,Math.pow(2,p))}];
      return caml_call2(_bc_(_fJ_),p,_Nm_)}
    function make_2pm2q(p,q,expected)
     {var
       _Nk_=
        [246,
         function(_Nl_)
          {return check$1(expected,Math.pow(2,p) - Math.pow(2,q))}];
      return caml_call3(_bc_(_fK_),p,q,_Nk_)}
    var
     _fL_=
      [0,
       make_2p
        (1023,
         cst_89884656743115795386465259539451236680898848947115328636715040578866337902750481566354238661203768010560056939935696678829394884407208311246423715319737062188883946712432742638151109800623047059726541476042502884419075341171231440736956555270413618581675255342293149119973622969239858152417678164812112068608),
       0],
     _fM_=
      [0,
       make_2p
        (222,
         cst_6739986666787659948666753771754907668409286105635143120275902562304),
       _fL_],
     _fN_=
      [0,
       make_2p
        (221,
         cst_3369993333393829974333376885877453834204643052817571560137951281152),
       _fM_],
     _fO_=
      [0,
       make_2p
        (220,
         cst_1684996666696914987166688442938726917102321526408785780068975640576),
       _fN_],
     _fP_=
      [0,
       make_2p
        (219,
         cst_842498333348457493583344221469363458551160763204392890034487820288),
       _fO_],
     _fQ_=
      [0,
       make_2p
        (218,
         cst_421249166674228746791672110734681729275580381602196445017243910144),
       _fP_],
     _fR_=
      [0,
       make_2p
        (217,
         cst_210624583337114373395836055367340864637790190801098222508621955072),
       _fQ_],
     _fS_=
      [0,
       make_2p
        (216,
         cst_105312291668557186697918027683670432318895095400549111254310977536),
       _fR_],
     _fT_=
      [0,
       make_2p
        (215,
         cst_52656145834278593348959013841835216159447547700274555627155488768),
       _fS_],
     _fU_=
      [0,
       make_2p
        (214,
         cst_26328072917139296674479506920917608079723773850137277813577744384),
       _fT_],
     _fV_=
      [0,
       make_2p
        (213,
         cst_13164036458569648337239753460458804039861886925068638906788872192),
       _fU_],
     _fW_=
      [0,
       make_2p
        (212,
         cst_6582018229284824168619876730229402019930943462534319453394436096),
       _fV_],
     _fX_=
      [0,
       make_2p
        (211,
         cst_3291009114642412084309938365114701009965471731267159726697218048),
       _fW_],
     _fY_=
      [0,
       make_2p
        (210,
         cst_1645504557321206042154969182557350504982735865633579863348609024),
       _fX_],
     _fZ_=
      [0,
       make_2p
        (209,
         cst_822752278660603021077484591278675252491367932816789931674304512),
       _fY_],
     _f0_=
      [0,
       make_2p
        (208,
         cst_411376139330301510538742295639337626245683966408394965837152256),
       _fZ_],
     _f1_=
      [0,
       make_2p
        (207,
         cst_205688069665150755269371147819668813122841983204197482918576128),
       _f0_],
     _f2_=
      [0,
       make_2p
        (206,
         cst_102844034832575377634685573909834406561420991602098741459288064),
       _f1_],
     _f3_=
      [0,
       make_2p
        (205,
         cst_51422017416287688817342786954917203280710495801049370729644032),
       _f2_],
     _f4_=
      [0,
       make_2p
        (204,
         cst_25711008708143844408671393477458601640355247900524685364822016),
       _f3_],
     _f5_=
      [0,
       make_2p
        (203,
         cst_12855504354071922204335696738729300820177623950262342682411008),
       _f4_],
     _f6_=
      [0,
       make_2p
        (202,
         cst_6427752177035961102167848369364650410088811975131171341205504),
       _f5_],
     _f7_=
      [0,
       make_2p
        (201,
         cst_3213876088517980551083924184682325205044405987565585670602752),
       _f6_],
     _f8_=
      [0,
       make_2p
        (200,
         cst_1606938044258990275541962092341162602522202993782792835301376),
       _f7_],
     _f9_=
      [0,
       make_2p
        (199,cst_803469022129495137770981046170581301261101496891396417650688),
       _f8_],
     _f__=
      [0,
       make_2p
        (198,cst_401734511064747568885490523085290650630550748445698208825344),
       _f9_],
     _f$_=
      [0,
       make_2p
        (197,cst_200867255532373784442745261542645325315275374222849104412672),
       _f__],
     _ga_=
      [0,
       make_2p
        (196,cst_100433627766186892221372630771322662657637687111424552206336),
       _f$_],
     _gb_=
      [0,
       make_2p
        (195,cst_50216813883093446110686315385661331328818843555712276103168),
       _ga_],
     _gc_=
      [0,
       make_2p
        (194,cst_25108406941546723055343157692830665664409421777856138051584),
       _gb_],
     _gd_=
      [0,
       make_2p
        (193,cst_12554203470773361527671578846415332832204710888928069025792),
       _gc_],
     _ge_=
      [0,
       make_2p
        (192,cst_6277101735386680763835789423207666416102355444464034512896),
       _gd_],
     _gf_=
      [0,
       make_2p
        (191,cst_3138550867693340381917894711603833208051177722232017256448),
       _ge_],
     _gg_=
      [0,
       make_2p
        (190,cst_1569275433846670190958947355801916604025588861116008628224),
       _gf_],
     _gh_=
      [0,
       make_2p
        (189,cst_784637716923335095479473677900958302012794430558004314112),
       _gg_],
     _gi_=
      [0,
       make_2p
        (188,cst_392318858461667547739736838950479151006397215279002157056),
       _gh_],
     _gj_=
      [0,
       make_2p
        (187,cst_196159429230833773869868419475239575503198607639501078528),
       _gi_],
     _gk_=
      [0,
       make_2p
        (186,cst_98079714615416886934934209737619787751599303819750539264),
       _gj_],
     _gl_=
      [0,
       make_2p
        (185,cst_49039857307708443467467104868809893875799651909875269632),
       _gk_],
     _gm_=
      [0,
       make_2p
        (184,cst_24519928653854221733733552434404946937899825954937634816),
       _gl_],
     _gn_=
      [0,
       make_2p
        (183,cst_12259964326927110866866776217202473468949912977468817408),
       _gm_],
     _go_=
      [0,
       make_2p
        (182,cst_6129982163463555433433388108601236734474956488734408704),
       _gn_],
     _gp_=
      [0,
       make_2p
        (181,cst_3064991081731777716716694054300618367237478244367204352),
       _go_],
     _gq_=
      [0,
       make_2p
        (180,cst_1532495540865888858358347027150309183618739122183602176),
       _gp_],
     _gr_=
      [0,
       make_2p(179,cst_766247770432944429179173513575154591809369561091801088),
       _gq_],
     _gs_=
      [0,
       make_2p(178,cst_383123885216472214589586756787577295904684780545900544),
       _gr_],
     _gt_=
      [0,
       make_2p(177,cst_191561942608236107294793378393788647952342390272950272),
       _gs_],
     _gu_=
      [0,
       make_2p(176,cst_95780971304118053647396689196894323976171195136475136),
       _gt_],
     _gv_=
      [0,
       make_2p(175,cst_47890485652059026823698344598447161988085597568237568),
       _gu_],
     _gw_=
      [0,
       make_2p(174,cst_23945242826029513411849172299223580994042798784118784),
       _gv_],
     _gx_=
      [0,
       make_2p(173,cst_11972621413014756705924586149611790497021399392059392),
       _gw_],
     _gy_=
      [0,
       make_2p(172,cst_5986310706507378352962293074805895248510699696029696),
       _gx_],
     _gz_=
      [0,
       make_2p(171,cst_2993155353253689176481146537402947624255349848014848),
       _gy_],
     _gA_=
      [0,
       make_2p(170,cst_1496577676626844588240573268701473812127674924007424),
       _gz_],
     _gB_=
      [0,
       make_2p(169,cst_748288838313422294120286634350736906063837462003712),
       _gA_],
     _gC_=
      [0,
       make_2p(168,cst_374144419156711147060143317175368453031918731001856),
       _gB_],
     _gD_=
      [0,
       make_2p(167,cst_187072209578355573530071658587684226515959365500928),
       _gC_],
     _gE_=
      [0,
       make_2p(166,cst_93536104789177786765035829293842113257979682750464),
       _gD_],
     _gF_=
      [0,
       make_2p(165,cst_46768052394588893382517914646921056628989841375232),
       _gE_],
     _gG_=
      [0,
       make_2p(164,cst_23384026197294446691258957323460528314494920687616),
       _gF_],
     _gH_=
      [0,
       make_2p(163,cst_11692013098647223345629478661730264157247460343808),
       _gG_],
     _gI_=
      [0,
       make_2p(162,cst_5846006549323611672814739330865132078623730171904),
       _gH_],
     _gJ_=
      [0,
       make_2p(161,cst_2923003274661805836407369665432566039311865085952),
       _gI_],
     _gK_=
      [0,
       make_2p(160,cst_1461501637330902918203684832716283019655932542976),
       _gJ_],
     _gL_=
      [0,
       make_2p(159,cst_730750818665451459101842416358141509827966271488),
       _gK_],
     _gM_=
      [0,
       make_2p(158,cst_365375409332725729550921208179070754913983135744),
       _gL_],
     _gN_=
      [0,
       make_2p(157,cst_182687704666362864775460604089535377456991567872),
       _gM_],
     _gO_=
      [0,
       make_2p(156,cst_91343852333181432387730302044767688728495783936),
       _gN_],
     _gP_=
      [0,
       make_2p(155,cst_45671926166590716193865151022383844364247891968),
       _gO_],
     _gQ_=
      [0,
       make_2p(154,cst_22835963083295358096932575511191922182123945984),
       _gP_],
     _gR_=
      [0,
       make_2p(153,cst_11417981541647679048466287755595961091061972992),
       _gQ_],
     _gS_=
      [0,make_2p(152,cst_5708990770823839524233143877797980545530986496),_gR_],
     _gT_=
      [0,make_2p(151,cst_2854495385411919762116571938898990272765493248),_gS_],
     _gU_=
      [0,make_2p(150,cst_1427247692705959881058285969449495136382746624),_gT_],
     _gV_=
      [0,make_2p(149,cst_713623846352979940529142984724747568191373312),_gU_],
     _gW_=
      [0,make_2p(148,cst_356811923176489970264571492362373784095686656),_gV_],
     _gX_=
      [0,make_2p(147,cst_178405961588244985132285746181186892047843328),_gW_],
     _gY_=
      [0,make_2p(146,cst_89202980794122492566142873090593446023921664),_gX_],
     _gZ_=
      [0,make_2p(145,cst_44601490397061246283071436545296723011960832),_gY_],
     _g0_=
      [0,make_2p(144,cst_22300745198530623141535718272648361505980416),_gZ_],
     _g1_=
      [0,make_2p(143,cst_11150372599265311570767859136324180752990208),_g0_],
     _g2_=
      [0,make_2p(142,cst_5575186299632655785383929568162090376495104),_g1_],
     _g3_=
      [0,make_2p(141,cst_2787593149816327892691964784081045188247552),_g2_],
     _g4_=
      [0,make_2p(140,cst_1393796574908163946345982392040522594123776),_g3_],
     _g5_=[0,make_2p(139,cst_696898287454081973172991196020261297061888),_g4_],
     _g6_=[0,make_2p(138,cst_348449143727040986586495598010130648530944),_g5_],
     _g7_=[0,make_2p(137,cst_174224571863520493293247799005065324265472),_g6_],
     _g8_=[0,make_2p(136,cst_87112285931760246646623899502532662132736),_g7_],
     _g9_=[0,make_2p(135,cst_43556142965880123323311949751266331066368),_g8_],
     _g__=[0,make_2p(134,cst_21778071482940061661655974875633165533184),_g9_],
     _g$_=[0,make_2p(133,cst_10889035741470030830827987437816582766592),_g__],
     _ha_=[0,make_2p(132,cst_5444517870735015415413993718908291383296),_g$_],
     _hb_=[0,make_2p(131,cst_2722258935367507707706996859454145691648),_ha_],
     _hc_=[0,make_2p(130,cst_1361129467683753853853498429727072845824),_hb_],
     _hd_=[0,make_2p(129,cst_680564733841876926926749214863536422912),_hc_],
     _he_=[0,make_2p(128,cst_340282366920938463463374607431768211456),_hd_],
     _hf_=[0,make_2p(127,cst_170141183460469231731687303715884105728),_he_],
     _hg_=[0,make_2p(126,cst_85070591730234615865843651857942052864),_hf_],
     _hh_=[0,make_2p(125,cst_42535295865117307932921825928971026432),_hg_],
     _hi_=[0,make_2p(124,cst_21267647932558653966460912964485513216),_hh_],
     _hj_=[0,make_2p(123,cst_10633823966279326983230456482242756608),_hi_],
     _hk_=[0,make_2p(122,cst_5316911983139663491615228241121378304),_hj_],
     _hl_=[0,make_2p(121,cst_2658455991569831745807614120560689152),_hk_],
     _hm_=[0,make_2p(120,cst_1329227995784915872903807060280344576),_hl_],
     _hn_=[0,make_2p(119,cst_664613997892457936451903530140172288),_hm_],
     _ho_=[0,make_2p(118,cst_332306998946228968225951765070086144),_hn_],
     _hp_=[0,make_2p(117,cst_166153499473114484112975882535043072),_ho_],
     _hq_=[0,make_2p(116,cst_83076749736557242056487941267521536),_hp_],
     _hr_=[0,make_2p(115,cst_41538374868278621028243970633760768),_hq_],
     _hs_=[0,make_2p(114,cst_20769187434139310514121985316880384),_hr_],
     _ht_=[0,make_2p(113,cst_10384593717069655257060992658440192),_hs_],
     _hu_=[0,make_2p(112,cst_5192296858534827628530496329220096),_ht_],
     _hv_=[0,make_2p(111,cst_2596148429267413814265248164610048),_hu_],
     _hw_=[0,make_2p(110,cst_1298074214633706907132624082305024),_hv_],
     _hx_=[0,make_2p(109,cst_649037107316853453566312041152512),_hw_],
     _hy_=[0,make_2p(108,cst_324518553658426726783156020576256),_hx_],
     _hz_=[0,make_2p(107,cst_162259276829213363391578010288128),_hy_],
     _hA_=[0,make_2p(106,cst_81129638414606681695789005144064),_hz_],
     _hB_=[0,make_2p(105,cst_40564819207303340847894502572032),_hA_],
     _hC_=[0,make_2p(104,cst_20282409603651670423947251286016),_hB_],
     _hD_=[0,make_2p(103,cst_10141204801825835211973625643008),_hC_],
     _hE_=[0,make_2p(102,cst_5070602400912917605986812821504),_hD_],
     _hF_=[0,make_2p(101,cst_2535301200456458802993406410752),_hE_],
     _hG_=[0,make_2p(100,cst_1267650600228229401496703205376),_hF_],
     _hH_=[0,make_2p(99,cst_633825300114114700748351602688),_hG_],
     _hI_=[0,make_2p(98,cst_316912650057057350374175801344),_hH_],
     _hJ_=[0,make_2p(97,cst_158456325028528675187087900672),_hI_],
     _hK_=[0,make_2p(96,cst_79228162514264337593543950336),_hJ_],
     _hL_=[0,make_2p(95,cst_39614081257132168796771975168),_hK_],
     _hM_=[0,make_2p(94,cst_19807040628566084398385987584),_hL_],
     _hN_=[0,make_2p(93,cst_9903520314283042199192993792),_hM_],
     _hO_=[0,make_2p(92,cst_4951760157141521099596496896),_hN_],
     _hP_=[0,make_2p(91,cst_2475880078570760549798248448),_hO_],
     _hQ_=[0,make_2p(90,cst_1237940039285380274899124224),_hP_],
     _hR_=[0,make_2p(89,cst_618970019642690137449562112),_hQ_],
     _hS_=[0,make_2p(88,cst_309485009821345068724781056),_hR_],
     _hT_=[0,make_2p(87,cst_154742504910672534362390528),_hS_],
     _hU_=[0,make_2p(86,cst_77371252455336267181195264),_hT_],
     _hV_=[0,make_2p(85,cst_38685626227668133590597632),_hU_],
     _hW_=[0,make_2p(84,cst_19342813113834066795298816),_hV_],
     _hX_=[0,make_2p(83,cst_9671406556917033397649408),_hW_],
     _hY_=[0,make_2p(82,cst_4835703278458516698824704),_hX_],
     _hZ_=[0,make_2p(81,cst_2417851639229258349412352),_hY_],
     _h0_=[0,make_2p(80,cst_1208925819614629174706176),_hZ_],
     _h1_=[0,make_2p(79,cst_604462909807314587353088),_h0_],
     _h2_=[0,make_2p(78,cst_302231454903657293676544),_h1_],
     _h3_=[0,make_2p(77,cst_151115727451828646838272),_h2_],
     _h4_=[0,make_2p(76,cst_75557863725914323419136),_h3_],
     _h5_=[0,make_2p(75,cst_37778931862957161709568),_h4_],
     _h6_=[0,make_2p(74,cst_18889465931478580854784),_h5_],
     _h7_=[0,make_2p(73,cst_9444732965739290427392),_h6_],
     _h8_=[0,make_2p(72,cst_4722366482869645213696),_h7_],
     _h9_=[0,make_2p(71,cst_2361183241434822606848),_h8_],
     _h__=[0,make_2p(70,cst_1180591620717411303424),_h9_],
     _h$_=[0,make_2p(69,cst_590295810358705651712),_h__],
     _ia_=[0,make_2p(68,cst_295147905179352825856),_h$_],
     _ib_=[0,make_2p(67,cst_147573952589676412928),_ia_],
     _ic_=[0,make_2p(66,cst_73786976294838206464),_ib_],
     _id_=[0,make_2p(65,cst_36893488147419103232),_ic_],
     _ie_=[0,make_2p(64,cst_18446744073709551616),_id_],
     _if_=[0,make_2p(63,cst_9223372036854775808),_ie_],
     _ig_=[0,make_2p(62,cst_4611686018427387904),_if_],
     _ih_=[0,make_2p(61,cst_2305843009213693952),_ig_],
     _ii_=[0,make_2p(60,cst_1152921504606846976),_ih_],
     _ij_=[0,make_2p(59,cst_576460752303423488),_ii_],
     _ik_=[0,make_2p(58,cst_288230376151711744),_ij_],
     _il_=[0,make_2p(57,cst_144115188075855872),_ik_],
     _im_=[0,make_2p(56,cst_72057594037927936),_il_],
     _in_=[0,make_2p(55,cst_36028797018963968),_im_],
     _io_=[0,make_2p(54,cst_18014398509481984),_in_],
     _ip_=[0,make_2p(53,cst_9007199254740992),_io_],
     _iq_=[0,make_2p(52,cst_4503599627370496),_ip_],
     _ir_=[0,make_2p(51,cst_2251799813685248),_iq_],
     _is_=[0,make_2p(50,cst_1125899906842624),_ir_],
     _it_=[0,make_2p(49,cst_562949953421312),_is_],
     _iu_=[0,make_2p(48,cst_281474976710656),_it_],
     _iv_=[0,make_2p(47,cst_140737488355328),_iu_],
     _iw_=[0,make_2p(46,cst_70368744177664),_iv_],
     _ix_=[0,make_2p(45,cst_35184372088832),_iw_],
     _iy_=[0,make_2p(44,cst_17592186044416),_ix_],
     _iz_=[0,make_2p(43,cst_8796093022208),_iy_],
     _iA_=[0,make_2p(42,cst_4398046511104),_iz_],
     _iB_=[0,make_2p(41,cst_2199023255552),_iA_],
     _iC_=[0,make_2p(40,cst_1099511627776),_iB_],
     _iD_=[0,make_2p(39,cst_549755813888),_iC_],
     _iE_=[0,make_2p(38,cst_274877906944),_iD_],
     _iF_=[0,make_2p(37,cst_137438953472),_iE_],
     _iG_=[0,make_2p(36,cst_68719476736),_iF_],
     _iH_=[0,make_2p(35,cst_34359738368),_iG_],
     _iI_=[0,make_2p(34,cst_17179869184),_iH_],
     _iJ_=[0,make_2p(33,cst_8589934592),_iI_],
     _iK_=[0,make_2p(32,cst_4294967296),_iJ_],
     _iL_=[0,make_2p(31,cst_2147483648),_iK_],
     _iM_=[0,make_2p(30,cst_1073741824),_iL_],
     _iN_=[0,make_2p(29,cst_536870912),_iM_],
     _iO_=[0,make_2p(28,cst_268435456),_iN_],
     _iP_=[0,make_2p(27,cst_134217728),_iO_],
     _iQ_=[0,make_2p(26,cst_67108864),_iP_],
     _iR_=[0,make_2p(25,cst_33554432),_iQ_],
     _iS_=[0,make_2p(24,cst_16777216),_iR_],
     _iT_=[0,make_2p(23,cst_8388608),_iS_],
     _iU_=[0,make_2p(22,cst_4194304),_iT_],
     _iV_=[0,make_2p(21,cst_2097152),_iU_],
     _iW_=[0,make_2p(20,cst_1048576),_iV_],
     _iX_=[0,make_2p(19,cst_524288),_iW_],
     _iY_=[0,make_2p(18,cst_262144),_iX_],
     _iZ_=[0,make_2p(17,cst_131072),_iY_],
     _i0_=[0,make_2p(16,cst_65536),_iZ_],
     _i1_=[0,make_2p(15,cst_32768),_i0_],
     _i2_=[0,make_2p(14,cst_16384),_i1_],
     _i3_=[0,make_2p(13,cst_8192),_i2_],
     _i4_=[0,make_2p(12,cst_4096),_i3_],
     _i5_=[0,make_2p(11,cst_2048),_i4_],
     _i6_=[0,make_2p(10,cst_1024),_i5_],
     _i7_=[0,make_2p(9,cst_512),_i6_],
     _i8_=[0,make_2p(8,cst_256),_i7_],
     _i9_=[0,make_2p(7,cst_128),_i8_],
     _i__=[0,make_2p(6,cst_64),_i9_],
     _i$_=[0,make_2p(5,cst_32),_i__],
     _ja_=[0,make_2p(4,cst_16),_i$_],
     _jb_=[0,make_2p(3,cst_8),_ja_],
     _jc_=[0,make_2p(2,cst_4),_jb_],
     _jd_=[0,make_2p(1,cst_2),_jc_],
     _je_=[0,make_2pm2q(95,42,cst_39614081257132164398725464064),_jd_],
     _jf_=[0,make_2pm2q(57,4,cst_144115188075855856),_je_],
     _jg_=[0,make_2pm2q(56,3,cst_72057594037927928),_jf_],
     _jh_=[0,make_2pm2q(55,2,cst_36028797018963964),_jg_],
     _ji_=[0,make_2pm2q(54,1,cst_18014398509481982),_jh_],
     _jj_=[0,make_2pm2q(53,0,cst_9007199254740991),_ji_],
     _jk_=[0,make_2pm2q(52,0,cst_4503599627370495),_jj_],
     _jl_=[0,make_2pm2q(51,0,cst_2251799813685247),_jk_],
     _jm_=[0,make_2pm2q(50,0,cst_1125899906842623),_jl_],
     _jn_=[0,make_2pm2q(3,0,cst_7),_jm_],
     _jo_=[0,make_2pm2q(2,0,cst_3),_jn_],
     _jp_=[0,make_2pm2q(1,0,cst_1$0),_jo_],
     _jq_=[0,_a$_(cst_of_float$0,[0,make_2pm2q(0,0,cst_0$0),_jp_]),_fI_],
     _jr_=
      [0,
       _ba_
        (cst_exponentiate_of_int_2_4,
         [246,
          function(_Ni_)
           {return expect_exception
                    ([0,
                      InvalidArgument,
                      cst_BigInt_exponentiate_Negative_exponent_4],
                     [246,
                      function(_Nj_)
                       {return exponentiate$3(caml_call1(of_int$4,2),-4)}])}]),
       _jq_],
     _js_=
      [0,
       Make0$8
         ([0,try_of_string$5,of_string$7,equal$36,repr$27],[0,of_string$8])
        [1],
       _jr_],
     test$13=
      _a$_
       (cst_BigInt,
        [0,
         Make0$14
           ([0,
             [0,
              _ff_,
              _fg_,
              _fh_,
              _fi_,
              _fj_,
              _fk_,
              _fl_,
              _fm_,
              _fn_,
              _fa_,
              _fb_,
              _fc_,
              _fd_,
              modulo$3],
             repr$27,
             equal$36,
             different$26,
             try_of_string$5,
             of_string$7,
             repr$27,
             zero$6,
             one$5,
             negate$4,
             add$3,
             substract$3,
             multiply$4,
             divide$4,
             square$3,
             exponentiate$3,
             of_int$4,
             of_float$4,
             compare$15,
             less_than$12,
             less_or_equal$12,
             greater_than$12,
             greater_or_equal$12,
             between$12,
             between_or_equal$12,
             min$13,
             max$13,
             min_max$12,
             abs$6,
             modulo$3,
             to_int$3,
             to_float$3,
             succ$5,
             pred$5],
            [0,
             to_string$11,
             different$27,
             of_string$8,
             to_string$11,
             add_substract$2,
             negate$5,
             multiply$5,
             divide$5,
             exponentiate$4,
             ordered$3,
             equal$37,
             succ$6])
          [1],
         _js_]),
     _jt_=0,
     _ju_=
      [0,
       _ba_
        (cst_xor_false_false,
         [246,function(_Nh_){return check_false(xor(0,0))}]),
       _jt_],
     _jv_=
      [0,
       _ba_
        (cst_xor_true_false,[246,function(_Ng_){return check_true(xor(1,0))}]),
       _ju_],
     _jw_=
      [0,
       _ba_
        (cst_xor_false_true,[246,function(_Nf_){return check_true(xor(0,1))}]),
       _jv_],
     _jx_=
      [0,
       _ba_
        (cst_xor_true_true,[246,function(_Ne_){return check_false(xor(1,1))}]),
       _jw_],
     _jy_=
      [0,
       _ba_(cst_false_false,[246,function(_Nd_){return check_false(0)}]),
       _jx_],
     _jz_=
      [0,_ba_(cst_false_true,[246,function(_Nc_){return check_true(1)}]),_jy_],
     _jA_=
      [0,
       _ba_(cst_true_whatever,[246,function(_Nb_){return check_true(1)}]),
       _jz_],
     _jB_=
      [0,
       _ba_
        (cst_or_false_false,[246,function(_Na_){return check_false(or(0,0))}]),
       _jA_],
     _jC_=
      [0,
       _ba_
        (cst_or_true_false,[246,function(_M$_){return check_true(or(1,0))}]),
       _jB_],
     _jD_=
      [0,
       _ba_
        (cst_or_false_true,[246,function(_M__){return check_true(or(0,1))}]),
       _jC_],
     _jE_=
      [0,
       _ba_(cst_or_true_true,[246,function(_M9_){return check_true(or(1,1))}]),
       _jD_],
     _jF_=
      [0,
       _ba_(cst_false_whatever,[246,function(_M8_){return check_false(0)}]),
       _jE_],
     _jG_=
      [0,
       _ba_(cst_true_false,[246,function(_M7_){return check_false(0)}]),
       _jF_],
     _jH_=
      [0,_ba_(cst_true_true,[246,function(_M6_){return check_true(1)}]),_jG_],
     _jI_=
      [0,
       _ba_
        (cst_and_false_false,
         [246,function(_M5_){return check_false(and(0,0))}]),
       _jH_],
     _jJ_=
      [0,
       _ba_
        (cst_and_true_false,
         [246,function(_M4_){return check_false(and(1,0))}]),
       _jI_],
     _jK_=
      [0,
       _ba_
        (cst_and_false_true,
         [246,function(_M3_){return check_false(and(0,1))}]),
       _jJ_],
     _jL_=
      [0,
       _ba_
        (cst_and_true_true,[246,function(_M2_){return check_true(and(1,1))}]),
       _jK_],
     _jM_=
      [0,_ba_(cst_not_false,[246,function(_M1_){return check_true(1)}]),_jL_],
     _jN_=
      [0,_ba_(cst_not_true,[246,function(_M0_){return check_false(0)}]),_jM_],
     _jO_=
      [0,
       Make0$8([0,try_of_string$0,of_string$1,equal$3,repr$0],[0,of_string$9])
        [1],
       _jN_],
     _jP_=[0,Make0$7([0,to_string$2],[0,repr$28])[1],_jO_],
     test$14=
      _a$_
       (cst_Bool,
        [0,
         Make0$12
           ([0,
             [0,_n_,_o_,_a_,_b_,_d_,_c_],
             equal$3,
             different$3,
             repr$0,
             compare,
             less_than,
             less_or_equal,
             greater_than,
             greater_or_equal,
             between,
             between_or_equal,
             min,
             max,
             min_max],
            [0,different$28,repr$28,ordered$4,equal$38])
          [1],
         _jP_]),
     of_string$10=Stdlib_bytes[5],
     to_string$12=Stdlib_bytes[6],
     get$3=runtime.caml_bytes_get,
     set$3=caml_bytes_set,
     size$2=runtime.caml_ml_bytes_length,
     empty$2=Stdlib_bytes[3],
     make$5=caml_create_bytes;
    function exponentiate_negative_exponent$0(param,_MZ_,n)
     {return caml_call1(invalid_argument(_jQ_),n)}
    var
     exponentiate$5=
      Make0$10([0,one,square,multiply,exponentiate_negative_exponent$0])[1],
     _jR_=0,
     _jS_=
      [0,
       _ba_
        (cst_exponentiate_2_4,
         [246,
          function(_MX_)
           {return expect_exception
                    ([0,
                      InvalidArgument,
                      cst_Int_exponentiate_Negative_exponent_4],
                     [246,function(_MY_){return caml_call2(exponentiate$5,2,-4)}])}]),
       _jR_],
     _jT_=
      [0,
       Make0$8([0,try_of_string,of_string$0,equal$2,repr],[0,of_string$11])[1],
       _jS_],
     test$15=
      _a$_
       (cst_Int,
        [0,
         Make0$14
           ([0,
             [0,
              _e_,
              _f_,
              _h_,
              _g_,
              _i_,
              _j_,
              _k_,
              _l_,
              exponentiate$5,
              _a_,
              _b_,
              _d_,
              _c_,
              mod],
             to_string$1,
             equal$2,
             different$2,
             try_of_string,
             of_string$0,
             repr,
             zero,
             one,
             negate,
             add,
             substract,
             multiply,
             divide,
             square,
             exponentiate$5,
             of_int,
             of_float,
             compare,
             less_than,
             less_or_equal,
             greater_than,
             greater_or_equal,
             between,
             between_or_equal,
             min,
             max,
             min_max,
             abs,
             modulo,
             to_int,
             to_float,
             succ,
             pred],
            [0,
             repr$29,
             different$29,
             of_string$11,
             repr$29,
             add_substract$3,
             negate$6,
             multiply$6,
             divide$6,
             exponentiate$6,
             ordered$5,
             equal$39,
             succ$7])
          [1],
         _jT_]),
     different$30=Make1$0([0,equal$5])[1];
    function Specialize(A)
     {var
       ToList=
        [0,
         map$0,
         map_acc,
         map_i,
         filter$0,
         filter_acc,
         filter_i,
         filter_map$0,
         filter_map_acc,
         filter_map_i,
         flat_map,
         flat_map_acc,
         flat_map_i,
         scan,
         scan_acc,
         scan_i,
         scan_short,
         scan_short_acc,
         scan_short_i];
      return [0,
              different$30,
              OCSA,
              empty,
              singleton,
              prepend,
              of_list,
              to_list,
              of_array,
              to_array,
              is_empty,
              try_head,
              try_tail,
              head,
              tail,
              reverse,
              rev_concat,
              concat$0,
              O$2,
              map$0,
              map_acc,
              map_i,
              flat_map,
              flat_map_acc,
              flat_map_i,
              filter$0,
              filter_acc,
              filter_i,
              filter_map$0,
              filter_map_acc,
              filter_map_i,
              fold,
              fold_acc,
              fold_i,
              try_reduce_acc,
              try_reduce,
              try_reduce_i,
              reduce_acc,
              reduce,
              reduce_i,
              scan,
              scan_acc,
              scan_i,
              iter$0,
              iter_acc,
              iter_i,
              count,
              count_acc,
              count_i,
              try_find,
              try_find_acc,
              try_find_i,
              find,
              find_acc,
              find_i,
              there_exists,
              there_exists_acc,
              there_exists_i,
              for_all,
              for_all_acc,
              for_all_i,
              try_find_map,
              try_find_map_acc,
              try_find_map_i,
              find_map,
              find_map_acc,
              find_map_i,
              fold_short,
              fold_short_acc,
              fold_short_i,
              try_reduce_short_acc,
              try_reduce_short,
              try_reduce_short_i,
              reduce_short_acc,
              reduce_short,
              reduce_short_i,
              scan_short,
              scan_short_acc,
              scan_short_i,
              iter_short,
              iter_short_acc,
              iter_short_i,
              contains,
              Poly$0,
              size,
              join,
              repr$2,
              Two,
              OCLL,
              equal$5,
              cartesian_product,
              ToList]}
    function SpecializeEquatable(A)
     {function contains$0(xs,x){return contains(xs,x,A[1])}
      return [0,contains$0]}
    var
     equal$40=[0,[0,empty,_jV_],_jU_],
     _jW_=0,
     _jY_=
      [0,
       _ba_
        (cst_iter,
         [246,
          function(_MW_)
           {var p=caml_call1(ref$0,2);
            iter$0
             (_jX_,
              function(n)
               {return caml_call2
                        (_ay_,p,caml_call2(exponentiate$5,caml_call1(_ax_,p),n))});
            return check_int(4096,caml_call1(_ax_,p))}]),
       _jW_],
     _jZ_=
      [0,
       _ba_
        (cst_try_reduce,
         [246,
          function(_MV_){return check_none_int(try_reduce(0,exponentiate$5))}]),
       _jY_],
     _j1_=
      [0,
       _ba_
        (cst_try_reduce$0,
         [246,
          function(_MU_)
           {return check_some_int(4096,try_reduce(_j0_,exponentiate$5))}]),
       _jZ_],
     _j3_=
      [0,
       _ba_
        (cst_reduce,
         [246,
          function(_MT_){return check_int(4096,reduce(_j2_,exponentiate$5))}]),
       _j1_],
     _j6_=
      [0,
       _ba_
        (cst_reduce_0,
         [246,
          function(_MS_)
           {return check_int
                    (0,reduce(_j5_,function(param){return failure(_j4_)}))}]),
       _j3_],
     _j9_=
      [0,
       _ba_
        (cst_fold,
         [246,
          function(_MR_)
           {return check_string(cst_init_3_4,fold(cst_init,_j8_,apply(_j7_)))}]),
       _j6_],
     _j$_=
      [0,
       _ba_
        (cst_fold$0,
         [246,
          function(_MQ_)
           {return check_int
                    (0,fold(0,0,function(param){return failure(_j__)}))}]),
       _j9_],
     _ka_=
      [0,
       _ba_
        (cst_tail,
         [246,
          function(_MO_)
           {return expect_exception
                    ([0,Failure,cst_List_tail],
                     [246,function(_MP_){return tail(0)}])}]),
       _j$_],
     _kd_=
      [0,
       _ba_
        (cst_tail$0,
         [246,function(_MN_){return check_int_list(_kc_,tail(_kb_))}]),
       _ka_],
     _ke_=
      [0,
       _ba_
        (cst_head,
         [246,
          function(_ML_)
           {return expect_exception
                    ([0,Failure,cst_List_head],
                     [246,function(_MM_){return head(0)}])}]),
       _kd_],
     _kg_=
      [0,
       _ba_(cst_head$0,[246,function(_MK_){return check_int(1,head(_kf_))}]),
       _ke_],
     _kh_=
      [0,
       _ba_
        (cst_try_tail,
         [246,
          function(_ME_)
           {var _MF_=try_tail(0);
            function _MG_(_MI_)
             {return function(_MJ_){return equal$5(_MI_,_MJ_,equal$7)}}
            return check_none
                    (function(_MH_){return repr$2(_MH_,repr$4)},_MG_,_MF_)}]),
       _kg_],
     _kk_=
      [0,
       _ba_
        (cst_try_tail$0,
         [246,
          function(_My_)
           {var _Mz_=try_tail(_ki_);
            function _MA_(_MC_)
             {return function(_MD_){return equal$5(_MC_,_MD_,equal$2)}}
            return check_some
                    (function(_MB_){return repr$2(_MB_,repr)},_MA_,_kj_,_Mz_)}]),
       _kh_],
     _kl_=
      [0,
       _ba_
        (cst_try_head,
         [246,function(_Mx_){return check_none_int(try_head(0))}]),
       _kk_],
     _kn_=
      [0,
       _ba_
        (cst_try_head$0,
         [246,function(_Mw_){return check_some_int(1,try_head(_km_))}]),
       _kl_],
     _kq_=
      [0,
       _ba_
        (cst_prepend,
         [246,function(_Mv_){return check_int_list(_kp_,[0,1,_ko_])}]),
       _kn_],
     _ku_=
      [0,
       _ba_
        (cst_concat,
         [246,function(_Mu_){return check_int_list(_kt_,concat$0(_ks_,_kr_))}]),
       _kq_],
     _kx_=
      [0,
       _ba_
        (cst_reverse,
         [246,function(_Mt_){return check_string_list(_kw_,reverse(_kv_))}]),
       _ku_],
     _ky_=
      [0,
       Make1$2
         ([0,
           map$0,
           map_i,
           map_acc,
           filter$0,
           filter_i,
           filter_acc,
           filter_map$0,
           filter_map_i,
           filter_map_acc,
           flat_map,
           flat_map_i,
           flat_map_acc,
           to_list,
           of_list])
        [1],
       _kx_],
     _kz_=
      [0,
       Make1$1
         ([0,equal$5,different$30,repr$2],
          [0,[0,equal$2,repr],equal$40,different$31])
        [1],
       _ky_],
     test$16=_a$_(cst_List,[0,Make1([0,repr$2],[0,[0,repr],repr$30])[1],_kz_]);
    function stack(n)
     {return 0 === n?[0,[0,current(0,0)],0]:[0,0,stack(n - 1 | 0)]}
    function _kA_(_Ms_){return filter_map$0(_Ms_,identity$0)}
    var
     stack$0=caml_call2(_au_,caml_call2(_au_,stack(2),_kA_),head),
     _kB_=0,
     _kC_=
      javascript
       ?cst$5
       :cst_Raised_by_primitive_operation_at_file_Implementation_CallStack_ml_line_3_characters_15_49_Called_from_file_Implementation_CallStack_ml_line_4_characters_15_30_Called_from_file_Implementation_CallStack_ml_line_4_characters_15_30_Called_from_file_Implementation_CallStack_ml_line_7_characters_2_9,
     to_string$13=[0,[0,stack$0,_kC_],_kB_],
     LocationExamples=[0,repr$31],
     match=frames(stack$0),
     _kD_=0;
    if(match)
     var
      frame=match[1],
      _kE_=0,
      _kG_=
       [0,
        _ba_
         (cst_location,
          [246,
           function(_Mr_)
            {return check_some(repr$3,equal$6,_kF_,caml_call1(Frame[2],frame))}]),
        _kE_],
      _kH_=
       [0,
        _ba_
         (cst_format_1,
          [246,
           function(_Mq_)
            {return check_some_string
                     (cst_Called_from_file_Implementation_CallStack_ml_line_3_characters_15_49,
                      caml_call2(Frame[3],1,frame))}]),
        _kG_],
      _kI_=
       [0,
        _ba_
         (cst_format_0,
          [246,
           function(_Mp_)
            {return check_some_string
                     (cst_Raised_by_primitive_operation_at_file_Implementation_CallStack_ml_line_3_characters_15_49,
                      caml_call2(Frame[3],0,frame))}]),
        _kH_];
    else
     var _kI_=0;
    var
     _kJ_=[0,_a$_(cst_Frame,_kI_),_kD_],
     _kK_=
      [0,_a$_(cst_Location,[0,Make0([0,repr$3],LocationExamples)[1],0]),_kJ_],
     _kL_=
      [0,
       _ba_
        (cst_frames,
         [246,
          function(_Mm_)
           {var
             _Mn_=caml_call2(_au_,caml_call2(_au_,stack$0,frames),size),
             _Mo_=javascript?0:4;
            return check_int(_Mo_,_Mn_)}]),
       _kK_],
     _kM_=[0,Make0([0,to_string$3],[0,to_string$13])[1],_kL_],
     test$17=
      _a$_
       (cst_CallStack,[0,Make0$7([0,to_string$3],[0,to_string$13])[1],_kM_]),
     of_int$5=Stdlib[1][17];
    function to_int$4(_Ml_){return _Ml_}
    function repeat(c,len){return caml_call2(Stdlib_string[1],len,c)}
    function to_string$14(c){return caml_call2(Stdlib_string[1],1,c)}
    var
     _kN_=0,
     _kO_=0,
     _kR_=
      [0,
       _ba_
        (cst_uncurry,
         [246,
          function(_Mj_)
           {var _Mk_=apply(_kQ_);
            return check_string
                    (cst_7_2_4_5_3,
                     caml_call1(caml_call1(Function5[3],_Mk_),_kP_))}]),
       _kO_],
     _kS_=
      [0,
       _ba_
        (cst_curry,
         [246,
          function(_Mc_)
           {var _Md_=2,_Me_=5,_Mf_=3,_Mg_=2,_Mh_=7;
            function _Mi_(param)
             {var v=param[5],u=param[4],z=param[3],y=param[2],x=param[1];
              return ((x - caml_mul(y,z) | 0) + u | 0) - v | 0}
            return check_int
                    (4,
                     caml_call5
                      (caml_call1(Function5[2],_Mi_),_Mh_,_Mg_,_Mf_,_Me_,_Md_))}]),
       _kR_],
     _kU_=
      [0,
       _a$_
        (cst_Function5,
         [0,
          _ba_
           (cst_flip,
            [246,
             function(_Ma_)
              {var _Mb_=apply(_kT_);
               return check_string
                       (cst_2_7_5_9_3,
                        caml_call5(caml_call1(Function5[1],_Mb_),3,9,5,7,2))}]),
          _kS_]),
       _kN_],
     _kV_=0,
     _kY_=
      [0,
       _ba_
        (cst_uncurry$0,
         [246,
          function(_L__)
           {var _L$_=apply(_kX_);
            return check_string
                    (cst_7_2_4_5,caml_call1(caml_call1(Function4[3],_L$_),_kW_))}]),
       _kV_],
     _kZ_=
      [0,
       _ba_
        (cst_curry$0,
         [246,
          function(_L4_)
           {var _L5_=5,_L6_=3,_L7_=2,_L8_=7;
            function _L9_(param)
             {var u=param[4],z=param[3],y=param[2],x=param[1];
              return (x - caml_mul(y,z) | 0) + u | 0}
            return check_int
                    (6,
                     caml_call4
                      (caml_call1(Function4[2],_L9_),_L8_,_L7_,_L6_,_L5_))}]),
       _kY_],
     _k1_=
      [0,
       _a$_
        (cst_Function4,
         [0,
          _ba_
           (cst_flip$0,
            [246,
             function(_L2_)
              {var _L3_=apply(_k0_);
               return check_string
                       (cst_2_7_5_9,
                        caml_call4(caml_call1(Function4[1],_L3_),9,5,7,2))}]),
          _kZ_]),
       _kU_],
     _k2_=0,
     _k5_=
      [0,
       _ba_
        (cst_uncurry$1,
         [246,
          function(_L0_)
           {var _L1_=apply(_k4_);
            return check_string
                    (cst_7_2_4,caml_call1(caml_call1(Function3[3],_L1_),_k3_))}]),
       _k2_],
     _k6_=
      [0,
       _ba_
        (cst_curry$1,
         [246,
          function(_LV_)
           {var _LW_=3,_LX_=2,_LY_=7;
            function _LZ_(param)
             {var z=param[3],y=param[2],x=param[1];
              return x - caml_mul(y,z) | 0}
            return check_int
                    (1,caml_call3(caml_call1(Function3[2],_LZ_),_LY_,_LX_,_LW_))}]),
       _k5_],
     _k8_=
      [0,
       _a$_
        (cst_Function3,
         [0,
          _ba_
           (cst_flip$1,
            [246,
             function(_LT_)
              {var _LU_=apply(_k7_);
               return check_string
                       (cst_2_7_5,caml_call3(caml_call1(Function3[1],_LU_),5,7,2))}]),
          _k6_]),
       _k1_],
     _k9_=0,
     _k$_=
      [0,
       _ba_
        (cst_uncurry$2,
         [246,
          function(_LS_)
           {return check_int(5,caml_call1(caml_call1(Function2[3],_j_),_k__))}]),
       _k9_],
     _la_=
      [0,
       _ba_
        (cst_curry$2,
         [246,
          function(_LO_)
           {var _LP_=2,_LQ_=7;
            function _LR_(param){var y=param[2],x=param[1];return x - y | 0}
            return check_int
                    (5,caml_call2(caml_call1(Function2[2],_LR_),_LQ_,_LP_))}]),
       _k$_],
     _lb_=
      [0,
       _a$_
        (cst_Function2,
         [0,
          _ba_
           (cst_flip$2,
            [246,
             function(_LN_)
              {return check_int
                       (128,
                        caml_call2(caml_call1(Function2[1],exponentiate$5),7,2))}]),
          _la_]),
       _k8_],
     _lc_=0,
     _le_=
      [0,
       _ba_
        (cst_compose,
         [246,
          function(_LI_)
           {var _LJ_=21;
            function _LK_(_LM_){return 2 * _LM_ | 0}
            var _LL_=apply(_ld_);
            return check_string
                    (cst_42,caml_call1(caml_call2(Function1[4],_LL_,_LK_),_LJ_))}]),
       _lc_],
     _lf_=
      [0,
       _ba_
        (cst_rev_apply,
         [246,
          function(_LF_)
           {function _LG_(_LH_){return 2 * _LH_ | 0}
            return check_42(caml_call2(Function1[3],21,_LG_))}]),
       _le_],
     _lg_=
      [0,
       _ba_
        (cst_apply,
         [246,
          function(_LB_)
           {var _LC_=21;
            function _LD_(_LE_){return 2 * _LE_ | 0}
            return check_42(caml_call2(Function1[2],_LD_,_LC_))}]),
       _lf_],
     test$18=
      _a$_
       (cst_Functions,
        [0,
         _a$_
          (cst_Function1,
           [0,
            _ba_
             (cst_identity_42,
              [246,
               function(_LA_){return check_42(caml_call1(Function1[1],42))}]),
            _lg_]),
         _lb_]);
    function seek(x,pos){return caml_call2(Stdlib[1][84][4],x,pos)}
    var pos=Stdlib[1][84][5],size$3=Stdlib[1][84][6];
    function with_file(s,f)
     {var file=caml_call1(Stdlib[1][67],s);
      try
       {var r=caml_call1(f,file);caml_call1(Stdlib[1][81],file);return r}
      catch(ex)
       {ex = caml_wrap_exception(ex);
        caml_call1(Stdlib[1][81],file);
        return raise(ex)}}
    function with_channel(s,f)
     {return with_file(s,caml_call2(_av_,f,identity$0))}
    var
     _lj_=[0,[0,make(_li_,_lh_,25),cst_3_to_23_step_4],0],
     _ll_=[0,[0,make(0,_lk_,-15),cst_0_down_to_12_step_3],_lj_],
     _lm_=[0,[0,make(0,0,5),cst_0_to_4_step_1],_ll_],
     _ln_=[0,[0,make(0,0,-5),cst$6],_lm_],
     repr$32=[0,[0,make(0,0,0),cst$7],_ln_],
     _lq_=[0,make(_lp_,_lo_,11),0],
     _lt_=[0,make(_ls_,_lr_,10),_lq_],
     _lw_=[0,[0,make(_lv_,_lu_,9),_lt_],0],
     _lz_=[0,make(_ly_,_lx_,10),0],
     _lA_=[0,[0,make(0,0,10),_lz_],_lw_],
     _lC_=[0,make(_lB_,0,3),[0,empty$0,0]],
     _lE_=[0,make(0,_lD_,10),_lC_],
     _lG_=[0,make(0,_lF_,10),_lE_],
     _lH_=[0,make(0,0,-4),_lG_],
     _lJ_=[0,make(0,_lI_,0),_lH_],
     equal$41=[0,[0,make(0,0,0),_lJ_],_lA_],
     _lM_=make(_lL_,_lK_,12),
     _lP_=[0,[0,make(_lO_,_lN_,11),_lM_],0],
     _lQ_=make(0,0,1),
     different$32=[0,[0,make(0,0,0),_lQ_],_lP_],
     _lR_=0,
     _lS_=0,
     _lW_=
      [0,
       _ba_
        (cst_with_step_0_and_start,
         [246,
          function(_Lz_)
           {return check_int_list(_lV_,to_list$1(make(_lU_,_lT_,-11)))}]),
       _lS_],
     _l0_=
      [0,
       _ba_
        (cst_with_step_0_and_start$0,
         [246,
          function(_Ly_)
           {return check_int_list(_lZ_,to_list$1(make(_lY_,_lX_,-10)))}]),
       _lW_],
     _l3_=
      [0,
       _ba_
        (cst_with_step_0,
         [246,
          function(_Lx_)
           {return check_int_list(_l2_,to_list$1(make(0,_l1_,-6)))}]),
       _l0_],
     _l6_=
      [0,
       _ba_
        (cst_with_step_0$0,
         [246,
          function(_Lw_)
           {return check_int_list(_l5_,to_list$1(make(0,_l4_,-6)))}]),
       _l3_],
     _l8_=
      [0,
       _ba_
        (cst_with_step_0$1,
         [246,
          function(_Lv_){return check_int_list(0,to_list$1(make(0,_l7_,6)))}]),
       _l6_],
     _ma_=
      [0,
       _ba_
        (cst_with_start_and_step,
         [246,
          function(_Lu_)
           {return check_int_list(_l$_,to_list$1(make(_l__,_l9_,9)))}]),
       _l8_],
     _me_=
      [0,
       _ba_
        (cst_with_start_and_step$0,
         [246,
          function(_Lt_)
           {return check_int_list(_md_,to_list$1(make(_mc_,_mb_,8)))}]),
       _ma_],
     _mi_=
      [0,
       _ba_
        (cst_with_start_and_step$1,
         [246,
          function(_Ls_)
           {return check_int_list(_mh_,to_list$1(make(_mg_,_mf_,8)))}]),
       _me_],
     _mm_=
      [0,
       _ba_
        (cst_with_start_and_step$2,
         [246,
          function(_Lr_)
           {return check_int_list(_ml_,to_list$1(make(_mk_,_mj_,7)))}]),
       _mi_],
     _mo_=
      [0,
       _ba_
        (cst_with_step_0$2,
         [246,
          function(_Lq_){return check_int_list(0,to_list$1(make(0,_mn_,6)))}]),
       _mm_],
     _mr_=
      [0,
       _ba_
        (cst_with_step,
         [246,
          function(_Lp_)
           {return check_int_list(_mq_,to_list$1(make(0,_mp_,6)))}]),
       _mo_],
     _mu_=
      [0,
       _ba_
        (cst_with_step$0,
         [246,
          function(_Lo_)
           {return check_int_list(_mt_,to_list$1(make(0,_ms_,5)))}]),
       _mr_],
     _mw_=
      [0,
       _ba_
        (cst_with_stop_start,
         [246,
          function(_Ln_){return check_int_list(0,to_list$1(make(_mv_,0,5)))}]),
       _mu_],
     _mx_=
      [0,
       _ba_
        (cst_with_stop_start$0,
         [246,
          function(_Lm_){return check_int_list(0,to_list$1(make(0,0,-5)))}]),
       _mw_],
     _my_=
      [0,
       _ba_
        (cst_with_stop_start$1,
         [246,function(_Ll_){return check_int_list(0,to_list$1(make(0,0,0)))}]),
       _mx_],
     _mz_=
      [0,
       _ba_
        (cst_with_stop_0,
         [246,
          function(_Lk_){return check_int_list(0,to_list$1(make(0,0,-5)))}]),
       _my_],
     _mC_=
      [0,
       _ba_
        (cst_with_start,
         [246,
          function(_Lj_)
           {return check_int_list(_mB_,to_list$1(make(_mA_,0,5)))}]),
       _mz_],
     _mE_=
      [0,
       _a$_
        (cst_to_list,
         [0,
          _ba_
           (cst_simplest,
            [246,
             function(_Li_)
              {return check_int_list(_mD_,to_list$1(make(0,0,5)))}]),
          _mC_]),
       _lR_],
     _mF_=
      [0,
       Make0$2([0,equal$10,different$8,O$4,repr$7],[0,equal$41,different$32])
        [1],
       _mE_],
     test$19=_a$_(cst_IntRange,[0,Make0([0,repr$7],[0,repr$32])[1],_mF_]),
     _mG_=0,
     _mJ_=
      [0,
       _ba_
        (cst_map_is_lazy,
         [246,
          function(param)
           {var
             x=[246,function(_Lh_){return failure(_mH_)}],
             y=map(x,function(param){return failure(_mI_)});
            return expect_exception
                    ([0,Failure,cst_You_called_me],
                     [246,function(_Lg_){return value(y)}])}]),
       _mG_],
     _mK_=
      [0,
       _ba_
        (cst_map$0,
         [246,
          function(_Le_)
           {return check_42
                    (value(map(21,function(_Lf_){return 2 * _Lf_ | 0})))}]),
       _mJ_],
     _mL_=
      [0,
       _ba_
        (cst_is_value,
         [246,
          function(param)
           {var x=[246,function(_Ld_){return 42}];
            check_false(caml_call1(is_value,x));
            check_42(value(x));
            return check_true(caml_call1(is_value,x))}]),
       _mK_],
     _mN_=
      [0,
       _ba_
        (cst_value_exc,
         [246,
          function(_La_)
           {return expect_exception
                    ([0,Failure,cst_nope],
                     [246,
                      function(_Lb_)
                       {return value([246,function(_Lc_){return failure(_mM_)}])}])}]),
       _mL_],
     test$20=
      _a$_
       (cst_Lazy,
        [0,
         _ba_(cst_value,[246,function(_K$_){return check_42(value(42))}]),
         _mN_]),
     zero$7=Stdlib_nativeint[1],
     one$6=Stdlib_nativeint[2],
     succ$8=Stdlib_nativeint[4],
     pred$6=Stdlib_nativeint[5],
     abs$7=Stdlib_nativeint[6],
     max_int$2=Stdlib_nativeint[8],
     min_int$2=Stdlib_nativeint[9],
     to_string$15=Stdlib_nativeint[12],
     compare$16=Stdlib_nativeint[13],
     equal$42=Stdlib_nativeint[14],
     _mO_=caml_int_of_string;
    function _mP_(_K__){return _K__}
    function _mQ_(_K9_){return _K9_ | 0}
    function _mR_(_K8_){return _K8_}
    function _mS_(_K7_){return _K7_}
    var _mT_=caml_mod,_mU_=caml_div;
    function _mV_(_K6_,_K5_){return caml_mul(_K6_,_K5_)}
    function _mW_(_K4_,_K3_){return _K4_ - _K3_ | 0}
    function _mX_(_K2_,_K1_){return _K2_ + _K1_ | 0}
    var
     include$10=
      Make
       ([0,
         name$2,
         repr_suffix$1,
         zero$7,
         one$6,
         function(_K0_){return - _K0_ | 0},
         _mX_,
         _mW_,
         _mV_,
         _mU_,
         _mT_,
         succ$8,
         pred$6,
         abs$7,
         max_int$2,
         min_int$2,
         _mS_,
         _mR_,
         _mQ_,
         _mP_,
         _mO_,
         to_string$15,
         compare$16,
         equal$42]),
     O$16=include$10[1],
     try_of_string$6=include$10[5],
     zero$8=include$10[8],
     one$7=include$10[9],
     add$4=include$10[11],
     substract$4=include$10[12],
     square$4=include$10[15],
     _m6_=include$10[16],
     of_int$6=include$10[17],
     of_float$5=include$10[18],
     compare$17=include$10[19],
     less_than$13=include$10[20],
     less_or_equal$13=include$10[21],
     greater_than$13=include$10[22],
     greater_or_equal$13=include$10[23],
     between$13=include$10[24],
     between_or_equal$13=include$10[25],
     min$14=include$10[26],
     max$14=include$10[27],
     min_max$13=include$10[28],
     abs$8=include$10[29],
     modulo$4=include$10[30],
     to_int$5=include$10[31],
     to_float$4=include$10[32],
     pred$7=include$10[34],
     smallest$3=include$10[35],
     greatest$3=include$10[36],
     _mY_=include$10[2],
     _mZ_=include$10[3],
     _m0_=include$10[4],
     _m1_=include$10[6],
     _m2_=include$10[7],
     _m3_=include$10[10],
     _m4_=include$10[13],
     _m5_=include$10[14],
     _m7_=include$10[33],
     _m8_=0,
     _m9_=
      [0,
       _ba_
        (cst_exponentiate_2n_4,
         [246,
          function(_KY_)
           {return expect_exception
                    ([0,
                      InvalidArgument,
                      cst_NativeInt_exponentiate_Negative_exponent_4],
                     [246,function(_KZ_){return caml_call2(_m6_,2,-4)}])}]),
       _m8_],
     _m__=
      [0,
       Make0$8
         ([0,include$10[5],include$10[6],include$10[3],include$10[7]],
          [0,of_string$12])
        [1],
       _m9_],
     test$21=
      _a$_
       (cst_NativeInt,
        [0,
         Make0$14
           ([0,
             include$10[1],
             include$10[2],
             include$10[3],
             include$10[4],
             include$10[5],
             include$10[6],
             include$10[7],
             include$10[8],
             include$10[9],
             include$10[10],
             include$10[11],
             include$10[12],
             include$10[13],
             include$10[14],
             include$10[15],
             include$10[16],
             include$10[17],
             include$10[18],
             include$10[19],
             include$10[20],
             include$10[21],
             include$10[22],
             include$10[23],
             include$10[24],
             include$10[25],
             include$10[26],
             include$10[27],
             include$10[28],
             include$10[29],
             include$10[30],
             include$10[31],
             include$10[32],
             include$10[33],
             include$10[34]],
            [0,
             to_string$16,
             different$33,
             of_string$12,
             repr$33,
             add_substract$4,
             negate$7,
             multiply$7,
             divide$7,
             exponentiate$7,
             ordered$6,
             equal$43,
             succ$9])
          [1],
         _m__]),
     different$34=Make1$0([0,equal$4])[1];
    function less_than$0(x,y,compare_a)
     {var match=compare$0(x,y,compare_a);return 0 === match?1:0}
    function less_or_equal$0(x,y,compare_a)
     {var match=compare$0(x,y,compare_a);return 2 <= match?0:1}
    function greater_than$0(x,y,compare_a)
     {var match=compare$0(x,y,compare_a);return 2 <= match?1:0}
    function greater_or_equal$0(x,y,compare_a)
     {var match=compare$0(x,y,compare_a);return 0 === match?0:1}
    function min$1(x,y,compare_a)
     {var match=compare$0(x,y,compare_a);return 0 === match?x:y}
    function max$1(x,y,compare_a)
     {var match=compare$0(x,y,compare_a);return 2 <= match?x:y}
    function min_max$0(x,y,compare_a)
     {var match=compare$0(x,y,compare_a);return 0 === match?[0,x,y]:[0,y,x]}
    function between$0(x,low,high,compare_a)
     {var _KX_=less_than$0(low,x,compare_a);
      return _KX_?greater_than$0(high,x,compare_a):_KX_}
    function between_or_equal$0(x,low,high,compare_a)
     {var _KW_=less_or_equal$0(low,x,compare_a);
      return _KW_?greater_or_equal$0(high,x,compare_a):_KW_}
    function Specialize$0(A)
     {return [0,
              equal$4,
              compare$0,
              repr$1,
              none,
              try_of_string$1,
              some_if,
              some_if$0,
              value_def,
              value$0,
              or_failure,
              func,
              value_map,
              is_some,
              is_none,
              iter,
              filter,
              filter_map,
              different$34,
              less_than$0,
              less_or_equal$0,
              greater_than$0,
              greater_or_equal$0,
              min$1,
              max$1,
              min_max$0,
              between$0,
              between_or_equal$0]}
    var
     _m$_=0,
     _nb_=
      [0,
       _ba_
        (cst_filter_map_Some_false,
         [246,
          function(_KV_)
           {return check_none_int(filter_map(_na_,function(param){return 0}))}]),
       _m$_],
     _ne_=
      [0,
       _ba_
        (cst_filter_map_Some_true,
         [246,
          function(_KU_)
           {return check_some_int
                    (57,filter_map(_nd_,function(param){return _nc_}))}]),
       _nb_],
     _ng_=
      [0,
       _ba_
        (cst_filter_map_None,
         [246,
          function(_KT_)
           {return check_none_int
                    (filter_map(0,function(param){return failure(_nf_)}))}]),
       _ne_],
     _ni_=
      [0,
       _ba_
        (cst_filter_Some_false,
         [246,
          function(_KS_)
           {return check_none_int(filter(_nh_,function(param){return 0}))}]),
       _ng_],
     _nk_=
      [0,
       _ba_
        (cst_filter_Some_true,
         [246,
          function(_KR_)
           {return check_some_42(filter(_nj_,function(param){return 1}))}]),
       _ni_],
     _nm_=
      [0,
       _ba_
        (cst_filter_None,
         [246,
          function(_KQ_)
           {return check_none_int
                    (filter(0,function(param){return failure(_nl_)}))}]),
       _nk_],
     _no_=
      [0,
       _ba_
        (cst_iter_Some,
         [246,
          function(_KP_)
           {var x=caml_call1(ref$0,0);
            iter(_nn_,function(n){return caml_call2(_ay_,x,n)});
            return check_42(caml_call1(_ax_,x))}]),
       _nm_],
     _nq_=
      [0,
       _ba_
        (cst_iter_None,
         [246,
          function(_KO_){return iter(0,function(param){return failure(_np_)})}]),
       _no_],
     _ns_=
      [0,
       _ba_
        (cst_value_map_Some,
         [246,
          function(_KM_)
           {return check_42
                    (value_map(_nr_,57,function(_KN_){return 2 * _KN_ | 0}))}]),
       _nq_],
     _nu_=
      [0,
       _ba_
        (cst_value_map_None,
         [246,
          function(_KL_)
           {return check_42
                    (value_map(0,42,function(param){return failure(_nt_)}))}]),
       _ns_],
     _nw_=
      [0,
       _ba_
        (cst_map_Some,
         [246,
          function(_KJ_)
           {return check_some_42
                    (func(_nv_,function(_KK_){return 2 * _KK_ | 0}))}]),
       _nu_],
     _ny_=
      [0,
       _ba_
        (cst_map_None,
         [246,
          function(_KI_)
           {return check_none_int
                    (func(0,function(param){return failure(_nx_)}))}]),
       _nw_],
     _nA_=
      [0,
       _ba_
        (cst_repr_None,
         [246,
          function(_KH_)
           {return check_string
                    (cst_None$0,repr$1(0,function(param){return failure(_nz_)}))}]),
       _ny_],
     _nB_=
      [0,
       _ba_
        (cst_value_exc_None,
         [246,
          function(_KF_)
           {return expect_exception
                    ([0,Failure,cst_Nope$0],
                     [246,
                      function(_KG_){return value$0([0,[0,Failure,cst_Nope]],0)}])}]),
       _nA_],
     _nC_=
      [0,
       _ba_
        (cst_value_None,
         [246,
          function(_KD_)
           {return expect_exception
                    ([0,Failure,cst_Option_value$0],
                     [246,function(_KE_){return value$0(0,0)}])}]),
       _nB_],
     _nE_=
      [0,
       _ba_
        (cst_value_Some,
         [246,function(_KC_){return check_string(cst_val,value$0(0,_nD_))}]),
       _nC_],
     _nG_=
      [0,
       _ba_
        (cst_value_def_Some,
         [246,
          function(_KB_)
           {return check_string(cst_val$0,value_def(_nF_,cst_def))}]),
       _nE_],
     _nH_=
      [0,
       _ba_
        (cst_value_def_None,
         [246,
          function(_KA_)
           {return check_string(cst_def$1,value_def(0,cst_def$0))}]),
       _nG_],
     _nJ_=
      [0,
       _ba_
        (cst_is_none_Some,
         [246,function(_Kz_){return check_false(is_none(_nI_))}]),
       _nH_],
     _nK_=
      [0,
       _ba_
        (cst_is_none_None,[246,function(_Ky_){return check_true(is_none(0))}]),
       _nJ_],
     _nM_=
      [0,
       _ba_
        (cst_is_some_Some,
         [246,function(_Kx_){return check_true(is_some(_nL_))}]),
       _nK_],
     _nN_=
      [0,
       _ba_
        (cst_is_some_None,
         [246,function(_Kw_){return check_false(is_some(0))}]),
       _nM_],
     _nO_=
      [0,
       _ba_
        (cst_some_if_false,
         [246,function(_Kv_){return check_none_int(some_if$0(0,42))}]),
       _nN_],
     _nP_=
      [0,
       _ba_
        (cst_some_if_true,
         [246,function(_Ku_){return check_some_42(some_if$0(1,42))}]),
       _nO_],
     _nR_=
      [0,
       _ba_
        (cst_some_if_false$0,
         [246,
          function(_Ks_)
           {return check_none_int
                    (some_if(0,[246,function(_Kt_){return failure(_nQ_)}]))}]),
       _nP_],
     _nS_=
      [0,
       _ba_
        (cst_some_if_true$0,
         [246,function(_Kr_){return check_some_42(some_if(1,42))}]),
       _nR_],
     _ds_=0,
     _cp_=[0,ordered$7,equal$44];
    function compare$6(x,y){return compare$0(x,y,compare)}
    function less_than$5(x,y){return less_than$0(x,y,compare)}
    function less_or_equal$5(x,y){return less_or_equal$0(x,y,compare)}
    function greater_than$5(x,y){return greater_than$0(x,y,compare)}
    function greater_or_equal$5(x,y){return greater_or_equal$0(x,y,compare)}
    function between$5(x,low,high){return between$0(x,low,high,compare)}
    function between_or_equal$5(x,low,high)
     {return between_or_equal$0(x,low,high,compare)}
    function min$6(x,y){return min$1(x,y,compare)}
    function max$6(x,y){return max$1(x,y,compare)}
    function min_max$5(x,y){return min_max$0(x,y,compare)}
    var
     O$9=
      Make0$3
       ([0,less_than$5,less_or_equal$5,greater_than$5,greater_or_equal$5]),
     repr$17=Specialize1([0,repr$1],[0,repr])[1],
     include$23=Specialize1$0([0,equal$4],[0,equal$2]),
     equal$24=include$23[1],
     _du_=[0,equal$2,repr],
     _dv_=[0,equal$4,different$34,repr$1],
     _dt_=
      [0,
       Make0$6
         ([0,
           compare$6,
           less_than$5,
           less_or_equal$5,
           greater_than$5,
           greater_or_equal$5,
           between$5,
           between_or_equal$5,
           min$6,
           max$6,
           min_max$5,
           O$9,
           repr$17,
           equal$24],
          _cp_)
        [1],
       _ds_],
     _dn_=[0,Make1([0,_dv_[3]],[0,[0,_du_[2]],repr$34])[1],0],
     test=
      _a$_
       (cst_Identifiable$0,
        [0,Make1$1(_dv_,[0,_du_,equal$44,different$35])[1],_dn_]),
     test$4=_a$_(cst_Able$0,[0,test,_dt_]),
     test$22=_a$_(cst_Option,[0,test$4,_nS_]),
     flush$0=Stdlib[1][51];
    function print(opt,channel,format)
     {if(opt)var sth=opt[1],do_flush=sth;else var do_flush=0;
      function _Kq_(channel)
       {return do_flush?caml_call1(flush$0,channel):do_flush}
      return caml_call3(Stdlib_printf[7],_Kq_,channel,format)}
    var output$0=Stdlib[1][55];
    function seek$0(x,pos){return caml_call2(Stdlib[1][84][1],x,pos)}
    var pos$0=Stdlib[1][84][2],size$4=Stdlib[1][84][3];
    function with_file$0(s,f)
     {var file=caml_call1(Stdlib[1][48],s);
      try
       {var r=caml_call1(f,file);caml_call1(Stdlib[1][64],file);return r}
      catch(ex)
       {ex = caml_wrap_exception(ex);
        caml_call1(Stdlib[1][64],file);
        return raise(ex)}}
    function with_channel$0(s,f)
     {return with_file$0(s,caml_call2(_av_,f,identity$0))}
    function less_than$1(x,y,compare_a,compare_b)
     {var match=compare$1(x,y,compare_a,compare_b);return 0 === match?1:0}
    function less_or_equal$1(x,y,compare_a,compare_b)
     {var match=compare$1(x,y,compare_a,compare_b);return 2 <= match?0:1}
    function greater_than$1(x,y,compare_a,compare_b)
     {var match=compare$1(x,y,compare_a,compare_b);return 2 <= match?1:0}
    function greater_or_equal$1(x,y,compare_a,compare_b)
     {var match=compare$1(x,y,compare_a,compare_b);return 0 === match?0:1}
    function min$2(x,y,compare_a,compare_b)
     {var match=compare$1(x,y,compare_a,compare_b);return 0 === match?x:y}
    function max$2(x,y,compare_a,compare_b)
     {var match=compare$1(x,y,compare_a,compare_b);return 2 <= match?x:y}
    function min_max$1(x,y,compare_a,compare_b)
     {var match=compare$1(x,y,compare_a,compare_b);
      return 0 === match?[0,x,y]:[0,y,x]}
    function different$9(x,y,equal_a,equal_b)
     {return 1 - equal$11(x,y,equal_a,equal_b)}
    function between$1(x,low,high,compare_a,compare_b)
     {var _Kp_=less_than$1(low,x,compare_a,compare_b);
      return _Kp_?greater_than$1(high,x,compare_a,compare_b):_Kp_}
    function between_or_equal$1(x,low,high,compare_a,compare_b)
     {var _Ko_=less_or_equal$1(low,x,compare_a,compare_b);
      return _Ko_?greater_or_equal$1(high,x,compare_a,compare_b):_Ko_}
    function less_than$2(x,y,compare_a,compare_b,compare_c)
     {var match=compare$2(x,y,compare_a,compare_b,compare_c);
      return 0 === match?1:0}
    function less_or_equal$2(x,y,compare_a,compare_b,compare_c)
     {var match=compare$2(x,y,compare_a,compare_b,compare_c);
      return 2 <= match?0:1}
    function greater_than$2(x,y,compare_a,compare_b,compare_c)
     {var match=compare$2(x,y,compare_a,compare_b,compare_c);
      return 2 <= match?1:0}
    function greater_or_equal$2(x,y,compare_a,compare_b,compare_c)
     {var match=compare$2(x,y,compare_a,compare_b,compare_c);
      return 0 === match?0:1}
    function min$3(x,y,compare_a,compare_b,compare_c)
     {var match=compare$2(x,y,compare_a,compare_b,compare_c);
      return 0 === match?x:y}
    function max$3(x,y,compare_a,compare_b,compare_c)
     {var match=compare$2(x,y,compare_a,compare_b,compare_c);
      return 2 <= match?x:y}
    function min_max$2(x,y,compare_a,compare_b,compare_c)
     {var match=compare$2(x,y,compare_a,compare_b,compare_c);
      return 0 === match?[0,x,y]:[0,y,x]}
    function different$10(x,y,equal_a,equal_b,equal_c)
     {return 1 - equal$12(x,y,equal_a,equal_b,equal_c)}
    function between$2(x,low,high,compare_a,compare_b,compare_c)
     {var _Kn_=less_than$2(low,x,compare_a,compare_b,compare_c);
      return _Kn_?greater_than$2(high,x,compare_a,compare_b,compare_c):_Kn_}
    function between_or_equal$2(x,low,high,compare_a,compare_b,compare_c)
     {var _Km_=less_or_equal$2(low,x,compare_a,compare_b,compare_c);
      return _Km_
              ?greater_or_equal$2(high,x,compare_a,compare_b,compare_c)
              :_Km_}
    function less_than$3(x,y,compare_a,compare_b,compare_c,compare_d)
     {var match=compare$3(x,y,compare_a,compare_b,compare_c,compare_d);
      return 0 === match?1:0}
    function less_or_equal$3(x,y,compare_a,compare_b,compare_c,compare_d)
     {var match=compare$3(x,y,compare_a,compare_b,compare_c,compare_d);
      return 2 <= match?0:1}
    function greater_than$3(x,y,compare_a,compare_b,compare_c,compare_d)
     {var match=compare$3(x,y,compare_a,compare_b,compare_c,compare_d);
      return 2 <= match?1:0}
    function greater_or_equal$3(x,y,compare_a,compare_b,compare_c,compare_d)
     {var match=compare$3(x,y,compare_a,compare_b,compare_c,compare_d);
      return 0 === match?0:1}
    function min$4(x,y,compare_a,compare_b,compare_c,compare_d)
     {var match=compare$3(x,y,compare_a,compare_b,compare_c,compare_d);
      return 0 === match?x:y}
    function max$4(x,y,compare_a,compare_b,compare_c,compare_d)
     {var match=compare$3(x,y,compare_a,compare_b,compare_c,compare_d);
      return 2 <= match?x:y}
    function min_max$3(x,y,compare_a,compare_b,compare_c,compare_d)
     {var match=compare$3(x,y,compare_a,compare_b,compare_c,compare_d);
      return 0 === match?[0,x,y]:[0,y,x]}
    function different$11(x,y,equal_a,equal_b,equal_c,equal_d)
     {return 1 - equal$13(x,y,equal_a,equal_b,equal_c,equal_d)}
    function between$3(x,low,high,compare_a,compare_b,compare_c,compare_d)
     {var _Kl_=less_than$3(low,x,compare_a,compare_b,compare_c,compare_d);
      return _Kl_
              ?greater_than$3(high,x,compare_a,compare_b,compare_c,compare_d)
              :_Kl_}
    function between_or_equal$3
     (x,low,high,compare_a,compare_b,compare_c,compare_d)
     {var _Kk_=less_or_equal$3(low,x,compare_a,compare_b,compare_c,compare_d);
      return _Kk_
              ?greater_or_equal$3
                (high,x,compare_a,compare_b,compare_c,compare_d)
              :_Kk_}
    function less_than$4
     (x,y,compare_a,compare_b,compare_c,compare_d,compare_e)
     {var
       match=
        compare$4(x,y,compare_a,compare_b,compare_c,compare_d,compare_e);
      return 0 === match?1:0}
    function less_or_equal$4
     (x,y,compare_a,compare_b,compare_c,compare_d,compare_e)
     {var
       match=
        compare$4(x,y,compare_a,compare_b,compare_c,compare_d,compare_e);
      return 2 <= match?0:1}
    function greater_than$4
     (x,y,compare_a,compare_b,compare_c,compare_d,compare_e)
     {var
       match=
        compare$4(x,y,compare_a,compare_b,compare_c,compare_d,compare_e);
      return 2 <= match?1:0}
    function greater_or_equal$4
     (x,y,compare_a,compare_b,compare_c,compare_d,compare_e)
     {var
       match=
        compare$4(x,y,compare_a,compare_b,compare_c,compare_d,compare_e);
      return 0 === match?0:1}
    function min$5(x,y,compare_a,compare_b,compare_c,compare_d,compare_e)
     {var
       match=
        compare$4(x,y,compare_a,compare_b,compare_c,compare_d,compare_e);
      return 0 === match?x:y}
    function max$5(x,y,compare_a,compare_b,compare_c,compare_d,compare_e)
     {var
       match=
        compare$4(x,y,compare_a,compare_b,compare_c,compare_d,compare_e);
      return 2 <= match?x:y}
    function min_max$4(x,y,compare_a,compare_b,compare_c,compare_d,compare_e)
     {var
       match=
        compare$4(x,y,compare_a,compare_b,compare_c,compare_d,compare_e);
      return 0 === match?[0,x,y]:[0,y,x]}
    function different$12(x,y,equal_a,equal_b,equal_c,equal_d,equal_e)
     {return 1 - equal$14(x,y,equal_a,equal_b,equal_c,equal_d,equal_e)}
    function between$4
     (x,low,high,compare_a,compare_b,compare_c,compare_d,compare_e)
     {var
       _Kj_=
        less_than$4(low,x,compare_a,compare_b,compare_c,compare_d,compare_e);
      return _Kj_
              ?greater_than$4
                (high,x,compare_a,compare_b,compare_c,compare_d,compare_e)
              :_Kj_}
    function between_or_equal$4
     (x,low,high,compare_a,compare_b,compare_c,compare_d,compare_e)
     {var
       _Ki_=
        less_or_equal$4
         (low,x,compare_a,compare_b,compare_c,compare_d,compare_e);
      return _Ki_
              ?greater_or_equal$4
                (high,x,compare_a,compare_b,compare_c,compare_d,compare_e)
              :_Ki_}
    var
     _nT_=0,
     _nU_=0,
     _nW_=
      [0,_ba_(cst_get_4,[246,function(_Kh_){return check_42(_nV_[5])}]),_nU_],
     _nY_=
      [0,_ba_(cst_get_3,[246,function(_Kg_){return check_42(_nX_[4])}]),_nW_],
     _n0_=
      [0,_ba_(cst_get_2,[246,function(_Kf_){return check_42(_nZ_[3])}]),_nY_],
     _n2_=
      [0,_ba_(cst_get_1,[246,function(_Ke_){return check_42(_n1_[2])}]),_n0_],
     _n4_=
      [0,_ba_(cst_get_0,[246,function(_Kd_){return check_42(_n3_[1])}]),_n2_],
     _n7_=
      [0,
       _ba_
        (cst_flip$3,
         [246,function(_Kc_){return check_int_tuple5(_n6_,flip$6(_n5_))}]),
       _n4_],
     _n9_=
      [0,
       _ba_
        (cst_make,
         [246,function(_Kb_){return check_int_tuple5(_n8_,[0,1,2,3,4,5])}]),
       _n7_],
     _dC_=0,
     _ct_=[0,ordered$11,equal$48];
    function compare$10(x,y)
     {return compare$4(x,y,compare,compare,compare,compare,compare)}
    function less_than$9(x,y)
     {return less_than$4(x,y,compare,compare,compare,compare,compare)}
    function less_or_equal$9(x,y)
     {return less_or_equal$4(x,y,compare,compare,compare,compare,compare)}
    function greater_than$9(x,y)
     {return greater_than$4(x,y,compare,compare,compare,compare,compare)}
    function greater_or_equal$9(x,y)
     {return greater_or_equal$4(x,y,compare,compare,compare,compare,compare)}
    function between$9(x,low,high)
     {return between$4(x,low,high,compare,compare,compare,compare,compare)}
    function between_or_equal$9(x,low,high)
     {return between_or_equal$4
              (x,low,high,compare,compare,compare,compare,compare)}
    function min$10(x,y)
     {return min$5(x,y,compare,compare,compare,compare,compare)}
    function max$10(x,y)
     {return max$5(x,y,compare,compare,compare,compare,compare)}
    function min_max$9(x,y)
     {return min_max$4(x,y,compare,compare,compare,compare,compare)}
    var
     O$13=
      Make0$3
       ([0,less_than$9,less_or_equal$9,greater_than$9,greater_or_equal$9]),
     repr$21=
      Specialize5
        ([0,repr$11],[0,repr],[0,repr$6],[0,repr$4],[0,repr],[0,repr])
       [1],
     include$19=
      Specialize5$0
       ([0,equal$14],
        [0,equal$2],
        [0,equal$9],
        [0,equal$7],
        [0,equal$2],
        [0,equal$2]),
     equal$28=include$19[1],
     _dD_=
      [0,
       Make0$6
         ([0,
           compare$10,
           less_than$9,
           less_or_equal$9,
           greater_than$9,
           greater_or_equal$9,
           between$9,
           between_or_equal$9,
           min$10,
           max$10,
           min_max$9,
           O$13,
           repr$21,
           equal$28],
          _ct_)
        [1],
       _dC_],
     E=[0,equal$2],
     D$0=[0,equal$2],
     C$1=[0,equal$7],
     B$2=[0,equal$9],
     A$2=[0,equal$2],
     _dr_=
      [0,
       Make0
         (Specialize5
           ([0,repr$11],[0,repr],[0,repr$6],[0,repr$4],[0,repr],[0,repr]),
          [0,repr$38])
        [1],
       0],
     include$28=Specialize5$0([0,equal$14],A$2,B$2,C$1,D$0,E),
     equal$22=include$28[1],
     _by_=[0,equal$48,different$39];
    function different$19(x,y)
     {return different$12(x,y,A$2[1],B$2[1],C$1[1],D$0[1],E[1])}
    var
     Self$2=[0,equal$22,different$19],
     O$8=Make0$0(Self$2),
     equal$23=Self$2[1],
     different$20=Self$2[2],
     include$24=
      Specialize5
       ([0,repr$11],[0,repr],[0,repr$6],[0,repr$4],[0,repr],[0,repr]),
     repr$16=include$24[1],
     test$3=
      _a$_
       (cst_Identifiable$4,
        [0,Make0$2([0,equal$23,different$20,O$8,repr$16],_by_)[1],_dr_]),
     test$8=_a$_(cst_Able$4,[0,test$3,_dD_]),
     _n__=[0,_a$_(cst_Tuple5,[0,test$8,_n9_]),_nT_],
     _n$_=0,
     _ob_=
      [0,
       _ba_(cst_get_3$0,[246,function(_Ka_){return check_42(_oa_[4])}]),
       _n$_],
     _od_=
      [0,
       _ba_(cst_get_2$0,[246,function(_J$_){return check_42(_oc_[3])}]),
       _ob_],
     _of_=
      [0,
       _ba_(cst_get_1$0,[246,function(_J__){return check_42(_oe_[2])}]),
       _od_],
     _oh_=
      [0,
       _ba_(cst_get_0$0,[246,function(_J9_){return check_42(_og_[1])}]),
       _of_],
     _ok_=
      [0,
       _ba_
        (cst_flip$4,
         [246,function(_J8_){return check_int_tuple4(_oj_,flip$5(_oi_))}]),
       _oh_],
     _om_=
      [0,
       _ba_
        (cst_make$0,
         [246,function(_J7_){return check_int_tuple4(_ol_,[0,1,2,3,4])}]),
       _ok_],
     _dA_=0,
     _cs_=[0,ordered$10,equal$47];
    function compare$9(x,y)
     {return compare$3(x,y,compare,compare,compare,compare)}
    function less_than$8(x,y)
     {return less_than$3(x,y,compare,compare,compare,compare)}
    function less_or_equal$8(x,y)
     {return less_or_equal$3(x,y,compare,compare,compare,compare)}
    function greater_than$8(x,y)
     {return greater_than$3(x,y,compare,compare,compare,compare)}
    function greater_or_equal$8(x,y)
     {return greater_or_equal$3(x,y,compare,compare,compare,compare)}
    function between$8(x,low,high)
     {return between$3(x,low,high,compare,compare,compare,compare)}
    function between_or_equal$8(x,low,high)
     {return between_or_equal$3(x,low,high,compare,compare,compare,compare)}
    function min$9(x,y){return min$4(x,y,compare,compare,compare,compare)}
    function max$9(x,y){return max$4(x,y,compare,compare,compare,compare)}
    function min_max$8(x,y)
     {return min_max$3(x,y,compare,compare,compare,compare)}
    var
     O$12=
      Make0$3
       ([0,less_than$8,less_or_equal$8,greater_than$8,greater_or_equal$8]),
     repr$20=
      Specialize4([0,repr$10],[0,repr],[0,repr$6],[0,repr$4],[0,repr])[1],
     include$20=
      Specialize4$0
       ([0,equal$13],[0,equal$2],[0,equal$9],[0,equal$7],[0,equal$2]),
     equal$27=include$20[1],
     _dB_=
      [0,
       Make0$6
         ([0,
           compare$9,
           less_than$8,
           less_or_equal$8,
           greater_than$8,
           greater_or_equal$8,
           between$8,
           between_or_equal$8,
           min$9,
           max$9,
           min_max$8,
           O$12,
           repr$20,
           equal$27],
          _cs_)
        [1],
       _dA_],
     D=[0,equal$2],
     C$0=[0,equal$7],
     B$1=[0,equal$9],
     A$1=[0,equal$2],
     _dq_=
      [0,
       Make0
         (Specialize4([0,repr$10],[0,repr],[0,repr$6],[0,repr$4],[0,repr]),
          [0,repr$37])
        [1],
       0],
     include$29=Specialize4$0([0,equal$13],A$1,B$1,C$0,D),
     equal$20=include$29[1],
     _bx_=[0,equal$47,different$38];
    function different$17(x,y)
     {return different$11(x,y,A$1[1],B$1[1],C$0[1],D[1])}
    var
     Self$1=[0,equal$20,different$17],
     O$7=Make0$0(Self$1),
     equal$21=Self$1[1],
     different$18=Self$1[2],
     include$25=
      Specialize4([0,repr$10],[0,repr],[0,repr$6],[0,repr$4],[0,repr]),
     repr$15=include$25[1],
     test$2=
      _a$_
       (cst_Identifiable$3,
        [0,Make0$2([0,equal$21,different$18,O$7,repr$15],_bx_)[1],_dq_]),
     test$7=_a$_(cst_Able$3,[0,test$2,_dB_]),
     _on_=[0,_a$_(cst_Tuple4,[0,test$7,_om_]),_n__],
     _oo_=0,
     _oq_=
      [0,
       _ba_(cst_get_2$1,[246,function(_J6_){return check_42(_op_[3])}]),
       _oo_],
     _os_=
      [0,
       _ba_(cst_get_1$1,[246,function(_J5_){return check_42(_or_[2])}]),
       _oq_],
     _ou_=
      [0,
       _ba_(cst_get_0$1,[246,function(_J4_){return check_42(_ot_[1])}]),
       _os_],
     _ox_=
      [0,
       _ba_
        (cst_flip$5,
         [246,function(_J3_){return check_int_tuple3(_ow_,flip$4(_ov_))}]),
       _ou_],
     _oz_=
      [0,
       _ba_
        (cst_make$1,
         [246,function(_J2_){return check_int_tuple3(_oy_,[0,1,2,3])}]),
       _ox_],
     _dy_=0,
     _cr_=[0,ordered$9,equal$46];
    function compare$8(x,y){return compare$2(x,y,compare,compare,compare)}
    function less_than$7(x,y){return less_than$2(x,y,compare,compare,compare)}
    function less_or_equal$7(x,y)
     {return less_or_equal$2(x,y,compare,compare,compare)}
    function greater_than$7(x,y)
     {return greater_than$2(x,y,compare,compare,compare)}
    function greater_or_equal$7(x,y)
     {return greater_or_equal$2(x,y,compare,compare,compare)}
    function between$7(x,low,high)
     {return between$2(x,low,high,compare,compare,compare)}
    function between_or_equal$7(x,low,high)
     {return between_or_equal$2(x,low,high,compare,compare,compare)}
    function min$8(x,y){return min$3(x,y,compare,compare,compare)}
    function max$8(x,y){return max$3(x,y,compare,compare,compare)}
    function min_max$7(x,y){return min_max$2(x,y,compare,compare,compare)}
    var
     O$11=
      Make0$3
       ([0,less_than$7,less_or_equal$7,greater_than$7,greater_or_equal$7]),
     repr$19=Specialize3([0,repr$9],[0,repr],[0,repr$6],[0,repr$4])[1],
     include$21=
      Specialize3$0([0,equal$12],[0,equal$2],[0,equal$9],[0,equal$7]),
     equal$26=include$21[1],
     _dz_=
      [0,
       Make0$6
         ([0,
           compare$8,
           less_than$7,
           less_or_equal$7,
           greater_than$7,
           greater_or_equal$7,
           between$7,
           between_or_equal$7,
           min$8,
           max$8,
           min_max$7,
           O$11,
           repr$19,
           equal$26],
          _cr_)
        [1],
       _dy_],
     C=[0,equal$7],
     B$0=[0,equal$9],
     A$0=[0,equal$2],
     _dp_=
      [0,
       Make0
         (Specialize3([0,repr$9],[0,repr],[0,repr$6],[0,repr$4]),[0,repr$36])
        [1],
       0],
     include$30=Specialize3$0([0,equal$12],A$0,B$0,C),
     equal$18=include$30[1],
     _bw_=[0,equal$46,different$37];
    function different$15(x,y){return different$10(x,y,A$0[1],B$0[1],C[1])}
    var
     Self$0=[0,equal$18,different$15],
     O$6=Make0$0(Self$0),
     equal$19=Self$0[1],
     different$16=Self$0[2],
     include$26=Specialize3([0,repr$9],[0,repr],[0,repr$6],[0,repr$4]),
     repr$14=include$26[1],
     test$1=
      _a$_
       (cst_Identifiable$2,
        [0,Make0$2([0,equal$19,different$16,O$6,repr$14],_bw_)[1],_dp_]),
     test$6=_a$_(cst_Able$2,[0,test$1,_dz_]),
     _oA_=[0,_a$_(cst_Tuple3,[0,test$6,_oz_]),_on_],
     _oB_=0,
     _oD_=
      [0,
       _ba_(cst_get_1$2,[246,function(_J1_){return check_42(_oC_[2])}]),
       _oB_],
     _oF_=
      [0,
       _ba_(cst_get_0$2,[246,function(_J0_){return check_42(_oE_[1])}]),
       _oD_],
     _oI_=
      [0,
       _ba_
        (cst_flip$6,
         [246,function(_JZ_){return check_int_tuple2(_oH_,flip$3(_oG_))}]),
       _oF_],
     _oK_=
      [0,
       _ba_
        (cst_make$2,
         [246,function(_JY_){return check_int_tuple2(_oJ_,[0,1,2])}]),
       _oI_],
     _dw_=0,
     _cq_=[0,ordered$8,equal$45];
    function compare$7(x,y){return compare$1(x,y,compare,compare)}
    function less_than$6(x,y){return less_than$1(x,y,compare,compare)}
    function less_or_equal$6(x,y){return less_or_equal$1(x,y,compare,compare)}
    function greater_than$6(x,y){return greater_than$1(x,y,compare,compare)}
    function greater_or_equal$6(x,y)
     {return greater_or_equal$1(x,y,compare,compare)}
    function between$6(x,low,high)
     {return between$1(x,low,high,compare,compare)}
    function between_or_equal$6(x,low,high)
     {return between_or_equal$1(x,low,high,compare,compare)}
    function min$7(x,y){return min$2(x,y,compare,compare)}
    function max$7(x,y){return max$2(x,y,compare,compare)}
    function min_max$6(x,y){return min_max$1(x,y,compare,compare)}
    var
     O$10=
      Make0$3
       ([0,less_than$6,less_or_equal$6,greater_than$6,greater_or_equal$6]),
     repr$18=Specialize2([0,repr$8],[0,repr],[0,repr$6])[1],
     include$22=Specialize2$0([0,equal$11],[0,equal$2],[0,equal$9]),
     equal$25=include$22[1],
     _dx_=
      [0,
       Make0$6
         ([0,
           compare$7,
           less_than$6,
           less_or_equal$6,
           greater_than$6,
           greater_or_equal$6,
           between$6,
           between_or_equal$6,
           min$7,
           max$7,
           min_max$6,
           O$10,
           repr$18,
           equal$25],
          _cq_)
        [1],
       _dw_],
     B=[0,equal$9],
     A=[0,equal$2],
     _do_=
      [0,Make0(Specialize2([0,repr$8],[0,repr],[0,repr$6]),[0,repr$35])[1],0],
     include$31=Specialize2$0([0,equal$11],A,B),
     equal$16=include$31[1],
     _bv_=[0,equal$45,different$36];
    function different$13(x,y){return different$9(x,y,A[1],B[1])}
    var
     Self=[0,equal$16,different$13],
     O$5=Make0$0(Self),
     equal$17=Self[1],
     different$14=Self[2],
     include$27=Specialize2([0,repr$8],[0,repr],[0,repr$6]),
     repr$13=include$27[1],
     test$0=
      _a$_
       (cst_Identifiable$1,
        [0,Make0$2([0,equal$17,different$14,O$5,repr$13],_bv_)[1],_do_]),
     test$5=_a$_(cst_Able$1,[0,test$0,_dx_]),
     test$23=_a$_(cst_Tuples,[0,_a$_(cst_Tuple2,[0,test$5,_oK_]),_oA_]),
     BrokenInvariants=
      [248,
       cst_General_RedBlackTree_Invariants_BrokenInvariants,
       caml_fresh_oo_id(0)];
    function repr$40(param)
     {switch(param)
       {case 0:return cst_HasBlackRoot;
        case 1:return cst_IsRedBlack;
        case 2:return cst_IsBlackBalanced;
        default:return cst_IsBinarySearchTree}}
    caml_call1
     (register_printer,
      function(param)
       {if(param[1] === BrokenInvariants)
         {var
           broken_invariants=param[2],
           _JU_=function(_JX_){return join(_oO_,_JX_)},
           _JV_=
            caml_call2
             (_au_,
              caml_call2
               (_au_,
                broken_invariants,
                function(_JW_){return map$0(_JW_,repr$40)}),
              _JU_);
          return [0,caml_call1(apply(_oP_),_JV_)]}
        return 0});
    function has_black_root(param)
     {var
       switch$0=
        typeof param === "number"?0 === param?0:1:0 === param[0]?0:1;
      return switch$0?0:1}
    function is_red_black(t)
     {function aux(param)
       {var param$0=param;
        for(;;)
         {if(typeof param$0 === "number")
           {if(0 === param$0)return 1;var switch$0=0}
          else
           switch(param$0[0])
            {case 0:var _JP_=param$0[1],r=_JP_[3],l=_JP_[1],switch$0=1;break;
             case 2:
              var _JR_=param$0[1],_JS_=_JR_[1];
              if(typeof _JS_ === "number")
               var switch$1=1;
              else
               if(2 === _JS_[0])var switch$0=0,switch$1=0;else var switch$1=1;
              if(switch$1)
               {var _JT_=_JR_[3];
                if(typeof _JT_ === "number")
                 var switch$2=1;
                else
                 if(2 === _JT_[0])
                  var switch$0=0,switch$2=0;
                 else
                  var switch$2=1;
                if(switch$2)var r=_JT_,l=_JS_,switch$0=1}
              break;
             default:var switch$0=0}
          if(switch$0)
           {var _JQ_=aux(l);if(_JQ_){var param$0=r;continue}return _JQ_}
          return 0}}
      return aux(t)}
    var black_height=function _JO_(_JN_){return _JO_.fun(_JN_)};
    function common_height(l,r)
     {var match=caml_call1(black_height,l),match$0=caml_call1(black_height,r);
      if(match)
       if(match$0)
        {var hr=match$0[1],hl=match[1];
         if(caml_call2(_aA_,hl,hr))return [0,hl]}
      return 0}
    runtime.caml_update_dummy
     (black_height,
      function(param)
       {if(typeof param === "number")
         return 0 === param?_oQ_:_oR_;
        else
         switch(param[0])
          {case 0:
            var
             match=param[1],
             r=match[3],
             l=match[1],
             _JF_=function(_JM_){return 1 + _JM_ | 0},
             _JG_=function(_JL_){return func(_JL_,_JF_)};
            return caml_call2(_au_,common_height(l,r),_JG_);
           case 1:
            var
             match$0=param[1],
             r$0=match$0[3],
             l$0=match$0[1],
             _JH_=function(_JK_){return 2 + _JK_ | 0},
             _JI_=function(_JJ_){return func(_JJ_,_JH_)};
            return caml_call2(_au_,common_height(l$0,r$0),_JI_);
           default:
            var match$1=param[1],r$1=match$1[3],l$1=match$1[1];
            return common_height(l$1,r$1)}});
    function is_black_balanced(t)
     {return caml_call2(_au_,caml_call2(_au_,t,black_height),is_some)}
    function validate(t,cmp)
     {function _Jq_(param)
       {var invariant=param[2],predicate=param[1];
        return some_if$0(1 - caml_call1(predicate,t),invariant)}
      function _Jr_(_JE_){return filter_map$0(_JE_,_Jq_)}
      var
       _Js_=0,
       _Jt_=3,
       broken_invariants=
        caml_call2
         (_au_,
          [0,
           [0,has_black_root,0],
           [0,
            [0,is_red_black,1],
            [0,
             [0,is_black_balanced,2],
             [0,
              [0,
               function(t)
                {function aux(min,max,param)
                  {var min$0=min,param$0=param;
                   for(;;)
                    {if(typeof param$0 === "number")return 1;
                     var
                      match=param$0[1],
                      r=match[3],
                      v=match[2],
                      l=match[1],
                      _Jx_=aux(min$0,[0,v],l);
                     if(_Jx_)
                      {var
                        _Ju_=
                         function(v)
                           {return function(min)
                             {var match=caml_call2(cmp,v,min);return 2 <= match?1:0}}
                          (v),
                        _Jv_=
                         caml_call2
                          (_au_,
                           min$0,
                           function(_JC_)
                             {return function(_JD_){return value_map(_JD_,1,_JC_)}}
                            (_Ju_));
                       if(_Jv_)
                        var
                         _Jw_=
                          function(v)
                            {return function(max)
                              {var match=caml_call2(cmp,v,max);return 0 === match?1:0}}
                           (v),
                         _Jy_=
                          caml_call2
                           (_au_,
                            max,
                            function(_JA_)
                              {return function(_JB_){return value_map(_JB_,1,_JA_)}}
                             (_Jw_));
                       else
                        var _Jy_=_Jv_;
                       if(_Jy_){var min$1=[0,v],min$0=min$1,param$0=r;continue}
                       var _Jz_=_Jy_}
                     else
                      var _Jz_=_Jx_;
                     return _Jz_}}
                 return aux(0,0,t)},
               _Jt_],
              _Js_]]]],
          _Jr_);
      return broken_invariants?raise([0,BrokenInvariants,broken_invariants]):t}
    function fix_root_color(t)
     {if(typeof t === "number")
       return 0;
      else
       {if(0 === t[0])return t;var node=t[1];return [0,node]}}
    function balance_reds_left(t)
     {if(typeof t !== "number")
       switch(t[0])
        {case 0:
          var _Jg_=t[1],_Jh_=_Jg_[1];
          if(typeof _Jh_ !== "number" && 2 === _Jh_[0])
           {var _Ji_=_Jh_[1],_Jj_=_Ji_[1];
            if(typeof _Jj_ !== "number" && 2 === _Jj_[0])
             {var
               d$0=_Jg_[3],
               z$0=_Jg_[2],
               c$0=_Ji_[3],
               y$0=_Ji_[2],
               match$0=_Jj_[1],
               b$0=match$0[3],
               x$0=match$0[2],
               a=match$0[1];
              return [2,[0,[0,[0,a,x$0,b$0]],y$0,[0,[0,c$0,z$0,d$0]]]]}
            var _Jk_=_Ji_[3];
            if(typeof _Jk_ !== "number" && 2 === _Jk_[0])
             {var
               d=_Jg_[3],
               z=_Jg_[2],
               match=_Jk_[1],
               c=match[3],
               y=match[2],
               b=match[1],
               x=_Ji_[2];
              return [2,[0,[0,[0,_Jj_,x,b]],y,[0,[0,c,z,d]]]]}}
          return t;
         case 1:
          var _Jl_=t[1],_Jm_=_Jl_[1];
          if(typeof _Jm_ !== "number" && 2 === _Jm_[0])
           {var _Jn_=_Jm_[1],_Jo_=_Jn_[1];
            if(typeof _Jo_ !== "number" && 2 === _Jo_[0])
             {var
               d$2=_Jl_[3],
               z$2=_Jl_[2],
               c$2=_Jn_[3],
               y$2=_Jn_[2],
               match$2=_Jo_[1],
               b$2=match$2[3],
               x$2=match$2[2],
               a$0=match$2[1];
              return [0,[0,[0,[0,a$0,x$2,b$2]],y$2,[0,[0,c$2,z$2,d$2]]]]}
            var _Jp_=_Jn_[3];
            if(typeof _Jp_ !== "number" && 2 === _Jp_[0])
             {var
               d$1=_Jl_[3],
               z$1=_Jl_[2],
               match$1=_Jp_[1],
               c$1=match$1[3],
               y$1=match$1[2],
               b$1=match$1[1],
               x$1=_Jn_[2];
              return [0,[0,[0,[0,_Jo_,x$1,b$1]],y$1,[0,[0,c$1,z$1,d$1]]]]}}
          return t
         }
      return failure(_oS_)}
    function balance_reds_right(t)
     {if(typeof t !== "number")
       switch(t[0])
        {case 0:
          var _I4_=t[1],_I5_=_I4_[3],_I6_=_I4_[2],_I7_=_I4_[1];
          if(typeof _I5_ !== "number" && 2 === _I5_[0])
           {var _I8_=_I5_[1],_I9_=_I8_[1];
            if(typeof _I9_ !== "number" && 2 === _I9_[0])
             {var
               d$0=_I8_[3],
               z$0=_I8_[2],
               match$0=_I9_[1],
               c$0=match$0[3],
               y$0=match$0[2],
               b=match$0[1];
              return [2,[0,[0,[0,_I7_,_I6_,b]],y$0,[0,[0,c$0,z$0,d$0]]]]}
            var _I__=_I8_[3];
            if(typeof _I__ !== "number" && 2 === _I__[0])
             {var match=_I__[1],d=match[3],z=match[2],c=match[1],y=_I8_[2];
              return [2,[0,[0,[0,_I7_,_I6_,_I9_]],y,[0,[0,c,z,d]]]]}}
          return t;
         case 1:
          var _I$_=t[1],_Ja_=_I$_[3],_Jb_=_I$_[2],_Jc_=_I$_[1];
          if(typeof _Ja_ !== "number" && 2 === _Ja_[0])
           {var _Jd_=_Ja_[1],_Je_=_Jd_[1];
            if(typeof _Je_ !== "number" && 2 === _Je_[0])
             {var
               d$2=_Jd_[3],
               z$2=_Jd_[2],
               match$2=_Je_[1],
               c$2=match$2[3],
               y$2=match$2[2],
               b$0=match$2[1];
              return [0,[0,[0,[0,_Jc_,_Jb_,b$0]],y$2,[0,[0,c$2,z$2,d$2]]]]}
            var _Jf_=_Jd_[3];
            if(typeof _Jf_ !== "number" && 2 === _Jf_[0])
             {var
               match$1=_Jf_[1],
               d$1=match$1[3],
               z$1=match$1[2],
               c$1=match$1[1],
               y$1=_Jd_[2];
              return [0,[0,[0,[0,_Jc_,_Jb_,_Je_]],y$1,[0,[0,c$1,z$1,d$1]]]]}}
          return t
         }
      return failure(_oT_)}
    function balance_blacks_left(t)
     {if(typeof t !== "number")
       switch(t[0])
        {case 0:
          var _IV_=t[1],_IW_=_IV_[1];
          if(typeof _IW_ === "number")
           var switch$0=0;
          else
           switch(_IW_[0])
            {case 1:var switch$0=0;break;
             case 0:
              var _IX_=_IV_[3];
              if(typeof _IX_ === "number")
               {if(0 !== _IX_)
                 {var
                   y=_IV_[2],
                   match=_IW_[1],
                   b=match[3],
                   x=match[2],
                   a=match[1];
                  return balance_reds_left([1,[0,[2,[0,a,x,b]],y,0]])}
                var switch$0=1}
              else
               var switch$0=1;
              break;
             default:
              var _IY_=_IW_[1],_IZ_=_IY_[3];
              if(typeof _IZ_ === "number")
               var switch$1=1;
              else
               if(0 === _IZ_[0])
                {var _I0_=_IV_[3];
                 if(typeof _I0_ === "number")
                  {if(0 !== _I0_)
                    {var
                      z=_IV_[2],
                      match$0=_IZ_[1],
                      c=match$0[3],
                      y$0=match$0[2],
                      b$0=match$0[1],
                      x$0=_IY_[2],
                      a$0=_IY_[1];
                     return [0,
                             [0,a$0,x$0,balance_reds_left([0,[0,[2,[0,b$0,y$0,c]],z,0]])]]}
                   var switch$0=1,switch$1=0}
                 else
                  var switch$0=1,switch$1=0}
               else
                var switch$1=1;
              if(switch$1)var switch$0=1}
          break;
         case 2:
          var _I1_=t[1],_I2_=_I1_[1];
          if(typeof _I2_ === "number")
           var switch$2=0;
          else
           if(0 === _I2_[0])
            {var _I3_=_I1_[3];
             if(typeof _I3_ === "number")
              {if(0 !== _I3_)
                {var
                  y$1=_I1_[2],
                  match$1=_I2_[1],
                  b$1=match$1[3],
                  x$1=match$1[2],
                  a$1=match$1[1];
                 return balance_reds_left([0,[0,[2,[0,a$1,x$1,b$1]],y$1,0]])}
               var switch$2=1}
             else
              var switch$2=1}
           else
            var switch$2=0;
          break
         }
      return t}
    function balance_blacks_right(t)
     {if(typeof t !== "number")
       switch(t[0])
        {case 0:
          var _IM_=t[1],_IN_=_IM_[1];
          if(typeof _IN_ === "number")
           if(0 !== _IN_)
            {var _IO_=_IM_[3],_IP_=_IM_[2];
             if(typeof _IO_ === "number")
              var switch$0=0;
             else
              switch(_IO_[0])
               {case 1:var switch$0=0;break;
                case 0:
                 var match=_IO_[1],c=match[3],y=match[2],b=match[1];
                 return balance_reds_right([1,[0,0,_IP_,[2,[0,b,y,c]]]]);
                default:
                 var _IQ_=_IO_[1],_IR_=_IQ_[1];
                 if(typeof _IR_ !== "number" && 0 === _IR_[0])
                  {var
                    d=_IQ_[3],
                    z=_IQ_[2],
                    match$0=_IR_[1],
                    c$0=match$0[3],
                    y$0=match$0[2],
                    b$0=match$0[1];
                   return [0,
                           [0,
                            balance_reds_right([0,[0,0,_IP_,[2,[0,b$0,y$0,c$0]]]]),
                            z,
                            d]]}
                 var switch$0=1}}
          break;
         case 2:
          var _IS_=t[1],_IT_=_IS_[1];
          if(typeof _IT_ === "number")
           if(0 !== _IT_)
            {var _IU_=_IS_[3];
             if(typeof _IU_ !== "number" && 0 === _IU_[0])
              {var
                match$1=_IU_[1],
                c$1=match$1[3],
                y$1=match$1[2],
                b$1=match$1[1],
                x=_IS_[2];
               return balance_reds_right([0,[0,0,x,[2,[0,b$1,y$1,c$1]]]])}}
          break
         }
      return t}
    var empty$3=0;
    function add$5(xs,cmp,x)
     {function aux(t)
       {if(typeof t === "number")
         {if(0 === t)return [0,1,[2,[0,0,x,0]]]}
        else
         switch(t[0])
          {case 0:
            var
             match=t[1],
             r=match[3],
             v=match[2],
             l=match[1],
             match$0=caml_call2(cmp,x,v);
            switch(match$0)
             {case 0:
               var match$1=aux(l),l$0=match$1[2],modified=match$1[1];
               return modified
                       ?[0,1,balance_reds_left([0,[0,l$0,v,r]])]
                       :[0,0,t];
              case 1:return [0,0,t];
              default:
               var match$2=aux(r),r$0=match$2[2],modified$0=match$2[1];
               return modified$0
                       ?[0,1,balance_reds_right([0,[0,l,v,r$0]])]
                       :[0,0,t]}
           case 2:
            var
             match$3=t[1],
             r$1=match$3[3],
             v$0=match$3[2],
             l$1=match$3[1],
             match$4=caml_call2(cmp,x,v$0);
            switch(match$4)
             {case 0:
               var match$5=aux(l$1),l$2=match$5[2],modified$1=match$5[1];
               return modified$1?[0,1,[2,[0,l$2,v$0,r$1]]]:[0,0,t];
              case 1:return [0,0,t];
              default:
               var match$6=aux(r$1),r$2=match$6[2],modified$2=match$6[1];
               return modified$2?[0,1,[2,[0,l$1,v$0,r$2]]]:[0,0,t]}
           }
        return failure(_oU_)}
      var
       match=caml_call2(_au_,xs,aux),
       t=match[2],
       modified=match[1],
       t$0=caml_call2(_au_,t,fix_root_color);
      return [0,modified,t$0]}
    function replace(xs,cmp,x)
     {function aux(param)
       {if(typeof param === "number")
         {if(0 === param)return [2,[0,0,x,0]]}
        else
         switch(param[0])
          {case 0:
            var
             match=param[1],
             r=match[3],
             v=match[2],
             l=match[1],
             match$0=caml_call2(cmp,x,v);
            switch(match$0)
             {case 0:return balance_reds_left([0,[0,aux(l),v,r]]);
              case 1:return [0,[0,l,x,r]];
              default:return balance_reds_right([0,[0,l,v,aux(r)]])}
           case 2:
            var
             match$1=param[1],
             r$0=match$1[3],
             v$0=match$1[2],
             l$0=match$1[1],
             match$2=caml_call2(cmp,x,v$0);
            switch(match$2)
             {case 0:return [2,[0,aux(l$0),v$0,r$0]];
              case 1:return [2,[0,l$0,x,r$0]];
              default:return [2,[0,l$0,v$0,aux(r$0)]]}
           }
        return failure(_oV_)}
      return caml_call2(_au_,caml_call2(_au_,xs,aux),fix_root_color)}
    function remove(xs,cmp,cmp_k,x)
     {function remove_min(param)
       {if(typeof param !== "number")
         switch(param[0])
          {case 0:
            var _IG_=param[1],_IH_=_IG_[1];
            if(typeof _IH_ === "number")
             if(0 === _IH_)
              {var _II_=_IG_[3],_IJ_=_IG_[2];
               if(typeof _II_ === "number")
                {if(1 !== _II_)return [0,1,_IJ_]}
               else
                if(2 === _II_[0])
                 {var
                   match$0=_II_[1],
                   r$0=match$0[3],
                   y=match$0[2],
                   l$0=match$0[1];
                  return [0,[0,[0,l$0,y,r$0]],_IJ_]}}
            var
             r=_IG_[3],
             v=_IG_[2],
             match=remove_min(_IH_),
             min=match[2],
             l=match[1],
             t=[0,[0,l,v,r]];
            return [0,balance_blacks_right(t),min];
           case 2:
            var _IK_=param[1],_IL_=_IK_[1];
            if(typeof _IL_ === "number")
             if(0 === _IL_){var r$1=_IK_[3],v$0=_IK_[2];return [0,r$1,v$0]}
            var
             r$2=_IK_[3],
             v$1=_IK_[2],
             match$1=remove_min(_IL_),
             min$0=match$1[2],
             l$1=match$1[1],
             t$0=[2,[0,l$1,v$1,r$2]];
            return [0,balance_blacks_right(t$0),min$0]
           }
        return failure(_oW_)}
      function aux(t)
       {if(typeof t === "number")
         {if(0 === t)return _oX_}
        else
         switch(t[0])
          {case 0:
            var
             match=t[1],
             r=match[3],
             v=match[2],
             l=match[1],
             match$0=caml_call2(cmp_k,x,v);
            switch(match$0)
             {case 0:
               var match$1=aux(l),l$0=match$1[2],modified=match$1[1];
               return modified
                       ?[0,1,balance_blacks_right([0,[0,l$0,v,r]])]
                       :[0,0,t];
              case 1:
               if(typeof r === "number")
                {if(0 === r)
                  {if(typeof l === "number")
                    {if(0 === l)return _oZ_}
                   else
                    if(2 === l[0]){var node=l[1];return [0,1,[0,node]]}
                   return failure(_o0_)}}
               else
                if(1 !== r[0])
                 {var match$2=remove_min(r),min=match$2[2],r$0=match$2[1];
                  return [0,1,balance_blacks_left([0,[0,l,min,r$0]])]}
               return failure(_o1_);
              default:
               var match$3=aux(r),r$1=match$3[2],modified$0=match$3[1];
               return modified$0
                       ?[0,1,balance_blacks_left([0,[0,l,v,r$1]])]
                       :[0,0,t]}
           case 2:
            var
             match$4=t[1],
             r$2=match$4[3],
             v$0=match$4[2],
             l$1=match$4[1],
             match$5=caml_call2(cmp_k,x,v$0);
            switch(match$5)
             {case 0:
               var match$6=aux(l$1),l$2=match$6[2],modified$1=match$6[1];
               return modified$1
                       ?[0,1,balance_blacks_right([2,[0,l$2,v$0,r$2]])]
                       :[0,0,t];
              case 1:
               if(typeof r$2 === "number")
                {if(0 === r$2)return [0,1,l$1]}
               else
                if(0 === r$2[0])
                 {var match$7=remove_min(r$2),min$0=match$7[2],r$3=match$7[1];
                  return [0,1,balance_blacks_left([2,[0,l$1,min$0,r$3]])]}
               return failure(_o2_);
              default:
               var match$8=aux(r$2),r$4=match$8[2],modified$2=match$8[1];
               return modified$2
                       ?[0,1,balance_blacks_left([2,[0,l$1,v$0,r$4]])]
                       :[0,0,t]}
           }
        return failure(_oY_)}
      var
       match=caml_call2(_au_,xs,aux),
       t=match[2],
       modified=match[1],
       t$0=caml_call2(_au_,t,fix_root_color);
      return [0,modified,t$0]}
    function is_empty$0(param)
     {if(typeof param === "number")if(0 === param)return 1;return 0}
    function try_get(xs,cmp,cmp_k,x)
     {function aux(param)
       {var param$0=param;
        for(;;)
         {if(typeof param$0 === "number")
           {if(0 === param$0)return 0}
          else
           if(1 !== param$0[0])
            {var
              match=param$0[1],
              r=match[3],
              v=match[2],
              l=match[1],
              match$0=caml_call2(cmp_k,x,v);
             switch(match$0)
              {case 0:var param$0=l;continue;
               case 1:return [0,v];
               default:var param$0=r;continue}}
          return failure(_o3_)}}
      return caml_call2(_au_,xs,aux)}
    function fold$2(xs,cmp,init,f)
     {function aux(acc,param)
       {var acc$0=acc,param$0=param;
        for(;;)
         {if(typeof param$0 === "number")
           {if(0 === param$0)return acc$0}
          else
           if(1 !== param$0[0])
            {var
              match=param$0[1],
              r=match[3],
              v=match[2],
              l=match[1],
              acc$1=caml_call2(f,aux(acc$0,l),v),
              acc$0=acc$1,
              param$0=r;
             continue}
          return failure(_o4_)}}
      return caml_call2(_au_,xs,function(_IF_){return aux(init,_IF_)})}
    function to_list$3(xs,cmp)
     {return caml_call2
              (_au_,fold$2(xs,cmp,0,caml_call1(Function2[1],prepend)),reverse)}
    function size$5(xs,cmp)
     {return fold$2(xs,cmp,0,function(n,param){return n + 1 | 0})}
    function repr$39(param)
     {if(typeof param === "number")
       return 0 === param?cst_Empty:cst_EmptyPlus;
      else
       switch(param[0])
        {case 0:
          var
           match=param[1],
           r=match[3],
           v=match[2],
           l=match[1],
           _Iw_=repr$39(r),
           _Ix_=caml_call1(repr,v),
           _Iy_=repr$39(l);
          return caml_call3(apply(_oL_),_Iy_,_Ix_,_Iw_);
         case 1:
          var
           match$0=param[1],
           r$0=match$0[3],
           v$0=match$0[2],
           l$0=match$0[1],
           _Iz_=repr$39(r$0),
           _IA_=caml_call1(repr,v$0),
           _IB_=repr$39(l$0);
          return caml_call3(apply(_oM_),_IB_,_IA_,_Iz_);
         default:
          var
           match$1=param[1],
           r$1=match$1[3],
           v$1=match$1[2],
           l$1=match$1[1],
           _IC_=repr$39(r$1),
           _ID_=caml_call1(repr,v$1),
           _IE_=repr$39(l$1);
          return caml_call3(apply(_oN_),_IE_,_ID_,_IC_)}}
    function cmp(a,b)
     {var _Iv_=caml_call1(abs,b);return compare(caml_call1(abs,a),_Iv_)}
    var _o5_=0;
    function make$6(t,expected)
     {var _It_=[246,function(_Iu_){return check_int(expected,size$5(t,cmp))}];
      return _ba_(repr$39(t),_It_)}
    var
     _o6_=[0,make$6(bb13br57r9,5),0],
     _o7_=[0,_a$_(cst_size,[0,make$6(empty$3,0),_o6_]),_o5_];
    function make$7(t,expected)
     {var
       _Ir_=
        [246,function(_Is_){return check_int_list(expected,to_list$3(t,cmp))}];
      return _ba_(repr$39(t),_Ir_)}
    var
     _o9_=[0,make$7(bb13br57r9,_o8_),0],
     _o__=[0,_a$_(cst_to_list$0,[0,make$7(empty$3,0),_o9_]),_o7_];
    function cmp_k(param,y){var x=param[2];return compare(x,y)}
    var
     _o$_=0,
     _pd_=
      [0,
       _ba_
        (cst_remove,
         [246,
          function(_Io_)
           {var _Ip_=remove(_pb_,cmp,cmp_k,_pa_);
            return check_poly
                    (function(_Iq_){return repr$8(_Iq_,repr$0,repr$39)},
                     _pc_,
                     _Ip_)}]),
       _o$_],
     _pg_=
      [0,
       _a$_
        (cst_heterogeneous,
         [0,
          _ba_
           (cst_try_get,
            [246,
             function(_In_)
              {return check_some_42(try_get(_pf_,cmp,cmp_k,_pe_))}]),
          _pd_]),
       _o__];
    function make$8(t,x,expected)
     {var
       _Ii_=
        [246,
         function(_Ik_)
          {var _Il_=remove(t,cmp,cmp,x);
           return check_poly
                   (function(_Im_){return repr$8(_Im_,repr$0,repr$39)},
                    expected,
                    _Il_)}],
       _Ij_=repr$39(t);
      return caml_call3(_bc_(_ph_),_Ij_,x,_Ii_)}
    function make_t(t,x,expected){return make$8(t,x,[0,1,expected])}
    function make_f(t,x){return make$8(t,x,[0,0,t])}
    var
     _pi_=[0,make_f(brbr135b79b11,12),0],
     _pk_=[0,make_t(brbr135b79b11,11,_pj_),_pi_],
     _pl_=[0,make_f(brbr135b79b11,10),_pk_],
     _pn_=[0,make_t(brbr135b79b11,9,_pm_),_pl_],
     _po_=[0,make_f(brbr135b79b11,8),_pn_],
     _pq_=[0,make_t(brbr135b79b11,7,_pp_),_po_],
     _pr_=[0,make_f(brbr135b79b11,6),_pq_],
     _pt_=[0,make_t(brbr135b79b11,5,_ps_),_pr_],
     _pu_=[0,make_f(brbr135b79b11,4),_pt_],
     _pw_=[0,make_t(brbr135b79b11,3,_pv_),_pu_],
     _px_=[0,make_f(brbr135b79b11,2),_pw_],
     _pz_=[0,make_t(brbr135b79b11,1,_py_),_px_],
     _pA_=[0,make_f(brbr135b79b11,0),_pz_],
     _pB_=[0,make_f(brb1r35b79b11,12),_pA_],
     _pD_=[0,make_t(brb1r35b79b11,11,_pC_),_pB_],
     _pE_=[0,make_f(brb1r35b79b11,10),_pD_],
     _pG_=[0,make_t(brb1r35b79b11,9,_pF_),_pE_],
     _pH_=[0,make_f(brb1r35b79b11,8),_pG_],
     _pJ_=[0,make_t(brb1r35b79b11,7,_pI_),_pH_],
     _pK_=[0,make_f(brb1r35b79b11,6),_pJ_],
     _pM_=[0,make_t(brb1r35b79b11,5,_pL_),_pK_],
     _pN_=[0,make_f(brb1r35b79b11,4),_pM_],
     _pP_=[0,make_t(brb1r35b79b11,3,_pO_),_pN_],
     _pQ_=[0,make_f(brb1r35b79b11,2),_pP_],
     _pS_=[0,make_t(brb1r35b79b11,1,_pR_),_pQ_],
     _pT_=[0,make_f(brb1r35b79b11,0),_pS_],
     _pU_=[0,make_f(brb13br579b11,12),_pT_],
     _pW_=[0,make_t(brb13br579b11,11,_pV_),_pU_],
     _pX_=[0,make_f(brb13br579b11,10),_pW_],
     _pZ_=[0,make_t(brb13br579b11,9,_pY_),_pX_],
     _p0_=[0,make_f(brb13br579b11,8),_pZ_],
     _p2_=[0,make_t(brb13br579b11,7,_p1_),_p0_],
     _p3_=[0,make_f(brb13br579b11,6),_p2_],
     _p5_=[0,make_t(brb13br579b11,5,_p4_),_p3_],
     _p6_=[0,make_f(brb13br579b11,4),_p5_],
     _p8_=[0,make_t(brb13br579b11,3,_p7_),_p6_],
     _p9_=[0,make_f(brb13br579b11,2),_p8_],
     _p$_=[0,make_t(brb13br579b11,1,_p__),_p9_],
     _qa_=[0,make_f(brb13br579b11,0),_p$_],
     _qb_=[0,make_f(brb13b5r79b11,12),_qa_],
     _qd_=[0,make_t(brb13b5r79b11,11,_qc_),_qb_],
     _qe_=[0,make_f(brb13b5r79b11,10),_qd_],
     _qg_=[0,make_t(brb13b5r79b11,9,_qf_),_qe_],
     _qh_=[0,make_f(brb13b5r79b11,8),_qg_],
     _qj_=[0,make_t(brb13b5r79b11,7,_qi_),_qh_],
     _qk_=[0,make_f(brb13b5r79b11,6),_qj_],
     _qm_=[0,make_t(brb13b5r79b11,5,_ql_),_qk_],
     _qn_=[0,make_f(brb13b5r79b11,4),_qm_],
     _qp_=[0,make_t(brb13b5r79b11,3,_qo_),_qn_],
     _qq_=[0,make_f(brb13b5r79b11,2),_qp_],
     _qs_=[0,make_t(brb13b5r79b11,1,_qr_),_qq_],
     _qt_=[0,make_f(brb13b5r79b11,0),_qs_],
     _qu_=[0,make_f(brb13b57br911,12),_qt_],
     _qw_=[0,make_t(brb13b57br911,11,_qv_),_qu_],
     _qx_=[0,make_f(brb13b57br911,10),_qw_],
     _qz_=[0,make_t(brb13b57br911,9,_qy_),_qx_],
     _qA_=[0,make_f(brb13b57br911,8),_qz_],
     _qC_=[0,make_t(brb13b57br911,7,_qB_),_qA_],
     _qD_=[0,make_f(brb13b57br911,6),_qC_],
     _qF_=[0,make_t(brb13b57br911,5,_qE_),_qD_],
     _qG_=[0,make_f(brb13b57br911,4),_qF_],
     _qI_=[0,make_t(brb13b57br911,3,_qH_),_qG_],
     _qJ_=[0,make_f(brb13b57br911,2),_qI_],
     _qL_=[0,make_t(brb13b57br911,1,_qK_),_qJ_],
     _qM_=[0,make_f(brb13b57br911,0),_qL_],
     _qN_=[0,make_f(brb13b57b9r11,12),_qM_],
     _qP_=[0,make_t(brb13b57b9r11,11,_qO_),_qN_],
     _qQ_=[0,make_f(brb13b57b9r11,10),_qP_],
     _qS_=[0,make_t(brb13b57b9r11,9,_qR_),_qQ_],
     _qT_=[0,make_f(brb13b57b9r11,8),_qS_],
     _qV_=[0,make_t(brb13b57b9r11,7,_qU_),_qT_],
     _qW_=[0,make_f(brb13b57b9r11,6),_qV_],
     _qY_=[0,make_t(brb13b57b9r11,5,_qX_),_qW_],
     _qZ_=[0,make_f(brb13b57b9r11,4),_qY_],
     _q1_=[0,make_t(brb13b57b9r11,3,_q0_),_qZ_],
     _q2_=[0,make_f(brb13b57b9r11,2),_q1_],
     _q4_=[0,make_t(brb13b57b9r11,1,_q3_),_q2_],
     _q5_=[0,make_f(brb13b57b9r11,0),_q4_],
     _q6_=[0,make_f(bbr13r57br911,12),_q5_],
     _q8_=[0,make_t(bbr13r57br911,11,_q7_),_q6_],
     _q9_=[0,make_f(bbr13r57br911,10),_q8_],
     _q$_=[0,make_t(bbr13r57br911,9,_q__),_q9_],
     _ra_=[0,make_f(bbr13r57br911,8),_q$_],
     _rc_=[0,make_t(bbr13r57br911,7,_rb_),_ra_],
     _rd_=[0,make_f(bbr13r57br911,6),_rc_],
     _rf_=[0,make_t(bbr13r57br911,5,_re_),_rd_],
     _rg_=[0,make_f(bbr13r57br911,4),_rf_],
     _ri_=[0,make_t(bbr13r57br911,3,_rh_),_rg_],
     _rj_=[0,make_f(bbr13r57br911,2),_ri_],
     _rl_=[0,make_t(bbr13r57br911,1,_rk_),_rj_],
     _rm_=[0,make_f(bbr13r57br911,0),_rl_],
     _rn_=[0,make_f(bbr13r57b9r11,12),_rm_],
     _rp_=[0,make_t(bbr13r57b9r11,11,_ro_),_rn_],
     _rq_=[0,make_f(bbr13r57b9r11,10),_rp_],
     _rs_=[0,make_t(bbr13r57b9r11,9,_rr_),_rq_],
     _rt_=[0,make_f(bbr13r57b9r11,8),_rs_],
     _rv_=[0,make_t(bbr13r57b9r11,7,_ru_),_rt_],
     _rw_=[0,make_f(bbr13r57b9r11,6),_rv_],
     _ry_=[0,make_t(bbr13r57b9r11,5,_rx_),_rw_],
     _rz_=[0,make_f(bbr13r57b9r11,4),_ry_],
     _rB_=[0,make_t(bbr13r57b9r11,3,_rA_),_rz_],
     _rC_=[0,make_f(bbr13r57b9r11,2),_rB_],
     _rE_=[0,make_t(bbr13r57b9r11,1,_rD_),_rC_],
     _rF_=[0,make_f(bbr13r57b9r11,0),_rE_],
     _rG_=[0,make_f(bbr135rb79b11,12),_rF_],
     _rI_=[0,make_t(bbr135rb79b11,11,_rH_),_rG_],
     _rJ_=[0,make_f(bbr135rb79b11,10),_rI_],
     _rL_=[0,make_t(bbr135rb79b11,9,_rK_),_rJ_],
     _rM_=[0,make_f(bbr135rb79b11,8),_rL_],
     _rO_=[0,make_t(bbr135rb79b11,7,_rN_),_rM_],
     _rP_=[0,make_f(bbr135rb79b11,6),_rO_],
     _rR_=[0,make_t(bbr135rb79b11,5,_rQ_),_rP_],
     _rS_=[0,make_f(bbr135rb79b11,4),_rR_],
     _rU_=[0,make_t(bbr135rb79b11,3,_rT_),_rS_],
     _rV_=[0,make_f(bbr135rb79b11,2),_rU_],
     _rX_=[0,make_t(bbr135rb79b11,1,_rW_),_rV_],
     _rY_=[0,make_f(bbr135rb79b11,0),_rX_],
     _rZ_=[0,make_f(bbr135br79r11,12),_rY_],
     _r1_=[0,make_t(bbr135br79r11,11,_r0_),_rZ_],
     _r2_=[0,make_f(bbr135br79r11,10),_r1_],
     _r4_=[0,make_t(bbr135br79r11,9,_r3_),_r2_],
     _r5_=[0,make_f(bbr135br79r11,8),_r4_],
     _r7_=[0,make_t(bbr135br79r11,7,_r6_),_r5_],
     _r8_=[0,make_f(bbr135br79r11,6),_r7_],
     _r__=[0,make_t(bbr135br79r11,5,_r9_),_r8_],
     _r$_=[0,make_f(bbr135br79r11,4),_r__],
     _sb_=[0,make_t(bbr135br79r11,3,_sa_),_r$_],
     _sc_=[0,make_f(bbr135br79r11,2),_sb_],
     _se_=[0,make_t(bbr135br79r11,1,_sd_),_sc_],
     _sf_=[0,make_f(bbr135br79r11,0),_se_],
     _sg_=[0,make_f(bb1r35rb79b11,12),_sf_],
     _si_=[0,make_t(bb1r35rb79b11,11,_sh_),_sg_],
     _sj_=[0,make_f(bb1r35rb79b11,10),_si_],
     _sl_=[0,make_t(bb1r35rb79b11,9,_sk_),_sj_],
     _sm_=[0,make_f(bb1r35rb79b11,8),_sl_],
     _so_=[0,make_t(bb1r35rb79b11,7,_sn_),_sm_],
     _sp_=[0,make_f(bb1r35rb79b11,6),_so_],
     _sr_=[0,make_t(bb1r35rb79b11,5,_sq_),_sp_],
     _ss_=[0,make_f(bb1r35rb79b11,4),_sr_],
     _su_=[0,make_t(bb1r35rb79b11,3,_st_),_ss_],
     _sv_=[0,make_f(bb1r35rb79b11,2),_su_],
     _sx_=[0,make_t(bb1r35rb79b11,1,_sw_),_sv_],
     _sy_=[0,make_f(bb1r35rb79b11,0),_sx_],
     _sz_=[0,make_f(bb1r35br79r11,12),_sy_],
     _sB_=[0,make_t(bb1r35br79r11,11,_sA_),_sz_],
     _sC_=[0,make_f(bb1r35br79r11,10),_sB_],
     _sE_=[0,make_t(bb1r35br79r11,9,_sD_),_sC_],
     _sF_=[0,make_f(bb1r35br79r11,8),_sE_],
     _sH_=[0,make_t(bb1r35br79r11,7,_sG_),_sF_],
     _sI_=[0,make_f(bb1r35br79r11,6),_sH_],
     _sK_=[0,make_t(bb1r35br79r11,5,_sJ_),_sI_],
     _sL_=[0,make_f(bb1r35br79r11,4),_sK_],
     _sN_=[0,make_t(bb1r35br79r11,3,_sM_),_sL_],
     _sO_=[0,make_f(bb1r35br79r11,2),_sN_],
     _sQ_=[0,make_t(bb1r35br79r11,1,_sP_),_sO_],
     _sR_=[0,make_f(bb1r35br79r11,0),_sQ_],
     _sS_=[0,make_f(bb13rbr579b11,12),_sR_],
     _sU_=[0,make_t(bb13rbr579b11,11,_sT_),_sS_],
     _sV_=[0,make_f(bb13rbr579b11,10),_sU_],
     _sX_=[0,make_t(bb13rbr579b11,9,_sW_),_sV_],
     _sY_=[0,make_f(bb13rbr579b11,8),_sX_],
     _s0_=[0,make_t(bb13rbr579b11,7,_sZ_),_sY_],
     _s1_=[0,make_f(bb13rbr579b11,6),_s0_],
     _s3_=[0,make_t(bb13rbr579b11,5,_s2_),_s1_],
     _s4_=[0,make_f(bb13rbr579b11,4),_s3_],
     _s6_=[0,make_t(bb13rbr579b11,3,_s5_),_s4_],
     _s7_=[0,make_f(bb13rbr579b11,2),_s6_],
     _s9_=[0,make_t(bb13rbr579b11,1,_s8_),_s7_],
     _s__=[0,make_f(bb13rbr579b11,0),_s9_],
     _s$_=[0,make_f(bb13rb5r79b11,12),_s__],
     _tb_=[0,make_t(bb13rb5r79b11,11,_ta_),_s$_],
     _tc_=[0,make_f(bb13rb5r79b11,10),_tb_],
     _te_=[0,make_t(bb13rb5r79b11,9,_td_),_tc_],
     _tf_=[0,make_f(bb13rb5r79b11,8),_te_],
     _th_=[0,make_t(bb13rb5r79b11,7,_tg_),_tf_],
     _ti_=[0,make_f(bb13rb5r79b11,6),_th_],
     _tk_=[0,make_t(bb13rb5r79b11,5,_tj_),_ti_],
     _tl_=[0,make_f(bb13rb5r79b11,4),_tk_],
     _tn_=[0,make_t(bb13rb5r79b11,3,_tm_),_tl_],
     _to_=[0,make_f(bb13rb5r79b11,2),_tn_],
     _tq_=[0,make_t(bb13rb5r79b11,1,_tp_),_to_],
     _tr_=[0,make_f(bb13rb5r79b11,0),_tq_],
     _ts_=[0,make_f(bb13rb57br911,12),_tr_],
     _tu_=[0,make_t(bb13rb57br911,11,_tt_),_ts_],
     _tv_=[0,make_f(bb13rb57br911,10),_tu_],
     _tx_=[0,make_t(bb13rb57br911,9,_tw_),_tv_],
     _ty_=[0,make_f(bb13rb57br911,8),_tx_],
     _tA_=[0,make_t(bb13rb57br911,7,_tz_),_ty_],
     _tB_=[0,make_f(bb13rb57br911,6),_tA_],
     _tD_=[0,make_t(bb13rb57br911,5,_tC_),_tB_],
     _tE_=[0,make_f(bb13rb57br911,4),_tD_],
     _tG_=[0,make_t(bb13rb57br911,3,_tF_),_tE_],
     _tH_=[0,make_f(bb13rb57br911,2),_tG_],
     _tJ_=[0,make_t(bb13rb57br911,1,_tI_),_tH_],
     _tK_=[0,make_f(bb13rb57br911,0),_tJ_],
     _tL_=[0,make_f(bb13rb57b9r11,12),_tK_],
     _tN_=[0,make_t(bb13rb57b9r11,11,_tM_),_tL_],
     _tO_=[0,make_f(bb13rb57b9r11,10),_tN_],
     _tQ_=[0,make_t(bb13rb57b9r11,9,_tP_),_tO_],
     _tR_=[0,make_f(bb13rb57b9r11,8),_tQ_],
     _tT_=[0,make_t(bb13rb57b9r11,7,_tS_),_tR_],
     _tU_=[0,make_f(bb13rb57b9r11,6),_tT_],
     _tW_=[0,make_t(bb13rb57b9r11,5,_tV_),_tU_],
     _tX_=[0,make_f(bb13rb57b9r11,4),_tW_],
     _tZ_=[0,make_t(bb13rb57b9r11,3,_tY_),_tX_],
     _t0_=[0,make_f(bb13rb57b9r11,2),_tZ_],
     _t2_=[0,make_t(bb13rb57b9r11,1,_t1_),_t0_],
     _t3_=[0,make_f(bb13rb57b9r11,0),_t2_],
     _t4_=[0,make_f(brb13b57b9,10),_t3_],
     _t6_=[0,make_t(brb13b57b9,9,_t5_),_t4_],
     _t7_=[0,make_f(brb13b57b9,8),_t6_],
     _t9_=[0,make_t(brb13b57b9,7,_t8_),_t7_],
     _t__=[0,make_f(brb13b57b9,6),_t9_],
     _ua_=[0,make_t(brb13b57b9,5,_t$_),_t__],
     _ub_=[0,make_f(brb13b57b9,4),_ua_],
     _ud_=[0,make_t(brb13b57b9,3,_uc_),_ub_],
     _ue_=[0,make_f(brb13b57b9,2),_ud_],
     _ug_=[0,make_t(brb13b57b9,1,_uf_),_ue_],
     _uh_=[0,make_f(brb13b57b9,0),_ug_],
     _ui_=[0,make_f(bbr13r57b9,10),_uh_],
     _uk_=[0,make_t(bbr13r57b9,9,_uj_),_ui_],
     _ul_=[0,make_f(bbr13r57b9,8),_uk_],
     _un_=[0,make_t(bbr13r57b9,7,_um_),_ul_],
     _uo_=[0,make_f(bbr13r57b9,6),_un_],
     _uq_=[0,make_t(bbr13r57b9,5,_up_),_uo_],
     _ur_=[0,make_f(bbr13r57b9,4),_uq_],
     _ut_=[0,make_t(bbr13r57b9,3,_us_),_ur_],
     _uu_=[0,make_f(bbr13r57b9,2),_ut_],
     _uw_=[0,make_t(bbr13r57b9,1,_uv_),_uu_],
     _ux_=[0,make_f(bbr13r57b9,0),_uw_],
     _uy_=[0,make_f(bbr135br79,10),_ux_],
     _uA_=[0,make_t(bbr135br79,9,_uz_),_uy_],
     _uB_=[0,make_f(bbr135br79,8),_uA_],
     _uD_=[0,make_t(bbr135br79,7,_uC_),_uB_],
     _uE_=[0,make_f(bbr135br79,6),_uD_],
     _uG_=[0,make_t(bbr135br79,5,_uF_),_uE_],
     _uH_=[0,make_f(bbr135br79,4),_uG_],
     _uJ_=[0,make_t(bbr135br79,3,_uI_),_uH_],
     _uK_=[0,make_f(bbr135br79,2),_uJ_],
     _uM_=[0,make_t(bbr135br79,1,_uL_),_uK_],
     _uN_=[0,make_f(bbr135br79,0),_uM_],
     _uO_=[0,make_f(bbr135b7r9,10),_uN_],
     _uQ_=[0,make_t(bbr135b7r9,9,_uP_),_uO_],
     _uR_=[0,make_f(bbr135b7r9,8),_uQ_],
     _uT_=[0,make_t(bbr135b7r9,7,_uS_),_uR_],
     _uU_=[0,make_f(bbr135b7r9,6),_uT_],
     _uW_=[0,make_t(bbr135b7r9,5,_uV_),_uU_],
     _uX_=[0,make_f(bbr135b7r9,4),_uW_],
     _uZ_=[0,make_t(bbr135b7r9,3,_uY_),_uX_],
     _u0_=[0,make_f(bbr135b7r9,2),_uZ_],
     _u2_=[0,make_t(bbr135b7r9,1,_u1_),_u0_],
     _u3_=[0,make_f(bbr135b7r9,0),_u2_],
     _u4_=[0,make_f(bb1r35br79,10),_u3_],
     _u6_=[0,make_t(bb1r35br79,9,_u5_),_u4_],
     _u7_=[0,make_f(bb1r35br79,8),_u6_],
     _u9_=[0,make_t(bb1r35br79,7,_u8_),_u7_],
     _u__=[0,make_f(bb1r35br79,6),_u9_],
     _va_=[0,make_t(bb1r35br79,5,_u$_),_u__],
     _vb_=[0,make_f(bb1r35br79,4),_va_],
     _vd_=[0,make_t(bb1r35br79,3,_vc_),_vb_],
     _ve_=[0,make_f(bb1r35br79,2),_vd_],
     _vg_=[0,make_t(bb1r35br79,1,_vf_),_ve_],
     _vh_=[0,make_f(bb1r35br79,0),_vg_],
     _vi_=[0,make_f(bb1r35b7r9,10),_vh_],
     _vk_=[0,make_t(bb1r35b7r9,9,_vj_),_vi_],
     _vl_=[0,make_f(bb1r35b7r9,8),_vk_],
     _vn_=[0,make_t(bb1r35b7r9,7,_vm_),_vl_],
     _vo_=[0,make_f(bb1r35b7r9,6),_vn_],
     _vq_=[0,make_t(bb1r35b7r9,5,_vp_),_vo_],
     _vr_=[0,make_f(bb1r35b7r9,4),_vq_],
     _vt_=[0,make_t(bb1r35b7r9,3,_vs_),_vr_],
     _vu_=[0,make_f(bb1r35b7r9,2),_vt_],
     _vw_=[0,make_t(bb1r35b7r9,1,_vv_),_vu_],
     _vx_=[0,make_f(bb1r35b7r9,0),_vw_],
     _vy_=[0,make_f(bb13rb57b9,10),_vx_],
     _vA_=[0,make_t(bb13rb57b9,9,_vz_),_vy_],
     _vB_=[0,make_f(bb13rb57b9,8),_vA_],
     _vD_=[0,make_t(bb13rb57b9,7,_vC_),_vB_],
     _vE_=[0,make_f(bb13rb57b9,6),_vD_],
     _vG_=[0,make_t(bb13rb57b9,5,_vF_),_vE_],
     _vH_=[0,make_f(bb13rb57b9,4),_vG_],
     _vJ_=[0,make_t(bb13rb57b9,3,_vI_),_vH_],
     _vK_=[0,make_f(bb13rb57b9,2),_vJ_],
     _vM_=[0,make_t(bb13rb57b9,1,_vL_),_vK_],
     _vN_=[0,make_f(bb13rb57b9,0),_vM_],
     _vO_=[0,make_f(bb13br57r9,10),_vN_],
     _vQ_=[0,make_t(bb13br57r9,9,_vP_),_vO_],
     _vR_=[0,make_f(bb13br57r9,8),_vQ_],
     _vT_=[0,make_t(bb13br57r9,7,_vS_),_vR_],
     _vU_=[0,make_f(bb13br57r9,6),_vT_],
     _vW_=[0,make_t(bb13br57r9,5,_vV_),_vU_],
     _vX_=[0,make_f(bb13br57r9,4),_vW_],
     _vZ_=[0,make_t(bb13br57r9,3,_vY_),_vX_],
     _v0_=[0,make_f(bb13br57r9,2),_vZ_],
     _v2_=[0,make_t(bb13br57r9,1,_v1_),_v0_],
     _v3_=[0,make_f(bb13br57r9,0),_v2_],
     _v4_=[0,make_f(bbr135b7,8),_v3_],
     _v6_=[0,make_t(bbr135b7,7,_v5_),_v4_],
     _v7_=[0,make_f(bbr135b7,6),_v6_],
     _v9_=[0,make_t(bbr135b7,5,_v8_),_v7_],
     _v__=[0,make_f(bbr135b7,4),_v9_],
     _wa_=[0,make_t(bbr135b7,3,_v$_),_v__],
     _wb_=[0,make_f(bbr135b7,2),_wa_],
     _wd_=[0,make_t(bbr135b7,1,_wc_),_wb_],
     _we_=[0,make_f(bbr135b7,0),_wd_],
     _wf_=[0,make_f(bb1r35b7,8),_we_],
     _wh_=[0,make_t(bb1r35b7,7,_wg_),_wf_],
     _wi_=[0,make_f(bb1r35b7,6),_wh_],
     _wk_=[0,make_t(bb1r35b7,5,_wj_),_wi_],
     _wl_=[0,make_f(bb1r35b7,4),_wk_],
     _wn_=[0,make_t(bb1r35b7,3,_wm_),_wl_],
     _wo_=[0,make_f(bb1r35b7,2),_wn_],
     _wq_=[0,make_t(bb1r35b7,1,_wp_),_wo_],
     _wr_=[0,make_f(bb1r35b7,0),_wq_],
     _ws_=[0,make_f(bb13br57,8),_wr_],
     _wu_=[0,make_t(bb13br57,7,_wt_),_ws_],
     _wv_=[0,make_f(bb13br57,6),_wu_],
     _wx_=[0,make_t(bb13br57,5,_ww_),_wv_],
     _wy_=[0,make_f(bb13br57,4),_wx_],
     _wA_=[0,make_t(bb13br57,3,_wz_),_wy_],
     _wB_=[0,make_f(bb13br57,2),_wA_],
     _wD_=[0,make_t(bb13br57,1,_wC_),_wB_],
     _wE_=[0,make_f(bb13br57,0),_wD_],
     _wF_=[0,make_f(bb13b5r7,8),_wE_],
     _wH_=[0,make_t(bb13b5r7,7,_wG_),_wF_],
     _wI_=[0,make_f(bb13b5r7,6),_wH_],
     _wK_=[0,make_t(bb13b5r7,5,_wJ_),_wI_],
     _wL_=[0,make_f(bb13b5r7,4),_wK_],
     _wN_=[0,make_t(bb13b5r7,3,_wM_),_wL_],
     _wO_=[0,make_f(bb13b5r7,2),_wN_],
     _wQ_=[0,make_t(bb13b5r7,1,_wP_),_wO_],
     _wR_=[0,make_f(bb13b5r7,0),_wQ_],
     _wS_=[0,make_f(br13r5,6),_wR_],
     _wU_=[0,make_t(br13r5,5,_wT_),_wS_],
     _wV_=[0,make_f(br13r5,4),_wU_],
     _wX_=[0,make_t(br13r5,3,_wW_),_wV_],
     _wY_=[0,make_f(br13r5,2),_wX_],
     _w0_=[0,make_t(br13r5,1,_wZ_),_wY_],
     _w1_=[0,make_f(br13r5,0),_w0_],
     _w2_=[0,make_f(bb13b5,6),_w1_],
     _w4_=[0,make_t(bb13b5,5,_w3_),_w2_],
     _w5_=[0,make_f(bb13b5,4),_w4_],
     _w7_=[0,make_t(bb13b5,3,_w6_),_w5_],
     _w8_=[0,make_f(bb13b5,2),_w7_],
     _w__=[0,make_t(bb13b5,1,_w9_),_w8_],
     _w$_=[0,make_f(bb13b5,0),_w__],
     _xa_=[0,make_f(br13,4),_w$_],
     _xc_=[0,make_t(br13,3,_xb_),_xa_],
     _xd_=[0,make_f(br13,2),_xc_],
     _xf_=[0,make_t(br13,1,_xe_),_xd_],
     _xg_=[0,make_f(br13,0),_xf_],
     _xh_=[0,make_f(b1r3,4),_xg_],
     _xj_=[0,make_t(b1r3,3,_xi_),_xh_],
     _xk_=[0,make_f(b1r3,2),_xj_],
     _xm_=[0,make_t(b1r3,1,_xl_),_xk_],
     _xn_=[0,make_f(b1r3,0),_xm_],
     _xo_=[0,make_f(b1,2),_xn_],
     _xp_=[0,make_t(b1,1,0),_xo_],
     _xq_=[0,make_f(b1,0),_xp_],
     _xr_=[0,_a$_(cst_remove$0,[0,make_f(0,0),_xq_]),_pg_],
     _xs_=0,
     _xt_=
      [0,
       _ba_
        (cst_not_empty,
         [246,function(_Ih_){return check_false(is_empty$0(bb13b5r7))}]),
       _xs_],
     _xu_=
      [0,
       _a$_
        (cst_is_empty,
         [0,
          _ba_
           (cst_empty,[246,function(_Ig_){return check_true(is_empty$0(0))}]),
          _xt_]),
       _xr_];
    function make$9(t,x,expected)
     {var
       _Id_=
        [246,
         function(_If_)
          {return check_int_option(expected,try_get(t,cmp,cmp,x))}],
       _Ie_=repr$39(t);
      return caml_call3(_bc_(_xv_),_Ie_,x,_Id_)}
    function make_t$0(t,x){return make$9(t,x,[0,caml_call1(abs,x)])}
    function make_f$0(t,x){return make$9(t,x,0)}
    var
     _xw_=[0,make_f$0(br13r5,6),0],
     _xx_=[0,make_t$0(br13r5,5),_xw_],
     _xy_=[0,make_f$0(br13r5,4),_xx_],
     _xz_=[0,make_t$0(br13r5,3),_xy_],
     _xA_=[0,make_f$0(br13r5,2),_xz_],
     _xB_=[0,make_t$0(br13r5,1),_xA_],
     _xC_=[0,make_f$0(br13r5,0),_xB_],
     _xD_=[0,make_t$0(br13r5,-1),_xC_],
     _xE_=[0,make_f$0(br13r5,-2),_xD_],
     _xF_=[0,make_t$0(br13r5,-3),_xE_],
     _xG_=[0,make_f$0(br13r5,-4),_xF_],
     _xH_=[0,make_t$0(br13r5,-5),_xG_],
     _xI_=[0,_a$_(cst_try_get$0,[0,make_f$0(br13r5,-6),_xH_]),_xu_];
    function make$10(t,x,expected)
     {var
       _Ia_=
        [246,
         function(_Ic_){return check_poly(repr$39,expected,replace(t,cmp,x))}],
       _Ib_=repr$39(t);
      return caml_call3(_bc_(_xJ_),_Ib_,x,_Ia_)}
    var
     _xL_=[0,make$10(br13,4,_xK_),0],
     _xN_=[0,make$10(br13,3,_xM_),_xL_],
     _xP_=[0,make$10(br13,2,_xO_),_xN_],
     _xR_=[0,make$10(br13,1,_xQ_),_xP_],
     _xT_=[0,make$10(br13,0,_xS_),_xR_],
     _xV_=[0,make$10(br13,-1,_xU_),_xT_],
     _xX_=[0,make$10(br13,-2,_xW_),_xV_],
     _xZ_=[0,make$10(br13,-3,_xY_),_xX_],
     _x1_=[0,make$10(br13,-4,_x0_),_xZ_],
     _x3_=[0,make$10(b1r3,4,_x2_),_x1_],
     _x5_=[0,make$10(b1r3,3,_x4_),_x3_],
     _x7_=[0,make$10(b1r3,2,_x6_),_x5_],
     _x9_=[0,make$10(b1r3,1,_x8_),_x7_],
     _x$_=[0,make$10(b1r3,0,_x__),_x9_],
     _yb_=[0,make$10(b1r3,-1,_ya_),_x$_],
     _yd_=[0,make$10(b1r3,-2,_yc_),_yb_],
     _yf_=[0,make$10(b1r3,-3,_ye_),_yd_],
     _yh_=[0,make$10(b1r3,-4,_yg_),_yf_],
     _yj_=[0,make$10(b1,2,_yi_),_yh_],
     _yl_=[0,make$10(b1,1,_yk_),_yj_],
     _yn_=[0,make$10(b1,0,_ym_),_yl_],
     _yp_=[0,make$10(b1,-1,_yo_),_yn_],
     _yr_=[0,make$10(b1,-2,_yq_),_yp_],
     _yt_=[0,_a$_(cst_replace,[0,make$10(0,0,_ys_),_yr_]),_xI_];
    function make$11(t,x,expected)
     {var
       _H7_=
        [246,
         function(_H9_)
          {var _H__=add$5(t,cmp,x);
           return check_poly
                   (function(_H$_){return repr$8(_H$_,repr$0,repr$39)},
                    expected,
                    _H__)}],
       _H8_=repr$39(t);
      return caml_call3(_bc_(_yu_),_H8_,x,_H7_)}
    function make_t$1(t,x,expected){return make$11(t,x,[0,1,expected])}
    function make_f$1(t,x){return make$11(t,x,[0,0,t])}
    var
     _yw_=[0,make_t$1(brb13b57b9,10,_yv_),0],
     _yx_=[0,make_f$1(brb13b57b9,9),_yw_],
     _yz_=[0,make_t$1(brb13b57b9,8,_yy_),_yx_],
     _yA_=[0,make_f$1(brb13b57b9,7),_yz_],
     _yC_=[0,make_t$1(brb13b57b9,6,_yB_),_yA_],
     _yD_=[0,make_f$1(brb13b57b9,5),_yC_],
     _yF_=[0,make_t$1(brb13b57b9,4,_yE_),_yD_],
     _yG_=[0,make_f$1(brb13b57b9,3),_yF_],
     _yI_=[0,make_t$1(brb13b57b9,2,_yH_),_yG_],
     _yJ_=[0,make_f$1(brb13b57b9,1),_yI_],
     _yL_=[0,make_t$1(brb13b57b9,0,_yK_),_yJ_],
     _yN_=[0,make_t$1(bbr13r57b9,10,_yM_),_yL_],
     _yO_=[0,make_f$1(bbr13r57b9,9),_yN_],
     _yQ_=[0,make_t$1(bbr13r57b9,8,_yP_),_yO_],
     _yR_=[0,make_f$1(bbr13r57b9,7),_yQ_],
     _yT_=[0,make_t$1(bbr13r57b9,6,_yS_),_yR_],
     _yU_=[0,make_f$1(bbr13r57b9,5),_yT_],
     _yW_=[0,make_t$1(bbr13r57b9,4,_yV_),_yU_],
     _yX_=[0,make_f$1(bbr13r57b9,3),_yW_],
     _yZ_=[0,make_t$1(bbr13r57b9,2,_yY_),_yX_],
     _y0_=[0,make_f$1(bbr13r57b9,1),_yZ_],
     _y2_=[0,make_t$1(bbr13r57b9,0,_y1_),_y0_],
     _y4_=[0,make_t$1(bbr135br79,10,_y3_),_y2_],
     _y5_=[0,make_f$1(bbr135br79,9),_y4_],
     _y7_=[0,make_t$1(bbr135br79,8,_y6_),_y5_],
     _y8_=[0,make_f$1(bbr135br79,7),_y7_],
     _y__=[0,make_t$1(bbr135br79,6,_y9_),_y8_],
     _y$_=[0,make_f$1(bbr135br79,5),_y__],
     _zb_=[0,make_t$1(bbr135br79,4,_za_),_y$_],
     _zc_=[0,make_f$1(bbr135br79,3),_zb_],
     _ze_=[0,make_t$1(bbr135br79,2,_zd_),_zc_],
     _zf_=[0,make_f$1(bbr135br79,1),_ze_],
     _zh_=[0,make_t$1(bbr135br79,0,_zg_),_zf_],
     _zj_=[0,make_t$1(bbr135b7r9,10,_zi_),_zh_],
     _zk_=[0,make_f$1(bbr135b7r9,9),_zj_],
     _zm_=[0,make_t$1(bbr135b7r9,8,_zl_),_zk_],
     _zn_=[0,make_f$1(bbr135b7r9,7),_zm_],
     _zp_=[0,make_t$1(bbr135b7r9,6,_zo_),_zn_],
     _zq_=[0,make_f$1(bbr135b7r9,5),_zp_],
     _zs_=[0,make_t$1(bbr135b7r9,4,_zr_),_zq_],
     _zt_=[0,make_f$1(bbr135b7r9,3),_zs_],
     _zv_=[0,make_t$1(bbr135b7r9,2,_zu_),_zt_],
     _zw_=[0,make_f$1(bbr135b7r9,1),_zv_],
     _zy_=[0,make_t$1(bbr135b7r9,0,_zx_),_zw_],
     _zA_=[0,make_t$1(bb1r35br79,10,_zz_),_zy_],
     _zB_=[0,make_f$1(bb1r35br79,9),_zA_],
     _zD_=[0,make_t$1(bb1r35br79,8,_zC_),_zB_],
     _zE_=[0,make_f$1(bb1r35br79,7),_zD_],
     _zG_=[0,make_t$1(bb1r35br79,6,_zF_),_zE_],
     _zH_=[0,make_f$1(bb1r35br79,5),_zG_],
     _zJ_=[0,make_t$1(bb1r35br79,4,_zI_),_zH_],
     _zK_=[0,make_f$1(bb1r35br79,3),_zJ_],
     _zM_=[0,make_t$1(bb1r35br79,2,_zL_),_zK_],
     _zN_=[0,make_f$1(bb1r35br79,1),_zM_],
     _zP_=[0,make_t$1(bb1r35br79,0,_zO_),_zN_],
     _zR_=[0,make_t$1(bb1r35b7r9,10,_zQ_),_zP_],
     _zS_=[0,make_f$1(bb1r35b7r9,9),_zR_],
     _zU_=[0,make_t$1(bb1r35b7r9,8,_zT_),_zS_],
     _zV_=[0,make_f$1(bb1r35b7r9,7),_zU_],
     _zX_=[0,make_t$1(bb1r35b7r9,6,_zW_),_zV_],
     _zY_=[0,make_f$1(bb1r35b7r9,5),_zX_],
     _z0_=[0,make_t$1(bb1r35b7r9,4,_zZ_),_zY_],
     _z1_=[0,make_f$1(bb1r35b7r9,3),_z0_],
     _z3_=[0,make_t$1(bb1r35b7r9,2,_z2_),_z1_],
     _z4_=[0,make_f$1(bb1r35b7r9,1),_z3_],
     _z6_=[0,make_t$1(bb1r35b7r9,0,_z5_),_z4_],
     _z8_=[0,make_t$1(bb13rb57b9,10,_z7_),_z6_],
     _z9_=[0,make_f$1(bb13rb57b9,9),_z8_],
     _z$_=[0,make_t$1(bb13rb57b9,8,_z__),_z9_],
     _Aa_=[0,make_f$1(bb13rb57b9,7),_z$_],
     _Ac_=[0,make_t$1(bb13rb57b9,6,_Ab_),_Aa_],
     _Ad_=[0,make_f$1(bb13rb57b9,5),_Ac_],
     _Af_=[0,make_t$1(bb13rb57b9,4,_Ae_),_Ad_],
     _Ag_=[0,make_f$1(bb13rb57b9,3),_Af_],
     _Ai_=[0,make_t$1(bb13rb57b9,2,_Ah_),_Ag_],
     _Aj_=[0,make_f$1(bb13rb57b9,1),_Ai_],
     _Al_=[0,make_t$1(bb13rb57b9,0,_Ak_),_Aj_],
     _An_=[0,make_t$1(bb13br57r9,10,_Am_),_Al_],
     _Ao_=[0,make_f$1(bb13br57r9,9),_An_],
     _Aq_=[0,make_t$1(bb13br57r9,8,_Ap_),_Ao_],
     _Ar_=[0,make_f$1(bb13br57r9,7),_Aq_],
     _At_=[0,make_t$1(bb13br57r9,6,_As_),_Ar_],
     _Au_=[0,make_f$1(bb13br57r9,5),_At_],
     _Aw_=[0,make_t$1(bb13br57r9,4,_Av_),_Au_],
     _Ax_=[0,make_f$1(bb13br57r9,3),_Aw_],
     _Az_=[0,make_t$1(bb13br57r9,2,_Ay_),_Ax_],
     _AA_=[0,make_f$1(bb13br57r9,1),_Az_],
     _AC_=[0,make_t$1(bb13br57r9,0,_AB_),_AA_],
     _AE_=[0,make_t$1(bbr135b7,8,_AD_),_AC_],
     _AF_=[0,make_f$1(bbr135b7,7),_AE_],
     _AH_=[0,make_t$1(bbr135b7,6,_AG_),_AF_],
     _AI_=[0,make_f$1(bbr135b7,5),_AH_],
     _AK_=[0,make_t$1(bbr135b7,4,_AJ_),_AI_],
     _AL_=[0,make_f$1(bbr135b7,3),_AK_],
     _AN_=[0,make_t$1(bbr135b7,2,_AM_),_AL_],
     _AO_=[0,make_f$1(bbr135b7,1),_AN_],
     _AQ_=[0,make_t$1(bb1r35b7,8,_AP_),_AO_],
     _AR_=[0,make_f$1(bb1r35b7,7),_AQ_],
     _AT_=[0,make_t$1(bb1r35b7,6,_AS_),_AR_],
     _AU_=[0,make_f$1(bb1r35b7,5),_AT_],
     _AW_=[0,make_t$1(bb1r35b7,4,_AV_),_AU_],
     _AX_=[0,make_f$1(bb1r35b7,3),_AW_],
     _AZ_=[0,make_t$1(bb1r35b7,2,_AY_),_AX_],
     _A0_=[0,make_f$1(bb1r35b7,1),_AZ_],
     _A2_=[0,make_t$1(bb13br57,8,_A1_),_A0_],
     _A3_=[0,make_f$1(bb13br57,7),_A2_],
     _A5_=[0,make_t$1(bb13br57,6,_A4_),_A3_],
     _A6_=[0,make_f$1(bb13br57,5),_A5_],
     _A8_=[0,make_t$1(bb13br57,4,_A7_),_A6_],
     _A9_=[0,make_f$1(bb13br57,3),_A8_],
     _A$_=[0,make_t$1(bb13br57,2,_A__),_A9_],
     _Ba_=[0,make_f$1(bb13br57,1),_A$_],
     _Bc_=[0,make_t$1(bb13b5r7,8,_Bb_),_Ba_],
     _Bd_=[0,make_f$1(bb13b5r7,7),_Bc_],
     _Bf_=[0,make_t$1(bb13b5r7,6,_Be_),_Bd_],
     _Bg_=[0,make_f$1(bb13b5r7,5),_Bf_],
     _Bi_=[0,make_t$1(bb13b5r7,4,_Bh_),_Bg_],
     _Bj_=[0,make_f$1(bb13b5r7,3),_Bi_],
     _Bl_=[0,make_t$1(bb13b5r7,2,_Bk_),_Bj_],
     _Bm_=[0,make_f$1(bb13b5r7,1),_Bl_],
     _Bo_=[0,make_t$1(bb13b5r7,0,_Bn_),_Bm_],
     _Bq_=[0,make_t$1(br13r5,6,_Bp_),_Bo_],
     _Br_=[0,make_f$1(br13r5,5),_Bq_],
     _Bt_=[0,make_t$1(br13r5,4,_Bs_),_Br_],
     _Bu_=[0,make_f$1(br13r5,3),_Bt_],
     _Bw_=[0,make_t$1(br13r5,2,_Bv_),_Bu_],
     _Bx_=[0,make_f$1(br13r5,1),_Bw_],
     _Bz_=[0,make_t$1(br13r5,0,_By_),_Bx_],
     _BB_=[0,make_t$1(bb13b5,6,_BA_),_Bz_],
     _BC_=[0,make_f$1(bb13b5,5),_BB_],
     _BE_=[0,make_t$1(bb13b5,4,_BD_),_BC_],
     _BF_=[0,make_f$1(bb13b5,3),_BE_],
     _BH_=[0,make_t$1(bb13b5,2,_BG_),_BF_],
     _BI_=[0,make_f$1(bb13b5,1),_BH_],
     _BK_=[0,make_t$1(bb13b5,0,_BJ_),_BI_],
     _BM_=[0,make_t$1(br13,4,_BL_),_BK_],
     _BN_=[0,make_f$1(br13,3),_BM_],
     _BP_=[0,make_t$1(br13,2,_BO_),_BN_],
     _BQ_=[0,make_f$1(br13,1),_BP_],
     _BS_=[0,make_t$1(br13,0,_BR_),_BQ_],
     _BU_=[0,make_t$1(b1r3,4,_BT_),_BS_],
     _BV_=[0,make_f$1(b1r3,3),_BU_],
     _BX_=[0,make_t$1(b1r3,2,_BW_),_BV_],
     _BY_=[0,make_f$1(b1r3,1),_BX_],
     _B0_=[0,make_t$1(b1r3,0,_BZ_),_BY_],
     _B2_=[0,make_t$1(b1,2,_B1_),_B0_],
     _B3_=[0,make_f$1(b1,1),_B2_],
     _B5_=[0,make_t$1(b1,0,_B4_),_B3_],
     _B7_=[0,_a$_(cst_add,[0,make_t$1(0,0,_B6_),_B5_]),_yt_],
     _B8_=0;
    function make$12(t,expected)
     {var
       _H3_=
        expected
         ?[246,
           function(_H4_)
            {return expect_exception
                     ([0,BrokenInvariants,expected],
                      [246,function(_H5_){return validate(t,cmp)}])}]
         :[246,function(_H6_){return caml_call2(_au_,validate(t,cmp),ignore)}];
      return _ba_(repr$39(t),_H3_)}
    var
     _B$_=[0,make$12(_B__,_B9_),0],
     _Cc_=[0,make$12(_Cb_,_Ca_),_B$_],
     _Cf_=[0,make$12(_Ce_,_Cd_),_Cc_],
     _Ci_=[0,make$12(_Ch_,_Cg_),_Cf_],
     _Ck_=[0,make$12(_Cj_,0),_Ci_],
     _Cn_=[0,make$12(_Cm_,_Cl_),_Ck_],
     _Cq_=[0,make$12(_Cp_,_Co_),_Cn_],
     _Cs_=[0,make$12(_Cr_,0),_Cq_],
     _Cv_=[0,make$12(_Cu_,_Ct_),_Cs_],
     _Cy_=[0,make$12(_Cx_,_Cw_),_Cv_],
     _CA_=[0,make$12(_Cz_,0),_Cy_],
     _CC_=[0,make$12(1,_CB_),_CA_],
     test$24=
      _a$_
       (cst_RedBlackTree,
        [0,
         _a$_
          (cst_Invariants,[0,_a$_(cst_validate,[0,make$12(0,0),_CC_]),_B8_]),
         _B7_]),
     empty$4=[0];
    function parent(i){return (i - 1 | 0) / 2 | 0}
    var
     BrokenInvariants$0=
      [248,
       cst_General_BinaryHeap_Invariants_BrokenInvariants,
       caml_fresh_oo_id(0)];
    function repr$41(param){return cst_IsMaxHeap}
    caml_call1
     (register_printer,
      function(param)
       {if(param[1] === BrokenInvariants$0)
         {var
           broken_invariants=param[2],
           _HZ_=function(_H2_){return join(_CD_,_H2_)},
           _H0_=
            caml_call2
             (_au_,
              caml_call2
               (_au_,
                broken_invariants,
                function(_H1_){return map$0(_H1_,repr$41)}),
              _HZ_);
          return [0,caml_call1(apply(_CE_),_H0_)]}
        return 0});
    function validate$0(xs,cmp)
     {function _HQ_(param)
       {var invariant=param[2],predicate=param[1];
        return some_if$0(1 - caml_call1(predicate,xs),invariant)}
      function _HR_(_HY_){return filter_map$0(_HY_,_HQ_)}
      var
       _HS_=0,
       _HT_=0,
       broken_invariants=
        caml_call2
         (_au_,
          [0,
           [0,
            function(xs)
             {function _HU_(i)
               {var
                 _HX_=get$2(xs,parent(i)),
                 match=caml_call2(cmp,get$2(xs,i),_HX_);
                return 2 <= match?0:1}
              function _HV_(_HW_){return for_all$0(_HW_,_HU_)}
              return caml_call2(_au_,make(0,0,xs.length - 1),_HV_)},
            _HT_],
           _HS_],
          _HR_);
      return broken_invariants
              ?raise([0,BrokenInvariants$0,broken_invariants])
              :xs}
    function swap(xs,i,j)
     {var x=get$2(xs,i);set$2(xs,i,get$2(xs,j));return set$2(xs,j,x)}
    function add$6(xs$0,cmp,x)
     {var
       xs$1=validate$0(xs$0,cmp),
       xs=caml_call2(Stdlib_arrayLabels[4],xs$1,[0,x]),
       i$0=xs.length - 1 - 1 | 0,
       i=i$0;
      for(;;)
       {if(0 !== i)
         {var
           p=parent(i),
           _HP_=get$2(xs,p),
           match=caml_call2(cmp,get$2(xs,i),_HP_);
          if(2 <= match){swap(xs,i,p);var i=p;continue}}
        return validate$0(xs,cmp)}}
    function max$15(xs){return get$2(xs,0)}
    function pop_max(xs,cmp)
     {function _HH_(_HO_){return validate$0(_HO_,cmp)}
      function _HI_(xs$0)
       {var len=xs$0.length - 1 - 1 | 0;
        if(caml_call2(_aA_,len,0))return empty$4;
        var
         last=get$2(xs$0,len),
         xs=caml_call3(Stdlib_arrayLabels[6],xs$0,0,len);
        set$2(xs,0,last);
        var i=0;
        for(;;)
         {var r=(2 * i | 0) + 2 | 0,l=(2 * i | 0) + 1 | 0;
          if(caml_lessthan(r,len))
           {var
             _HK_=get$2(xs,l),
             match=caml_call2(cmp,get$2(xs,i),_HK_),
             _HL_=get$2(xs,r),
             match$0=caml_call2(cmp,get$2(xs,i),_HL_),
             switch$0=0 === match?0:0 === match$0?0:1;
            if(! switch$0)
             {var
               _HM_=get$2(xs,r),
               match$1=caml_call2(cmp,get$2(xs,l),_HM_),
               c=2 <= match$1?l:r;
              swap(xs,i,c);
              var i=c;
              continue}}
          else
           if(caml_lessthan(l,len))
            {var _HN_=get$2(xs,l),match$2=caml_call2(cmp,get$2(xs,i),_HN_);
             if(0 === match$2){swap(xs,i,l);var i=l;continue}}
          return xs}}
      return caml_call2
              (_au_,
               caml_call2
                (_au_,
                 caml_call2
                  (_au_,xs,function(_HJ_){return validate$0(_HJ_,cmp)}),
                 _HI_),
               _HH_)}
    function make$13(name,opt,fs,expected)
     {if(opt)var sth=opt[1],init=sth;else var init=empty$4;
      return _ba_
              (name,
               [246,
                function(_HG_)
                 {var
                   heap=
                    fold(init,fs,function(heap,f){return caml_call1(f,heap)});
                  return check_int_list
                          (expected,caml_call1(Stdlib_arrayLabels[10],heap))}])}
    function pop_max$0(xs){return pop_max(xs,compare)}
    var _CF_=0;
    function make$14(xs,expected)
     {var name=repr$2(xs,repr);
      return make$13
              (name,
               [0,caml_call1(Stdlib_arrayLabels[11],xs)],
               [0,pop_max$0,0],
               expected)}
    var
     _CI_=[0,make$14(_CH_,_CG_),0],
     _CL_=[0,make$14(_CK_,_CJ_),_CI_],
     _CO_=[0,make$14(_CN_,_CM_),_CL_],
     _CR_=[0,make$14(_CQ_,_CP_),_CO_],
     _CU_=[0,make$14(_CT_,_CS_),_CR_],
     _CX_=[0,make$14(_CW_,_CV_),_CU_],
     _CZ_=[0,_a$_(cst_pop_max,[0,make$14(_CY_,0),_CX_]),_CF_];
    function make$15(xs,expected)
     {var
       name=repr$2(xs,repr),
       fs=
        map$0(xs,function(x){return function(xs){return add$6(xs,compare,x)}});
      return make$13(name,0,fs,expected)}
    var
     _C2_=[0,make$15(_C1_,_C0_),0],
     _C5_=[0,make$15(_C4_,_C3_),_C2_],
     _C8_=[0,make$15(_C7_,_C6_),_C5_],
     _C$_=[0,make$15(_C__,_C9_),_C8_],
     _Dc_=[0,make$15(_Db_,_Da_),_C$_],
     _Df_=[0,make$15(_De_,_Dd_),_Dc_],
     _Di_=[0,make$15(_Dh_,_Dg_),_Df_],
     _Dl_=[0,make$15(_Dk_,_Dj_),_Di_],
     _Do_=[0,make$15(_Dn_,_Dm_),_Dl_],
     _Dr_=[0,make$15(_Dq_,_Dp_),_Do_],
     _Du_=[0,_a$_(cst_add$0,[0,make$15(_Dt_,_Ds_),_Dr_]),_CZ_],
     test$25=_a$_(cst_BinaryHeap,[0,make$13(cst_empty$0,0,0,0),_Du_]);
    function cmp$0(param,_HF_){var y=_HF_[1],x=param[1];return compare(x,y)}
    function add$7(xs,k,v){return add$6(xs,cmp$0,[0,k,v])}
    function max$16(xs){return max$15(xs)}
    function pop_max$1(xs){return pop_max(xs,cmp$0)}
    function SpecializeOperators(A)
     {var ref=O$3[1];return [0,ref,O$3[2],O$3[3]]}
    function Specialize$1(A){return [0,of_contents,contents,assign,O$3]}
    function SpecializePredSucc(A)
     {function increment(r)
       {var _HD_=caml_call1(O$3[2],r),_HE_=caml_call1(A[1],_HD_);
        return caml_call2(O$3[3],r,_HE_)}
      function decrement(r)
       {var _HB_=caml_call1(O$3[2],r),_HC_=caml_call1(A[2],_HB_);
        return caml_call2(O$3[3],r,_HC_)}
      return [0,increment,decrement]}
    function SpecializeRingoidOperators(A)
     {function _Hq_(r,v)
       {var _Hz_=caml_call1(O$3[2],r),_HA_=caml_call2(A[4],_Hz_,v);
        return caml_call2(O$3[3],r,_HA_)}
      function _Hr_(r,v)
       {var _Hx_=caml_call1(O$3[2],r),_Hy_=caml_call2(A[5],_Hx_,v);
        return caml_call2(O$3[3],r,_Hy_)}
      function _Hs_(r,v)
       {var _Hv_=caml_call1(O$3[2],r),_Hw_=caml_call2(A[6],_Hv_,v);
        return caml_call2(O$3[3],r,_Hw_)}
      return [0,
              _Hq_,
              _Hr_,
              _Hs_,
              function(r,v)
               {var _Ht_=caml_call1(O$3[2],r),_Hu_=caml_call2(A[7],_Ht_,v);
                return caml_call2(O$3[3],r,_Hu_)}]}
    function SpecializeRingoid(A)
     {var O=SpecializeRingoidOperators(A);return [0,O]}
    function cmp$1(param,_Hp_){var y=_Hp_[1],x=param[1];return compare(x,y)}
    function cmp_k$0(x,param){var y=param[1];return compare(x,y)}
    function size$6(t){return size$5(t,cmp$1)}
    function add$8(t,k,v){return add$5(t,cmp$1,[0,k,v])}
    function of_list_first(vs)
     {function _Hn_(t,param)
       {var v=param[2],k=param[1];return caml_call2(_au_,add$8(t,k,v),get_1)}
      return caml_call2
              (_au_,vs,function(_Ho_){return fold(empty$3,_Ho_,_Hn_)})}
    function replace$0(t,k,v){return replace(t,cmp$1,[0,k,v])}
    function of_list_last(vs)
     {function _Hl_(t,param)
       {var v=param[2],k=param[1];return replace$0(t,k,v)}
      return caml_call2
              (_au_,vs,function(_Hm_){return fold(empty$3,_Hm_,_Hl_)})}
    function remove$0(t,k){return remove(t,cmp$1,cmp_k$0,k)}
    function to_list$4(t){return to_list$3(t,cmp$1)}
    function try_get$0(t,k)
     {function _Hj_(_Hk_){return func(_Hk_,get_1)}
      return caml_call2(_au_,try_get(t,cmp$1,cmp_k$0,k),_Hj_)}
    function get$4(t,k)
     {var _Hi_=or_failure(_Dv_);return caml_call2(_au_,try_get$0(t,k),_Hi_)}
    function Make$0(K)
     {function cmp(param,_Hh_)
       {var y=_Hh_[1],x=param[1];return caml_call2(K[1],x,y)}
      function cmp_k(x,param){var y=param[1];return caml_call2(K[1],x,y)}
      function size(t){return size$5(t,cmp)}
      function add(t,k,v){return add$5(t,cmp,[0,k,v])}
      function of_list_first(vs)
       {function _Hf_(t,param)
         {var v=param[2],k=param[1];return caml_call2(_au_,add(t,k,v),get_1)}
        return caml_call2
                (_au_,vs,function(_Hg_){return fold(empty$3,_Hg_,_Hf_)})}
      function replace$0(t,k,v){return replace(t,cmp,[0,k,v])}
      function of_list_last(vs)
       {function _Hd_(t,param)
         {var v=param[2],k=param[1];return replace$0(t,k,v)}
        return caml_call2
                (_au_,vs,function(_He_){return fold(empty$3,_He_,_Hd_)})}
      function remove$0(t,k){return remove(t,cmp,cmp_k,k)}
      function to_list(t){return to_list$3(t,cmp)}
      function try_get$0(t,k)
       {function _Hb_(_Hc_){return func(_Hc_,get_1)}
        return caml_call2(_au_,try_get(t,cmp,cmp_k,k),_Hb_)}
      function get(t,k)
       {var _Ha_=or_failure(_Dw_);return caml_call2(_au_,try_get$0(t,k),_Ha_)}
      return [0,
              cmp,
              cmp_k,
              empty$3,
              is_empty$0,
              size,
              add,
              of_list_first,
              replace$0,
              of_list_last,
              remove$0,
              to_list,
              try_get$0,
              get]}
    function size$7(t){return size$5(t,compare)}
    function add$9(t,v){return add$5(t,compare,v)}
    function of_list$2(vs)
     {function _G__(t,v){return caml_call2(_au_,add$9(t,v),get_1)}
      return caml_call2
              (_au_,vs,function(_G$_){return fold(empty$3,_G$_,_G__)})}
    function replace$1(t,v){return replace(t,compare,v)}
    function remove$1(t,v){return remove(t,compare,compare,v)}
    function to_list$5(t){return to_list$3(t,compare)}
    function contains$1(t,v)
     {return caml_call2(_au_,try_get(t,compare,compare,v),is_some)}
    function Make$1(E)
     {var cmp=E[1];
      function size(t){return size$5(t,cmp)}
      function add(t,v){return add$5(t,cmp,v)}
      function of_list(vs)
       {function _G8_(t,v){return caml_call2(_au_,add(t,v),get_1)}
        return caml_call2
                (_au_,vs,function(_G9_){return fold(empty$3,_G9_,_G8_)})}
      function replace$0(t,v){return replace(t,cmp,v)}
      function remove$0(t,v){return remove(t,cmp,cmp,v)}
      function to_list(t){return to_list$3(t,cmp)}
      function contains(t,v)
       {return caml_call2(_au_,try_get(t,cmp,cmp,v),is_some)}
      return [0,
              cmp,
              cmp,
              empty$3,
              is_empty$0,
              size,
              add,
              of_list,
              replace$0,
              remove$0,
              to_list,
              contains]}
    function cmp$2(x,y){return compare(x,y)}
    function add$10(xs,v){return add$6(xs,cmp$2,v)}
    function max$17(xs){return max$15(xs)}
    function pop_max$2(xs){return pop_max(xs,cmp$2)}
    function Make$2(C)
     {var channel=C[1];
      function print$0(opt,format)
       {if(opt)var sth=opt[1],flush=sth;else var flush=C[2];
        return print([0,flush],channel,format)}
      function output(x){return caml_call2(output$0,channel,x)}
      function flush(param){return caml_call1(flush$0,channel)}
      return [0,channel,print$0,output,flush]}
    var
     channel=Stdlib[1][28],
     include$11=Make$2([0,channel,1]),
     channel$0=include$11[1],
     print$0=include$11[2],
     output$1=include$11[3],
     flush$1=include$11[4],
     channel$1=Stdlib[1][26],
     channel$2=Stdlib[1][27],
     include$12=Make$2([0,channel$2,0]),
     channel$3=include$12[1],
     print$1=include$12[2],
     output$2=include$12[3],
     flush$2=include$12[4],
     _Dx_=
      [0,
       caml_call1
         (caml_call1
           (caml_call1(ToList$0[1][1],[0,of_list$1]),
            [0,
             map$3,
             map_i$2,
             map_acc$2,
             filter$4,
             filter_i$2,
             filter_acc$2,
             filter_map$3,
             filter_map_i$2,
             filter_map_acc$2,
             flat_map$2,
             flat_map_i$2,
             flat_map_acc$2]),
          [0,of_list,to_list])
        [1],
       0],
     test$26=
      _a$_
       (cst_Stream,
        [0,
         Make1$2
           ([0,
             map$2,
             map_i$1,
             map_acc$1,
             filter$3,
             filter_i$1,
             filter_acc$1,
             filter_map$2,
             filter_map_i$1,
             filter_map_acc$1,
             flat_map$1,
             flat_map_i$1,
             flat_map_acc$1,
             to_list$2,
             of_list$1])
          [1],
         _Dx_]);
    function split$0(s,seps)
     {var seps$0=of_list$2(seps);
      function _G3_(param,c)
       {var current_part=param[2],parts=param[1];
        return contains$1(seps$0,c)
                ?[0,[0,current_part,parts],0]
                :[0,parts,[0,c,current_part]]}
      var
       match=caml_call2(_au_,s,function(_G7_){return fold$0(_Dy_,_G7_,_G3_)}),
       last_part=match[2],
       parts=match[1];
      function _G4_(_G6_){return map$0(_G6_,of_list$0)}
      return caml_call2
              (_au_,
               caml_call2
                (_au_,
                 caml_call2
                  (_au_,
                   [0,last_part,parts],
                   function(_G5_){return map$0(_G5_,reverse)}),
                 _G4_),
               reverse)}
    var _Dz_=0;
    function make$16(s,seps,expected)
     {var
       _G0_=
        [246,
         function(_G2_){return check_string_list(expected,split$0(s,seps))}],
       _G1_=of_list$0(seps);
      return caml_call3(_bc_(_DA_),s,_G1_,_G0_)}
    var
     _DD_=[0,make$16(cst_xabxxcdx,_DC_,_DB_),0],
     _DG_=[0,_a$_(cst_split,[0,make$16(cst_abcdefghfj,_DF_,_DE_),_DD_]),_Dz_],
     test$27=
      _a$_
       (cst_String,
        [0,
         Make0$12
           ([0,
             [0,_ab_,_ac_,_a_,_b_,_d_,_c_],
             equal$9,
             different$7,
             repr$6,
             compare,
             less_than,
             less_or_equal,
             greater_than,
             greater_or_equal,
             between,
             between_or_equal,
             min,
             max,
             min_max],
            [0,different$40,repr$42,ordered$12,equal$49])
          [1],
         _DG_]),
     callstack=current(0,0),
     TestException0=
      [248,cst_General_TestingTests_Tests_TestException0,caml_fresh_oo_id(0)],
     TestException0$0=
      [248,
       cst_General_TestingTests_Tests_TestException0$0,
       caml_fresh_oo_id(0)],
     TestException1=
      [248,cst_General_TestingTests_Tests_TestException1,caml_fresh_oo_id(0)];
    caml_call1
     (register_printer,
      function(param)
       {if(param === TestException0)return _DH_;
        if(param === TestException0$0)return _DI_;
        if(param[1] === TestException1)
         {var s=param[2];return [0,caml_call1(apply(_DJ_),s)]}
        return 0});
    var
     repr$43=
      [0,
       _DO_,
       [0,
        _DN_,
        [0,
         [0,
          [0,[0,cst_foo$8,[0,[1,TestException0]]]],
          cst_Single_label_foo_status_Failure_NoException_TestingTests_Tests_TestException0],
         [0,
          _DM_,
          [0,
           [0,
            [0,[0,cst_foo$7,[0,[3,TestException0,TestException0$0,0]]]],
            cst_Single_label_foo_status_Failure_WrongException_TestingTests_Tests_TestException0_TestingTests_Tests_TestException0_None],
           [0,
            [0,
             [0,[0,cst_foo$6,[0,[4,cst_Foo,TestException0$0,0]]]],
             cst_Single_label_foo_status_Failure_WrongExceptionNamed_Foo_TestingTests_Tests_TestException0_None],
            [0,
             _DL_,
             [0,
              [0,
               [0,[0,cst_foo$5,[1,TestException0,0]]],
               cst_Single_label_foo_status_Error_TestingTests_Tests_TestException0_None],
              _DK_]]]]]]]],
     ResultExamples=[0,repr$43],
     _DP_=0,
     _DQ_=0;
    function make$17(expected,test)
     {if(0 === test[0])
       var match=test[1],label=match[1],name=label;
      else
       var match$0=test[1],name$0=match$0[1],name=name$0;
      return _ba_
              (name,
               [246,
                function(_GZ_)
                 {return check
                          (repr$12,equal$15,expected,caml_call2(Test[1],_DR_,test))}])}
    var
     _DS_=0,
     _DT_=
      [0,
       make$17
        ([0,[0,cst_error$0,[1,TestException0,0]]],
         _ba_(cst_error,[246,function(_GY_){return raise(TestException0)}])),
       _DS_],
     _DW_=
      [0,
       make$17
        (_DV_,
         _ba_(cst_custom_failure,[246,function(_GX_){return fail(_DU_)}])),
       _DT_],
     _DX_=
      [0,
       make$17
        ([0,
          [0,cst_wrong_exception$0,[0,[3,TestException0,TestException0$0,0]]]],
         _ba_
          (cst_wrong_exception,
           [246,
            function(_GV_)
             {return expect_exception
                      (TestException0,
                       [246,function(_GW_){return raise(TestException0$0)}])}])),
       _DW_],
     _DY_=
      [0,
       make$17
        ([0,[0,cst_no_exception$0,[0,[1,TestException0]]]],
         _ba_
          (cst_no_exception,
           [246,function(_GU_){return expect_exception(TestException0,0)}])),
       _DX_],
     _D0_=
      [0,
       make$17
        (_DZ_,
         _ba_(cst_not_equal_failure,[246,function(_GT_){return check_42(43)}])),
       _DY_],
     _D2_=
      [0,make$17(_D1_,_a$_(cst_group_success,[0,_ba_(cst_child,0),0])),_D0_],
     _D4_=[0,make$17(_D3_,_ba_(cst_single_success,0)),_D2_],
     _D6_=[0,_a$_(cst_Test,[0,caml_call2(_bb_(_D5_),cst_n,_D4_),_DQ_]),_DP_],
     _D7_=0;
    function make$18(opt,expected,result)
     {if(opt)var sth=opt[1],verbose=sth;else var verbose=0;
      var
       _GQ_=
        [246,
         function(_GS_)
          {var actual=caml_call2(_au_,result,to_indented_strings(verbose));
           return check_string_list(expected,actual)}];
      return _ba_
              (caml_call2
                (_au_,expected,function(_GR_){return join(_D8_,_GR_)}),
               _GQ_)}
    var
     _D$_=
      [0,
       make$18
        (0,
         _D__,
         [1,[0,cst_foo$9,[0,[0,[0,cst_bar$1,[1,TestException0,0]]],0],_D9_]]),
       0],
     _Ed_=[0,make$18(_Ec_,_Eb_,_Ea_),_D$_],
     _Eh_=[0,make$18(_Eg_,_Ef_,_Ee_),_Ed_],
     _El_=[0,make$18(_Ek_,_Ej_,_Ei_),_Eh_],
     _Ep_=[0,make$18(_Eo_,_En_,_Em_),_El_],
     _Eq_=[0,[0,cst_bar_7,[1,[0,TestException1,cst_bad],[0,callstack]]]],
     _Er_=0,
     _Es_=
      javascript
       ?cst_bar_7_ERROR_exception_TestingTests_Tests_TestException1_bad_raised
       :cst_bar_7_ERROR_exception_TestingTests_Tests_TestException1_bad_raised_Raised_by_primitive_operation_at_file_Implementation_TestingTests_ml_line_2_characters_16_36,
     _Et_=[0,make$18(0,[0,_Es_,_Er_],_Eq_),_Ep_],
     _Ev_=[0,make$18(0,_Eu_,[0,[0,cst_bar_6,[1,TestException0,0]]]),_Et_],
     _Ey_=[0,make$18(0,_Ex_,_Ew_),_Ev_],
     _Ez_=
      [0,
       [0,
        cst_bar_4,
        [0,[4,cst_Foo$0,[0,TestException1,cst_too_bad],[0,callstack]]]]],
     _EA_=0,
     _EB_=
      javascript
       ?cst_bar_4_FAILED_expected_exception_Foo_not_raised_but_exception_TestingTests_Tests_TestException1_too_bad_raised
       :cst_bar_4_FAILED_expected_exception_Foo_not_raised_but_exception_TestingTests_Tests_TestException1_too_bad_raised_Raised_by_primitive_operation_at_file_Implementation_TestingTests_ml_line_2_characters_16_36,
     _EC_=[0,make$18(0,[0,_EB_,_EA_],_Ez_),_Ey_],
     _ED_=
      [0,
       [0,
        cst_bar_4$0,
        [0,
         [3,
          [0,TestException1,cst_bad$0],
          [0,TestException1,cst_too_bad$0],
          [0,callstack]]]]],
     _EE_=0,
     _EF_=
      javascript
       ?cst_bar_4_FAILED_expected_exception_TestingTests_Tests_TestException1_bad_not_raised_but_exception_TestingTests_Tests_TestException1_too_bad_raised
       :cst_bar_4_FAILED_expected_exception_TestingTests_Tests_TestException1_bad_not_raised_but_exception_TestingTests_Tests_TestException1_too_bad_raised_Raised_by_primitive_operation_at_file_Implementation_TestingTests_ml_line_2_characters_16_36,
     _EG_=[0,make$18(0,[0,_EF_,_EE_],_ED_),_EC_],
     _EI_=
      [0,
       make$18(0,_EH_,[0,[0,cst_bar_3,[0,[4,cst_Foo$1,TestException0$0,0]]]]),
       _EG_],
     _EK_=
      [0,
       make$18
        (0,_EJ_,[0,[0,cst_bar_3$0,[0,[3,TestException0,TestException0$0,0]]]]),
       _EI_],
     _EN_=[0,make$18(0,_EM_,_EL_),_EK_],
     _EP_=[0,make$18(0,_EO_,[0,[0,cst_bar_2,[0,[1,TestException0]]]]),_EN_],
     _ES_=[0,make$18(0,_ER_,_EQ_),_EP_],
     _EW_=
      [0,_a$_(cst_to_indented_strings,[0,make$18(_EV_,_EU_,_ET_),_ES_]),_D7_],
     test$28=
      _a$_
       (cst_Testing,
        [0,
         _a$_(cst_Result,[0,Make0([0,repr$12],ResultExamples)[1],_EW_]),
         _D6_]),
     Unit=[0,ignore],
     _EX_=Specialize([0]),
     empty$5=_EX_[3],
     singleton$1=_EX_[4],
     prepend$1=_EX_[5],
     of_list$3=_EX_[6],
     to_list$6=_EX_[7],
     of_array$0=_EX_[8],
     to_array$1=_EX_[9],
     is_empty$1=_EX_[10],
     try_head$0=_EX_[11],
     try_tail$0=_EX_[12],
     head$0=_EX_[13],
     tail$0=_EX_[14],
     reverse$0=_EX_[15],
     concat$3=_EX_[17],
     map$4=_EX_[19],
     map_acc$3=_EX_[20],
     map_i$3=_EX_[21],
     flat_map$3=_EX_[22],
     flat_map_acc$3=_EX_[23],
     flat_map_i$3=_EX_[24],
     filter$5=_EX_[25],
     filter_acc$3=_EX_[26],
     filter_i$3=_EX_[27],
     filter_map$4=_EX_[28],
     filter_map_acc$3=_EX_[29],
     filter_map_i$3=_EX_[30],
     fold$3=_EX_[31],
     fold_acc$1=_EX_[32],
     fold_i$1=_EX_[33],
     try_reduce_acc$1=_EX_[34],
     try_reduce$1=_EX_[35],
     try_reduce_i$1=_EX_[36],
     reduce_acc$1=_EX_[37],
     reduce$1=_EX_[38],
     reduce_i$1=_EX_[39],
     scan$1=_EX_[40],
     scan_acc$1=_EX_[41],
     scan_i$1=_EX_[42],
     iter$2=_EX_[43],
     iter_acc$1=_EX_[44],
     iter_i$1=_EX_[45],
     count$1=_EX_[46],
     count_acc$1=_EX_[47],
     count_i$1=_EX_[48],
     try_find$1=_EX_[49],
     try_find_acc$1=_EX_[50],
     try_find_i$1=_EX_[51],
     find$1=_EX_[52],
     find_acc$1=_EX_[53],
     find_i$1=_EX_[54],
     there_exists$1=_EX_[55],
     there_exists_acc$1=_EX_[56],
     there_exists_i$1=_EX_[57],
     for_all$1=_EX_[58],
     for_all_acc$1=_EX_[59],
     for_all_i$1=_EX_[60],
     try_find_map$1=_EX_[61],
     try_find_map_acc$1=_EX_[62],
     try_find_map_i$1=_EX_[63],
     find_map$1=_EX_[64],
     find_map_acc$1=_EX_[65],
     find_map_i$1=_EX_[66],
     fold_short$1=_EX_[67],
     fold_short_acc$1=_EX_[68],
     fold_short_i$1=_EX_[69],
     try_reduce_short_acc$1=_EX_[70],
     try_reduce_short$1=_EX_[71],
     try_reduce_short_i$1=_EX_[72],
     reduce_short_acc$1=_EX_[73],
     reduce_short$1=_EX_[74],
     reduce_short_i$1=_EX_[75],
     scan_short$1=_EX_[76],
     scan_short_acc$1=_EX_[77],
     scan_short_i$1=_EX_[78],
     iter_short$1=_EX_[79],
     iter_short_acc$1=_EX_[80],
     iter_short_i$1=_EX_[81],
     size$8=_EX_[84],
     ToList$5=_EX_[91],
     Equa=SpecializeEquatable([0,equal$2]),
     contains$2=Equa[1],
     _EY_=Specialize([0]),
     empty$6=_EY_[3],
     singleton$2=_EY_[4],
     prepend$2=_EY_[5],
     of_list$4=_EY_[6],
     to_list$7=_EY_[7],
     of_array$1=_EY_[8],
     to_array$2=_EY_[9],
     is_empty$2=_EY_[10],
     try_head$1=_EY_[11],
     try_tail$1=_EY_[12],
     head$1=_EY_[13],
     tail$1=_EY_[14],
     reverse$1=_EY_[15],
     concat$4=_EY_[17],
     map$5=_EY_[19],
     map_acc$4=_EY_[20],
     map_i$4=_EY_[21],
     flat_map$4=_EY_[22],
     flat_map_acc$4=_EY_[23],
     flat_map_i$4=_EY_[24],
     filter$6=_EY_[25],
     filter_acc$4=_EY_[26],
     filter_i$4=_EY_[27],
     filter_map$5=_EY_[28],
     filter_map_acc$4=_EY_[29],
     filter_map_i$4=_EY_[30],
     fold$4=_EY_[31],
     fold_acc$2=_EY_[32],
     fold_i$2=_EY_[33],
     try_reduce_acc$2=_EY_[34],
     try_reduce$2=_EY_[35],
     try_reduce_i$2=_EY_[36],
     reduce_acc$2=_EY_[37],
     reduce$2=_EY_[38],
     reduce_i$2=_EY_[39],
     scan$2=_EY_[40],
     scan_acc$2=_EY_[41],
     scan_i$2=_EY_[42],
     iter$3=_EY_[43],
     iter_acc$2=_EY_[44],
     iter_i$2=_EY_[45],
     count$2=_EY_[46],
     count_acc$2=_EY_[47],
     count_i$2=_EY_[48],
     try_find$2=_EY_[49],
     try_find_acc$2=_EY_[50],
     try_find_i$2=_EY_[51],
     find$2=_EY_[52],
     find_acc$2=_EY_[53],
     find_i$2=_EY_[54],
     there_exists$2=_EY_[55],
     there_exists_acc$2=_EY_[56],
     there_exists_i$2=_EY_[57],
     for_all$2=_EY_[58],
     for_all_acc$2=_EY_[59],
     for_all_i$2=_EY_[60],
     try_find_map$2=_EY_[61],
     try_find_map_acc$2=_EY_[62],
     try_find_map_i$2=_EY_[63],
     find_map$2=_EY_[64],
     find_map_acc$2=_EY_[65],
     find_map_i$2=_EY_[66],
     fold_short$2=_EY_[67],
     fold_short_acc$2=_EY_[68],
     fold_short_i$2=_EY_[69],
     try_reduce_short_acc$2=_EY_[70],
     try_reduce_short$2=_EY_[71],
     try_reduce_short_i$2=_EY_[72],
     reduce_short_acc$2=_EY_[73],
     reduce_short$2=_EY_[74],
     reduce_short_i$2=_EY_[75],
     scan_short$2=_EY_[76],
     scan_short_acc$2=_EY_[77],
     scan_short_i$2=_EY_[78],
     iter_short$2=_EY_[79],
     iter_short_acc$2=_EY_[80],
     iter_short_i$2=_EY_[81],
     size$9=_EY_[84],
     ToList$6=_EY_[91],
     Equa$0=SpecializeEquatable([0,equal$7]),
     contains$3=Equa$0[1],
     _EZ_=Specialize([0]),
     empty$7=_EZ_[3],
     singleton$3=_EZ_[4],
     prepend$3=_EZ_[5],
     of_list$5=_EZ_[6],
     to_list$8=_EZ_[7],
     of_array$2=_EZ_[8],
     to_array$3=_EZ_[9],
     is_empty$3=_EZ_[10],
     try_head$2=_EZ_[11],
     try_tail$2=_EZ_[12],
     head$2=_EZ_[13],
     tail$2=_EZ_[14],
     reverse$2=_EZ_[15],
     concat$5=_EZ_[17],
     map$6=_EZ_[19],
     map_acc$5=_EZ_[20],
     map_i$5=_EZ_[21],
     flat_map$5=_EZ_[22],
     flat_map_acc$5=_EZ_[23],
     flat_map_i$5=_EZ_[24],
     filter$7=_EZ_[25],
     filter_acc$5=_EZ_[26],
     filter_i$5=_EZ_[27],
     filter_map$6=_EZ_[28],
     filter_map_acc$5=_EZ_[29],
     filter_map_i$5=_EZ_[30],
     fold$5=_EZ_[31],
     fold_acc$3=_EZ_[32],
     fold_i$3=_EZ_[33],
     try_reduce_acc$3=_EZ_[34],
     try_reduce$3=_EZ_[35],
     try_reduce_i$3=_EZ_[36],
     reduce_acc$3=_EZ_[37],
     reduce$3=_EZ_[38],
     reduce_i$3=_EZ_[39],
     scan$3=_EZ_[40],
     scan_acc$3=_EZ_[41],
     scan_i$3=_EZ_[42],
     iter$4=_EZ_[43],
     iter_acc$3=_EZ_[44],
     iter_i$3=_EZ_[45],
     count$3=_EZ_[46],
     count_acc$3=_EZ_[47],
     count_i$3=_EZ_[48],
     try_find$3=_EZ_[49],
     try_find_acc$3=_EZ_[50],
     try_find_i$3=_EZ_[51],
     find$3=_EZ_[52],
     find_acc$3=_EZ_[53],
     find_i$3=_EZ_[54],
     there_exists$3=_EZ_[55],
     there_exists_acc$3=_EZ_[56],
     there_exists_i$3=_EZ_[57],
     for_all$3=_EZ_[58],
     for_all_acc$3=_EZ_[59],
     for_all_i$3=_EZ_[60],
     try_find_map$3=_EZ_[61],
     try_find_map_acc$3=_EZ_[62],
     try_find_map_i$3=_EZ_[63],
     find_map$3=_EZ_[64],
     find_map_acc$3=_EZ_[65],
     find_map_i$3=_EZ_[66],
     fold_short$3=_EZ_[67],
     fold_short_acc$3=_EZ_[68],
     fold_short_i$3=_EZ_[69],
     try_reduce_short_acc$3=_EZ_[70],
     try_reduce_short$3=_EZ_[71],
     try_reduce_short_i$3=_EZ_[72],
     reduce_short_acc$3=_EZ_[73],
     reduce_short$3=_EZ_[74],
     reduce_short_i$3=_EZ_[75],
     scan_short$3=_EZ_[76],
     scan_short_acc$3=_EZ_[77],
     scan_short_i$3=_EZ_[78],
     iter_short$3=_EZ_[79],
     iter_short_acc$3=_EZ_[80],
     iter_short_i$3=_EZ_[81],
     size$10=_EZ_[84],
     ToList$7=_EZ_[91],
     Equa$1=SpecializeEquatable([0,equal$9]),
     contains$4=Equa$1[1],
     include$13=Specialize$0([0]),
     some_if$1=include$13[6],
     some_if$2=include$13[7],
     value_def$0=include$13[8],
     value$1=include$13[9],
     or_failure$0=include$13[10],
     map$7=include$13[11],
     value_map$0=include$13[12],
     is_some$0=include$13[13],
     is_none$0=include$13[14],
     iter$5=include$13[15],
     filter$8=include$13[16],
     filter_map$7=include$13[17],
     include$14=Specialize$0([0]),
     some_if$3=include$14[6],
     some_if$4=include$14[7],
     value_def$1=include$14[8],
     value$2=include$14[9],
     or_failure$1=include$14[10],
     map$8=include$14[11],
     value_map$1=include$14[12],
     is_some$1=include$14[13],
     is_none$1=include$14[14],
     iter$6=include$14[15],
     filter$9=include$14[16],
     filter_map$8=include$14[17],
     include$15=Specialize$0([0]),
     some_if$5=include$15[6],
     some_if$6=include$15[7],
     value_def$2=include$15[8],
     value$3=include$15[9],
     or_failure$2=include$15[10],
     map$9=include$15[11],
     value_map$2=include$15[12],
     is_some$2=include$15[13],
     is_none$2=include$15[14],
     iter$7=include$15[15],
     filter$10=include$15[16],
     filter_map$9=include$15[17],
     Spe=Specialize$1([0]),
     Ringoid=
      SpecializeRingoid([0,zero,one,negate,add,substract,multiply,divide]),
     _E0_=Spe[4],
     ref$1=_E0_[1],
     include$16=Ringoid[1],
     O$17=
      [0,
       ref$1,
       _E0_[2],
       _E0_[3],
       include$16[1],
       include$16[2],
       include$16[3],
       include$16[4]],
     assign$0=Spe[3],
     contents$0=Spe[2],
     of_contents$0=Spe[1];
    function increment(_GP_){_GP_[1]++;return 0}
    function decrement(_GO_){_GO_[1] += -1;return 0}
    var
     Spe$0=Specialize$1([0]),
     Ringoid$0=
      SpecializeRingoid
       ([0,zero$0,one$0,negate$0,add$0,substract$0,multiply$0,divide$0]),
     _E1_=Spe$0[4],
     ref$2=_E1_[1],
     include$17=Ringoid$0[1],
     O$18=
      [0,
       ref$2,
       _E1_[2],
       _E1_[3],
       include$17[1],
       include$17[2],
       include$17[3],
       include$17[4]],
     assign$1=Spe$0[3],
     contents$1=Spe$0[2],
     of_contents$1=Spe$0[1],
     Spe$1=Specialize$1([0]),
     include$18=Spe$1[4],
     ref$3=include$18[1],
     _E2_=include$18[2],
     _E3_=include$18[3],
     O$19=
      [0,
       ref$3,
       _E2_,
       _E3_,
       function(r,x)
        {return caml_call2(_E3_,r,caml_call2(_ad_,caml_call1(_E2_,r),x))}],
     assign$2=Spe$1[3],
     contents$2=Spe$1[2],
     of_contents$2=Spe$1[1],
     Int=Make$0([0,compare]),
     Float$1=Make$0([0,compare]),
     String$1=Make$0([0,compare]),
     Char$1=Make$0([0,compare]),
     Int$0=Make$1([0,compare]),
     Float$2=Make$1([0,compare]),
     String$2=Make$1([0,compare]),
     Char$2=Make$1([0,compare]),
     _E4_=Reset[1],
     raise$1=_E4_[1],
     raise_notrace$0=_E4_[2],
     invalid_arg$0=_E4_[3],
     failwith$0=_E4_[4],
     compare$18=_E4_[11],
     min$15=_E4_[12],
     max$18=_E4_[13],
     or$1=_E4_[20],
     succ$10=_E4_[25],
     pred$8=_E4_[26],
     abs$9=_E4_[32],
     max_int$3=_E4_[33],
     min_int$3=_E4_[34],
     land$0=_E4_[35],
     lor$0=_E4_[36],
     lxor$0=_E4_[37],
     lnot$0=_E4_[38],
     lsl$0=_E4_[39],
     lsr$0=_E4_[40],
     asr$0=_E4_[41],
     sqrt$1=_E4_[49],
     exp$1=_E4_[50],
     log$1=_E4_[51],
     log10$1=_E4_[52],
     expm1$1=_E4_[53],
     log1p$1=_E4_[54],
     cos$1=_E4_[55],
     sin$1=_E4_[56],
     tan$1=_E4_[57],
     acos$1=_E4_[58],
     asin$1=_E4_[59],
     atan$1=_E4_[60],
     atan2$1=_E4_[61],
     hypot$1=_E4_[62],
     cosh$1=_E4_[63],
     sinh$1=_E4_[64],
     tanh$1=_E4_[65],
     ceil$1=_E4_[66],
     floor$1=_E4_[67],
     abs_float$0=_E4_[68],
     copysign$0=_E4_[69],
     mod_float$0=_E4_[70],
     frexp$0=_E4_[71],
     ldexp$0=_E4_[72],
     modf$0=_E4_[73],
     float$1=_E4_[74],
     float_of_int$0=_E4_[75],
     truncate$0=_E4_[76],
     int_of_float$0=_E4_[77],
     infinity$1=_E4_[78],
     neg_infinity$0=_E4_[79],
     nan$0=_E4_[80],
     max_float$0=_E4_[81],
     min_float$0=_E4_[82],
     epsilon_float$0=_E4_[83],
     classify_float$0=_E4_[84],
     int_of_char$0=_E4_[86],
     char_of_int$0=_E4_[87],
     string_of_bool$0=_E4_[89],
     bool_of_string$0=_E4_[90],
     bool_of_string_opt$0=_E4_[91],
     string_of_int$0=_E4_[92],
     int_of_string$0=_E4_[93],
     int_of_string_opt$0=_E4_[94],
     string_of_float$0=_E4_[95],
     float_of_string$0=_E4_[96],
     float_of_string_opt$0=_E4_[97],
     fst$0=_E4_[98],
     snd$0=_E4_[99],
     stdin$0=_E4_[101],
     stdout$0=_E4_[102],
     stderr$0=_E4_[103],
     print_char$0=_E4_[104],
     print_string$0=_E4_[105],
     print_bytes$0=_E4_[106],
     print_int$0=_E4_[107],
     print_float$0=_E4_[108],
     print_endline$0=_E4_[109],
     print_newline$0=_E4_[110],
     prerr_char$0=_E4_[111],
     prerr_string$0=_E4_[112],
     prerr_bytes$0=_E4_[113],
     prerr_int$0=_E4_[114],
     prerr_float$0=_E4_[115],
     prerr_endline$0=_E4_[116],
     prerr_newline$0=_E4_[117],
     read_line$0=_E4_[118],
     read_int$0=_E4_[119],
     read_int_opt$0=_E4_[120],
     read_float$0=_E4_[121],
     read_float_opt$0=_E4_[122],
     open_out$0=_E4_[123],
     open_out_bin$0=_E4_[124],
     open_out_gen$0=_E4_[125],
     flush$3=_E4_[126],
     flush_all$0=_E4_[127],
     output_char$0=_E4_[128],
     output_string$0=_E4_[129],
     output_bytes$0=_E4_[130],
     output$3=_E4_[131],
     output_substring$0=_E4_[132],
     output_byte$0=_E4_[133],
     output_binary_int$0=_E4_[134],
     output_value$0=_E4_[135],
     seek_out$0=_E4_[136],
     pos_out$0=_E4_[137],
     out_channel_length$0=_E4_[138],
     close_out$0=_E4_[139],
     close_out_noerr$0=_E4_[140],
     set_binary_mode_out$0=_E4_[141],
     open_in$0=_E4_[142],
     open_in_bin$0=_E4_[143],
     open_in_gen$0=_E4_[144],
     input_char$0=_E4_[145],
     input_line$0=_E4_[146],
     input$0=_E4_[147],
     really_input$0=_E4_[148],
     really_input_string$0=_E4_[149],
     input_byte$0=_E4_[150],
     input_binary_int$0=_E4_[151],
     input_value$0=_E4_[152],
     seek_in$0=_E4_[153],
     pos_in$0=_E4_[154],
     in_channel_length$0=_E4_[155],
     close_in$0=_E4_[156],
     close_in_noerr$0=_E4_[157],
     set_binary_mode_in$0=_E4_[158],
     LargeFile$1=_E4_[159],
     incr$0=_E4_[163],
     decr$0=_E4_[164],
     string_of_format$0=_E4_[165],
     format_of_string$0=_E4_[166],
     exit$1=_E4_[168],
     at_exit$1=_E4_[169],
     valid_float_lexem$0=_E4_[170],
     unsafe_really_input$0=_E4_[171],
     do_at_exit$0=_E4_[172],
     _E9_=Reset[2],
     Arith_status$1=_E9_[52],
     Big_int$2=_E9_[51],
     Num$1=_E9_[50],
     Weak$1=_E9_[49],
     Uchar$1=_E9_[48],
     Sys$1=_E9_[47],
     StringLabels$1=_E9_[46],
     StdLabels$1=_E9_[43],
     Stack$1=_E9_[42],
     Spacetime$1=_E9_[41],
     Sort$1=_E9_[40],
     Set$1=_E9_[39],
     Seq$1=_E9_[38],
     Scanf$1=_E9_[37],
     Random$1=_E9_[36],
     Queue$1=_E9_[35],
     Printf$1=_E9_[34],
     Printexc$1=_E9_[33],
     Parsing$1=_E9_[32],
     Oo$1=_E9_[31],
     Nativeint$1=_E9_[30],
     MoreLabels$1=_E9_[29],
     Marshal$1=_E9_[28],
     Map$1=_E9_[27],
     ListLabels$1=_E9_[26],
     Lexing$1=_E9_[24],
     Hashtbl$1=_E9_[20],
     Genlex$1=_E9_[19],
     Gc$1=_E9_[18],
     Filename$1=_E9_[15],
     Ephemeron$1=_E9_[14],
     Digest$1=_E9_[13],
     Complex$1=_E9_[12],
     Callback$1=_E9_[10],
     BytesLabels$1=_E9_[9],
     Buffer$1=_E9_[7],
     Bigarray$1=_E9_[6],
     ArrayLabels$1=_E9_[5],
     Arg$1=_E9_[3],
     Pervasives$1=_E9_[2],
     OCamlStandard$1=_E9_[1],
     _E__=Reset[1],
     raise$2=_E__[1],
     raise_notrace$1=_E__[2],
     invalid_arg$1=_E__[3],
     failwith$1=_E__[4],
     compare$19=_E__[11],
     min$16=_E__[12],
     max$19=_E__[13],
     or$2=_E__[20],
     succ$11=_E__[25],
     pred$9=_E__[26],
     abs$10=_E__[32],
     max_int$4=_E__[33],
     min_int$4=_E__[34],
     land$1=_E__[35],
     lor$1=_E__[36],
     lxor$1=_E__[37],
     lnot$1=_E__[38],
     lsl$1=_E__[39],
     lsr$1=_E__[40],
     asr$1=_E__[41],
     sqrt$2=_E__[49],
     exp$2=_E__[50],
     log$2=_E__[51],
     log10$2=_E__[52],
     expm1$2=_E__[53],
     log1p$2=_E__[54],
     cos$2=_E__[55],
     sin$2=_E__[56],
     tan$2=_E__[57],
     acos$2=_E__[58],
     asin$2=_E__[59],
     atan$2=_E__[60],
     atan2$2=_E__[61],
     hypot$2=_E__[62],
     cosh$2=_E__[63],
     sinh$2=_E__[64],
     tanh$2=_E__[65],
     ceil$2=_E__[66],
     floor$2=_E__[67],
     abs_float$1=_E__[68],
     copysign$1=_E__[69],
     mod_float$1=_E__[70],
     frexp$1=_E__[71],
     ldexp$1=_E__[72],
     modf$1=_E__[73],
     float$2=_E__[74],
     float_of_int$1=_E__[75],
     truncate$1=_E__[76],
     int_of_float$1=_E__[77],
     infinity$2=_E__[78],
     neg_infinity$1=_E__[79],
     nan$1=_E__[80],
     max_float$1=_E__[81],
     min_float$1=_E__[82],
     epsilon_float$1=_E__[83],
     classify_float$1=_E__[84],
     int_of_char$1=_E__[86],
     char_of_int$1=_E__[87],
     string_of_bool$1=_E__[89],
     bool_of_string$1=_E__[90],
     bool_of_string_opt$1=_E__[91],
     string_of_int$1=_E__[92],
     int_of_string$1=_E__[93],
     int_of_string_opt$1=_E__[94],
     string_of_float$1=_E__[95],
     float_of_string$1=_E__[96],
     float_of_string_opt$1=_E__[97],
     fst$1=_E__[98],
     snd$1=_E__[99],
     stdin$1=_E__[101],
     stdout$1=_E__[102],
     stderr$1=_E__[103],
     print_char$1=_E__[104],
     print_string$1=_E__[105],
     print_bytes$1=_E__[106],
     print_int$1=_E__[107],
     print_float$1=_E__[108],
     print_endline$1=_E__[109],
     print_newline$1=_E__[110],
     prerr_char$1=_E__[111],
     prerr_string$1=_E__[112],
     prerr_bytes$1=_E__[113],
     prerr_int$1=_E__[114],
     prerr_float$1=_E__[115],
     prerr_endline$1=_E__[116],
     prerr_newline$1=_E__[117],
     read_line$1=_E__[118],
     read_int$1=_E__[119],
     read_int_opt$1=_E__[120],
     read_float$1=_E__[121],
     read_float_opt$1=_E__[122],
     open_out$1=_E__[123],
     open_out_bin$1=_E__[124],
     open_out_gen$1=_E__[125],
     flush$4=_E__[126],
     flush_all$1=_E__[127],
     output_char$1=_E__[128],
     output_string$1=_E__[129],
     output_bytes$1=_E__[130],
     output$4=_E__[131],
     output_substring$1=_E__[132],
     output_byte$1=_E__[133],
     output_binary_int$1=_E__[134],
     output_value$1=_E__[135],
     seek_out$1=_E__[136],
     pos_out$1=_E__[137],
     out_channel_length$1=_E__[138],
     close_out$1=_E__[139],
     close_out_noerr$1=_E__[140],
     set_binary_mode_out$1=_E__[141],
     open_in$1=_E__[142],
     open_in_bin$1=_E__[143],
     open_in_gen$1=_E__[144],
     input_char$1=_E__[145],
     input_line$1=_E__[146],
     input$1=_E__[147],
     really_input$1=_E__[148],
     really_input_string$1=_E__[149],
     input_byte$1=_E__[150],
     input_binary_int$1=_E__[151],
     input_value$1=_E__[152],
     seek_in$1=_E__[153],
     pos_in$1=_E__[154],
     in_channel_length$1=_E__[155],
     close_in$1=_E__[156],
     close_in_noerr$1=_E__[157],
     set_binary_mode_in$1=_E__[158],
     LargeFile$2=_E__[159],
     incr$1=_E__[163],
     decr$1=_E__[164],
     string_of_format$1=_E__[165],
     format_of_string$1=_E__[166],
     exit$2=_E__[168],
     at_exit$2=_E__[169],
     valid_float_lexem$1=_E__[170],
     unsafe_really_input$1=_E__[171],
     do_at_exit$1=_E__[172],
     _Fd_=Reset[2],
     Arith_status$2=_Fd_[52],
     Big_int$3=_Fd_[51],
     Num$2=_Fd_[50],
     Weak$2=_Fd_[49],
     Uchar$2=_Fd_[48],
     Sys$2=_Fd_[47],
     StringLabels$2=_Fd_[46],
     String$4=_Fd_[45],
     Stream$2=_Fd_[44],
     StdLabels$2=_Fd_[43],
     Stack$2=_Fd_[42],
     Spacetime$2=_Fd_[41],
     Sort$2=_Fd_[40],
     Set$2=_Fd_[39],
     Seq$2=_Fd_[38],
     Scanf$2=_Fd_[37],
     Random$2=_Fd_[36],
     Queue$2=_Fd_[35],
     Printf$2=_Fd_[34],
     Printexc$2=_Fd_[33],
     Parsing$2=_Fd_[32],
     Oo$2=_Fd_[31],
     Nativeint$2=_Fd_[30],
     MoreLabels$2=_Fd_[29],
     Marshal$2=_Fd_[28],
     Map$2=_Fd_[27],
     ListLabels$2=_Fd_[26],
     List$2=_Fd_[25],
     Lexing$2=_Fd_[24],
     Lazy$2=_Fd_[23],
     Hashtbl$2=_Fd_[20],
     Genlex$2=_Fd_[19],
     Gc$2=_Fd_[18],
     Format$2=_Fd_[17],
     Float$4=_Fd_[16],
     Filename$2=_Fd_[15],
     Ephemeron$2=_Fd_[14],
     Digest$2=_Fd_[13],
     Complex$2=_Fd_[12],
     Char$4=_Fd_[11],
     Callback$2=_Fd_[10],
     BytesLabels$2=_Fd_[9],
     Bytes$2=_Fd_[8],
     Buffer$2=_Fd_[7],
     Bigarray$2=_Fd_[6],
     ArrayLabels$2=_Fd_[5],
     Array$2=_Fd_[4],
     Arg$2=_Fd_[3],
     Pervasives$2=_Fd_[2],
     OCamlStandard$2=_Fd_[1],
     _E5_=_E4_[14],
     _E6_=_E4_[15],
     _E7_=_E4_[19],
     _E8_=_E4_[167],
     _E$_=_E__[14],
     _Fa_=_E__[15],
     _Fb_=_E__[19],
     _Fc_=_E__[167],
     test$29=
      _a$_
       (cst_General,
        [0,
         test$13,
         [0,
          test$25,
          [0,
           test$14,
           [0,
            test$17,
            [0,
             test$9,
             [0,
              test$12,
              [0,
               test$18,
               [0,
                test$15,
                [0,
                 test$10,
                 [0,
                  test$11,
                  [0,
                   test$20,
                   [0,
                    test$16,
                    [0,
                     test$21,
                     [0,
                      test$22,
                      [0,
                       test$24,
                       [0,
                        test$26,
                        [0,test$27,[0,test$23,[0,test$19,[0,test$28,0]]]]]]]]]]]]]]]]]]]]),
     Tests=[0,test$29],
     Testing=0,
     Array$1=0,
     BigInt=0,
     Bool=0,
     Bytes$1=0,
     CallStack=0,
     Char$3=0,
     Exception=0,
     Exit$0=0,
     Float$3=0,
     Format$1=0,
     Function1$0=0,
     Function2$0=0,
     Function3$0=0,
     Function4$0=0,
     Function5$0=0,
     Heap=0,
     InChannel=0,
     InFile=0,
     Int$1=0,
     Int32$1=0,
     Int64$1=0,
     Lazy$1=0,
     List$1=0,
     NativeInt=0,
     Option=0,
     OutChannel=0,
     OutFile=0,
     PriorityQueue=0,
     Reference=0,
     SortedMap=0,
     SortedSet=0,
     StdErr=0,
     StdIn=0,
     StdOut=0,
     Stream$1=0,
     String$3=0,
     Tuple2=0,
     Tuple3=0,
     Tuple4=0,
     Tuple5=0,
     Unit$0=0,
     IntRange=0,
     FloatOption=0,
     IntOption=0,
     StringOption=0,
     FloatReference=0,
     IntReference=0,
     StringReference=0,
     FloatList=0,
     IntList=0,
     StringList=0,
     CharSortedSet=0,
     FloatSortedSet=0,
     IntSortedSet=0,
     StringSortedSet=0,
     CharSortedMap=0,
     FloatSortedMap=0,
     IntSortedMap=0,
     StringSortedMap=0,
     Tst=0,
     Ar=0,
     BigInt$0=0,
     Bo=0,
     By=0,
     CallStack$0=0,
     Ch=0,
     Exit$1=0,
     Exn=0,
     Fl=0,
     Frmt=0,
     Fun1=0,
     Fun2=0,
     Fun3=0,
     Fun4=0,
     Fun5=0,
     Heap$0=0,
     InCh=0,
     InFile$0=0,
     Int$2=0,
     Int32$2=0,
     Int64$2=0,
     Laz=0,
     Li=0,
     NativeInt$0=0,
     Opt=0,
     OutCh=0,
     OutFile$0=0,
     PriQu=0,
     Ref=0,
     SoMap=0,
     SoSet=0,
     StdErr$0=0,
     StdIn$0=0,
     StdOut$0=0,
     Str=0,
     Strm=0,
     Tu2=0,
     Tu3=0,
     Tu4=0,
     Tu5=0,
     Unit$1=0,
     IntRa=0,
     FlOpt=0,
     IntOpt=0,
     StrOpt=0,
     FlRef=0,
     IntRef=0,
     StrRef=0,
     FlLi=0,
     IntLi=0,
     StrLi=0,
     ChSoSet=0,
     FlSoSet=0,
     IntSoSet=0,
     StrSoSet=0,
     ChSoMap=0,
     FlSoMap=0,
     IntSoMap=0,
     StrSoMap=0;
    function _Fe_(_GM_,_GL_){var _GN_=_GM_ || _GL_;return _GN_}
    var
     _Ff_=
      [0,
       Tst,
       Ar,
       BigInt$0,
       Bo,
       By,
       CallStack$0,
       Ch,
       Exit$1,
       Exn,
       Fl,
       Frmt,
       Fun1,
       Fun2,
       Fun3,
       Fun4,
       Fun5,
       Heap$0,
       InCh,
       InFile$0,
       Int$2,
       Int32$2,
       Int64$2,
       Laz,
       Li,
       NativeInt$0,
       Opt,
       OutCh,
       OutFile$0,
       PriQu,
       Ref,
       SoMap,
       SoSet,
       StdErr$0,
       StdIn$0,
       StdOut$0,
       Str,
       Strm,
       Tu2,
       Tu3,
       Tu4,
       Tu5,
       Unit$1,
       IntRa,
       FlOpt,
       IntOpt,
       StrOpt,
       FlRef,
       IntRef,
       StrRef,
       FlLi,
       IntLi,
       StrLi,
       ChSoSet,
       FlSoSet,
       IntSoSet,
       StrSoSet,
       ChSoMap,
       FlSoMap,
       IntSoMap,
       StrSoMap,
       raise$2,
       raise_notrace$1,
       invalid_arg$1,
       failwith$1,
       compare$19,
       min$16,
       max$19,
       _E$_,
       _Fa_,
       _Fb_,
       or$2,
       succ$11,
       pred$9,
       abs$10,
       max_int$4,
       min_int$4,
       land$1,
       lor$1,
       lxor$1,
       lnot$1,
       lsl$1,
       lsr$1,
       asr$1,
       sqrt$2,
       exp$2,
       log$2,
       log10$2,
       expm1$2,
       log1p$2,
       cos$2,
       sin$2,
       tan$2,
       acos$2,
       asin$2,
       atan$2,
       atan2$2,
       hypot$2,
       cosh$2,
       sinh$2,
       tanh$2,
       ceil$2,
       floor$2,
       abs_float$1,
       copysign$1,
       mod_float$1,
       frexp$1,
       ldexp$1,
       modf$1,
       float$2,
       float_of_int$1,
       truncate$1,
       int_of_float$1,
       infinity$2,
       neg_infinity$1,
       nan$1,
       max_float$1,
       min_float$1,
       epsilon_float$1,
       classify_float$1,
       int_of_char$1,
       char_of_int$1,
       string_of_bool$1,
       bool_of_string$1,
       bool_of_string_opt$1,
       string_of_int$1,
       int_of_string$1,
       int_of_string_opt$1,
       string_of_float$1,
       float_of_string$1,
       float_of_string_opt$1,
       fst$1,
       snd$1,
       stdin$1,
       stdout$1,
       stderr$1,
       print_char$1,
       print_string$1,
       print_bytes$1,
       print_int$1,
       print_float$1,
       print_endline$1,
       print_newline$1,
       prerr_char$1,
       prerr_string$1,
       prerr_bytes$1,
       prerr_int$1,
       prerr_float$1,
       prerr_endline$1,
       prerr_newline$1,
       read_line$1,
       read_int$1,
       read_int_opt$1,
       read_float$1,
       read_float_opt$1,
       open_out$1,
       open_out_bin$1,
       open_out_gen$1,
       flush$4,
       flush_all$1,
       output_char$1,
       output_string$1,
       output_bytes$1,
       output$4,
       output_substring$1,
       output_byte$1,
       output_binary_int$1,
       output_value$1,
       seek_out$1,
       pos_out$1,
       out_channel_length$1,
       close_out$1,
       close_out_noerr$1,
       set_binary_mode_out$1,
       open_in$1,
       open_in_bin$1,
       open_in_gen$1,
       input_char$1,
       input_line$1,
       input$1,
       really_input$1,
       really_input_string$1,
       input_byte$1,
       input_binary_int$1,
       input_value$1,
       seek_in$1,
       pos_in$1,
       in_channel_length$1,
       close_in$1,
       close_in_noerr$1,
       set_binary_mode_in$1,
       LargeFile$2,
       incr$1,
       decr$1,
       string_of_format$1,
       format_of_string$1,
       _Fc_,
       exit$2,
       at_exit$2,
       valid_float_lexem$1,
       unsafe_really_input$1,
       do_at_exit$1,
       OCamlStandard$2,
       Pervasives$2,
       Arg$2,
       Array$2,
       ArrayLabels$2,
       Bigarray$2,
       Buffer$2,
       Bytes$2,
       BytesLabels$2,
       Callback$2,
       Char$4,
       Complex$2,
       Digest$2,
       Ephemeron$2,
       Filename$2,
       Float$4,
       Format$2,
       Gc$2,
       Genlex$2,
       Hashtbl$2,
       Lazy$2,
       Lexing$2,
       List$2,
       ListLabels$2,
       Map$2,
       Marshal$2,
       MoreLabels$2,
       Nativeint$2,
       Oo$2,
       Parsing$2,
       Printexc$2,
       Printf$2,
       Queue$2,
       Random$2,
       Scanf$2,
       Seq$2,
       Set$2,
       Sort$2,
       Spacetime$2,
       Stack$2,
       StdLabels$2,
       Stream$2,
       String$4,
       StringLabels$2,
       Sys$2,
       Uchar$2,
       Weak$2,
       Num$2,
       Big_int$3,
       Arith_status$2,
       not,
       function(_GJ_,_GI_){var _GK_=_GJ_?_GI_:_GJ_;return _GK_},
       _Fe_,
       _g_,
       _h_,
       _i_,
       _j_,
       _k_,
       _l_,
       mod,
       _R_,
       _S_,
       _T_,
       _U_,
       _V_,
       _W_,
       _X_,
       _at_,
       _au_,
       _av_,
       ref$0,
       _ay_,
       _ax_,
       _aA_,
       _aB_,
       _a_,
       _b_,
       _c_,
       _d_,
       ignore,
       identity$0,
       _aw_,
       _ad_];
    function _Fg_(_GG_,_GF_){var _GH_=_GG_ || _GF_;return _GH_}
    var
     _Fh_=
      [0,
       Testing,
       Array$1,
       BigInt,
       Bool,
       Bytes$1,
       CallStack,
       Char$3,
       Exception,
       Exit$0,
       Float$3,
       Format$1,
       Function1$0,
       Function2$0,
       Function3$0,
       Function4$0,
       Function5$0,
       Heap,
       InChannel,
       InFile,
       Int$1,
       Int32$1,
       Int64$1,
       Lazy$1,
       List$1,
       NativeInt,
       Option,
       OutChannel,
       OutFile,
       PriorityQueue,
       Reference,
       SortedMap,
       SortedSet,
       StdErr,
       StdIn,
       StdOut,
       Stream$1,
       String$3,
       Tuple2,
       Tuple3,
       Tuple4,
       Tuple5,
       Unit$0,
       IntRange,
       FloatOption,
       IntOption,
       StringOption,
       FloatReference,
       IntReference,
       StringReference,
       FloatList,
       IntList,
       StringList,
       CharSortedSet,
       FloatSortedSet,
       IntSortedSet,
       StringSortedSet,
       CharSortedMap,
       FloatSortedMap,
       IntSortedMap,
       StringSortedMap,
       raise$1,
       raise_notrace$0,
       invalid_arg$0,
       failwith$0,
       compare$18,
       min$15,
       max$18,
       _E5_,
       _E6_,
       _E7_,
       or$1,
       succ$10,
       pred$8,
       abs$9,
       max_int$3,
       min_int$3,
       land$0,
       lor$0,
       lxor$0,
       lnot$0,
       lsl$0,
       lsr$0,
       asr$0,
       sqrt$1,
       exp$1,
       log$1,
       log10$1,
       expm1$1,
       log1p$1,
       cos$1,
       sin$1,
       tan$1,
       acos$1,
       asin$1,
       atan$1,
       atan2$1,
       hypot$1,
       cosh$1,
       sinh$1,
       tanh$1,
       ceil$1,
       floor$1,
       abs_float$0,
       copysign$0,
       mod_float$0,
       frexp$0,
       ldexp$0,
       modf$0,
       float$1,
       float_of_int$0,
       truncate$0,
       int_of_float$0,
       infinity$1,
       neg_infinity$0,
       nan$0,
       max_float$0,
       min_float$0,
       epsilon_float$0,
       classify_float$0,
       int_of_char$0,
       char_of_int$0,
       string_of_bool$0,
       bool_of_string$0,
       bool_of_string_opt$0,
       string_of_int$0,
       int_of_string$0,
       int_of_string_opt$0,
       string_of_float$0,
       float_of_string$0,
       float_of_string_opt$0,
       fst$0,
       snd$0,
       stdin$0,
       stdout$0,
       stderr$0,
       print_char$0,
       print_string$0,
       print_bytes$0,
       print_int$0,
       print_float$0,
       print_endline$0,
       print_newline$0,
       prerr_char$0,
       prerr_string$0,
       prerr_bytes$0,
       prerr_int$0,
       prerr_float$0,
       prerr_endline$0,
       prerr_newline$0,
       read_line$0,
       read_int$0,
       read_int_opt$0,
       read_float$0,
       read_float_opt$0,
       open_out$0,
       open_out_bin$0,
       open_out_gen$0,
       flush$3,
       flush_all$0,
       output_char$0,
       output_string$0,
       output_bytes$0,
       output$3,
       output_substring$0,
       output_byte$0,
       output_binary_int$0,
       output_value$0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       close_out$0,
       close_out_noerr$0,
       set_binary_mode_out$0,
       open_in$0,
       open_in_bin$0,
       open_in_gen$0,
       input_char$0,
       input_line$0,
       input$0,
       really_input$0,
       really_input_string$0,
       input_byte$0,
       input_binary_int$0,
       input_value$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0,
       close_in$0,
       close_in_noerr$0,
       set_binary_mode_in$0,
       LargeFile$1,
       incr$0,
       decr$0,
       string_of_format$0,
       format_of_string$0,
       _E8_,
       exit$1,
       at_exit$1,
       valid_float_lexem$0,
       unsafe_really_input$0,
       do_at_exit$0,
       OCamlStandard$1,
       Pervasives$1,
       Arg$1,
       ArrayLabels$1,
       Bigarray$1,
       Buffer$1,
       BytesLabels$1,
       Callback$1,
       Complex$1,
       Digest$1,
       Ephemeron$1,
       Filename$1,
       Gc$1,
       Genlex$1,
       Hashtbl$1,
       Lexing$1,
       ListLabels$1,
       Map$1,
       Marshal$1,
       MoreLabels$1,
       Nativeint$1,
       Oo$1,
       Parsing$1,
       Printexc$1,
       Printf$1,
       Queue$1,
       Random$1,
       Scanf$1,
       Seq$1,
       Set$1,
       Sort$1,
       Spacetime$1,
       Stack$1,
       StdLabels$1,
       StringLabels$1,
       Sys$1,
       Uchar$1,
       Weak$1,
       Num$1,
       Big_int$2,
       Arith_status$1,
       not,
       function(_GD_,_GC_){var _GE_=_GD_?_GC_:_GD_;return _GE_},
       _Fg_,
       _g_,
       _h_,
       _i_,
       _j_,
       _k_,
       _l_,
       mod,
       _R_,
       _S_,
       _T_,
       _U_,
       _V_,
       _W_,
       _X_,
       _at_,
       _au_,
       _av_,
       ref$0,
       _ay_,
       _ax_,
       _aA_,
       _aB_,
       _a_,
       _b_,
       _c_,
       _d_,
       ignore,
       identity$0,
       _aw_,
       _ad_],
     _Fi_=
      [0,
       [0,[0,to_string$6],[0]],
       Test,
       command_line_main,
       _a$_,
       _ba_,
       _bc_,
       _bb_,
       fail,
       expect_exception,
       expect_exception_named,
       check,
       check_poly,
       check_string,
       check_bool,
       check_true,
       check_false,
       check_int,
       check_float,
       check_float_in,
       check_float_exact,
       check_option,
       check_option_poly,
       check_some,
       check_none,
       check_some_poly,
       check_none_poly,
       check_int_option,
       check_some_int,
       check_none_int,
       check_string_option,
       check_some_string,
       check_none_string,
       check_list,
       check_list_poly,
       check_string_list,
       check_int_list],
     _Fj_=[0,channel$0,print$0,output$1,flush$1],
     _Fk_=[0,channel$3,print$1,output$2,flush$2],
     _Fl_=[0,channel$1],
     _Fm_=[0,with_file$0,with_channel$0,identity$0,seek$0,pos$0,size$4],
     _Fn_=[0,print,output$0,flush$0],
     _Fo_=[0,with_file,with_channel,identity$0,seek,pos,size$3],
     _Fp_=[0],
     _Fq_=[0,with_result,apply,to_string,of_string,concat,with_scan_result],
     _Fr_=
      [0,
       Char$1[3],
       Char$1[7],
       Char$1[9],
       Char$1[11],
       Char$1[4],
       Char$1[5],
       Char$1[6],
       Char$1[8],
       Char$1[10],
       Char$1[12],
       Char$1[13]],
     _Fs_=
      [0,
       String$1[3],
       String$1[7],
       String$1[9],
       String$1[11],
       String$1[4],
       String$1[5],
       String$1[6],
       String$1[8],
       String$1[10],
       String$1[12],
       String$1[13]],
     _Ft_=
      [0,
       Float$1[3],
       Float$1[7],
       Float$1[9],
       Float$1[11],
       Float$1[4],
       Float$1[5],
       Float$1[6],
       Float$1[8],
       Float$1[10],
       Float$1[12],
       Float$1[13]],
     _Fu_=
      [0,
       Int[3],
       Int[7],
       Int[9],
       Int[11],
       Int[4],
       Int[5],
       Int[6],
       Int[8],
       Int[10],
       Int[12],
       Int[13]],
     _Fv_=
      [0,
       Char$2[3],
       Char$2[7],
       Char$2[10],
       Char$2[4],
       Char$2[5],
       Char$2[6],
       Char$2[8],
       Char$2[9],
       Char$2[11]],
     _Fw_=
      [0,
       String$2[3],
       String$2[7],
       String$2[10],
       String$2[4],
       String$2[5],
       String$2[6],
       String$2[8],
       String$2[9],
       String$2[11]],
     _Fx_=
      [0,
       Float$2[3],
       Float$2[7],
       Float$2[10],
       Float$2[4],
       Float$2[5],
       Float$2[6],
       Float$2[8],
       Float$2[9],
       Float$2[11]],
     _Fy_=
      [0,
       Int$0[3],
       Int$0[7],
       Int$0[10],
       Int$0[4],
       Int$0[5],
       Int$0[6],
       Int$0[8],
       Int$0[9],
       Int$0[11]],
     _Fz_=
      [0,
       O$2,
       empty$7,
       singleton$3,
       of_list$5,
       to_list$8,
       of_array$2,
       to_array$3,
       size$10,
       is_empty$3,
       head$2,
       tail$2,
       try_head$2,
       try_tail$2,
       prepend$3,
       reverse$2,
       concat$5,
       map$6,
       map_i$5,
       map_acc$5,
       filter$7,
       filter_i$5,
       filter_acc$5,
       filter_map$6,
       filter_map_i$5,
       filter_map_acc$5,
       flat_map$5,
       flat_map_i$5,
       flat_map_acc$5,
       fold$5,
       fold_i$3,
       fold_acc$3,
       reduce$3,
       reduce_i$3,
       reduce_acc$3,
       try_reduce$3,
       try_reduce_i$3,
       try_reduce_acc$3,
       iter$4,
       iter_i$3,
       iter_acc$3,
       count$3,
       count_i$3,
       count_acc$3,
       fold_short$3,
       fold_short_i$3,
       fold_short_acc$3,
       reduce_short$3,
       reduce_short_i$3,
       reduce_short_acc$3,
       try_reduce_short$3,
       try_reduce_short_i$3,
       try_reduce_short_acc$3,
       iter_short$3,
       iter_short_i$3,
       iter_short_acc$3,
       for_all$3,
       for_all_i$3,
       for_all_acc$3,
       there_exists$3,
       there_exists_i$3,
       there_exists_acc$3,
       find$3,
       find_i$3,
       find_acc$3,
       try_find$3,
       try_find_i$3,
       try_find_acc$3,
       find_map$3,
       find_map_i$3,
       find_map_acc$3,
       try_find_map$3,
       try_find_map_i$3,
       try_find_map_acc$3,
       scan$3,
       scan_i$3,
       scan_acc$3,
       scan_short$3,
       scan_short_i$3,
       scan_short_acc$3,
       [0,
        ToList$7[1],
        ToList$7[3],
        ToList$7[2],
        ToList$7[4],
        ToList$7[6],
        ToList$7[5],
        ToList$7[7],
        ToList$7[9],
        ToList$7[8],
        ToList$7[10],
        ToList$7[12],
        ToList$7[11],
        ToList$7[13],
        ToList$7[15],
        ToList$7[14],
        ToList$7[16],
        ToList$7[18],
        ToList$7[17]],
       contains$4,
       join],
     _FA_=
      [0,
       O$2,
       empty$6,
       singleton$2,
       of_list$4,
       to_list$7,
       of_array$1,
       to_array$2,
       size$9,
       is_empty$2,
       head$1,
       tail$1,
       try_head$1,
       try_tail$1,
       prepend$2,
       reverse$1,
       concat$4,
       map$5,
       map_i$4,
       map_acc$4,
       filter$6,
       filter_i$4,
       filter_acc$4,
       filter_map$5,
       filter_map_i$4,
       filter_map_acc$4,
       flat_map$4,
       flat_map_i$4,
       flat_map_acc$4,
       fold$4,
       fold_i$2,
       fold_acc$2,
       reduce$2,
       reduce_i$2,
       reduce_acc$2,
       try_reduce$2,
       try_reduce_i$2,
       try_reduce_acc$2,
       iter$3,
       iter_i$2,
       iter_acc$2,
       count$2,
       count_i$2,
       count_acc$2,
       fold_short$2,
       fold_short_i$2,
       fold_short_acc$2,
       reduce_short$2,
       reduce_short_i$2,
       reduce_short_acc$2,
       try_reduce_short$2,
       try_reduce_short_i$2,
       try_reduce_short_acc$2,
       iter_short$2,
       iter_short_i$2,
       iter_short_acc$2,
       for_all$2,
       for_all_i$2,
       for_all_acc$2,
       there_exists$2,
       there_exists_i$2,
       there_exists_acc$2,
       find$2,
       find_i$2,
       find_acc$2,
       try_find$2,
       try_find_i$2,
       try_find_acc$2,
       find_map$2,
       find_map_i$2,
       find_map_acc$2,
       try_find_map$2,
       try_find_map_i$2,
       try_find_map_acc$2,
       scan$2,
       scan_i$2,
       scan_acc$2,
       scan_short$2,
       scan_short_i$2,
       scan_short_acc$2,
       [0,
        ToList$6[1],
        ToList$6[3],
        ToList$6[2],
        ToList$6[4],
        ToList$6[6],
        ToList$6[5],
        ToList$6[7],
        ToList$6[9],
        ToList$6[8],
        ToList$6[10],
        ToList$6[12],
        ToList$6[11],
        ToList$6[13],
        ToList$6[15],
        ToList$6[14],
        ToList$6[16],
        ToList$6[18],
        ToList$6[17]],
       contains$3],
     _FB_=
      [0,
       O$2,
       empty$5,
       singleton$1,
       of_list$3,
       to_list$6,
       of_array$0,
       to_array$1,
       size$8,
       is_empty$1,
       head$0,
       tail$0,
       try_head$0,
       try_tail$0,
       prepend$1,
       reverse$0,
       concat$3,
       map$4,
       map_i$3,
       map_acc$3,
       filter$5,
       filter_i$3,
       filter_acc$3,
       filter_map$4,
       filter_map_i$3,
       filter_map_acc$3,
       flat_map$3,
       flat_map_i$3,
       flat_map_acc$3,
       fold$3,
       fold_i$1,
       fold_acc$1,
       reduce$1,
       reduce_i$1,
       reduce_acc$1,
       try_reduce$1,
       try_reduce_i$1,
       try_reduce_acc$1,
       iter$2,
       iter_i$1,
       iter_acc$1,
       count$1,
       count_i$1,
       count_acc$1,
       fold_short$1,
       fold_short_i$1,
       fold_short_acc$1,
       reduce_short$1,
       reduce_short_i$1,
       reduce_short_acc$1,
       try_reduce_short$1,
       try_reduce_short_i$1,
       try_reduce_short_acc$1,
       iter_short$1,
       iter_short_i$1,
       iter_short_acc$1,
       for_all$1,
       for_all_i$1,
       for_all_acc$1,
       there_exists$1,
       there_exists_i$1,
       there_exists_acc$1,
       find$1,
       find_i$1,
       find_acc$1,
       try_find$1,
       try_find_i$1,
       try_find_acc$1,
       find_map$1,
       find_map_i$1,
       find_map_acc$1,
       try_find_map$1,
       try_find_map_i$1,
       try_find_map_acc$1,
       scan$1,
       scan_i$1,
       scan_acc$1,
       scan_short$1,
       scan_short_i$1,
       scan_short_acc$1,
       [0,
        ToList$5[1],
        ToList$5[3],
        ToList$5[2],
        ToList$5[4],
        ToList$5[6],
        ToList$5[5],
        ToList$5[7],
        ToList$5[9],
        ToList$5[8],
        ToList$5[10],
        ToList$5[12],
        ToList$5[11],
        ToList$5[13],
        ToList$5[15],
        ToList$5[14],
        ToList$5[16],
        ToList$5[18],
        ToList$5[17]],
       contains$2],
     _FC_=
      [0,
       equal$10,
       different$8,
       O$4,
       repr$7,
       empty$0,
       make,
       to_list$1,
       to_array$0,
       fold$1,
       fold_i$0,
       fold_acc$0,
       reduce$0,
       reduce_i$0,
       reduce_acc$0,
       try_reduce$0,
       try_reduce_i$0,
       try_reduce_acc$0,
       iter$1,
       iter_i$0,
       iter_acc$0,
       count$0,
       count_i$0,
       count_acc$0,
       fold_short$0,
       fold_short_i$0,
       fold_short_acc$0,
       reduce_short$0,
       reduce_short_i$0,
       reduce_short_acc$0,
       try_reduce_short$0,
       try_reduce_short_i$0,
       try_reduce_short_acc$0,
       iter_short$0,
       iter_short_i$0,
       iter_short_acc$0,
       for_all$0,
       for_all_i$0,
       for_all_acc$0,
       there_exists$0,
       there_exists_i$0,
       there_exists_acc$0,
       find$0,
       find_i$0,
       find_acc$0,
       try_find$0,
       try_find_i$0,
       try_find_acc$0,
       find_map$0,
       find_map_i$0,
       find_map_acc$0,
       try_find_map$0,
       try_find_map_i$0,
       try_find_map_acc$0,
       ToList],
     _FD_=
      [0,
       [0,empty$4,add$7,pop_max$1,max$16],
       function(E)
        {function cmp(param,_GB_)
          {var y=_GB_[1],x=param[1];return caml_call2(E[1],x,y)}
         function add(xs,k,v){return add$6(xs,cmp,[0,k,v])}
         function max(xs){return max$15(xs)}
         function pop_max$0(xs){return pop_max(xs,cmp)}
         return [0,empty$4,add,pop_max$0,max]}],
     _FE_=
      [0,
       [0,empty$4,add$10,pop_max$2,max$17],
       function(E)
        {function cmp(x,y){return caml_call2(E[1],x,y)}
         function add(xs,v){return add$6(xs,cmp,v)}
         function max(xs){return max$15(xs)}
         function pop_max$0(xs){return pop_max(xs,cmp)}
         return [0,empty$4,add,pop_max$0,max]}],
     _FF_=
      [0,
       [0,
        empty$3,
        of_list_first,
        of_list_last,
        to_list$4,
        is_empty$0,
        size$6,
        add$8,
        replace$0,
        remove$0,
        try_get$0,
        get$4],
       function(_Gz_)
        {var _GA_=Make$0(_Gz_);
         return [0,
                 _GA_[3],
                 _GA_[7],
                 _GA_[9],
                 _GA_[11],
                 _GA_[4],
                 _GA_[5],
                 _GA_[6],
                 _GA_[8],
                 _GA_[10],
                 _GA_[12],
                 _GA_[13]]}],
     _FG_=
      [0,
       [0,
        empty$3,
        of_list$2,
        to_list$5,
        is_empty$0,
        size$7,
        add$9,
        replace$1,
        remove$1,
        contains$1],
       function(_Gx_)
        {var _Gy_=Make$1(_Gx_);
         return [0,
                 _Gy_[3],
                 _Gy_[7],
                 _Gy_[10],
                 _Gy_[4],
                 _Gy_[5],
                 _Gy_[6],
                 _Gy_[8],
                 _Gy_[9],
                 _Gy_[11]]}],
     _FH_=
      [0,
       empty$1,
       singleton$0,
       to_list$2,
       of_list$1,
       prepend$0,
       concat$2,
       map$2,
       map_i$1,
       map_acc$1,
       filter$3,
       filter_i$1,
       filter_acc$1,
       filter_map$2,
       filter_map_i$1,
       filter_map_acc$1,
       flat_map$1,
       flat_map_i$1,
       flat_map_acc$1,
       [0,
        map$3,
        map_i$2,
        map_acc$2,
        filter$4,
        filter_i$2,
        filter_acc$2,
        filter_map$3,
        filter_map_i$2,
        filter_map_acc$2,
        flat_map$2,
        flat_map_i$2,
        flat_map_acc$2]],
     _FI_=[0,size$1,get$2,set$2],
     _FJ_=
      [0,
       O$2,
       empty,
       singleton,
       of_list,
       to_list,
       of_array,
       to_array,
       size,
       is_empty,
       head,
       tail,
       try_head,
       try_tail,
       contains,
       Poly$0,
       prepend,
       reverse,
       concat$0,
       map$0,
       map_i,
       map_acc,
       filter$0,
       filter_i,
       filter_acc,
       filter_map$0,
       filter_map_i,
       filter_map_acc,
       flat_map,
       flat_map_i,
       flat_map_acc,
       fold,
       fold_i,
       fold_acc,
       reduce,
       reduce_i,
       reduce_acc,
       try_reduce,
       try_reduce_i,
       try_reduce_acc,
       iter$0,
       iter_i,
       iter_acc,
       count,
       count_i,
       count_acc,
       fold_short,
       fold_short_i,
       fold_short_acc,
       reduce_short,
       reduce_short_i,
       reduce_short_acc,
       try_reduce_short,
       try_reduce_short_i,
       try_reduce_short_acc,
       iter_short,
       iter_short_i,
       iter_short_acc,
       for_all,
       for_all_i,
       for_all_acc,
       there_exists,
       there_exists_i,
       there_exists_acc,
       find,
       find_i,
       find_acc,
       try_find,
       try_find_i,
       try_find_acc,
       find_map,
       find_map_i,
       find_map_acc,
       try_find_map,
       try_find_map_i,
       try_find_map_acc,
       scan,
       scan_i,
       scan_acc,
       scan_short,
       scan_short_i,
       scan_short_acc,
       Two,
       function(_Gu_)
        {var _Gv_=Specialize(_Gu_),_Gw_=_Gv_[91];
         return [0,
                 O$2,
                 _Gv_[3],
                 _Gv_[4],
                 _Gv_[6],
                 _Gv_[7],
                 _Gv_[8],
                 _Gv_[9],
                 _Gv_[84],
                 _Gv_[10],
                 _Gv_[13],
                 _Gv_[14],
                 _Gv_[11],
                 _Gv_[12],
                 _Gv_[5],
                 _Gv_[15],
                 _Gv_[17],
                 _Gv_[19],
                 _Gv_[21],
                 _Gv_[20],
                 _Gv_[25],
                 _Gv_[27],
                 _Gv_[26],
                 _Gv_[28],
                 _Gv_[30],
                 _Gv_[29],
                 _Gv_[22],
                 _Gv_[24],
                 _Gv_[23],
                 _Gv_[31],
                 _Gv_[33],
                 _Gv_[32],
                 _Gv_[38],
                 _Gv_[39],
                 _Gv_[37],
                 _Gv_[35],
                 _Gv_[36],
                 _Gv_[34],
                 _Gv_[43],
                 _Gv_[45],
                 _Gv_[44],
                 _Gv_[46],
                 _Gv_[48],
                 _Gv_[47],
                 _Gv_[67],
                 _Gv_[69],
                 _Gv_[68],
                 _Gv_[74],
                 _Gv_[75],
                 _Gv_[73],
                 _Gv_[71],
                 _Gv_[72],
                 _Gv_[70],
                 _Gv_[79],
                 _Gv_[81],
                 _Gv_[80],
                 _Gv_[58],
                 _Gv_[60],
                 _Gv_[59],
                 _Gv_[55],
                 _Gv_[57],
                 _Gv_[56],
                 _Gv_[52],
                 _Gv_[54],
                 _Gv_[53],
                 _Gv_[49],
                 _Gv_[51],
                 _Gv_[50],
                 _Gv_[64],
                 _Gv_[66],
                 _Gv_[65],
                 _Gv_[61],
                 _Gv_[63],
                 _Gv_[62],
                 _Gv_[40],
                 _Gv_[42],
                 _Gv_[41],
                 _Gv_[76],
                 _Gv_[78],
                 _Gv_[77],
                 [0,
                  _Gw_[1],
                  _Gw_[3],
                  _Gw_[2],
                  _Gw_[4],
                  _Gw_[6],
                  _Gw_[5],
                  _Gw_[7],
                  _Gw_[9],
                  _Gw_[8],
                  _Gw_[10],
                  _Gw_[12],
                  _Gw_[11],
                  _Gw_[13],
                  _Gw_[15],
                  _Gw_[14],
                  _Gw_[16],
                  _Gw_[18],
                  _Gw_[17]]]},
       SpecializeEquatable],
     _FK_=[0,O$19,of_contents$2,contents$2,assign$2],
     _FL_=[0,O$18,of_contents$1,contents$1,assign$1],
     _FM_=[0,O$17,of_contents$0,contents$0,assign$0,increment,decrement],
     _FN_=
      [0,
       some_if$5,
       some_if$6,
       is_some$2,
       is_none$2,
       value_def$2,
       value$3,
       or_failure$2,
       map$9,
       iter$7,
       filter$10,
       filter_map$9,
       value_map$2],
     _FO_=
      [0,
       some_if$3,
       some_if$4,
       is_some$1,
       is_none$1,
       value_def$1,
       value$2,
       or_failure$1,
       map$8,
       iter$6,
       filter$9,
       filter_map$8,
       value_map$1],
     _FP_=
      [0,
       some_if$1,
       some_if$2,
       is_some$0,
       is_none$0,
       value_def$0,
       value$1,
       or_failure$0,
       map$7,
       iter$5,
       filter$8,
       filter_map$7,
       value_map$0],
     _FQ_=
      [0,
       equal$14,
       different$12,
       repr$11,
       compare$4,
       less_than$4,
       less_or_equal$4,
       greater_than$4,
       greater_or_equal$4,
       between$4,
       between_or_equal$4,
       min$5,
       max$5,
       min_max$4,
       make$3,
       get_0$2,
       get_1$2,
       get_2$1,
       get_3$0,
       get_4,
       flip$6],
     _FR_=
      [0,
       equal$13,
       different$11,
       repr$10,
       compare$3,
       less_than$3,
       less_or_equal$3,
       greater_than$3,
       greater_or_equal$3,
       between$3,
       between_or_equal$3,
       min$4,
       max$4,
       min_max$3,
       make$2,
       get_0$1,
       get_1$1,
       get_2$0,
       get_3,
       flip$5],
     _FS_=
      [0,
       equal$12,
       different$10,
       repr$9,
       compare$2,
       less_than$2,
       less_or_equal$2,
       greater_than$2,
       greater_or_equal$2,
       between$2,
       between_or_equal$2,
       min$3,
       max$3,
       min_max$2,
       make$1,
       get_0$0,
       get_1$0,
       get_2,
       flip$4],
     _FT_=
      [0,
       equal$11,
       different$9,
       repr$8,
       compare$1,
       less_than$1,
       less_or_equal$1,
       greater_than$1,
       greater_or_equal$1,
       between$1,
       between_or_equal$1,
       min$2,
       max$2,
       min_max$1,
       make$0,
       get_0,
       get_1,
       flip$3],
     _FU_=
      [0,
       of_contents,
       contents,
       assign,
       O$3,
       SpecializeOperators,
       Specialize$1,
       SpecializePredSucc,
       SpecializeRingoidOperators,
       SpecializeRingoid],
     _FV_=[0,is_value,value,map],
     _FW_=
      [0,
       equal$4,
       different$34,
       repr$1,
       compare$0,
       less_than$0,
       less_or_equal$0,
       greater_than$0,
       greater_or_equal$0,
       between$0,
       between_or_equal$0,
       min$1,
       max$1,
       min_max$0,
       none,
       try_of_string$1,
       some_if,
       some_if$0,
       is_some,
       is_none,
       value_def,
       value$0,
       or_failure,
       func,
       iter,
       filter,
       filter_map,
       value_map,
       function(_Gs_)
        {var _Gt_=Specialize$0(_Gs_);
         return [0,
                 _Gt_[6],
                 _Gt_[7],
                 _Gt_[13],
                 _Gt_[14],
                 _Gt_[8],
                 _Gt_[9],
                 _Gt_[10],
                 _Gt_[11],
                 _Gt_[15],
                 _Gt_[16],
                 _Gt_[17],
                 _Gt_[12]]}],
     _FX_=[0,size$2,of_string$10,to_string$12,get$3,set$3,empty$2,make$5],
     _FY_=
      [0,
       of_char,
       of_list$0,
       to_list$0,
       size$0,
       get$1,
       set$1,
       of_bytes,
       to_bytes,
       [0,_ab_,_ac_,_a_,_b_,_d_,_c_,_ad_],
       to_string$5,
       try_of_string$1,
       of_string$3,
       equal$9,
       different$7,
       repr$6,
       compare,
       less_than,
       less_or_equal,
       greater_than,
       greater_or_equal,
       between,
       between_or_equal,
       min,
       max,
       min_max,
       concat$1,
       substring,
       prefix,
       suffix,
       has_prefix,
       try_drop_prefix,
       drop_prefix$0,
       drop_prefix,
       has_suffix,
       try_drop_suffix,
       drop_suffix$0,
       drop_suffix,
       split,
       split$0,
       fold$0,
       filter$1],
     _FZ_=
      [0,
       [0,
        _I_,
        _J_,
        _L_,
        _K_,
        _M_,
        _N_,
        _O_,
        _P_,
        exponentiate$1,
        _a_,
        _b_,
        _d_,
        _c_,
        mod$0],
       to_string$4,
       equal$7,
       different$5,
       try_of_string$2,
       of_string$2,
       repr$4,
       zero$0,
       one$0,
       negate$0,
       add$0,
       substract$0,
       multiply$0,
       divide$0,
       square$0,
       exponentiate$1,
       of_int$0,
       of_float$0,
       compare,
       less_than,
       less_or_equal,
       greater_than,
       greater_or_equal,
       between,
       between_or_equal,
       min,
       max,
       min_max,
       abs$0,
       modulo$0,
       to_int$0,
       to_float$0,
       approx_equal,
       epsilon,
       smallest$0,
       greatest$0,
       infinity,
       negative_infinity,
       not_a_number,
       pi,
       e,
       of_parts,
       to_parts,
       to_fractional_and_integral,
       sqrt,
       exp,
       log,
       log10,
       expm1,
       log1p,
       cos,
       sin,
       tan,
       acos,
       asin,
       atan,
       atan2,
       hypot,
       cosh,
       sinh,
       tanh,
       ceil,
       floor,
       copy_sign,
       [0,repr$5,of_float$1]],
     _F0_=
      [0,
       [0,
        _ff_,
        _fg_,
        _fh_,
        _fi_,
        _fj_,
        _fk_,
        _fl_,
        _fm_,
        _fn_,
        _fa_,
        _fb_,
        _fc_,
        _fd_,
        modulo$3],
       repr$27,
       equal$36,
       different$26,
       try_of_string$5,
       of_string$7,
       repr$27,
       zero$6,
       one$5,
       negate$4,
       add$3,
       substract$3,
       multiply$4,
       divide$4,
       square$3,
       exponentiate$3,
       of_int$4,
       of_float$4,
       compare$15,
       less_than$12,
       less_or_equal$12,
       greater_than$12,
       greater_or_equal$12,
       between$12,
       between_or_equal$12,
       min$13,
       max$13,
       min_max$12,
       abs$6,
       modulo$3,
       to_int$3,
       to_float$3,
       succ$5,
       pred$5],
     _F1_=
      [0,
       O$16,
       _mY_,
       _mZ_,
       _m0_,
       try_of_string$6,
       _m1_,
       _m2_,
       zero$8,
       one$7,
       _m3_,
       add$4,
       substract$4,
       _m4_,
       _m5_,
       square$4,
       _m6_,
       of_int$6,
       of_float$5,
       compare$17,
       less_than$13,
       less_or_equal$13,
       greater_than$13,
       greater_or_equal$13,
       between$13,
       between_or_equal$13,
       min$14,
       max$14,
       min_max$13,
       abs$8,
       modulo$4,
       to_int$5,
       to_float$4,
       _m7_,
       pred$7,
       smallest$3,
       greatest$3],
     _F2_=
      [0,
       O$15,
       _eo_,
       _ep_,
       _eq_,
       try_of_string$4,
       _er_,
       _es_,
       zero$5,
       one$4,
       _et_,
       add$2,
       substract$2,
       _eu_,
       _ev_,
       square$2,
       _ew_,
       of_int$3,
       of_float$3,
       compare$14,
       less_than$11,
       less_or_equal$11,
       greater_than$11,
       greater_or_equal$11,
       between$11,
       between_or_equal$11,
       min$12,
       max$12,
       min_max$11,
       abs$5,
       modulo$2,
       to_int$2,
       to_float$2,
       _ex_,
       pred$4,
       smallest$2,
       greatest$2],
     _F3_=
      [0,
       O$14,
       _eb_,
       _ec_,
       _ed_,
       try_of_string$3,
       _ee_,
       _ef_,
       zero$3,
       one$2,
       _eg_,
       add$1,
       substract$1,
       _eh_,
       _ei_,
       square$1,
       _ej_,
       of_int$2,
       of_float$2,
       compare$12,
       less_than$10,
       less_or_equal$10,
       greater_than$10,
       greater_or_equal$10,
       between$10,
       between_or_equal$10,
       min$11,
       max$11,
       min_max$10,
       abs$3,
       modulo$1,
       to_int$1,
       to_float$1,
       _ek_,
       pred$2,
       smallest$1,
       greatest$1],
     _F4_=
      [0,
       [0,_e_,_f_,_h_,_g_,_i_,_j_,_k_,_l_,exponentiate$5,_a_,_b_,_d_,_c_,mod],
       to_string$1,
       equal$2,
       different$2,
       try_of_string,
       of_string$0,
       repr,
       zero,
       one,
       negate,
       add,
       substract,
       multiply,
       divide,
       square,
       exponentiate$5,
       of_int,
       of_float,
       compare,
       less_than,
       less_or_equal,
       greater_than,
       greater_or_equal,
       between,
       between_or_equal,
       min,
       max,
       min_max,
       abs,
       modulo,
       to_int,
       to_float,
       succ,
       pred,
       smallest,
       greatest,
       Bitwise],
     _F5_=
      [0,
       compare,
       less_than,
       less_or_equal,
       greater_than,
       greater_or_equal,
       between,
       between_or_equal,
       min,
       max,
       min_max,
       [0,_a_,_b_,_d_,_c_],
       of_int$5,
       to_int$4,
       to_string$14,
       repeat];
    function _F6_(_Gq_,_Gp_){var _Gr_=_Gq_ || _Gp_;return _Gr_}
    var
     _F7_=
      [0,
       [0,
        _n_,
        _o_,
        _a_,
        _b_,
        _d_,
        _c_,
        not,
        function(_Gn_,_Gm_){var _Go_=_Gn_?_Gm_:_Gn_;return _Go_},
        _F6_,
        xor],
       equal$3,
       different$3,
       repr$0,
       compare,
       less_than,
       less_or_equal,
       greater_than,
       greater_or_equal,
       between,
       between_or_equal,
       min,
       max,
       min_max,
       to_string$2,
       try_of_string$0,
       of_string$1,
       not$0,
       and,
       or,
       xor],
     _F8_=[0,of_int$1,exit,at_exit],
     _F9_=
      [0,
       equal$1,
       different$1,
       O$0,
       to_string$0,
       to_string$0,
       register_printer,
       record_backtraces,
       recording_backtraces,
       most_recent_backtrace,
       MatchFailure,
       AssertFailure,
       InvalidArgument,
       Failure,
       NotFound,
       OutOfMemory,
       StackOverflow,
       SysError,
       EndOfFile,
       DivisionByZero,
       SysBlockedIO,
       UndefinedRecursiveModule,
       Exit,
       raise,
       raise_without_backtrace,
       invalid_argument,
       failure,
       failure_if,
       failure_unless,
       name,
       or_none],
     _F__=
      [0,
       to_string$3,
       to_string$3,
       current,
       [0,
        [0,_F_,_G_,_a_,_b_,_d_,_c_],
        equal$6,
        different$4,
        repr$3,
        compare,
        less_than,
        less_or_equal,
        greater_than,
        greater_or_equal,
        between,
        between_or_equal,
        min,
        max,
        min_max],
       Frame,
       frames],
     _F$_=
      [0,[0,Operators],[0,Operators$0],[0,Operators$1],[0,Operators$2],[0]],
     _Ga_=[0],
     _Gb_=[0],
     _Gc_=
      [0,
       [0],
       [0],
       [0],
       [0,[0],[0]],
       [0,[0],[0]],
       [0,Basic,[0]],
       [0],
       [0,function(_Gl_){return [0]},_Gb_,_Ga_],
       Foldable,
       Scanable],
     _Gd_=
      [0,
       [0,
        compare,
        less_than,
        less_or_equal,
        greater_than,
        greater_or_equal,
        between,
        between_or_equal,
        min,
        max,
        min_max,
        [0,_a_,_b_,_d_,_c_]]];
    function _Ge_(_Gj_,_Gi_){var _Gk_=_Gj_ || _Gi_;return _Gk_}
    var
     General=
      [0,
       Reset,
       [0,
        raise$0,
        raise_notrace,
        invalid_arg,
        failwith,
        compare$5,
        min$0,
        max$0,
        _aD_,
        _aE_,
        _aF_,
        or$0,
        succ$0,
        pred$0,
        abs$1,
        max_int,
        min_int,
        land,
        lor,
        lxor,
        lnot,
        lsl,
        lsr,
        asr,
        sqrt$0,
        exp$0,
        log$0,
        log10$0,
        expm1$0,
        log1p$0,
        cos$0,
        sin$0,
        tan$0,
        acos$0,
        asin$0,
        atan$0,
        atan2$0,
        hypot$0,
        cosh$0,
        sinh$0,
        tanh$0,
        ceil$0,
        floor$0,
        abs_float,
        copysign,
        mod_float,
        frexp,
        ldexp,
        modf,
        float$0,
        float_of_int,
        truncate,
        int_of_float,
        infinity$0,
        neg_infinity,
        nan,
        max_float,
        min_float,
        epsilon_float,
        classify_float,
        int_of_char,
        char_of_int,
        string_of_bool,
        bool_of_string,
        bool_of_string_opt,
        string_of_int,
        int_of_string,
        int_of_string_opt,
        string_of_float,
        float_of_string,
        float_of_string_opt,
        fst,
        snd,
        stdin,
        stdout,
        stderr,
        print_char,
        print_string,
        print_bytes,
        print_int,
        print_float,
        print_endline,
        print_newline,
        prerr_char,
        prerr_string,
        prerr_bytes,
        prerr_int,
        prerr_float,
        prerr_endline,
        prerr_newline,
        read_line,
        read_int,
        read_int_opt,
        read_float,
        read_float_opt,
        open_out,
        open_out_bin,
        open_out_gen,
        flush,
        flush_all,
        output_char,
        output_string,
        output_bytes,
        output,
        output_substring,
        output_byte,
        output_binary_int,
        output_value,
        seek_out,
        pos_out,
        out_channel_length,
        close_out,
        close_out_noerr,
        set_binary_mode_out,
        open_in,
        open_in_bin,
        open_in_gen,
        input_char,
        input_line,
        input,
        really_input,
        really_input_string,
        input_byte,
        input_binary_int,
        input_value,
        seek_in,
        pos_in,
        in_channel_length,
        close_in,
        close_in_noerr,
        set_binary_mode_in,
        LargeFile$0,
        incr,
        decr,
        string_of_format,
        format_of_string,
        _aG_,
        exit$0,
        at_exit$0,
        valid_float_lexem,
        unsafe_really_input,
        do_at_exit,
        OCamlStandard$0,
        Pervasives$0,
        Arg$0,
        Array$0,
        ArrayLabels$0,
        Bigarray$0,
        Buffer$0,
        Bytes$0,
        BytesLabels$0,
        Callback$0,
        Char$0,
        Complex$0,
        Digest$0,
        Ephemeron$0,
        Filename$0,
        Float$0,
        Format$0,
        Gc$0,
        Genlex$0,
        Hashtbl$0,
        Int32$0,
        Int64$0,
        Lazy$0,
        Lexing$0,
        List$0,
        ListLabels$0,
        Map$0,
        Marshal$0,
        MoreLabels$0,
        Nativeint$0,
        Oo$0,
        Parsing$0,
        Printexc$0,
        Printf$0,
        Queue$0,
        Random$0,
        Scanf$0,
        Seq$0,
        Set$0,
        Sort$0,
        Spacetime$0,
        Stack$0,
        StdLabels$0,
        Stream$0,
        String$0,
        StringLabels$0,
        Sys$0,
        Uchar$0,
        Weak$0,
        Num$0,
        Big_int$0,
        Arith_status$0,
        not,
        function(_Gg_,_Gf_){var _Gh_=_Gg_?_Gf_:_Gg_;return _Gh_},
        _Ge_,
        _g_,
        _h_,
        _i_,
        _j_,
        _k_,
        _l_,
        mod,
        _R_,
        _S_,
        _T_,
        _U_,
        _V_,
        _W_,
        _X_,
        _at_,
        _au_,
        _av_,
        ref$0,
        _ay_,
        _ax_,
        _aA_,
        _aB_,
        _a_,
        _b_,
        _c_,
        _d_,
        ignore,
        identity$0,
        _aw_,
        _ad_],
       Shorten,
       _Gd_,
       Equate,
       _Gc_,
       _F$_,
       _F__,
       _F9_,
       _F8_,
       Function1,
       Function2,
       Function3,
       Function4,
       Function5,
       Unit,
       _F7_,
       _F5_,
       _F4_,
       _F3_,
       _F2_,
       _F1_,
       _F0_,
       _FZ_,
       _FY_,
       _FX_,
       _FW_,
       _FV_,
       _FU_,
       _FT_,
       _FS_,
       _FR_,
       _FQ_,
       _FP_,
       _FO_,
       _FN_,
       _FM_,
       _FL_,
       _FK_,
       _FJ_,
       _FI_,
       _FH_,
       _FG_,
       _FF_,
       _FE_,
       _FD_,
       _FC_,
       _FB_,
       _FA_,
       _Fz_,
       _Fy_,
       _Fx_,
       _Fw_,
       _Fv_,
       _Fu_,
       _Ft_,
       _Fs_,
       _Fr_,
       _Fq_,
       _Fp_,
       _Fo_,
       _Fn_,
       _Fm_,
       _Fl_,
       _Fk_,
       _Fj_,
       _Fi_,
       _Fh_,
       _Ff_,
       Tests];
    runtime.caml_register_global(1578,General,"General");
    return}
  (function(){return this}()));


//# 1 "../src/JsOfOCairo.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_float_compare=runtime.caml_float_compare,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_compare=runtime.caml_int_compare,
     caml_js_to_string=runtime.caml_js_to_string,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_update_dummy=runtime.caml_update_dummy,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    function caml_call9(f,a0,a1,a2,a3,a4,a5,a6,a7,a8)
     {return f.length == 9
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8])}
    function caml_call10(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
     {return f.length == 10
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_weight=caml_new_string("weight"),
     cst_slant=caml_new_string("slant"),
     cst_ofs=caml_new_string("ofs"),
     cst_alpha=caml_new_string("alpha"),
     partial=[0,2],
     partial$0=[0,2],
     partial$1=[12,32,[8,0,0,[0,2],0]],
     partial$2=[0,2],
     partial$3=[12,32,[8,0,0,[0,2],0]],
     partial$4=[0,2],
     cst$3=caml_new_string(""),
     cst$2=caml_new_string(""),
     cst_Bold=caml_new_string("Bold"),
     cst_Normal=caml_new_string("Normal"),
     cst_Upright=caml_new_string("Upright"),
     cst_Italic=caml_new_string("Italic"),
     cst_Oblique=caml_new_string("Oblique"),
     partial$5=[11,caml_new_string("; y_advance="),[8,0,0,[0,2],[12,125,0]]],
     partial$6=[0,2],
     partial$7=[12,125,0],
     partial$8=[0,2],
     partial$9=[12,125,0],
     partial$10=[0,2],
     cst$1=caml_new_string("; "),
     partial$11=[11,caml_new_string("})"),0],
     partial$12=
      [11,
       caml_new_string("; r1"),
       [8,
        0,
        0,
        [0,2],
        [11,
         caml_new_string("; stop_points="),
         [2,0,[11,caml_new_string("})"),0]]]]],
     partial$13=[0,2],
     cst_CLEAR=caml_new_string("CLEAR"),
     cst_SOURCE=caml_new_string("SOURCE"),
     cst_OVER=caml_new_string("OVER"),
     cst_IN=caml_new_string("IN"),
     cst_OUT=caml_new_string("OUT"),
     cst_ATOP=caml_new_string("ATOP"),
     cst_DEST=caml_new_string("DEST"),
     cst_DEST_OVER=caml_new_string("DEST_OVER"),
     cst_DEST_IN=caml_new_string("DEST_IN"),
     cst_DEST_OUT=caml_new_string("DEST_OUT"),
     cst_DEST_ATOP=caml_new_string("DEST_ATOP"),
     cst_XOR=caml_new_string("XOR"),
     cst_ADD=caml_new_string("ADD"),
     cst_SATURATE=caml_new_string("SATURATE"),
     cst_JOIN_MITER=caml_new_string("JOIN_MITER"),
     cst_JOIN_ROUND=caml_new_string("JOIN_ROUND"),
     cst_JOIN_BEVEL=caml_new_string("JOIN_BEVEL"),
     cst_BUTT=caml_new_string("BUTT"),
     cst_ROUND=caml_new_string("ROUND"),
     cst_SQUARE=caml_new_string("SQUARE"),
     cst_EVEN_ODD=caml_new_string("EVEN_ODD"),
     cst_WINDING=caml_new_string("WINDING"),
     cst$0=caml_new_string("; "),
     partial$14=[11,caml_new_string("; y0="),[8,0,0,[0,2],[12,125,0]]],
     partial$15=[0,2],
     cst=caml_new_string(""),
     cst_INVALID_RESTORE=caml_new_string("INVALID_RESTORE"),
     cst_INVALID_POP_GROUP=caml_new_string("INVALID_POP_GROUP"),
     cst_NO_CURRENT_POINT=caml_new_string("NO_CURRENT_POINT"),
     cst_INVALID_MATRIX=caml_new_string("INVALID_MATRIX"),
     cst_INVALID_STATUS=caml_new_string("INVALID_STATUS"),
     cst_NULL_POINTER=caml_new_string("NULL_POINTER"),
     cst_INVALID_STRING=caml_new_string("INVALID_STRING"),
     cst_INVALID_PATH_DATA=caml_new_string("INVALID_PATH_DATA"),
     cst_READ_ERROR=caml_new_string("READ_ERROR"),
     cst_WRITE_ERROR=caml_new_string("WRITE_ERROR"),
     cst_SURFACE_FINISHED=caml_new_string("SURFACE_FINISHED"),
     cst_SURFACE_TYPE_MISMATCH=caml_new_string("SURFACE_TYPE_MISMATCH"),
     cst_PATTERN_TYPE_MISMATCH=caml_new_string("PATTERN_TYPE_MISMATCH"),
     cst_INVALID_CONTENT=caml_new_string("INVALID_CONTENT"),
     cst_INVALID_FORMAT=caml_new_string("INVALID_FORMAT"),
     cst_INVALID_VISUAL=caml_new_string("INVALID_VISUAL"),
     cst_FILE_NOT_FOUND=caml_new_string("FILE_NOT_FOUND"),
     cst_INVALID_DASH=caml_new_string("INVALID_DASH"),
     cst_INVALID_DSC_COMMENT=caml_new_string("INVALID_DSC_COMMENT"),
     cst_INVALID_INDEX=caml_new_string("INVALID_INDEX"),
     cst_CLIP_NOT_REPRESENTABLE=caml_new_string("CLIP_NOT_REPRESENTABLE"),
     cst_TEMP_FILE_ERROR=caml_new_string("TEMP_FILE_ERROR"),
     cst_INVALID_STRIDE=caml_new_string("INVALID_STRIDE"),
     cst_FONT_TYPE_MISMATCH=caml_new_string("FONT_TYPE_MISMATCH"),
     cst_USER_FONT_IMMUTABLE=caml_new_string("USER_FONT_IMMUTABLE"),
     cst_USER_FONT_ERROR=caml_new_string("USER_FONT_ERROR"),
     cst_NEGATIVE_COUNT=caml_new_string("NEGATIVE_COUNT"),
     cst_INVALID_CLUSTERS=caml_new_string("INVALID_CLUSTERS"),
     cst_INVALID_SLANT=caml_new_string("INVALID_SLANT"),
     cst_INVALID_WEIGHT=caml_new_string("INVALID_WEIGHT"),
     cst_INVALID_SIZE=caml_new_string("INVALID_SIZE"),
     cst_USER_FONT_NOT_IMPLEMENTED=
      caml_new_string("USER_FONT_NOT_IMPLEMENTED"),
     cst_DEVICE_TYPE_MISMATCH=caml_new_string("DEVICE_TYPE_MISMATCH"),
     cst_DEVICE_ERROR=caml_new_string("DEVICE_ERROR"),
     cst_INVALID_MESH_CONSTRUCTION=
      caml_new_string("INVALID_MESH_CONSTRUCTION"),
     cst_DEVICE_FINISHED=caml_new_string("DEVICE_FINISHED"),
     cst_JBIG2_GLOBAL_MISSING=caml_new_string("JBIG2_GLOBAL_MISSING"),
     cst_cairo_restore_without_matching_cairo_save=
      caml_new_string("cairo_restore() without matching cairo_save()"),
     cst_no_saved_group_to_pop_i_e_cairo_pop_group_without_matching_cairo_push_group=
      caml_new_string
       ("no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group()"),
     cst_no_current_point_defined=caml_new_string("no current point defined"),
     cst_invalid_matrix_not_invertible=
      caml_new_string("invalid matrix (not invertible)"),
     cst_invalid_value_for_an_input_cairo_status_t=
      caml_new_string("invalid value for an input cairo_status_t"),
     cst_NULL_pointer=caml_new_string("NULL pointer"),
     cst_input_string_not_valid_UTF_8=
      caml_new_string("input string not valid UTF-8"),
     cst_input_path_data_not_valid=
      caml_new_string("input path data not valid"),
     cst_error_while_reading_from_input_stream=
      caml_new_string("error while reading from input stream"),
     cst_error_while_writing_to_output_stream=
      caml_new_string("error while writing to output stream"),
     cst_the_target_surface_has_been_finished=
      caml_new_string("the target surface has been finished"),
     cst_the_surface_type_is_not_appropriate_for_the_operation=
      caml_new_string("the surface type is not appropriate for the operation"),
     cst_the_pattern_type_is_not_appropriate_for_the_operation=
      caml_new_string("the pattern type is not appropriate for the operation"),
     cst_invalid_value_for_an_input_cairo_content_t=
      caml_new_string("invalid value for an input cairo_content_t"),
     cst_invalid_value_for_an_input_cairo_format_t=
      caml_new_string("invalid value for an input cairo_format_t"),
     cst_invalid_value_for_an_input_Visual=
      caml_new_string("invalid value for an input Visual*"),
     cst_file_not_found=caml_new_string("file not found"),
     cst_invalid_value_for_a_dash_setting=
      caml_new_string("invalid value for a dash setting"),
     cst_invalid_value_for_a_DSC_comment=
      caml_new_string("invalid value for a DSC comment"),
     cst_invalid_index_passed_to_getter=
      caml_new_string("invalid index passed to getter"),
     cst_clip_region_not_representable_in_desired_format=
      caml_new_string("clip region not representable in desired format"),
     cst_error_creating_or_writing_to_a_temporary_file=
      caml_new_string("error creating or writing to a temporary file"),
     cst_invalid_value_for_stride=caml_new_string("invalid value for stride"),
     cst_the_font_type_is_not_appropriate_for_the_operation=
      caml_new_string("the font type is not appropriate for the operation"),
     cst_the_user_font_is_immutable=
      caml_new_string("the user-font is immutable"),
     cst_error_occurred_in_a_user_font_callback_function=
      caml_new_string("error occurred in a user-font callback function"),
     cst_negative_number_used_where_it_is_not_allowed=
      caml_new_string("negative number used where it is not allowed"),
     cst_input_clusters_do_not_represent_the_accompanying_text_and_glyph_arrays=
      caml_new_string
       ("input clusters do not represent the accompanying text and glyph arrays"),
     cst_invalid_value_for_an_input_cairo_font_slant_t=
      caml_new_string("invalid value for an input cairo_font_slant_t"),
     cst_invalid_value_for_an_input_cairo_font_weight_t=
      caml_new_string("invalid value for an input cairo_font_weight_t"),
     cst_invalid_value_typically_too_big_for_the_size_of_the_input_surface_pattern_etc=
      caml_new_string
       ("invalid value (typically too big) for the size of the input (surface, pattern, etc.)"),
     cst_user_font_method_not_implemented=
      caml_new_string("user-font method not implemented"),
     cst_the_device_type_is_not_appropriate_for_the_operation=
      caml_new_string("the device type is not appropriate for the operation"),
     cst_an_operation_to_the_device_caused_an_unspecified_error=
      caml_new_string
       ("an operation to the device caused an unspecified error"),
     cst_invalid_operation_during_mesh_pattern_construction=
      caml_new_string("invalid operation during mesh pattern construction"),
     cst_the_target_device_has_been_finished=
      caml_new_string("the target device has been finished"),
     cst_CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID_used_but_no_CAIRO_MIME_TYPE_JBIG2_GLOBAL_data_provided=
      caml_new_string
       ("CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID used but no CAIRO_MIME_TYPE_JBIG2_GLOBAL data provided"),
     point_definitions=
      caml_new_string
       ("\x84\x95\xa6\xbe\0\0\r\xe7\0\0\x01\xcd\0\0\x071\0\0\x071\b\0\x070\0\xa0\x01=\xc2e\xa0\x01=\xcf@\xa0\x01>\x16A\xa0\x01>\x83B\xa0\x01>\xb6C\xa0\x01>\xeeD\xa0\x01?0E\xa0\x01?SF\xa0\x01?\x88G\xa0\x01?\xbdH\xa0\x01?\xf7I\xa0\x01@1J\xa0\x01@pK\xa0\x01@\xc5L\xa0\x01A\x1aM\xa0\x01A^N\xa0\x01A\xa0O\xa0\x01A\xdbP\xa0\x01B\x02Q\xa0\x01B9R\xa0\x01BvS\xa0\x01B\xacT\xa0\x01B\xfcU\xa0\x01CCV\xa0\x01CtW\xa0\x01C\xc3X\xa0\x01C\xfbY\xa0\x01DDZ\xa0\x01D\x89[\xa0\x01D\xea\\\xa0\x01E/]\xa0\x01Ev^\xa0\x01E\xe1_\xa0\x01F%`\xa0\x01Fxa\xa0\x01F\xc5b\xa0\x01G\x1bc\xa0\x01GXd\xa0\x01G\xdch\xa0\x01G\xe9f\xa0\x01H\x12g\xa0\x01Pbi\xa0\x01P\xadj\xa0\x01P\xf2k\xa0\x01Q:l\xa0\x01Q\xedx\xa0\x01Q\xf5v\xa0\x01R\x11w\xa0\x01R t\xa0\x01RBu\xa0\x01RKm\xa0\x01R`n\xa0\x01Rxo\xa0\x01R\x90p\xa0\x01R\xa5q\xa0\x01R\xcer\xa0\x01R\xf1s\xa0\x01Sj\0@\xa0\x01Ssy\xa0\x01S\x97z\xa0\x01S\xbb{\xa0\x01S\xdf|\xa0\x01T\x03}\xa0\x01T-~\xa0\x01TQ\x7f\xa0\x01T\xa4\0A\xa0\x01U\x1e\0B\xa0\x01Uw\0H\xa0\x01U\x87\0G\xa0\x01U\x97\0F\xa0\x01U\xa7\0E\xa0\x01U\xb7\0D\xa0\x01U\xc7\0C\xa0\x01U\xeb\0I\xa0\x01V,\0J\xa0\x01Vp\0K\xa0\x01V\xad\0L\xa0\x01ZV\0O\xa0\x01Z\x8b\0M\xa0\x01Z\xb4\0N\xa0\x01Z\xf1\0P\xa0\x01[\x04\0Q\xa0\x01[3\0Z\xa0\x01[A\0X\xa0\x01[u\0Y\xa0\x01[\x83\0V\xa0\x01[\x96\0T\xa0\x01[\xb0\0U\xa0\x01[\xf1\0R\xa0\x01\\\x10\0S\xa0\x01\\*\0W\xa0\x01\\M\0\\\xa0\x01\\|\0[\xa0\x01\\\xa3\0_\xa0\x01\\\xc1\0]\xa0\x01\\\xd8\0^\xa0\x01]o\0a\xa0\x01]\xa0\0`\xa0\x01`\xda\0b\xa0\x01a\x10\0c\xa0\x01aC\0h\xa0\x01a_\0d\xa0\x01a{\0e\xa0\x01a\x94\0f\xa0\x01a\xad\0g\xa0\x01b\f\0i\xa0\x01b\x83\0n\xa0\x01b\x9f\0j\xa0\x01b\xcc\0k\xa0\x01b\xdb\0l\xa0\x01b\xf4\0m\xa0\x01c[\0o\xa0\x01c\xdc\0t\xa0\x01c\xf8\0p\xa0\x01d'\0q\xa0\x01d@\0r\xa0\x01dO\0s\xa0\x01d\xac\0|\xa0\x01d\xbe\0{\xa0\x01d\xcf\0y\xa0\x01d\xe8\0z\xa0\x01e\x04\0u\xa0\x01e\x99\0v\xa0\x01f.\0w\xa0\x01fX\0x\xa0\x01f\x9e\0}\xa0\x01f\xf2\x01\0\x82\xa0\x01g\x0e\0~\xa0\x01g0\0\x7f\xa0\x01gz\x01\0\x80\xa0\x01g\x89\x01\0\x81\xa0\x01g\xeb\x01\0\x87\xa0\x01h\x07\x01\0\x83\xa0\x01h)\x01\0\x84\xa0\x01hy\x01\0\x85\xa0\x01h\x88\x01\0\x86\xa0\x01m]\x01\0\x88\xa0\x01m\xbd\x01\0\x89\xa0\x01n:\x01\0\x8b\xa0\x01nZ\x01\0\x8a\xa0\x01n\xbb\x01\0\x8c\xa0\x01o\x06\x01\0\x8d\xa0\x01ot\x01\0\x8e\xa0\x01o\xb5\x01\0\x8f\xa0\x01o\xf8\x01\0\x92\xa0\x01p\x1a\x01\0\x90\xa0\x01p/\x01\0\x91\xa0\x01p\xb5\x01\0\x95\xa0\x01p\xdf\x01\0\x93\xa0\x01q6\x01\0\x94\xa0\x01r\xf7\x01\0\x96\xa0\x01u\x1a\x01\0\x97\xa0\x01uM\x01\0\x9a\xa0\x01uY\x01\0\x98\xa0\x01ur\x01\0\x99\xa0\x01u\xbf\x01\0\x9b\xa0\x01v\x0e\x01\0\xa0\xa0\x01v!\x01\0\x9e\xa0\x01v\xd2\x01\0\x9c\xa0\x01w\x01\x01\0\x9d\xa0\x01w \x01\0\x9f\xa0\x01wi\x01\0\xa2\xa0\x01w\x88\x01\0\xa1\xa0\x01w\xc1\x01\0\xa3\xa0\x01w\xfc\x01\0\xa4\xa0\x01xd\x01\0\xa5\xa0\x01x\xa7\x01\0\xa6\xa0\x01y\x04\x01\0\xa7\xa0\x01yd\x01\0\xa8\xa0\x01y\xc6\x01\0\xaa\xa0\x01y\xe5\x01\0\xa9\xa0\x01z>\x01\0\xab\xa0\x01z\xc1\x01\0\xac\xa0\x01{@\x01\0\xad\xa0\x01{\xad\x01\0\xae\xa0\x01|\"\x01\0\xc5\xa0\x01|7\x01\0\xc3\xa0\x01|]\x01\0\xc4\xa0\x01|\x7f\x01\0\xc1\xa0\x01|\x94\x01\0\xbf\xa0\x01|\xd9\x01\0\xbd\xa0\x01}\f\x01\0\xbe\xa0\x01}1\x01\0\xc0\xa0\x01}O\x01\0\xc2\xa0\x01}n\x01\0\xb7\xa0\x01}\x82\x01\0\xb8\xa0\x01}\xb6\x01\0\xb9\xa0\x01~\x0e\x01\0\xba\xa0\x01~[\x01\0\xbb\xa0\x01~\x86\x01\0\xb5\xa0\x01~\xa7\x01\0\xb6\xa0\x01~\xea\x01\0\xbc\xa0\x01\x7f\x0b\x01\0\xb1\xa0\x01\x7fA\x01\0\xb2\xa0\x01\x7f\x84\x01\0\xb3\xa0\x01\x7f\xd3\x01\0\xb4\xa0\x01\x7f\xfe\x01\0\xaf\xa0\x02\0\0\x80\x1f\x01\0\xb0\xa0\x02\0\0\x80\x81\x01\0\xc6\xa0\x02\0\0\x80\xe5\x01\0\xc7\xa0\x02\0\0\x81J\x01\0\xc8\xa0\x02\0\0\x81\xb4\x01\0\xc9\xa0\x02\0\0\x82,\x01\0\xca\xa0\x02\0\0\x82\xa7\x01\0\xcb\xa0\x02\0\0\x83\"\x01\0\xcc\xa0\x02\0\0\x83\x84\x01\0\xcd\xa0\x02\0\0\x84>\x01\0\xce\xa0\x02\0\0\x85\t\x01\0\xd3\xa0\x02\0\0\x85\x1e\x01\0\xd1\xa0\x02\0\0\x85F\x01\0\xd2\xa0\x02\0\0\x85\x89\x01\0\xcf\xa0\x02\0\0\x85\xa4\x01\0\xd0\xa0\x02\0\0\x85\xd9\x01\0\xd4\xa0\x02\0\0\x86,\x01\0\xd5\xa0\x02\0\0\x86\x88\x01\0\xd6\xa0\x02\0\0\x86\xa7\x01\0\xd7\xa0\x02\0\0\x86\xf8\x01\0\xd8\xa0\x02\0\0\x87\x15\x01\0\xd9\xa0\x02\0\0\x87f\x01\0\xda\xa0\x02\0\0\x87\x83\x01\0\xdb\xa0\x02\0\0\x87\xd5\x01\0\xdc\xa0\x02\0\0\x88\b\x01\0\xde\xa0\x02\0\0\x88'\x01\0\xdd\xa0\x02\0\0\x88`\x01\0\xdf\xa0\x02\0\0\x88\x99\x01\0\xe2\xa0\x02\0\0\x88\xaa\x01\0\xe1\xa0\x02\0\0\x88\xc9\x01\0\xe0\xa0\x02\0\0\x88\xfd\x01\0\xe5\xa0\x02\0\0\x89\t\x01\0\xe3\xa0\x02\0\0\x89\x1e\x01\0\xe4\xa0\x02\0\0\x89e\x01\0\xe7\xa0\x02\0\0\x89\x84\x01\0\xe6\xa0\x02\0\0\x89\xbb\x01\0\xe8\xa0\x02\0\0\x8a\0\x01\0\xea\xa0\x02\0\0\x8a\x1f\x01\0\xe9\xa0\x02\0\0\x8aT\x01\0\xeb\xa0\x02\0\0\x8a\x9a\x01\0\xed\xa0\x02\0\0\x8a\xb9\x01\0\xec\xa0\x02\0\0\x8a\xf0\x01\0\xee\xa0\x02\0\0\x8b;\x01\0\xf0\xa0\x02\0\0\x8bZ\x01\0\xef\xa0\x02\0\0\x8b\x95\x01\0\xf1\xa0\x02\0\0\x8b\xdc\x01\0\xf3\xa0\x02\0\0\x8b\xfb\x01\0\xf2\xa0\x02\0\0\x8c0\x01\0\xf4\xa0\x02\0\0\x8cr\x01\0\xf8\xa0\x02\0\0\x8c\x7f\x01\0\xf6\xa0\x02\0\0\x8c\x8f\x01\0\xf7\xa0\x02\0\0\x8c\xae\x01\0\xf5\xa0\x02\0\0\x8c\xdf\x01\0\xf9\xa0\x02\0\0\x8d$\x01\0\xfd\xa0\x02\0\0\x8d1\x01\0\xfb\xa0\x02\0\0\x8dT\x01\0\xfc\xa0\x02\0\0\x8ds\x01\0\xfa\xa0\x02\0\0\x8d\xb1\x01\x01\x01\xa0\x02\0\0\x8d\xbe\x01\0\xff\xa0\x02\0\0\x8d\xe4\x01\x01\0\xa0\x02\0\0\x8e\x03\x01\0\xfe\xa0\x02\0\0\x8e=\x01\x01\x05\xa0\x02\0\0\x8eO\x01\x01\x04\xa0\x02\0\0\x8ed\x01\x01\x03\xa0\x02\0\0\x8e\x83\x01\x01\x02\xa0\x02\0\0\x8e\xde\x01\x01\x07\xa0\x02\0\0\x8e\xfd\x01\x01\x06\xa0\x02\0\0\x8f@\x01\x01\x0b\xa0\x02\0\0\x8fS\x01\x01\b\xa0\x02\0\0\x8f\x88\x01\x01\t\xa0\x02\0\0\x8f\xd8\x01\x01\n\xa0\x02\0\0\x90=\x01\x01\x0e\xa0\x02\0\0\x90J\x01\x01\f\xa0\x02\0\0\x90k\x01\x01\r\xa0\x02\0\0\x91\x0e\x01\x01\x12\xa0\x02\0\0\x91 \x01\x01\x0f\xa0\x02\0\0\x91|\x01\x01\x10\xa0\x02\0\0\x91\xa1\x01\x01\x11\xa0\x02\0\0\x9a<\x01\x01\x13\xa0\x02\0\0\x9a\x88\x01\x01\x14\xa0\x02\0\0\x9a\xa4\x01\x01\x15\xa0\x02\0\0\x9a\xed\x01\x01\x16\xa0\x02\0\0\x9bf\x01\x01\x17\xa0\x02\0\0\x9b\xa7\x01\x01\x1c\xa0\x02\0\0\x9b\xb7\x01\x01\x18\xa0\x02\0\0\x9b\xce\x01\x01\x19\xa0\x02\0\0\x9b\xfb\x01\x01\x1a\xa0\x02\0\0\x9c\x1c\x01\x01\x1b\xa0\x02\0\0\x9cZ\x01\x01\x1d\xa0\x02\0\0\x9c\x9b\x01\x01 \xa0\x02\0\0\x9c\xac\x01\x01\x1e\xa0\x02\0\0\x9c\xc9\x01\x01\x1f\xa0\x02\0\0\x9c\xf4\x01\x01$\xa0\x02\0\0\x9d\x05\x01\x01!\xa0\x02\0\0\x9d\x1c\x01\x01\"\xa0\x02\0\0\x9d5\x01\x01#\xa0\x02\0\0\x9d]\x01\x01(\xa0\x02\0\0\x9dn\x01\x01%\xa0\x02\0\0\x9d\x91\x01\x01&\xa0\x02\0\0\x9d\xb4\x01\x01'\xa0\x02\0\0\x9d\xe3\x01\x017\xa0\x02\0\0\x9d\xf4\x01\x01)\xa0\x02\0\0\x9e\r\x01\x01*\xa0\x02\0\0\x9e(\x01\x01+\xa0\x02\0\0\x9e?\x01\x01,\xa0\x02\0\0\x9eR\x01\x01-\xa0\x02\0\0\x9eg\x01\x01.\xa0\x02\0\0\x9e~\x01\x01/\xa0\x02\0\0\x9e\x95\x01\x010\xa0\x02\0\0\x9e\xb6\x01\x011\xa0\x02\0\0\x9e\xd3\x01\x012\xa0\x02\0\0\x9e\xf2\x01\x013\xa0\x02\0\0\x9f\x13\x01\x014\xa0\x02\0\0\x9f(\x01\x015\xa0\x02\0\0\x9f=\x01\x016\xa0\x02\0\0\x9fm\x01\x01M\xa0\x02\0\0\x9f\x93\x01\x01?\xa0\x02\0\0\x9f\xae\x01\x01>\xa0\x02\0\0\x9f\xf5\x01\x01K\xa0\x02\0\0\xa0\x01\x01\x01I\xa0\x02\0\0\xa0(\x01\x01J\xa0\x02\0\0\xa0:\x01\x01G\xa0\x02\0\0\xa0k\x01\x01H\xa0\x02\0\0\xa0\x91\x01\x01E\xa0\x02\0\0\xa0\xdc\x01\x01F\xa0\x02\0\0\xa0\xf3\x01\x01@\xa0\x02\0\0\xa1\f\x01\x01B\xa0\x02\0\0\xa17\x01\x01A\xa0\x02\0\0\xa1\x95\x01\x01C\xa0\x02\0\0\xa1\xb8\x01\x01D\xa0\x02\0\0\xa1\xdd\x01\x01L\xa0\x02\0\0\xa1\xff\x01\x01<\xa0\x02\0\0\xa2i\x01\x01=\xa0\x02\0\0\xa2\x9e\x01\x01:\xa0\x02\0\0\xa3C\x01\x01;\xa0\x02\0\0\xa3v\x01\x018\xa0\x02\0\0\xa3\x9f\x01\x019\xa0\x02\0\0\xa4\x88\x01\x01N\xa0\x02\0\0\xa5z\x01\x01O\xa0\x02\0\0\xa6+\x01\x01S\xa0\x02\0\0\xa6<\x01\x01P\xa0\x02\0\0\xa6Y\x01\x01Q\xa0\x02\0\0\xa6t\x01\x01R\xa0\x02\0\0\xa6\x9b\x01\x01V\xa0\x02\0\0\xa6\xac\x01\x01T\xa0\x02\0\0\xa6\xc7\x01\x01U\xa0\x02\0\0\xa7\x0b\x01\x01W\xa0\x02\0\0\xa71\x01\x01X\xa0\x02\0\0\xa7Z\x01\x01Y\xa0\x02\0\0\xa7\x83\x01\x01Z\xa0\x02\0\0\xa7\xac\x01\x01[\xa0\x02\0\0\xa7\xd3\x01\x01\\\xa0\x02\0\0\xa7\xf7\x01\x01]\xa0\x02\0\0\xa8\x1c\x01\x01`\xa0\x02\0\0\xa8-\x01\x01^\xa0\x02\0\0\xa8@\x01\x01_\xa0\x02\0\0\xa9\xa9\x01\x01a\xa0\x02\0\0\xa9\xd9\x01\x01b\xa0\x02\0\0\xaa\r\x01\x01q\xa0\x02\0\0\xaa>\x01\x01p\xa0\x02\0\0\xaa\\\x01\x01m\xa0\x02\0\0\xaau\x01\x01n\xa0\x02\0\0\xaa\x87\x01\x01k\xa0\x02\0\0\xaa\xa2\x01\x01l\xa0\x02\0\0\xaa\xb9\x01\x01i\xa0\x02\0\0\xaa\xe1\x01\x01h\xa0\x02\0\0\xab+\x01\x01g\xa0\x02\0\0\xabG\x01\x01j\xa0\x02\0\0\xabw\x01\x01f\xa0\x02\0\0\xab\x98\x01\x01o\xa0\x02\0\0\xab\xbb\x01\x01d\xa0\x02\0\0\xac\t\x01\x01e\xa0\x02\0\0\xac;\x01\x01c\xa0\x02\0\0\xac\x93\x01\x01r\xa0\x02\0\0\xac\xb1\x01\x01s\xa0\x02\0\0\xad \x01\x01t\xa0\x02\0\0\xad\xb2\x01\x01u\xa0\x02\0\0\xaeP\x01\x01w\xa0\x02\0\0\xae\xb8\x01\x01v\xa0\x02\0\0\xaf\x0e\x01\x01x\xa0\x02\0\0\xaf\xb2\x01\x01z\xa0\x02\0\0\xb0\x19\x01\x01y\xa0\x02\0\0\xb0m\x01\x01|\xa0\x02\0\0\xb0\xd0\x01\x01{\xa0\x02\0\0\xb1&\x01\x01~\xa0\x02\0\0\xb1\x8d\x01\x01}\xa0\x02\0\0\xb1\xe6\x01\x01\x80\xa0\x02\0\0\xb2G\x01\x01\x7f\xa0\x02\0\0\xb2\xa2\x01\x01\x81\xa0\x02\0\0\xb3U\x01\x01\x83\xa0\x02\0\0\xb3\xc3\x01\x01\x82\xa0\x02\0\0\xb40\x01\x01\x85\xa0\x02\0\0\xb4\xa7\x01\x01\x84\xa0\x02\0\0\xb5\x14\x01\x01\x87\xa0\x02\0\0\xb5\x82\x01\x01\x86\xa0\x02\0\0\xb5\xef\x01\x01\x89\xa0\x02\0\0\xb6f\x01\x01\x88\xa0\x02\0\0\xb6\xcd\x01\x01\x8b\xa0\x02\0\0\xb72\x01\x01\x8a\xa0\x02\0\0\xb7\x8c\x01\x01\x8d\xa0\x02\0\0\xb7\xf5\x01\x01\x8c\xa0\x02\0\0\xb8O\x01\x01\x8f\xa0\x02\0\0\xb8\xb4\x01\x01\x8e\xa0\x02\0\0\xb9\x0e\x01\x01\x91\xa0\x02\0\0\xb9w\x01\x01\x90\xa0\x02\0\0\xb9\xe0\x01\x01\x93\xa0\x02\0\0\xbah\x01\x01\x92\xa0\x02\0\0\xba\xe0\x01\x01\x95\xa0\x02\0\0\xbbl\x01\x01\x94\xa0\x02\0\0\xbb\xdd\x01\x01\x97\xa0\x02\0\0\xbcX\x01\x01\x96\xa0\x02\0\0\xbc\xbd\x01\x01\x99\xa0\x02\0\0\xbd@\x01\x01\x98\xa0\x02\0\0\xbd\xad\x01\x01\x9b\xa0\x02\0\0\xbe9\x01\x01\x9a\xa0\x02\0\0\xbe\xc2\x01\x01\x9c\xa0\x02\0\0\xbf\x80\x01\x01\x9d\xa0\x02\0\0\xc0$\x01\x01\x9e\xa0\x02\0\0\xc0\xd2\x01\x01\x9f\xa0\x02\0\0\xc1y\x01\x01\xa0\xa0\x02\0\0\xc2\x15\x01\x01\xa1\xa0\x02\0\0\xc2\xb6\x01\x01\xa2\xa0\x02\0\0\xc3N\x01\x01\xa3\xa0\x02\0\0\xc3\xef\x01\x01\xa4\xa0\x02\0\0\xc4\x86\x01\x01\xa5\xa0\x02\0\0\xc5Y\x01\x01\xa7\xa0\x02\0\0\xc5\xc7\x01\x01\xa6\xa0\x02\0\0\xc6.\x01\x01\xa8\xa0\x02\0\0\xc6\xe2\x01\x01\xaa\xa0\x02\0\0\xc7l\x01\x01\xa9\xa0\x02\0\0\xc7\xc8\x01\x01\xab\xa0\x02\0\0\xc8x\x01\x01\xad\xa0\x02\0\0\xc8\xee\x01\x01\xac\xa0\x02\0\0\xc9R\x01\x01\xae\xa0\x02\0\0\xca\t\x01\x01\xb0\xa0\x02\0\0\xca|\x01\x01\xaf\xa0\x02\0\0\xca\xdd\x01\x01\xb1\xa0\x02\0\0\xcb\x93\x01\x01\xb3\xa0\x02\0\0\xcc\t\x01\x01\xb2\xa0\x02\0\0\xccm\x01\x01\xb4\xa0\x02\0\0\xcd*\x01\x01\xb6\xa0\x02\0\0\xcd\x9a\x01\x01\xb5\xa0\x02\0\0\xce\x04\x01\x01\xb7\xa0\x02\0\0\xce\xbb\x01\x01\xb9\xa0\x02\0\0\xcf.\x01\x01\xb8\xa0\x02\0\0\xcf\x8f\x01\x01\xba\xa0\x02\0\0\xd0@\x01\x01\xbc\xa0\x02\0\0\xd0\xb9\x01\x01\xbb\xa0\x02\0\0\xd1\x14\x01\x01\xbd\xa0\x02\0\0\xd1\xc1\x01\x01\xbf\xa0\x02\0\0\xd24\x01\x01\xbe\xa0\x02\0\0\xd2\x9f\x01\x01\xc1\xa0\x02\0\0\xd3\x1a\x01\x01\xc0\xa0\x02\0\0\xd3\x98\x01\x01\xc3\xa0\x02\0\0\xd4K\x01\x01\xc2\xa0\x02\0\0\xd4\xc8\x01\x01\xc5\xa0\x02\0\0\xd54\x01\x01\xc4\xa0\x02\0\0\xd5\x96\x01\x01\xc7\xa0\x02\0\0\xd5\xf4\x01\x01\xc6\xa0\x02\0\0\xd6K\x01\x01\xc8\xa0\x02\0\0\xd6\xfc\x01\x01\xca\xa0\x02\0\0\xd7e\x01\x01\xc9\xa0\x02\0\0\xd7\xa8\x01\x01\xcb"),
     cst_src_CairoMock_ml=caml_new_string("src/CairoMock.ml"),
     cst_CairoMock_Mock_Error=caml_new_string("CairoMock.Mock.Error"),
     cst_CairoMock_Mock_Unavailable=
      caml_new_string("CairoMock.Mock.Unavailable"),
     cst_normal=caml_new_string("normal"),
     cst_italic=caml_new_string("italic"),
     cst_oblique=caml_new_string("oblique"),
     cst_bold=caml_new_string("bold"),
     cst_normal$0=caml_new_string("normal"),
     cst_over=caml_new_string("over"),
     cst_add=caml_new_string("add"),
     cst_destination_atop$0=caml_new_string("destination-atop"),
     cst_destination_in$0=caml_new_string("destination-in"),
     cst_destination_out$0=caml_new_string("destination-out"),
     cst_destination_over$0=caml_new_string("destination-over"),
     cst_lighter$0=caml_new_string("lighter"),
     cst_source_atop$0=caml_new_string("source-atop"),
     cst_source_in$0=caml_new_string("source-in"),
     cst_source_out$0=caml_new_string("source-out"),
     cst_source_over$0=caml_new_string("source-over"),
     cst_xor$0=caml_new_string("xor"),
     cst_Unsupported_operator_CLEAR=
      caml_new_string("Unsupported operator CLEAR"),
     cst_Unsupported_operator_SOURCE=
      caml_new_string("Unsupported operator SOURCE"),
     cst_source_over=caml_new_string("source-over"),
     cst_source_in=caml_new_string("source-in"),
     cst_source_out=caml_new_string("source-out"),
     cst_source_atop=caml_new_string("source-atop"),
     cst_Unsupported_operator_DEST=
      caml_new_string("Unsupported operator DEST"),
     cst_destination_over=caml_new_string("destination-over"),
     cst_destination_in=caml_new_string("destination-in"),
     cst_destination_out=caml_new_string("destination-out"),
     cst_destination_atop=caml_new_string("destination-atop"),
     cst_xor=caml_new_string("xor"),
     cst_lighter=caml_new_string("lighter"),
     cst_Unsupported_operator_SATURATE=
      caml_new_string("Unsupported operator SATURATE"),
     cst_bevel$0=caml_new_string("bevel"),
     cst_round$2=caml_new_string("round"),
     cst_miter=caml_new_string("miter"),
     cst_round$1=caml_new_string("round"),
     cst_bevel=caml_new_string("bevel"),
     cst_round$0=caml_new_string("round"),
     cst_square$0=caml_new_string("square"),
     cst_butt=caml_new_string("butt"),
     cst_round=caml_new_string("round"),
     cst_square=caml_new_string("square"),
     cst_INVALID_RESTORE$0=caml_new_string("INVALID_RESTORE"),
     cst_INVALID_POP_GROUP$0=caml_new_string("INVALID_POP_GROUP"),
     cst_NO_CURRENT_POINT$0=caml_new_string("NO_CURRENT_POINT"),
     cst_INVALID_MATRIX$0=caml_new_string("INVALID_MATRIX"),
     cst_INVALID_STATUS$0=caml_new_string("INVALID_STATUS"),
     cst_NULL_POINTER$0=caml_new_string("NULL_POINTER"),
     cst_INVALID_STRING$0=caml_new_string("INVALID_STRING"),
     cst_INVALID_PATH_DATA$0=caml_new_string("INVALID_PATH_DATA"),
     cst_READ_ERROR$0=caml_new_string("READ_ERROR"),
     cst_WRITE_ERROR$0=caml_new_string("WRITE_ERROR"),
     cst_SURFACE_FINISHED$0=caml_new_string("SURFACE_FINISHED"),
     cst_SURFACE_TYPE_MISMATCH$0=caml_new_string("SURFACE_TYPE_MISMATCH"),
     cst_PATTERN_TYPE_MISMATCH$0=caml_new_string("PATTERN_TYPE_MISMATCH"),
     cst_INVALID_CONTENT$0=caml_new_string("INVALID_CONTENT"),
     cst_INVALID_FORMAT$0=caml_new_string("INVALID_FORMAT"),
     cst_INVALID_VISUAL$0=caml_new_string("INVALID_VISUAL"),
     cst_FILE_NOT_FOUND$0=caml_new_string("FILE_NOT_FOUND"),
     cst_INVALID_DASH$0=caml_new_string("INVALID_DASH"),
     cst_INVALID_DSC_COMMENT$0=caml_new_string("INVALID_DSC_COMMENT"),
     cst_INVALID_INDEX$0=caml_new_string("INVALID_INDEX"),
     cst_CLIP_NOT_REPRESENTABLE$0=caml_new_string("CLIP_NOT_REPRESENTABLE"),
     cst_TEMP_FILE_ERROR$0=caml_new_string("TEMP_FILE_ERROR"),
     cst_INVALID_STRIDE$0=caml_new_string("INVALID_STRIDE"),
     cst_FONT_TYPE_MISMATCH$0=caml_new_string("FONT_TYPE_MISMATCH"),
     cst_USER_FONT_IMMUTABLE$0=caml_new_string("USER_FONT_IMMUTABLE"),
     cst_USER_FONT_ERROR$0=caml_new_string("USER_FONT_ERROR"),
     cst_NEGATIVE_COUNT$0=caml_new_string("NEGATIVE_COUNT"),
     cst_INVALID_CLUSTERS$0=caml_new_string("INVALID_CLUSTERS"),
     cst_INVALID_SLANT$0=caml_new_string("INVALID_SLANT"),
     cst_INVALID_WEIGHT$0=caml_new_string("INVALID_WEIGHT"),
     cst_INVALID_SIZE$0=caml_new_string("INVALID_SIZE"),
     cst_USER_FONT_NOT_IMPLEMENTED$0=
      caml_new_string("USER_FONT_NOT_IMPLEMENTED"),
     cst_DEVICE_TYPE_MISMATCH$0=caml_new_string("DEVICE_TYPE_MISMATCH"),
     cst_DEVICE_ERROR$0=caml_new_string("DEVICE_ERROR"),
     cst_INVALID_MESH_CONSTRUCTION$0=
      caml_new_string("INVALID_MESH_CONSTRUCTION"),
     cst_DEVICE_FINISHED$0=caml_new_string("DEVICE_FINISHED"),
     cst_JBIG2_GLOBAL_MISSING$0=caml_new_string("JBIG2_GLOBAL_MISSING"),
     cst_cairo_restore_without_matching_cairo_save$0=
      caml_new_string("cairo_restore() without matching cairo_save()"),
     cst_no_saved_group_to_pop_i_e_cairo_pop_group_without_matching_cairo_push_group$0=
      caml_new_string
       ("no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group()"),
     cst_no_current_point_defined$0=
      caml_new_string("no current point defined"),
     cst_invalid_matrix_not_invertible$0=
      caml_new_string("invalid matrix (not invertible)"),
     cst_invalid_value_for_an_input_cairo_status_t$0=
      caml_new_string("invalid value for an input cairo_status_t"),
     cst_NULL_pointer$0=caml_new_string("NULL pointer"),
     cst_input_string_not_valid_UTF_8$0=
      caml_new_string("input string not valid UTF-8"),
     cst_input_path_data_not_valid$0=
      caml_new_string("input path data not valid"),
     cst_error_while_reading_from_input_stream$0=
      caml_new_string("error while reading from input stream"),
     cst_error_while_writing_to_output_stream$0=
      caml_new_string("error while writing to output stream"),
     cst_the_target_surface_has_been_finished$0=
      caml_new_string("the target surface has been finished"),
     cst_the_surface_type_is_not_appropriate_for_the_operation$0=
      caml_new_string("the surface type is not appropriate for the operation"),
     cst_the_pattern_type_is_not_appropriate_for_the_operation$0=
      caml_new_string("the pattern type is not appropriate for the operation"),
     cst_invalid_value_for_an_input_cairo_content_t$0=
      caml_new_string("invalid value for an input cairo_content_t"),
     cst_invalid_value_for_an_input_cairo_format_t$0=
      caml_new_string("invalid value for an input cairo_format_t"),
     cst_invalid_value_for_an_input_Visual$0=
      caml_new_string("invalid value for an input Visual*"),
     cst_file_not_found$0=caml_new_string("file not found"),
     cst_invalid_value_for_a_dash_setting$0=
      caml_new_string("invalid value for a dash setting"),
     cst_invalid_value_for_a_DSC_comment$0=
      caml_new_string("invalid value for a DSC comment"),
     cst_invalid_index_passed_to_getter$0=
      caml_new_string("invalid index passed to getter"),
     cst_clip_region_not_representable_in_desired_format$0=
      caml_new_string("clip region not representable in desired format"),
     cst_error_creating_or_writing_to_a_temporary_file$0=
      caml_new_string("error creating or writing to a temporary file"),
     cst_invalid_value_for_stride$0=
      caml_new_string("invalid value for stride"),
     cst_the_font_type_is_not_appropriate_for_the_operation$0=
      caml_new_string("the font type is not appropriate for the operation"),
     cst_the_user_font_is_immutable$0=
      caml_new_string("the user-font is immutable"),
     cst_error_occurred_in_a_user_font_callback_function$0=
      caml_new_string("error occurred in a user-font callback function"),
     cst_negative_number_used_where_it_is_not_allowed$0=
      caml_new_string("negative number used where it is not allowed"),
     cst_input_clusters_do_not_represent_the_accompanying_text_and_glyph_arrays$0=
      caml_new_string
       ("input clusters do not represent the accompanying text and glyph arrays"),
     cst_invalid_value_for_an_input_cairo_font_slant_t$0=
      caml_new_string("invalid value for an input cairo_font_slant_t"),
     cst_invalid_value_for_an_input_cairo_font_weight_t$0=
      caml_new_string("invalid value for an input cairo_font_weight_t"),
     cst_invalid_value_typically_too_big_for_the_size_of_the_input_surface_pattern_etc$0=
      caml_new_string
       ("invalid value (typically too big) for the size of the input (surface, pattern, etc.)"),
     cst_user_font_method_not_implemented$0=
      caml_new_string("user-font method not implemented"),
     cst_the_device_type_is_not_appropriate_for_the_operation$0=
      caml_new_string("the device type is not appropriate for the operation"),
     cst_an_operation_to_the_device_caused_an_unspecified_error$0=
      caml_new_string
       ("an operation to the device caused an unspecified error"),
     cst_invalid_operation_during_mesh_pattern_construction$0=
      caml_new_string("invalid operation during mesh pattern construction"),
     cst_the_target_device_has_been_finished$0=
      caml_new_string("the target device has been finished"),
     cst_CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID_used_but_no_CAIRO_MIME_TYPE_JBIG2_GLOBAL_data_provided$0=
      caml_new_string
       ("CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID used but no CAIRO_MIME_TYPE_JBIG2_GLOBAL data provided"),
     point_definitions$0=
      caml_new_string
       ('\x84\x95\xa6\xbe\0\0\t\xe8\0\0\x01\x86\0\0\x06\x15\0\0\x06\x15\b\0\x06\x14\0\xa0\x01\x05Ie\xa0\x01\x05V@\xa0\x01\x05\x9dA\xa0\x01\x06\nB\xa0\x01\x06=C\xa0\x01\x06uD\xa0\x01\x06\xb7E\xa0\x01\x06\xdaF\xa0\x01\x07\x0fG\xa0\x01\x07DH\xa0\x01\x07~I\xa0\x01\x07\xb8J\xa0\x01\x07\xf7K\xa0\x01\bLL\xa0\x01\b\xa1M\xa0\x01\b\xe5N\xa0\x01\t\'O\xa0\x01\tbP\xa0\x01\t\x89Q\xa0\x01\t\xc0R\xa0\x01\t\xfdS\xa0\x01\n3T\xa0\x01\n\x83U\xa0\x01\n\xcaV\xa0\x01\n\xfbW\xa0\x01\x0bJX\xa0\x01\x0b\x82Y\xa0\x01\x0b\xcbZ\xa0\x01\f\x10[\xa0\x01\fq\\\xa0\x01\f\xb6]\xa0\x01\f\xfd^\xa0\x01\rh_\xa0\x01\r\xac`\xa0\x01\r\xffa\xa0\x01\x0eLb\xa0\x01\x0e\xa2c\xa0\x01\x0e\xdfd\xa0\x01\x0fch\xa0\x01\x0fpf\xa0\x01\x0f\x99g\xa0\x01\x17\xe9i\xa0\x01\x184j\xa0\x01\x18yk\xa0\x01\x18\xc1l\xa0\x01\x19tx\xa0\x01\x19|v\xa0\x01\x19\x98w\xa0\x01\x19\xa7t\xa0\x01\x19\xc9u\xa0\x01\x19\xd2m\xa0\x01\x19\xe7n\xa0\x01\x19\xffo\xa0\x01\x1a\x17p\xa0\x01\x1a,q\xa0\x01\x1aUr\xa0\x01\x1axs\xa0\x01\x1a\xf1\0@\xa0\x01\x1a\xfay\xa0\x01\x1b\x1ez\xa0\x01\x1bB{\xa0\x01\x1bf|\xa0\x01\x1b\x8a}\xa0\x01\x1b\xb4~\xa0\x01\x1b\xd8\x7f\xa0\x01\x1c+\0A\xa0\x01\x1c\xa5\0B\xa0\x01\x1c\xfe\0H\xa0\x01\x1d\x0e\0G\xa0\x01\x1d\x1e\0F\xa0\x01\x1d.\0E\xa0\x01\x1d>\0D\xa0\x01\x1dN\0C\xa0\x01\x1dr\0I\xa0\x01\x1d\xb3\0J\xa0\x01\x1d\xf7\0K\xa0\x01\x1e4\0L\xa0\x01!\xdd\0O\xa0\x01"\x12\0M\xa0\x01";\0N\xa0\x01"x\0P\xa0\x01"\x8b\0Q\xa0\x01"\xba\0Z\xa0\x01"\xc8\0X\xa0\x01"\xfc\0Y\xa0\x01#\n\0V\xa0\x01#\x1d\0T\xa0\x01#7\0U\xa0\x01#x\0R\xa0\x01#\x97\0S\xa0\x01#\xb1\0W\xa0\x01#\xd4\0\\\xa0\x01$\x03\0[\xa0\x01$*\0_\xa0\x01$H\0]\xa0\x01$_\0^\xa0\x01$\xf6\0a\xa0\x01%\'\0`\xa0\x01(a\0b\xa0\x01(\x97\0c\xa0\x01(\xca\0h\xa0\x01(\xe6\0d\xa0\x01)\x02\0e\xa0\x01)\x1b\0f\xa0\x01)4\0g\xa0\x01)\x93\0i\xa0\x01*\n\0n\xa0\x01*&\0j\xa0\x01*S\0k\xa0\x01*b\0l\xa0\x01*{\0m\xa0\x01*\xe2\0o\xa0\x01+c\0t\xa0\x01+\x7f\0p\xa0\x01+\xae\0q\xa0\x01+\xc7\0r\xa0\x01+\xd6\0s\xa0\x01,3\0|\xa0\x01,E\0{\xa0\x01,V\0y\xa0\x01,o\0z\xa0\x01,\x8b\0u\xa0\x01- \0v\xa0\x01-\xb5\0w\xa0\x01-\xdf\0x\xa0\x01.%\0}\xa0\x01.y\x01\0\x82\xa0\x01.\x95\0~\xa0\x01.\xb7\0\x7f\xa0\x01/\x01\x01\0\x80\xa0\x01/\x10\x01\0\x81\xa0\x01/r\x01\0\x87\xa0\x01/\x8e\x01\0\x83\xa0\x01/\xb0\x01\0\x84\xa0\x010\0\x01\0\x85\xa0\x010\x0f\x01\0\x86\xa0\x014\xe4\x01\0\x88\xa0\x015D\x01\0\x89\xa0\x015\xc1\x01\0\x8b\xa0\x015\xe1\x01\0\x8a\xa0\x016B\x01\0\x8c\xa0\x016\x8d\x01\0\x8d\xa0\x016\xfb\x01\0\x8e\xa0\x017<\x01\0\x8f\xa0\x017\x7f\x01\0\x92\xa0\x017\xa1\x01\0\x90\xa0\x017\xb6\x01\0\x91\xa0\x0188\x01\0\x95\xa0\x018`\x01\0\x93\xa0\x018\xb6\x01\0\x94\xa0\x01=\x1a\x01\0\x96\xa0\x01>\x8a\x01\0\x97\xa0\x01>\xc6\x01\0\x98\xa0\x01?\x12\x01\0\x99\xa0\x01?a\x01\0\x9f\xa0\x01?t\x01\0\x9d\xa0\x01?\x98\x01\0\x9a\xa0\x01?\x9d\x01\0\x9b\xa0\x01?\xcc\x01\0\x9c\xa0\x01?\xeb\x01\0\x9e\xa0\x01@(\x01\0\xa0\xa0\x01@\x7f\x01\0\xa1\xa0\x01@\xd3\x01\0\xa2\xa0\x01A\f\x01\0\xa3\xa0\x01AX\x01\0\xa4\xa0\x01A\x97\x01\0\xa5\xa0\x01A\xe8\x01\0\xa6\xa0\x01B0\x01\0\xa7\xa0\x01B\x91\x01\0\xaa\xa0\x01B\xa6\x01\0\xa8\xa0\x01B\xc4\x01\0\xa9\xa0\x01C!\x01\0\xab\xa0\x01Cw\x01\0\xae\xa0\x01C\x8c\x01\0\xac\xa0\x01C\xaa\x01\0\xad\xa0\x01D\x1e\x01\0\xaf\xa0\x01Dn\x01\0\xb2\xa0\x01D\x83\x01\0\xb0\xa0\x01D\xa1\x01\0\xb1\xa0\x01D\xfd\x01\0\xb5\xa0\x01E\x12\x01\0\xb3\xa0\x01E0\x01\0\xb4\xa0\x01E\x91\x01\0\xb6\xa0\x01F\x06\x01\0\xb8\xa0\x01F\x1c\x01\0\xb7\xa0\x01FN\x01\0\xba\xa0\x01Fg\x01\0\xb9\xa0\x01F\xcd\x01\0\xbc\xa0\x01F\xfd\x01\0\xbb\xa0\x01GP\x01\0\xbd\xa0\x01G\x90\x01\0\xbe\xa0\x01G\xf7\x01\0\xbf\xa0\x01H@\x01\0\xc0\xa0\x01H\x8c\x01\0\xc1\xa0\x01H\xda\x01\0\xc2\xa0\x01I+\x01\0\xc3\xa0\x01I\xb0\x01\0\xc4\xa0\x01J1\x01\0\xc5\xa0\x01J\xa0\x01\0\xc6\xa0\x01K\x0e\x01\0\xc9\xa0\x01KA\x01\0\xc7\xa0\x01Kn\x01\0\xc8\xa0\x01K\xad\x01\0\xcc\xa0\x01K\xc9\x01\0\xcb\xa0\x01K\xf7\x01\0\xca\xa0\x01LM\x01\0\xcf\xa0\x01LZ\x01\0\xcd\xa0\x01Lv\x01\0\xce\xa0\x01L\xa7\x01\0\xd2\xa0\x01L\xc3\x01\0\xd1\xa0\x01L\xf9\x01\0\xd0\xa0\x01MG\x01\0\xd5\xa0\x01MT\x01\0\xd3\xa0\x01Mp\x01\0\xd4\xa0\x01M\xb0\x01\0\xd8\xa0\x01M\xe1\x01\0\xd7\xa0\x01N\x19\x01\0\xd6\xa0\x01Nx\x01\0\xdd\xa0\x01N\x87\x01\0\xd9\xa0\x01N\xb5\x01\0\xda\xa0\x01N\xe3\x01\0\xdb\xa0\x01O\x05\x01\0\xdc\xa0\x01OM\x01\0\xdf\xa0\x01O}\x01\0\xde\xa0\x01O\xc2\x01\0\xe2\xa0\x01O\xe7\x01\0\xe1\xa0\x01P?\x01\0\xe0\xa0\x01P\x99\x01\0\xe3\xa0\x01P\xc1\x01\0\xe4\xa0\x01Q\x10\x01\0\xe7\xa0\x01QE\x01\0\xe5\xa0\x01Q^\x01\0\xe6\xa0\x01Q\x8f\x01\0\xea\xa0\x01Q\xac\x01\0\xe9\xa0\x01Q\xd7\x01\0\xe8\xa0\x01R\x1a\x01\0\xec\xa0\x01R7\x01\0\xeb\xa0\x01R\x91\x01\0\xed\xa0\x01R\xbe\x01\0\xef\xa0\x01R\xd9\x01\0\xee\xa0\x01S\x0b\x01\0\xf2\xa0\x01S:\x01\0\xf0\xa0\x01S^\x01\0\xf1\xa0\x01S\xbc\x01\0\xf4\xa0\x01S\xd5\x01\0\xf3\xa0\x01T\x07\x01\0\xf5\xa0\x01T0\x01\0\xf7\xa0\x01TI\x01\0\xf6\xa0\x01To\x01\x01\0\xa0\x01T\x7f\x01\0\xff\xa0\x01T\x8f\x01\0\xfe\xa0\x01T\xb6\x01\0\xfd\xa0\x01T\xd1\x01\0\xfc\xa0\x01T\xdd\x01\0\xf9\xa0\x01U\x19\x01\0\xfa\xa0\x01UL\x01\0\xfb\xa0\x01Uy\x01\0\xf8\xa0\x01U\xb0\x01\x01\x01\xa0\x01U\xf2\x01\x01\x02\xa0\x01V\'\x01\x01\x07\xa0\x01V6\x01\x01\x06\xa0\x01VA\x01\x01\x04\xa0\x01Vd\x01\x01\x05\xa0\x01V\x84\x01\x01\x03\xa0\x01V\xc2\x01\x01\n\xa0\x01V\xcd\x01\x01\b\xa0\x01V\xf0\x01\x01\t\xa0\x01WR\x01\x01\x0b\xa0\x01W\x9e\x01\x01\f\xa0\x01W\xde\x01\x01\x12\xa0\x01W\xe8\x01\x01\x10\xa0\x01W\xfd\x01\x01\r\xa0\x01X\x12\x01\x01\x0e\xa0\x01X)\x01\x01\x0f\xa0\x01XC\x01\x01\x11\xa0\x01X\x89\x01\x01\x16\xa0\x01X\xbe\x01\x01\x13\xa0\x01X\xd5\x01\x01\x14\xa0\x01X\xee\x01\x01\x15\xa0\x01Y\x1c\x01\x01\x1c\xa0\x01Y\'\x01\x01\x1a\xa0\x01Y=\x01\x01\x17\xa0\x01YZ\x01\x01\x18\xa0\x01Yv\x01\x01\x19\xa0\x01Y\x93\x01\x01\x1b\xa0\x01Y\xdc\x01\x01 \xa0\x01Z\x12\x01\x01\x1d\xa0\x01Z.\x01\x01\x1e\xa0\x01ZJ\x01\x01\x1f\xa0\x01Z}\x01\x01!\xa0\x01Z\xbd\x01\x01"\xa0\x01Z\xfe\x01\x013\xa0\x01[\r\x01\x011\xa0\x01[\'\x01\x01#\xa0\x01[\\\x01\x01$\xa0\x01[\x93\x01\x01%\xa0\x01[\xaf\x01\x01&\xa0\x01[\xcb\x01\x01\'\xa0\x01[\xe3\x01\x01(\xa0\x01[\xfd\x01\x01)\xa0\x01\\#\x01\x01*\xa0\x01\\I\x01\x01+\xa0\x01\\k\x01\x01,\xa0\x01\\\x8f\x01\x01-\xa0\x01\\\xa6\x01\x01.\xa0\x01\\\xb9\x01\x01/\xa0\x01\\\xec\x01\x010\xa0\x01](\x01\x012\xa0\x01]\x84\x01\x01A\xa0\x01]\xca\x01\x014\xa0\x01^,\x01\x015\xa0\x01^b\x01\x016\xa0\x01^~\x01\x017\xa0\x01^\x9a\x01\x018\xa0\x01^\xb2\x01\x019\xa0\x01^\xcc\x01\x01:\xa0\x01^\xf2\x01\x01;\xa0\x01_\x18\x01\x01<\xa0\x01_:\x01\x01=\xa0\x01_^\x01\x01>\xa0\x01_u\x01\x01?\xa0\x01_\x88\x01\x01@\xa0\x01_\xf9\x01\x01^\xa0\x01`\t\x01\x01\\\xa0\x01`8\x01\x01]\xa0\x01`S\x01\x01Z\xa0\x01`\xb0\x01\x01[\xa0\x01`\xbd\x01\x01X\xa0\x01`\xcb\x01\x01Y\xa0\x01`\xf5\x01\x01W\xa0\x01a\r\x01\x01S\xa0\x01a<\x01\x01C\xa0\x01aZ\x01\x01D\xa0\x01a\x83\x01\x01B\xa0\x01a\xad\x01\x01T\xa0\x01b\x03\x01\x01J\xa0\x01b;\x01\x01K\xa0\x01bP\x01\x01F\xa0\x01bw\x01\x01H\xa0\x01b\xab\x01\x01G\xa0\x01b\xf1\x01\x01I\xa0\x01c&\x01\x01E\xa0\x01c\\\x01\x01U\xa0\x01c\xbb\x01\x01Q\xa0\x01c\xf9\x01\x01R\xa0\x01d\x0e\x01\x01M\xa0\x01d5\x01\x01O\xa0\x01di\x01\x01N\xa0\x01d\xaf\x01\x01P\xa0\x01d\xe4\x01\x01L\xa0\x01e\x1a\x01\x01V\xa0\x01eW\x01\x01_\xa0\x01e\x9e\x01\x01`\xa0\x01e\xf5\x01\x01a\xa0\x01fj\x01\x01m\xa0\x01f\x90\x01\x01l\xa0\x01f\xa1\x01\x01i\xa0\x01f\xb8\x01\x01d\xa0\x01f\xd2\x01\x01e\xa0\x01f\xeb\x01\x01f\xa0\x01g\x14\x01\x01j\xa0\x01g,\x01\x01g\xa0\x01gE\x01\x01h\xa0\x01g[\x01\x01k\xa0\x01gf\x01\x01b\xa0\x01g\xbc\x01\x01c\xa0\x01h\b\x01\x01p\xa0\x01h\x1a\x01\x01o\xa0\x01h-\x01\x01n\xa0\x01h\x9b\x01\x01q\xa0\x01h\xf1\x01\x01v\xa0\x01h\xfe\x01\x01s\xa0\x01i\'\x01\x01t\xa0\x01i^\x01\x01u\xa0\x01i\x93\x01\x01r\xa0\x01i\xda\x01\x01y\xa0\x01i\xea\x01\x01w\xa0\x01j\n\x01\x01x\xa0\x01j\xa8\x01\x01}\xa0\x01j\xb8\x01\x01z\xa0\x01j\xdd\x01\x01{\xa0\x01k\x14\x01\x01|\xa0\x01k\xa2\x01\x01\x84\xa0\x01k\xad\x01\x01\x81\xa0\x01k\xdc\x01\x01\x82\xa0\x01k\xf1\x01\x01\x83\xa0\x01k\xff\x01\x01\x7f\xa0\x01l\x1f\x01\x01\x80\xa0\x01l=\x01\x01~'),
     cst_src_JsOfOCairo_ml=caml_new_string("src/JsOfOCairo.ml"),
     cst_JsOfOCairo_Error=caml_new_string("JsOfOCairo.Error"),
     cst_JsOfOCairo_Unavailable=caml_new_string("JsOfOCairo.Unavailable"),
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Stdlib_listLabels=global_data.Stdlib__listLabels,
     Stdlib_arrayLabels=global_data.Stdlib__arrayLabels,
     Stdlib_stringLabels=global_data.Stdlib__stringLabels,
     Bisect_Runtime=global_data.Bisect__Runtime,
     Dom_html=global_data.Dom_html,
     Stdlib=global_data.Stdlib,
     Js=global_data.Js,
     match=
      caml_call3(Bisect_Runtime[1],cst_src_CairoMock_ml,460,point_definitions),
     bisect_visit=match[2],
     Error=[248,cst_CairoMock_Mock_Error,caml_fresh_oo_id(0)];
    caml_call1(bisect_visit,37);
    var
     _ax_=
      [0,
       [11,caml_new_string("text_extents "),[3,0,0]],
       caml_new_string("text_extents %S")],
     _aw_=
      [0,
       [11,caml_new_string("font_extents"),0],
       caml_new_string("font_extents")],
     _av_=
      [0,
       [11,caml_new_string("show_text "),[3,0,0]],
       caml_new_string("show_text %S")],
     _au_=
      [0,
       [11,caml_new_string("set_font_size "),[8,0,0,[0,2],0]],
       caml_new_string("set_font_size %.2f")],
     _at_=
      [0,
       [11,caml_new_string("select_font_face"),[15,[15,[12,32,[3,0,0]]]]],
       caml_new_string("select_font_face%a%a %S")],
     _as_=
      [0,
       [11,
        caml_new_string("set_source_rgba "),
        [8,
         0,
         0,
         [0,2],
         [12,32,[8,0,0,[0,2],[12,32,[8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]]]]]],
       caml_new_string("set_source_rgba %.2f %.2f %.2f %.2f")],
     _ar_=
      [0,
       [11,
        caml_new_string("set_source_rgb "),
        [8,0,0,[0,2],[12,32,[8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]]]],
       caml_new_string("set_source_rgb %.2f %.2f %.2f")],
     _aq_=
      [0,[11,caml_new_string("get_source"),0],caml_new_string("get_source")],
     _ap_=
      [0,
       [11,caml_new_string("set_source "),[15,0]],
       caml_new_string("set_source %a")],
     _ao_=
      [0,
       [11,caml_new_string("get_operator"),0],
       caml_new_string("get_operator")],
     _an_=
      [0,
       [11,caml_new_string("set_operator "),[15,0]],
       caml_new_string("set_operator %a")],
     _am_=
      [0,
       [11,caml_new_string("get_miter_limit"),0],
       caml_new_string("get_miter_limit")],
     _al_=
      [0,
       [11,caml_new_string("set_miter_limit "),[8,0,0,[0,2],0]],
       caml_new_string("set_miter_limit %.2f")],
     _ak_=
      [0,
       [11,caml_new_string("get_line_join"),0],
       caml_new_string("get_line_join")],
     _aj_=
      [0,
       [11,caml_new_string("set_line_join "),[15,0]],
       caml_new_string("set_line_join %a")],
     _ai_=
      [0,
       [11,caml_new_string("get_line_cap"),0],
       caml_new_string("get_line_cap")],
     _ah_=
      [0,
       [11,caml_new_string("set_line_cap "),[15,0]],
       caml_new_string("set_line_cap %a")],
     _ag_=
      [0,
       [11,caml_new_string("get_fill_rule"),0],
       caml_new_string("get_fill_rule")],
     _af_=
      [0,
       [11,caml_new_string("set_fill_rule "),[15,0]],
       caml_new_string("set_fill_rule %a")],
     _ae_=[0,[11,caml_new_string("get_dash"),0],caml_new_string("get_dash")],
     _ad_=
      [0,
       [11,caml_new_string("set_dash"),[15,[12,32,[15,0]]]],
       caml_new_string("set_dash%a %a")],
     _ac_=
      [0,
       [11,caml_new_string("get_line_width"),0],
       caml_new_string("get_line_width")],
     _ab_=
      [0,
       [11,caml_new_string("set_line_width "),[8,0,0,[0,2],0]],
       caml_new_string("set_line_width %.2f")],
     _aa_=[0,[11,caml_new_string("paint"),[15,0]],caml_new_string("paint%a")],
     _$_=[0,[11,caml_new_string("clip"),0],caml_new_string("clip")],
     ___=
      [0,
       [11,caml_new_string("clip_preserve"),0],
       caml_new_string("clip_preserve")],
     _Z_=[0,[11,caml_new_string("fill"),0],caml_new_string("fill")],
     _Y_=
      [0,
       [11,caml_new_string("fill_preserve"),0],
       caml_new_string("fill_preserve")],
     _X_=[0,[11,caml_new_string("stroke"),0],caml_new_string("stroke")],
     _W_=
      [0,
       [11,caml_new_string("stroke_preserve"),0],
       caml_new_string("stroke_preserve")],
     _V_=
      [0,[11,caml_new_string("Path.close"),0],caml_new_string("Path.close")],
     _U_=
      [0,[11,caml_new_string("Path.clear"),0],caml_new_string("Path.clear")],
     _T_=
      [0,
       [11,caml_new_string("Path.get_current_point"),0],
       caml_new_string("Path.get_current_point")],
     _S_=
      [0,
       [11,
        caml_new_string("arc_negative "),
        [8,
         0,
         0,
         [0,2],
         [12,
          32,
          [8,
           0,
           0,
           [0,2],
           [11,
            caml_new_string(" ~r:"),
            [8,
             0,
             0,
             [0,2],
             [11,
              caml_new_string(" ~a1:"),
              [8,0,0,[0,2],[11,caml_new_string(" ~a2:"),[8,0,0,partial,0]]]]]]]]]],
       caml_new_string("arc_negative %.2f %.2f ~r:%.2f ~a1:%.2f ~a2:%.2f")],
     _R_=
      [0,
       [11,
        caml_new_string("arc "),
        [8,
         0,
         0,
         [0,2],
         [12,
          32,
          [8,
           0,
           0,
           [0,2],
           [11,
            caml_new_string(" ~r:"),
            [8,
             0,
             0,
             [0,2],
             [11,
              caml_new_string(" ~a1:"),
              [8,0,0,[0,2],[11,caml_new_string(" ~a2:"),[8,0,0,partial$0,0]]]]]]]]]],
       caml_new_string("arc %.2f %.2f ~r:%.2f ~a1:%.2f ~a2:%.2f")],
     _Q_=
      [0,
       [11,
        caml_new_string("rectangle "),
        [8,
         0,
         0,
         [0,2],
         [12,
          32,
          [8,
           0,
           0,
           [0,2],
           [11,
            caml_new_string(" ~w:"),
            [8,0,0,[0,2],[11,caml_new_string(" ~h:"),[8,0,0,[0,2],0]]]]]]]],
       caml_new_string("rectangle %.2f %.2f ~w:%.2f ~h:%.2f")],
     _P_=
      [0,
       [11,
        caml_new_string("rel_curve_to "),
        [8,
         0,
         0,
         [0,2],
         [12,
          32,
          [8,
           0,
           0,
           [0,2],
           [12,
            32,
            [8,
             0,
             0,
             [0,2],
             [12,32,[8,0,0,[0,2],[12,32,[8,0,0,partial$2,partial$1]]]]]]]]]],
       caml_new_string("rel_curve_to %.2f %.2f %.2f %.2f %.2f %.2f")],
     _O_=
      [0,
       [11,
        caml_new_string("curve_to "),
        [8,
         0,
         0,
         [0,2],
         [12,
          32,
          [8,
           0,
           0,
           [0,2],
           [12,
            32,
            [8,
             0,
             0,
             [0,2],
             [12,32,[8,0,0,[0,2],[12,32,[8,0,0,partial$4,partial$3]]]]]]]]]],
       caml_new_string("curve_to %.2f %.2f %.2f %.2f %.2f %.2f")],
     _N_=
      [0,
       [11,
        caml_new_string("rel_line_to "),
        [8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]],
       caml_new_string("rel_line_to %.2f %.2f")],
     _M_=
      [0,
       [11,caml_new_string("line_to "),[8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]],
       caml_new_string("line_to %.2f %.2f")],
     _L_=
      [0,
       [11,
        caml_new_string("rel_move_to "),
        [8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]],
       caml_new_string("rel_move_to %.2f %.2f")],
     _K_=
      [0,
       [11,caml_new_string("move_to "),[8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]],
       caml_new_string("move_to %.2f %.2f")],
     _J_=
      [0,
       [11,
        caml_new_string("user_to_device_distance "),
        [8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]],
       caml_new_string("user_to_device_distance %.2f %.2f")],
     _I_=
      [0,
       [11,
        caml_new_string("user_to_device "),
        [8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]],
       caml_new_string("user_to_device %.2f %.2f")],
     _H_=
      [0,
       [11,
        caml_new_string("device_to_user_distance "),
        [8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]],
       caml_new_string("device_to_user_distance %.2f %.2f")],
     _G_=
      [0,
       [11,
        caml_new_string("device_to_user "),
        [8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]],
       caml_new_string("device_to_user %.2f %.2f")],
     _F_=
      [0,
       [11,caml_new_string("identity_matrix"),0],
       caml_new_string("identity_matrix")],
     _E_=
      [0,
       [11,caml_new_string("rotate "),[8,0,0,[0,2],0]],
       caml_new_string("rotate %.2f")],
     _D_=
      [0,
       [11,
        caml_new_string("translate "),
        [8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]],
       caml_new_string("translate %.2f %.2f")],
     _C_=
      [0,
       [11,caml_new_string("scale "),[8,0,0,[0,2],[12,32,[8,0,0,[0,2],0]]]],
       caml_new_string("scale %.2f %.2f")],
     _B_=
      [0,
       [11,caml_new_string("transform "),[15,0]],
       caml_new_string("transform %a")],
     _A_=
      [0,[11,caml_new_string("get_matrix"),0],caml_new_string("get_matrix")],
     _z_=
      [0,
       [11,caml_new_string("set_matrix "),[15,0]],
       caml_new_string("set_matrix %a")],
     _y_=[0,[11,caml_new_string("restore"),0],caml_new_string("restore")],
     _x_=[0,[11,caml_new_string("save"),0],caml_new_string("save")],
     _w_=
      [0,
       [2,0,[11,caml_new_string(" -> "),[2,0,0]]],
       caml_new_string("%s -> %s")],
     _v_=
      [0,
       [2,0,[11,caml_new_string(" -> raise ("),[2,0,[12,41,0]]]],
       caml_new_string("%s -> raise (%s)")],
     _u_=
      [0,
       [11,caml_new_string(" ~"),[2,0,[12,58,[2,0,0]]]],
       caml_new_string(" ~%s:%s")],
     _t_=
      [0,
       [11,
        caml_new_string("{x_bearing="),
        [8,
         0,
         0,
         [0,2],
         [11,
          caml_new_string("; y_bearing="),
          [8,
           0,
           0,
           [0,2],
           [11,
            caml_new_string("; width="),
            [8,
             0,
             0,
             [0,2],
             [11,
              caml_new_string("; height="),
              [8,
               0,
               0,
               [0,2],
               [11,
                caml_new_string("; x_advance="),
                [8,0,0,partial$6,partial$5]]]]]]]]]],
       caml_new_string
        ("{x_bearing=%.2f; y_bearing=%.2f; width=%.2f; height=%.2f; x_advance=%.2f; y_advance=%.2f}")],
     _s_=
      [0,
       [11,
        caml_new_string("{ascent="),
        [8,
         0,
         0,
         [0,2],
         [11,
          caml_new_string("; descent="),
          [8,
           0,
           0,
           [0,2],
           [11,
            caml_new_string("; baseline="),
            [8,
             0,
             0,
             [0,2],
             [11,
              caml_new_string("; max_x_advance="),
              [8,
               0,
               0,
               [0,2],
               [11,
                caml_new_string("; max_y_advance="),
                [8,0,0,partial$8,partial$7]]]]]]]]]],
       caml_new_string
        ("{ascent=%.2f; descent=%.2f; baseline=%.2f; max_x_advance=%.2f; max_y_advance=%.2f}")],
     _n_=
      [0,
       [11,
        caml_new_string("{position="),
        [8,
         0,
         0,
         [0,2],
         [11,
          caml_new_string("; r="),
          [8,
           0,
           0,
           [0,2],
           [11,
            caml_new_string("; g="),
            [8,
             0,
             0,
             [0,2],
             [11,
              caml_new_string("; b="),
              [8,
               0,
               0,
               [0,2],
               [11,caml_new_string("; a="),[8,0,0,partial$10,partial$9]]]]]]]]]],
       caml_new_string("{position=%.2f; r=%.2f; g=%.2f; b=%.2f; a=%.2f}")],
     _m_=[0,0,0,0,0,0],
     _o_=[0,[12,91,[2,0,[12,93,0]]],caml_new_string("[%s]")],
     _p_=
      [0,
       [11,
        caml_new_string("(Rgba {r="),
        [8,
         0,
         0,
         [0,2],
         [11,
          caml_new_string("; g="),
          [8,
           0,
           0,
           [0,2],
           [11,
            caml_new_string("; b="),
            [8,
             0,
             0,
             [0,2],
             [11,
              caml_new_string("; a="),
              [8,0,0,[0,2],[11,caml_new_string("})"),0]]]]]]]]],
       caml_new_string("(Rgba {r=%.2f; g=%.2f; b=%.2f; a=%.2f})")],
     _q_=
      [0,
       [11,
        caml_new_string("(LinearGradient {x0="),
        [8,
         0,
         0,
         [0,2],
         [11,
          caml_new_string("; y0="),
          [8,
           0,
           0,
           [0,2],
           [11,
            caml_new_string("; x1="),
            [8,
             0,
             0,
             [0,2],
             [11,
              caml_new_string("; y1="),
              [8,
               0,
               0,
               [0,2],
               [11,caml_new_string("; stop_points="),[2,0,partial$11]]]]]]]]]],
       caml_new_string
        ("(LinearGradient {x0=%.2f; y0=%.2f; x1=%.2f; y1=%.2f; stop_points=%s})")],
     _r_=
      [0,
       [11,
        caml_new_string("(RadialGradient {x0="),
        [8,
         0,
         0,
         [0,2],
         [11,
          caml_new_string("; y0="),
          [8,
           0,
           0,
           [0,2],
           [11,
            caml_new_string("; r0="),
            [8,
             0,
             0,
             [0,2],
             [11,
              caml_new_string("; x1="),
              [8,
               0,
               0,
               [0,2],
               [11,caml_new_string("; y1="),[8,0,0,partial$13,partial$12]]]]]]]]]],
       caml_new_string
        ("(RadialGradient {x0=%.2f; y0=%.2f; r0=%.2f; x1=%.2f; y1=%.2f; r1%.2f; stop_points=%s})")],
     _l_=
      [0,
       [12,40,[2,0,[11,caml_new_string(", "),[8,0,0,[0,2],[12,41,0]]]]],
       caml_new_string("(%s, %.2f)")],
     _j_=[0,[8,0,0,[0,2],0],caml_new_string("%.2f")],
     _k_=
      [0,
       [11,caml_new_string("[|"),[2,0,[11,caml_new_string("|]"),0]]],
       caml_new_string("[|%s|]")],
     _i_=
      [0,
       [12,
        40,
        [8,0,0,[0,2],[11,caml_new_string(", "),[8,0,0,[0,2],[12,41,0]]]]],
       caml_new_string("(%.2f, %.2f)")],
     _h_=
      [0,
       [11,
        caml_new_string("{xx="),
        [8,
         0,
         0,
         [0,2],
         [11,
          caml_new_string("; xy="),
          [8,
           0,
           0,
           [0,2],
           [11,
            caml_new_string("; yx="),
            [8,
             0,
             0,
             [0,2],
             [11,
              caml_new_string("; yy="),
              [8,
               0,
               0,
               [0,2],
               [11,caml_new_string("; x0="),[8,0,0,partial$15,partial$14]]]]]]]]]],
       caml_new_string
        ("{xx=%.2f; xy=%.2f; yx=%.2f; yy=%.2f; x0=%.2f; y0=%.2f}")],
     _g_=[0,[8,0,0,[0,2],0],caml_new_string("%.2f")],
     _f_=[0,0,0],
     _e_=[0,0,0,10,caml_new_string("sans-serif")],
     _d_=
      [0,
       [11,caml_new_string("CairoMock.Error("),[2,0,[12,41,0]]],
       caml_new_string("CairoMock.Error(%s)")],
     _b_=[0,0,0,0,0,0],
     _aI_=
      [0,
       [2,0,[12,32,[2,0,[12,32,[21,1,[11,caml_new_string("px "),[2,0,0]]]]]]],
       caml_new_string("%s %s %npx %s")],
     _aH_=
      [0,
       [11,
        caml_new_string("rgba("),
        [2,
         0,
         [11,
          caml_new_string(", "),
          [2,
           0,
           [11,
            caml_new_string(", "),
            [2,0,[11,caml_new_string(", "),[8,0,0,0,[12,41,0]]]]]]]]],
       caml_new_string("rgba(%s, %s, %s, %f)")],
     _aG_=
      [0,
       [11,caml_new_string("Unexpected globalCompositeOperation "),[3,0,0]],
       caml_new_string("Unexpected globalCompositeOperation %S")],
     _aF_=[0,0,0],
     _aC_=[0,0,0,10,caml_new_string("sans-serif")],
     _aB_=
      [0,
       [11,caml_new_string("JsOfOCairo.Error("),[2,0,[12,41,0]]],
       caml_new_string("JsOfOCairo.Error(%s)")],
     _ay_=[0,0,0,0,0,0];
    function status_to_string(param)
     {switch(param)
       {case 0:
         caml_call1(bisect_visit,0);
         return cst_cairo_restore_without_matching_cairo_save;
        case 1:
         caml_call1(bisect_visit,1);
         return cst_no_saved_group_to_pop_i_e_cairo_pop_group_without_matching_cairo_push_group;
        case 2:caml_call1(bisect_visit,2);return cst_no_current_point_defined;
        case 3:
         caml_call1(bisect_visit,3);return cst_invalid_matrix_not_invertible;
        case 4:
         caml_call1(bisect_visit,4);
         return cst_invalid_value_for_an_input_cairo_status_t;
        case 5:caml_call1(bisect_visit,5);return cst_NULL_pointer;
        case 6:
         caml_call1(bisect_visit,6);return cst_input_string_not_valid_UTF_8;
        case 7:
         caml_call1(bisect_visit,7);return cst_input_path_data_not_valid;
        case 8:
         caml_call1(bisect_visit,8);
         return cst_error_while_reading_from_input_stream;
        case 9:
         caml_call1(bisect_visit,9);
         return cst_error_while_writing_to_output_stream;
        case 10:
         caml_call1(bisect_visit,10);
         return cst_the_target_surface_has_been_finished;
        case 11:
         caml_call1(bisect_visit,11);
         return cst_the_surface_type_is_not_appropriate_for_the_operation;
        case 12:
         caml_call1(bisect_visit,12);
         return cst_the_pattern_type_is_not_appropriate_for_the_operation;
        case 13:
         caml_call1(bisect_visit,13);
         return cst_invalid_value_for_an_input_cairo_content_t;
        case 14:
         caml_call1(bisect_visit,14);
         return cst_invalid_value_for_an_input_cairo_format_t;
        case 15:
         caml_call1(bisect_visit,15);
         return cst_invalid_value_for_an_input_Visual;
        case 16:caml_call1(bisect_visit,16);return cst_file_not_found;
        case 17:
         caml_call1(bisect_visit,17);
         return cst_invalid_value_for_a_dash_setting;
        case 18:
         caml_call1(bisect_visit,18);
         return cst_invalid_value_for_a_DSC_comment;
        case 19:
         caml_call1(bisect_visit,19);
         return cst_invalid_index_passed_to_getter;
        case 20:
         caml_call1(bisect_visit,20);
         return cst_clip_region_not_representable_in_desired_format;
        case 21:
         caml_call1(bisect_visit,21);
         return cst_error_creating_or_writing_to_a_temporary_file;
        case 22:
         caml_call1(bisect_visit,22);return cst_invalid_value_for_stride;
        case 23:
         caml_call1(bisect_visit,23);
         return cst_the_font_type_is_not_appropriate_for_the_operation;
        case 24:
         caml_call1(bisect_visit,24);return cst_the_user_font_is_immutable;
        case 25:
         caml_call1(bisect_visit,25);
         return cst_error_occurred_in_a_user_font_callback_function;
        case 26:
         caml_call1(bisect_visit,26);
         return cst_negative_number_used_where_it_is_not_allowed;
        case 27:
         caml_call1(bisect_visit,27);
         return cst_input_clusters_do_not_represent_the_accompanying_text_and_glyph_arrays;
        case 28:
         caml_call1(bisect_visit,28);
         return cst_invalid_value_for_an_input_cairo_font_slant_t;
        case 29:
         caml_call1(bisect_visit,29);
         return cst_invalid_value_for_an_input_cairo_font_weight_t;
        case 30:
         caml_call1(bisect_visit,30);
         return cst_invalid_value_typically_too_big_for_the_size_of_the_input_surface_pattern_etc;
        case 31:
         caml_call1(bisect_visit,31);
         return cst_user_font_method_not_implemented;
        case 32:
         caml_call1(bisect_visit,32);
         return cst_the_device_type_is_not_appropriate_for_the_operation;
        case 33:
         caml_call1(bisect_visit,33);
         return cst_an_operation_to_the_device_caused_an_unspecified_error;
        case 34:
         caml_call1(bisect_visit,34);
         return cst_invalid_operation_during_mesh_pattern_construction;
        case 35:
         caml_call1(bisect_visit,35);
         return cst_the_target_device_has_been_finished;
        default:
         caml_call1(bisect_visit,36);
         return cst_CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID_used_but_no_CAIRO_MIME_TYPE_JBIG2_GLOBAL_data_provided}}
    caml_call1(bisect_visit,40);
    var Unavailable=[248,cst_CairoMock_Mock_Unavailable,caml_fresh_oo_id(0)];
    function init_identity(param)
     {caml_call1(bisect_visit,41);return [254,1,0,0,1,0,0]}
    function init_translate(x,y)
     {caml_call1(bisect_visit,42);return [254,1,0,0,1,x,y]}
    function init_scale(x,y)
     {caml_call1(bisect_visit,43);return [254,x,0,0,y,0,0]}
    function init_rotate(angle)
     {caml_call1(bisect_visit,44);
      return [254,
              Math.cos(angle),
              Math.sin(angle),
              - Math.sin(angle),
              Math.cos(angle),
              0,
              0]}
    function init_inverse(param)
     {var
       xx=param[1],
       yx=param[2],
       xy=param[3],
       yy=param[4],
       x0=param[5],
       y0=param[6];
      caml_call1(bisect_visit,56);
      caml_call1(bisect_visit,54);
      var d=xx * yy - xy * yx;
      caml_call1(bisect_visit,55);
      if(d == 0){caml_call1(bisect_visit,52);throw [0,Error,3]}
      caml_call1(bisect_visit,53);
      caml_call1(bisect_visit,45);
      var xx$0=yy / d;
      caml_call1(bisect_visit,46);
      var xy$0=- xy / d;
      caml_call1(bisect_visit,47);
      var yx$0=- yx / d;
      caml_call1(bisect_visit,48);
      var yy$0=xx / d;
      caml_call1(bisect_visit,49);
      var x0$0=(xy * y0 - yy * x0) / d;
      caml_call1(bisect_visit,50);
      var y0$0=(yx * x0 - xx * y0) / d;
      caml_call1(bisect_visit,51);
      return [254,xx$0,yx$0,xy$0,yy$0,x0$0,y0$0]}
    function multiply(param)
     {var
       xx=param[1],
       yx=param[2],
       xy=param[3],
       yy=param[4],
       x0=param[5],
       y0=param[6];
      return function(param)
       {var
         xx$0=param[1],
         yx$0=param[2],
         xy$0=param[3],
         yy$0=param[4],
         x0$0=param[5],
         y0$0=param[6];
        caml_call1(bisect_visit,64);
        caml_call1(bisect_visit,57);
        var xx$1=xx * xx$0 + xy * yx$0;
        caml_call1(bisect_visit,58);
        var xy$1=xx * xy$0 + xy * yy$0;
        caml_call1(bisect_visit,59);
        var yx$1=yx * xx$0 + yy * yx$0;
        caml_call1(bisect_visit,60);
        var yy$1=yx * xy$0 + yy * yy$0;
        caml_call1(bisect_visit,61);
        var x0$1=xx * x0$0 + xy * y0$0 + x0;
        caml_call1(bisect_visit,62);
        var y0$1=yx * x0$0 + yy * y0$0 + y0;
        caml_call1(bisect_visit,63);
        return [254,xx$1,yx$1,xy$1,yy$1,x0$1,y0$1]}}
    function transform_point(param)
     {var
       xx=param[1],
       yx=param[2],
       xy=param[3],
       yy=param[4],
       x0=param[5],
       y0=param[6];
      return function(x,y)
       {caml_call1(bisect_visit,65);
        return [0,xx * x + xy * y + x0,yx * x + yy * y + y0]}}
    function transform_distance(param)
     {var xx=param[1],yx=param[2],xy=param[3],yy=param[4];
      return function(dx,dy)
       {caml_call1(bisect_visit,66);
        return [0,xx * dx + xy * dy,yx * dx + yy * dy]}}
    function set(m,param)
     {var
       xx=param[1],
       yx=param[2],
       xy=param[3],
       yy=param[4],
       x0=param[5],
       y0=param[6];
      caml_call1(bisect_visit,72);
      m[1] = xx;
      caml_call1(bisect_visit,71);
      m[3] = xy;
      caml_call1(bisect_visit,70);
      m[2] = yx;
      caml_call1(bisect_visit,69);
      m[4] = yy;
      caml_call1(bisect_visit,68);
      m[5] = x0;
      caml_call1(bisect_visit,67);
      m[6] = y0;
      return 0}
    function scale(m,x,y)
     {caml_call1(bisect_visit,73);
      var _dE_=init_scale(x,y);
      return set(m,caml_call1(multiply(m),_dE_))}
    function translate(m,x,y)
     {caml_call1(bisect_visit,74);
      var _dD_=init_translate(x,y);
      return set(m,caml_call1(multiply(m),_dD_))}
    function rotate(m,angle)
     {caml_call1(bisect_visit,75);
      var _dC_=init_rotate(angle);
      return set(m,caml_call1(multiply(m),_dC_))}
    function invert(m)
     {caml_call1(bisect_visit,76);return set(m,init_inverse(m))}
    caml_call1(bisect_visit,80);
    caml_call1(bisect_visit,81);
    var size=Stdlib_listLabels[1],empty=0;
    function add(xs,stop_point)
     {caml_call1(bisect_visit,90);
      caml_call1(bisect_visit,88);
      var param=[0,caml_call1(Stdlib_listLabels[1],xs),stop_point];
      caml_call1(bisect_visit,89);
      var aux=function _dB_(_dA_){return _dB_.fun(_dA_)};
      caml_call1(bisect_visit,86);
      caml_update_dummy
       (aux,
        function(xxs)
         {if(xxs)
           {var xs=xxs[2],x=xxs[1];
            caml_call1(bisect_visit,85);
            var
             position_b=x[2][1],
             added_b=x[1],
             match=param[2],
             position_a=match[1],
             added_a=param[1];
            caml_call1(bisect_visit,79);
            var
             n=caml_float_compare(position_a,position_b),
             match$0=
              0 === n
               ?(caml_call1(bisect_visit,77),
                 caml_int_compare(added_a,added_b))
               :(caml_call1(bisect_visit,78),n);
            return -1 === match$0
                    ?(caml_call1(bisect_visit,82),[0,param,xxs])
                    :(caml_call1(bisect_visit,83),[0,x,caml_call1(aux,xs)])}
          caml_call1(bisect_visit,84);
          return [0,param,0]});
      caml_call1(bisect_visit,87);
      return caml_call1(aux,xs)}
    caml_call1(bisect_visit,97);
    var xs=add(empty,_b_);
    caml_call1(bisect_visit,96);
    caml_call1(bisect_visit,92);
    function _a_(param)
     {var stop_point=param[2];caml_call1(bisect_visit,91);return stop_point}
    caml_call2(Stdlib_listLabels[17],_a_,xs);
    function create_rgba(r,g,b,a)
     {caml_call1(bisect_visit,98);return [0,[0,[0,r,g,b,a]]]}
    function create_rgb(r,g,b)
     {caml_call1(bisect_visit,99);return create_rgba(r,g,b,1)}
    function get_rgba(pattern)
     {caml_call1(bisect_visit,104);
      var _dz_=pattern[1];
      if(typeof _dz_ !== "number" && 0 === _dz_[0])
       {var color=_dz_[1];caml_call1(bisect_visit,100);return color}
      if(typeof _dz_ === "number")
       caml_call1(bisect_visit,103);
      else
       switch(_dz_[0])
        {case 0:break;
         case 1:caml_call1(bisect_visit,101);break;
         default:caml_call1(bisect_visit,102)}
      throw [0,Error,12]}
    function create_linear(x0,y0,x1,y1)
     {caml_call1(bisect_visit,105);return [0,[1,[0,[0,x0,y0,x1,y1],empty]]]}
    function get_linear_points(pattern)
     {caml_call1(bisect_visit,110);
      var _dy_=pattern[1];
      if(typeof _dy_ !== "number" && 1 === _dy_[0])
       {var match=_dy_[1],points=match[1];
        caml_call1(bisect_visit,106);
        return points}
      if(typeof _dy_ === "number")
       caml_call1(bisect_visit,109);
      else
       switch(_dy_[0])
        {case 0:caml_call1(bisect_visit,107);break;
         case 1:break;
         default:caml_call1(bisect_visit,108)}
      throw [0,Error,12]}
    function create_radial(x0,y0,r0,x1,y1,r1)
     {caml_call1(bisect_visit,111);
      return [0,[2,[0,[0,x0,y0,r0,x1,y1,r1],empty]]]}
    function get_radial_circles(pattern)
     {caml_call1(bisect_visit,116);
      var _dx_=pattern[1];
      if(typeof _dx_ !== "number" && 2 === _dx_[0])
       {var match=_dx_[1],circles=match[1];
        caml_call1(bisect_visit,112);
        return circles}
      if(typeof _dx_ === "number")
       caml_call1(bisect_visit,115);
      else
       switch(_dx_[0])
        {case 0:caml_call1(bisect_visit,114);break;
         case 1:caml_call1(bisect_visit,113);break
         }
      throw [0,Error,12]}
    function add_color_stop_rgba(pattern,opt,r,g,b,a)
     {if(opt)
       var sth=opt[1],ofs=sth;
      else
       {caml_call1(bisect_visit,124);var ofs=0}
      caml_call1(bisect_visit,123);
      caml_call1(bisect_visit,121);
      var stop_point=[0,ofs,r,g,b,a];
      caml_call1(bisect_visit,122);
      var _du_=pattern[1];
      if(typeof _du_ === "number")
       {caml_call1(bisect_visit,120);return 0}
      else
       switch(_du_[0])
        {case 0:caml_call1(bisect_visit,119);pattern[1] = 0;return 0;
         case 1:
          var gradient=_du_[1];
          caml_call1(bisect_visit,117);
          var _dv_=add(gradient[2],stop_point);
          pattern[1] = [1,[0,gradient[1],_dv_]];
          return 0;
         default:
          var gradient$0=_du_[1];
          caml_call1(bisect_visit,118);
          var _dw_=add(gradient$0[2],stop_point);
          pattern[1] = [2,[0,gradient$0[1],_dw_]];
          return 0}}
    function add_color_stop_rgb(pattern,ofs,r,g,b)
     {caml_call1(bisect_visit,125);
      return add_color_stop_rgba(pattern,ofs,r,g,b,1)}
    function get_color_stop_count(pattern)
     {caml_call1(bisect_visit,130);
      var _dt_=pattern[1];
      if(typeof _dt_ !== "number" && 0 !== _dt_[0])
       {var match=_dt_[1],stop_points=match[2];
        if(typeof _dt_ === "number")
         var switch$0=0;
        else
         switch(_dt_[0])
          {case 1:caml_call1(bisect_visit,126);var switch$0=1;break;
           case 2:caml_call1(bisect_visit,127);var switch$0=1;break;
           default:var switch$0=0}
        return caml_call1(size,stop_points)}
      if(typeof _dt_ === "number")
       caml_call1(bisect_visit,129);
      else
       if(0 === _dt_[0])caml_call1(bisect_visit,128);
      throw [0,Error,12]}
    function get_color_stop_rgba(pattern,idx)
     {caml_call1(bisect_visit,135);
      var _ds_=pattern[1];
      if(typeof _ds_ !== "number" && 0 !== _ds_[0])
       {var match$0=_ds_[1],stop_points=match$0[2];
        if(typeof _ds_ === "number")
         var switch$0=0;
        else
         switch(_ds_[0])
          {case 1:caml_call1(bisect_visit,131);var switch$0=1;break;
           case 2:caml_call1(bisect_visit,132);var switch$0=1;break;
           default:var switch$0=0}
        caml_call1(bisect_visit,95);
        caml_call1(bisect_visit,93);
        var
         match=caml_call2(Stdlib_listLabels[7],stop_points,idx),
         stop_point=match[2];
        caml_call1(bisect_visit,94);
        return stop_point}
      if(typeof _ds_ === "number")
       caml_call1(bisect_visit,134);
      else
       if(0 === _ds_[0])caml_call1(bisect_visit,133);
      throw [0,Error,12]}
    function set_start(points,transformation,x,y)
     {caml_call1(bisect_visit,137);
      points[1] = [0,caml_call2(transform_point(transformation),x,y)];
      return 0}
    function set_current(points,transformation,x,y)
     {caml_call1(bisect_visit,141);
      points[2] = [0,caml_call2(transform_point(transformation),x,y)];
      return 0}
    function current(points,transformation)
     {caml_call1(bisect_visit,146);
      var _dr_=points[2];
      if(_dr_)
       {var match=_dr_[1],y=match[2],x=match[1];
        caml_call1(bisect_visit,145);
        return [0,
                caml_call2(transform_point(init_inverse(transformation)),x,y)]}
      caml_call1(bisect_visit,144);
      return 0}
    caml_call1(bisect_visit,149);
    function _c_(param)
     {if(param[1] === Error)
       {var status=param[2];
        caml_call1(bisect_visit,147);
        switch(status)
         {case 0:
           caml_call1(bisect_visit,38);var _dq_=cst_INVALID_RESTORE;break;
          case 1:var _dq_=cst_INVALID_POP_GROUP;break;
          case 2:
           caml_call1(bisect_visit,39);var _dq_=cst_NO_CURRENT_POINT;break;
          case 3:var _dq_=cst_INVALID_MATRIX;break;
          case 4:var _dq_=cst_INVALID_STATUS;break;
          case 5:var _dq_=cst_NULL_POINTER;break;
          case 6:var _dq_=cst_INVALID_STRING;break;
          case 7:var _dq_=cst_INVALID_PATH_DATA;break;
          case 8:var _dq_=cst_READ_ERROR;break;
          case 9:var _dq_=cst_WRITE_ERROR;break;
          case 10:var _dq_=cst_SURFACE_FINISHED;break;
          case 11:var _dq_=cst_SURFACE_TYPE_MISMATCH;break;
          case 12:var _dq_=cst_PATTERN_TYPE_MISMATCH;break;
          case 13:var _dq_=cst_INVALID_CONTENT;break;
          case 14:var _dq_=cst_INVALID_FORMAT;break;
          case 15:var _dq_=cst_INVALID_VISUAL;break;
          case 16:var _dq_=cst_FILE_NOT_FOUND;break;
          case 17:var _dq_=cst_INVALID_DASH;break;
          case 18:var _dq_=cst_INVALID_DSC_COMMENT;break;
          case 19:var _dq_=cst_INVALID_INDEX;break;
          case 20:var _dq_=cst_CLIP_NOT_REPRESENTABLE;break;
          case 21:var _dq_=cst_TEMP_FILE_ERROR;break;
          case 22:var _dq_=cst_INVALID_STRIDE;break;
          case 23:var _dq_=cst_FONT_TYPE_MISMATCH;break;
          case 24:var _dq_=cst_USER_FONT_IMMUTABLE;break;
          case 25:var _dq_=cst_USER_FONT_ERROR;break;
          case 26:var _dq_=cst_NEGATIVE_COUNT;break;
          case 27:var _dq_=cst_INVALID_CLUSTERS;break;
          case 28:var _dq_=cst_INVALID_SLANT;break;
          case 29:var _dq_=cst_INVALID_WEIGHT;break;
          case 30:var _dq_=cst_INVALID_SIZE;break;
          case 31:var _dq_=cst_USER_FONT_NOT_IMPLEMENTED;break;
          case 32:var _dq_=cst_DEVICE_TYPE_MISMATCH;break;
          case 33:var _dq_=cst_DEVICE_ERROR;break;
          case 34:var _dq_=cst_INVALID_MESH_CONSTRUCTION;break;
          case 35:var _dq_=cst_DEVICE_FINISHED;break;
          default:var _dq_=cst_JBIG2_GLOBAL_MISSING}
        return [0,caml_call2(Stdlib_printf[4],_d_,_dq_)]}
      caml_call1(bisect_visit,148);
      return 0}
    caml_call1(Stdlib_printexc[8],_c_);
    function create(param)
     {caml_call1(bisect_visit,150);
      caml_call1(bisect_visit,136);
      var _dp_=init_identity(0);
      return [0,
              [0,[0,[0],0,_e_,0,0,2,10,0,2,create_rgb(0,0,0)[1],_dp_],0],
              [0,0,0]]}
    function state(param)
     {var states=param[1];
      caml_call1(bisect_visit,151);
      return caml_call1(Stdlib_listLabels[2],states)}
    function mutate_state(context,f)
     {caml_call1(bisect_visit,154);
      caml_call1(bisect_visit,152);
      var state$0=caml_call1(f,state(context));
      caml_call1(bisect_visit,153);
      context[1] = [0,state$0,caml_call1(Stdlib_listLabels[6],context[1])];
      return 0}
    function save(context)
     {caml_call1(bisect_visit,155);
      var _do_=context[1];
      context[1] = [0,state(context),_do_];
      return 0}
    function restore(context)
     {caml_call1(bisect_visit,160);
      caml_call1(bisect_visit,158);
      var _dm_=context[1];
      if(_dm_)
       {var _dn_=_dm_[2];
        if(_dn_)
         {caml_call1(bisect_visit,157);
          caml_call1(bisect_visit,159);
          context[1] = _dn_;
          return 0}}
      if(_dm_)if(! _dm_[2])caml_call1(bisect_visit,156);
      throw [0,Error,0]}
    function set_matrix(context,transformation)
     {caml_call1(bisect_visit,162);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,161);
                 return [0,
                         s[1],
                         s[2],
                         s[3],
                         s[4],
                         s[5],
                         s[6],
                         s[7],
                         s[8],
                         s[9],
                         s[10],
                         transformation]})}
    function get_matrix(context)
     {caml_call1(bisect_visit,163);return state(context)[11]}
    function transform(m,init)
     {caml_call1(bisect_visit,164);
      var _dl_=caml_call1(multiply(init[11]),m);
      return [0,
              init[1],
              init[2],
              init[3],
              init[4],
              init[5],
              init[6],
              init[7],
              init[8],
              init[9],
              init[10],
              _dl_]}
    function transform$0(context,m)
     {caml_call1(bisect_visit,165);
      return mutate_state(context,function(_dk_){return transform(m,_dk_)})}
    function scale$0(context,x,y)
     {caml_call1(bisect_visit,166);
      var _di_=init_scale(x,y);
      return mutate_state(context,function(_dj_){return transform(_di_,_dj_)})}
    function translate$0(context,x,y)
     {caml_call1(bisect_visit,167);
      var _dg_=init_translate(x,y);
      return mutate_state(context,function(_dh_){return transform(_dg_,_dh_)})}
    function rotate$0(context,angle)
     {caml_call1(bisect_visit,168);
      var _de_=init_rotate(angle);
      return mutate_state(context,function(_df_){return transform(_de_,_df_)})}
    function identity_matrix(context)
     {caml_call1(bisect_visit,170);
      return mutate_state
              (context,
               function(init)
                {caml_call1(bisect_visit,169);
                 var _dd_=init_identity(0);
                 return [0,
                         init[1],
                         init[2],
                         init[3],
                         init[4],
                         init[5],
                         init[6],
                         init[7],
                         init[8],
                         init[9],
                         init[10],
                         _dd_]})}
    function device_to_user(context,x,y)
     {caml_call1(bisect_visit,171);
      return caml_call2(transform_point(init_inverse(state(context)[11])),x,y)}
    function device_to_user_distance(context,dx,dy)
     {caml_call1(bisect_visit,172);
      return caml_call2
              (transform_distance(init_inverse(state(context)[11])),dx,dy)}
    function user_to_device(context,x,y)
     {caml_call1(bisect_visit,173);
      return caml_call2(transform_point(state(context)[11]),x,y)}
    function user_to_device_distance(context,dx,dy)
     {caml_call1(bisect_visit,174);
      return caml_call2(transform_distance(state(context)[11]),dx,dy)}
    function mutate_points(context,start,current$0)
     {caml_call1(bisect_visit,197);
      caml_call1(bisect_visit,195);
      var transformation=state(context)[11];
      caml_call1(bisect_visit,196);
      function make_relative(dx,dy)
       {caml_call1(bisect_visit,193);
        caml_call1(bisect_visit,191);
        var match=current(context[2],transformation);
        if(match)
         {var match$0=match[1],y=match$0[2],x=match$0[1];
          caml_call1(bisect_visit,190);
          caml_call1(bisect_visit,192);
          return [0,x + dx,y + dy]}
        caml_call1(bisect_visit,189);
        throw [0,Error,2]}
      caml_call1(bisect_visit,194);
      if(typeof start === "number")
       if(870530776 <= start)
        caml_call1(bisect_visit,183);
       else
        {caml_call1(bisect_visit,184);
         var _da_=context[2];
         caml_call1(bisect_visit,140);
         _da_[1] = 0}
      else
       {var _db_=start[1];
        if(260471020 === _db_)
         {var match$2=start[2],dy$0=match$2[2],dx$0=match$2[1];
          caml_call1(bisect_visit,187);
          caml_call1(bisect_visit,181);
          var match$3=make_relative(dx$0,dy$0),y$1=match$3[2],x$1=match$3[1];
          caml_call1(bisect_visit,182);
          set_start(context[2],transformation,x$1,y$1)}
        else
         if(516931925 <= _db_)
          {var match$4=start[2],y$2=match$4[2],x$2=match$4[1];
           caml_call1(bisect_visit,185);
           var _dc_=context[2];
           caml_call1(bisect_visit,139);
           if(0 === _dc_[1])
            {caml_call1(bisect_visit,138);
             _dc_[1] = [0,caml_call2(transform_point(transformation),x$2,y$2)]}}
         else
          {var match$5=start[2],y$3=match$5[2],x$3=match$5[1];
           caml_call1(bisect_visit,186);
           set_start(context[2],transformation,x$3,y$3)}}
      caml_call1(bisect_visit,188);
      if(typeof current$0 === "number")
       {if(-101336657 <= current$0)
         {caml_call1(bisect_visit,177);
          var _c__=context[2];
          caml_call1(bisect_visit,143);
          _c__[2] = 0;
          return 0}
        caml_call1(bisect_visit,178);
        var _c$_=context[2];
        caml_call1(bisect_visit,142);
        _c$_[2] = _c$_[1];
        return 0}
      if(260471020 <= current$0[1])
       {var match=current$0[2],dy=match[2],dx=match[1];
        caml_call1(bisect_visit,180);
        caml_call1(bisect_visit,175);
        var match$0=make_relative(dx,dy),y=match$0[2],x=match$0[1];
        caml_call1(bisect_visit,176);
        return set_current(context[2],transformation,x,y)}
      var match$1=current$0[2],y$0=match$1[2],x$0=match$1[1];
      caml_call1(bisect_visit,179);
      return set_current(context[2],transformation,x$0,y$0)}
    function move_to(context,x,y)
     {caml_call1(bisect_visit,198);
      return mutate_points(context,[0,4150146,[0,x,y]],-630768008)}
    function rel_move_to(context,x,y)
     {caml_call1(bisect_visit,199);
      return mutate_points(context,[0,260471020,[0,x,y]],-630768008)}
    function line_to(context,x,y)
     {caml_call1(bisect_visit,200);
      return mutate_points(context,[0,516931925,[0,x,y]],[0,4150146,[0,x,y]])}
    function rel_line_to(context,x,y)
     {caml_call1(bisect_visit,201);
      return mutate_points
              (context,[0,516931925,[0,x,y]],[0,260471020,[0,x,y]])}
    function curve_to(context,x1,y1,param,_c9_,x3,y3)
     {caml_call1(bisect_visit,202);
      return mutate_points
              (context,[0,516931925,[0,x1,y1]],[0,4150146,[0,x3,y3]])}
    function rel_curve_to(context,x1,y1,param,_c8_,x3,y3)
     {caml_call1(bisect_visit,203);
      return mutate_points
              (context,[0,516931925,[0,x1,y1]],[0,260471020,[0,x3,y3]])}
    function rectangle(context,x,y,param,_c7_)
     {caml_call1(bisect_visit,204);
      return mutate_points(context,870530776,[0,4150146,[0,x,y]])}
    function arc(context,x,y,r,a1,a2)
     {caml_call1(bisect_visit,205);
      return mutate_points
              (context,
               [0,516931925,[0,x + r * Math.cos(a1),y + r * Math.sin(a1)]],
               [0,4150146,[0,x + r * Math.cos(a2),y + r * Math.sin(a2)]])}
    function arc_negative(context,x,y,r,a1,a2)
     {caml_call1(bisect_visit,206);
      return mutate_points
              (context,
               [0,516931925,[0,x + r * Math.cos(a1),y + r * Math.sin(a1)]],
               [0,4150146,[0,x + r * Math.cos(a2),y + r * Math.sin(a2)]])}
    function get_current_point(context)
     {caml_call1(bisect_visit,211);
      caml_call1(bisect_visit,209);
      var transformation=state(context)[11];
      caml_call1(bisect_visit,210);
      var match=current(context[2],transformation);
      if(match)
       {var match$0=match[1],y=match$0[2],x=match$0[1];
        caml_call1(bisect_visit,208);
        return [0,x,y]}
      caml_call1(bisect_visit,207);
      return _f_}
    function clear(context)
     {caml_call1(bisect_visit,212);
      return mutate_points(context,-101336657,-101336657)}
    function close(context)
     {caml_call1(bisect_visit,213);
      return mutate_points(context,870530776,-630768008)}
    var Path=[0,get_current_point,clear,close];
    function stroke_preserve(param){caml_call1(bisect_visit,214);return 0}
    function stroke(context)
     {caml_call1(bisect_visit,215);
      return mutate_points(context,-101336657,-101336657)}
    function fill_preserve(param){caml_call1(bisect_visit,216);return 0}
    function fill(context)
     {caml_call1(bisect_visit,217);
      return mutate_points(context,-101336657,-101336657)}
    function clip_preserve(param){caml_call1(bisect_visit,218);return 0}
    function clip(context)
     {caml_call1(bisect_visit,219);
      return mutate_points(context,-101336657,-101336657)}
    function paint(param,_c6_){caml_call1(bisect_visit,220);return 0}
    function set_line_width(context,line_width)
     {caml_call1(bisect_visit,222);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,221);
                 return [0,
                         s[1],
                         s[2],
                         s[3],
                         s[4],
                         s[5],
                         line_width,
                         s[7],
                         s[8],
                         s[9],
                         s[10],
                         s[11]]})}
    function get_line_width(context)
     {caml_call1(bisect_visit,223);return state(context)[6]}
    function set_dash(context,opt,dashes)
     {if(opt)
       var sth=opt[1],ofs=sth;
      else
       {caml_call1(bisect_visit,226);var ofs=0}
      caml_call1(bisect_visit,225);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,224);
                 return [0,
                         dashes,
                         s[2],
                         s[3],
                         s[4],
                         s[5],
                         s[6],
                         s[7],
                         ofs,
                         s[9],
                         s[10],
                         s[11]]})}
    function get_dash(context)
     {caml_call1(bisect_visit,229);
      caml_call1(bisect_visit,227);
      var state$0=state(context);
      caml_call1(bisect_visit,228);
      return [0,state$0[1],state$0[8]]}
    function set_fill_rule(context,fill_rule)
     {caml_call1(bisect_visit,231);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,230);
                 return [0,
                         s[1],
                         fill_rule,
                         s[3],
                         s[4],
                         s[5],
                         s[6],
                         s[7],
                         s[8],
                         s[9],
                         s[10],
                         s[11]]})}
    function get_fill_rule(context)
     {caml_call1(bisect_visit,232);return state(context)[2]}
    function set_line_cap(context,line_cap)
     {caml_call1(bisect_visit,234);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,233);
                 return [0,
                         s[1],
                         s[2],
                         s[3],
                         line_cap,
                         s[5],
                         s[6],
                         s[7],
                         s[8],
                         s[9],
                         s[10],
                         s[11]]})}
    function get_line_cap(context)
     {caml_call1(bisect_visit,235);return state(context)[4]}
    function set_line_join(context,line_join)
     {caml_call1(bisect_visit,237);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,236);
                 return [0,
                         s[1],
                         s[2],
                         s[3],
                         s[4],
                         line_join,
                         s[6],
                         s[7],
                         s[8],
                         s[9],
                         s[10],
                         s[11]]})}
    function get_line_join(context)
     {caml_call1(bisect_visit,238);return state(context)[5]}
    function set_miter_limit(context,miter_limit)
     {caml_call1(bisect_visit,240);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,239);
                 return [0,
                         s[1],
                         s[2],
                         s[3],
                         s[4],
                         s[5],
                         s[6],
                         miter_limit,
                         s[8],
                         s[9],
                         s[10],
                         s[11]]})}
    function get_miter_limit(context)
     {caml_call1(bisect_visit,241);return state(context)[7]}
    function set_operator(context,operator)
     {caml_call1(bisect_visit,243);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,242);
                 return [0,
                         s[1],
                         s[2],
                         s[3],
                         s[4],
                         s[5],
                         s[6],
                         s[7],
                         s[8],
                         operator,
                         s[10],
                         s[11]]})}
    function get_operator(context)
     {caml_call1(bisect_visit,244);return state(context)[9]}
    function set_source(context,pattern)
     {caml_call1(bisect_visit,248);
      caml_call1(bisect_visit,246);
      var source=pattern[1];
      caml_call1(bisect_visit,247);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,245);
                 return [0,
                         s[1],
                         s[2],
                         s[3],
                         s[4],
                         s[5],
                         s[6],
                         s[7],
                         s[8],
                         s[9],
                         source,
                         s[11]]})}
    function get_source(context)
     {caml_call1(bisect_visit,249);return [0,state(context)[10]]}
    function set_source_rgb(context,r,g,b)
     {caml_call1(bisect_visit,253);
      caml_call1(bisect_visit,251);
      var source=create_rgb(r,g,b)[1];
      caml_call1(bisect_visit,252);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,250);
                 return [0,
                         s[1],
                         s[2],
                         s[3],
                         s[4],
                         s[5],
                         s[6],
                         s[7],
                         s[8],
                         s[9],
                         source,
                         s[11]]})}
    function set_source_rgba(context,r,g,b,a)
     {caml_call1(bisect_visit,257);
      caml_call1(bisect_visit,255);
      var source=create_rgba(r,g,b,a)[1];
      caml_call1(bisect_visit,256);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,254);
                 return [0,
                         s[1],
                         s[2],
                         s[3],
                         s[4],
                         s[5],
                         s[6],
                         s[7],
                         s[8],
                         s[9],
                         source,
                         s[11]]})}
    function select_font_face(context,opt,_c5_,family)
     {if(opt)
       var sth=opt[1],slant=sth;
      else
       {caml_call1(bisect_visit,261);var slant=0}
      if(_c5_)
       var sth$0=_c5_[1],weight=sth$0;
      else
       {caml_call1(bisect_visit,260);var weight=0}
      caml_call1(bisect_visit,259);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,258);
                 return [0,
                         s[1],
                         s[2],
                         [0,slant,weight,s[3][3],family],
                         s[4],
                         s[5],
                         s[6],
                         s[7],
                         s[8],
                         s[9],
                         s[10],
                         s[11]]})}
    function set_font_size(context,size)
     {caml_call1(bisect_visit,263);
      return mutate_state
              (context,
               function(s)
                {caml_call1(bisect_visit,262);
                 var _c4_=s[3];
                 return [0,
                         s[1],
                         s[2],
                         [0,_c4_[1],_c4_[2],size,_c4_[4]],
                         s[4],
                         s[5],
                         s[6],
                         s[7],
                         s[8],
                         s[9],
                         s[10],
                         s[11]]})}
    function show_text(context,s)
     {caml_call1(bisect_visit,267);
      caml_call1(bisect_visit,264);
      var match=caml_call1(Path[1],context),_c2_=match[2],_c3_=match[1];
      caml_call1(bisect_visit,265);
      var width=state(context)[3][3] * 0.8 * caml_ml_string_length(s);
      caml_call1(bisect_visit,266);
      return mutate_points
              (context,870530776,[0,4150146,[0,_c3_ + width,_c2_]])}
    function font_extents(context)
     {caml_call1(bisect_visit,270);
      caml_call1(bisect_visit,268);
      var ascent=state(context)[3][3];
      caml_call1(bisect_visit,269);
      return [254,ascent,ascent / 4,0,2 * ascent,0]}
    function text_extents(context,s)
     {caml_call1(bisect_visit,274);
      caml_call1(bisect_visit,271);
      var width=state(context)[3][3] * 0.8 * caml_ml_string_length(s);
      caml_call1(bisect_visit,272);
      var height=state(context)[3][3];
      caml_call1(bisect_visit,273);
      return [254,0,0,width,height,width,0]}
    function Decorate(C)
     {var _bZ_=C[10],_b0_=C[4],_b1_=C[1],_b2_=C[3];
      caml_call1(bisect_visit,275);
      var _b3_=C[2];
      function unit(param){caml_call1(bisect_visit,276);return cst}
      function float$0(x)
       {caml_call1(bisect_visit,277);
        return caml_call2(Stdlib_printf[4],_g_,x)}
      function matrix(param)
       {var
         xx=param[1],
         yx=param[2],
         xy=param[3],
         yy=param[4],
         x0=param[5],
         y0=param[6];
        caml_call1(bisect_visit,278);
        return caml_call7(Stdlib_printf[4],_h_,xx,xy,yx,yy,x0,y0)}
      function coords(param)
       {var y=param[2],x=param[1];
        caml_call1(bisect_visit,279);
        return caml_call3(Stdlib_printf[4],_i_,x,y)}
      function dashes(dashes)
       {caml_call1(bisect_visit,284);
        caml_call1(bisect_visit,280);
        var _cY_=caml_call1(Stdlib_arrayLabels[10],dashes);
        caml_call1(bisect_visit,281);
        var
         _cZ_=caml_call1(Stdlib_printf[4],_j_),
         _c0_=caml_call1(caml_call1(Stdlib_listLabels[17],_cZ_),_cY_);
        caml_call1(bisect_visit,282);
        var _c1_=caml_call1(caml_call1(Stdlib_stringLabels[7],cst$0),_c0_);
        caml_call1(bisect_visit,283);
        return caml_call1(caml_call1(Stdlib_printf[4],_k_),_c1_)}
      function dashes_ofs(param)
       {var ofs=param[2],ds=param[1];
        caml_call1(bisect_visit,285);
        var _cX_=dashes(ds);
        return caml_call3(Stdlib_printf[4],_l_,_cX_,ofs)}
      caml_call1(bisect_visit,288);
      function fill_rule(param)
       {return 0 === param
                ?(caml_call1(bisect_visit,286),cst_WINDING)
                :(caml_call1(bisect_visit,287),cst_EVEN_ODD)}
      caml_call1(bisect_visit,292);
      function line_cap(param)
       {switch(param)
         {case 0:caml_call1(bisect_visit,289);return cst_BUTT;
          case 1:caml_call1(bisect_visit,290);return cst_ROUND;
          default:caml_call1(bisect_visit,291);return cst_SQUARE}}
      caml_call1(bisect_visit,296);
      function line_join(param)
       {switch(param)
         {case 0:caml_call1(bisect_visit,293);return cst_JOIN_MITER;
          case 1:caml_call1(bisect_visit,294);return cst_JOIN_ROUND;
          default:caml_call1(bisect_visit,295);return cst_JOIN_BEVEL}}
      caml_call1(bisect_visit,311);
      function operator(param)
       {switch(param)
         {case 0:caml_call1(bisect_visit,297);return cst_CLEAR;
          case 1:caml_call1(bisect_visit,298);return cst_SOURCE;
          case 2:caml_call1(bisect_visit,299);return cst_OVER;
          case 3:caml_call1(bisect_visit,300);return cst_IN;
          case 4:caml_call1(bisect_visit,301);return cst_OUT;
          case 5:caml_call1(bisect_visit,302);return cst_ATOP;
          case 6:caml_call1(bisect_visit,303);return cst_DEST;
          case 7:caml_call1(bisect_visit,304);return cst_DEST_OVER;
          case 8:caml_call1(bisect_visit,305);return cst_DEST_IN;
          case 9:caml_call1(bisect_visit,306);return cst_DEST_OUT;
          case 10:caml_call1(bisect_visit,307);return cst_DEST_ATOP;
          case 11:caml_call1(bisect_visit,308);return cst_XOR;
          case 12:caml_call1(bisect_visit,309);return cst_ADD;
          default:caml_call1(bisect_visit,310);return cst_SATURATE}}
      function source(source)
       {caml_call1(bisect_visit,333);
        function get(get)
         {caml_call1(bisect_visit,319);
          try
           {var _cV_=[0,caml_call1(get,source)];return _cV_}
          catch(_cW_)
           {_cW_ = caml_wrap_exception(_cW_);
            if(_cW_[1] === C[1])
             if(12 === _cW_[2]){caml_call1(bisect_visit,318);return 0}
            throw _cW_}}
        function stop_points(param)
         {caml_call1(bisect_visit,331);
          caml_call1(bisect_visit,329);
          var count=caml_call1(C[10][3],source);
          caml_call1(bisect_visit,330);
          caml_call1(bisect_visit,327);
          var stop_points=runtime.caml_make_vect(count,_m_);
          caml_call1(bisect_visit,328);
          var _cO_=count - 1 | 0,_cN_=0;
          if(! (_cO_ < 0))
           {var idx=_cN_;
            for(;;)
             {caml_call1(bisect_visit,325);
              var _cT_=caml_call2(C[10][4],source,idx);
              runtime.caml_check_bound(stop_points,idx)[idx + 1] = _cT_;
              var _cU_=idx + 1 | 0;
              if(_cO_ !== idx){var idx=_cU_;continue}
              break}}
          caml_call1(bisect_visit,326);
          caml_call1(bisect_visit,320);
          var _cP_=caml_call1(Stdlib_arrayLabels[10],stop_points);
          caml_call1(bisect_visit,322);
          function _cQ_(param)
           {var a=param[5],b=param[4],g=param[3],r=param[2],position=param[1];
            caml_call1(bisect_visit,321);
            return caml_call6(Stdlib_printf[4],_n_,position,r,g,b,a)}
          var _cR_=caml_call1(caml_call1(Stdlib_listLabels[17],_cQ_),_cP_);
          caml_call1(bisect_visit,323);
          var _cS_=caml_call1(caml_call1(Stdlib_stringLabels[7],cst$1),_cR_);
          caml_call1(bisect_visit,324);
          return caml_call1(caml_call1(Stdlib_printf[4],_o_),_cS_)}
        caml_call1(bisect_visit,332);
        var match=get(C[10][7]);
        if(match)
         {var
           match$0=match[1],
           a=match$0[4],
           b=match$0[3],
           g=match$0[2],
           r=match$0[1];
          caml_call1(bisect_visit,316);
          return caml_call5(Stdlib_printf[4],_p_,r,g,b,a)}
        caml_call1(bisect_visit,317);
        var match$1=get(C[10][9]);
        if(match$1)
         {var
           match$2=match$1[1],
           y2=match$2[4],
           x2=match$2[3],
           y1=match$2[2],
           x1=match$2[1];
          caml_call1(bisect_visit,314);
          var _cL_=stop_points(0);
          return caml_call6(Stdlib_printf[4],_q_,x1,y1,x2,y2,_cL_)}
        caml_call1(bisect_visit,315);
        caml_call1(bisect_visit,312);
        var
         match$3=caml_call1(C[10][11],source),
         r2=match$3[6],
         y2$0=match$3[5],
         x2$0=match$3[4],
         r1=match$3[3],
         y1$0=match$3[2],
         x1$0=match$3[1];
        caml_call1(bisect_visit,313);
        var _cM_=stop_points(0);
        return caml_call8(Stdlib_printf[4],_r_,x1$0,y1$0,r1,x2$0,y2$0,r2,_cM_)}
      function font_extents(param)
       {var
         max_y_advance=param[5],
         max_x_advance=param[4],
         baseline=param[3],
         descent=param[2],
         ascent=param[1];
        caml_call1(bisect_visit,334);
        return caml_call6
                (Stdlib_printf[4],
                 _s_,
                 ascent,
                 descent,
                 baseline,
                 max_x_advance,
                 max_y_advance)}
      function text_extents(param)
       {var
         y_advance=param[6],
         x_advance=param[5],
         height=param[4],
         width=param[3],
         y_bearing=param[2],
         x_bearing=param[1];
        caml_call1(bisect_visit,335);
        return caml_call7
                (Stdlib_printf[4],
                 _t_,
                 x_bearing,
                 y_bearing,
                 width,
                 height,
                 x_advance,
                 y_advance)}
      caml_call1(bisect_visit,339);
      function slant(param)
       {switch(param)
         {case 0:caml_call1(bisect_visit,336);return cst_Upright;
          case 1:caml_call1(bisect_visit,337);return cst_Italic;
          default:caml_call1(bisect_visit,338);return cst_Oblique}}
      caml_call1(bisect_visit,342);
      function weight(param)
       {return 0 === param
                ?(caml_call1(bisect_visit,340),cst_Normal)
                :(caml_call1(bisect_visit,341),cst_Bold)}
      var
       P=
        [0,
         unit,
         float$0,
         matrix,
         coords,
         dashes,
         dashes_ofs,
         fill_rule,
         line_cap,
         line_join,
         operator,
         source,
         font_extents,
         text_extents,
         slant,
         weight];
      function matrix$0(param){caml_call1(bisect_visit,343);return P[3]}
      function operator$0(param){caml_call1(bisect_visit,344);return P[10]}
      function fill_rule$0(param){caml_call1(bisect_visit,345);return P[7]}
      function line_cap$0(param){caml_call1(bisect_visit,346);return P[8]}
      function line_join$0(param){caml_call1(bisect_visit,347);return P[9]}
      function source$0(param){caml_call1(bisect_visit,348);return P[11]}
      function dashes$0(param){caml_call1(bisect_visit,349);return P[5]}
      function option(name,p,param)
       {caml_call1(bisect_visit,352);
        return function(param)
         {if(param)
           {var x=param[1];
            caml_call1(bisect_visit,351);
            var _cK_=caml_call1(p,x);
            return caml_call3(Stdlib_printf[4],_u_,name,_cK_)}
          caml_call1(bisect_visit,350);
          return cst$2}}
      var
       A=
        [0,
         matrix$0,
         operator$0,
         fill_rule$0,
         line_cap$0,
         line_join$0,
         source$0,
         dashes$0,
         option];
      function create(c){caml_call1(bisect_visit,353);return [0,c,0]}
      function calls(param)
       {var calls=param[2];
        caml_call1(bisect_visit,354);
        return caml_call1(Stdlib_listLabels[9],calls)}
      function call(context,format)
       {caml_call1(bisect_visit,369);
        function _cI_(call,print_ret,f)
         {caml_call1(bisect_visit,368);
          try
           {caml_call1(bisect_visit,365);
            var ret=caml_call1(f,context[1]);
            caml_call1(bisect_visit,366);
            caml_call1(bisect_visit,363);
            var printed_ret=caml_call1(print_ret,ret);
            caml_call1(bisect_visit,364);
            caml_call1(bisect_visit,361);
            var
             call$1=
              caml_string_notequal(printed_ret,cst$3)
               ?(caml_call1(bisect_visit,360),
                 caml_call3(Stdlib_printf[4],_w_,call,printed_ret))
               :(caml_call1(bisect_visit,359),call);
            caml_call1(bisect_visit,362);
            context[2] = [0,call$1,context[2]];
            caml_call1(bisect_visit,358);
            return ret}
          catch(ex)
           {ex = caml_wrap_exception(ex);
            caml_call1(bisect_visit,367);
            caml_call1(bisect_visit,356);
            var
             _cJ_=caml_call1(Stdlib_printexc[1],ex),
             call$0=caml_call3(Stdlib_printf[4],_v_,call,_cJ_);
            caml_call1(bisect_visit,357);
            context[2] = [0,call$0,context[2]];
            caml_call1(bisect_visit,355);
            throw ex}}
        return caml_call2(Stdlib_printf[9],_cI_,format)}
      var Context=[0,create,call,calls];
      caml_call1(bisect_visit,370);
      var _b4_=Context[1];
      caml_call1(bisect_visit,371);
      var calls$0=Context[3];
      function save(context)
       {caml_call1(bisect_visit,372);
        return caml_call4(Context[2],context,_x_,P[1],C[11])}
      function restore(context)
       {caml_call1(bisect_visit,373);
        return caml_call4(Context[2],context,_y_,P[1],C[12])}
      function set_matrix(context,m)
       {caml_call1(bisect_visit,375);
        function _cH_(c)
         {caml_call1(bisect_visit,374);return caml_call2(C[52],c,m)}
        return caml_call6(Context[2],context,_z_,A[1],m,P[1],_cH_)}
      function get_matrix(context)
       {caml_call1(bisect_visit,376);
        return caml_call4(Context[2],context,_A_,P[3],C[53])}
      function transform(context,m)
       {caml_call1(bisect_visit,378);
        function _cG_(c)
         {caml_call1(bisect_visit,377);return caml_call2(C[51],c,m)}
        return caml_call6(Context[2],context,_B_,A[1],m,P[1],_cG_)}
      function scale(context,x,y)
       {caml_call1(bisect_visit,380);
        function _cF_(c)
         {caml_call1(bisect_visit,379);return caml_call3(C[49],c,x,y)}
        return caml_call6(Context[2],context,_C_,x,y,P[1],_cF_)}
      function translate(context,x,y)
       {caml_call1(bisect_visit,382);
        function _cE_(c)
         {caml_call1(bisect_visit,381);return caml_call3(C[48],c,x,y)}
        return caml_call6(Context[2],context,_D_,x,y,P[1],_cE_)}
      function rotate(context,angle)
       {caml_call1(bisect_visit,384);
        function _cD_(c)
         {caml_call1(bisect_visit,383);return caml_call2(C[50],c,angle)}
        return caml_call5(Context[2],context,_E_,angle,P[1],_cD_)}
      function identity_matrix(context)
       {caml_call1(bisect_visit,385);
        return caml_call4(Context[2],context,_F_,P[1],C[54])}
      function device_to_user(context,x,y)
       {caml_call1(bisect_visit,387);
        function _cC_(c)
         {caml_call1(bisect_visit,386);return caml_call3(C[57],c,x,y)}
        return caml_call6(Context[2],context,_G_,x,y,P[4],_cC_)}
      function device_to_user_distance(context,x,y)
       {caml_call1(bisect_visit,389);
        function _cB_(c)
         {caml_call1(bisect_visit,388);return caml_call3(C[58],c,x,y)}
        return caml_call6(Context[2],context,_H_,x,y,P[4],_cB_)}
      function user_to_device(context,x,y)
       {caml_call1(bisect_visit,391);
        function _cA_(c)
         {caml_call1(bisect_visit,390);return caml_call3(C[55],c,x,y)}
        return caml_call6(Context[2],context,_I_,x,y,P[4],_cA_)}
      function user_to_device_distance(context,x,y)
       {caml_call1(bisect_visit,393);
        function _cz_(c)
         {caml_call1(bisect_visit,392);return caml_call3(C[56],c,x,y)}
        return caml_call6(Context[2],context,_J_,x,y,P[4],_cz_)}
      function move_to(context,x,y)
       {caml_call1(bisect_visit,395);
        function _cy_(c)
         {caml_call1(bisect_visit,394);return caml_call3(C[43],c,x,y)}
        return caml_call6(Context[2],context,_K_,x,y,P[1],_cy_)}
      function rel_move_to(context,x,y)
       {caml_call1(bisect_visit,397);
        function _cx_(c)
         {caml_call1(bisect_visit,396);return caml_call3(C[47],c,x,y)}
        return caml_call6(Context[2],context,_L_,x,y,P[1],_cx_)}
      function line_to(context,x,y)
       {caml_call1(bisect_visit,399);
        function _cw_(c)
         {caml_call1(bisect_visit,398);return caml_call3(C[42],c,x,y)}
        return caml_call6(Context[2],context,_M_,x,y,P[1],_cw_)}
      function rel_line_to(context,x,y)
       {caml_call1(bisect_visit,401);
        function _cv_(c)
         {caml_call1(bisect_visit,400);return caml_call3(C[46],c,x,y)}
        return caml_call6(Context[2],context,_N_,x,y,P[1],_cv_)}
      function curve_to(context,x1,y1,x2,y2,x3,y3)
       {caml_call1(bisect_visit,403);
        function _cu_(c)
         {caml_call1(bisect_visit,402);
          return caml_call7(C[41],c,x1,y1,x2,y2,x3,y3)}
        return caml_call10(Context[2],context,_O_,x1,y1,x2,y2,x3,y3,P[1],_cu_)}
      function rel_curve_to(context,x1,y1,x2,y2,x3,y3)
       {caml_call1(bisect_visit,405);
        function _ct_(c)
         {caml_call1(bisect_visit,404);
          return caml_call7(C[45],c,x1,y1,x2,y2,x3,y3)}
        return caml_call10(Context[2],context,_P_,x1,y1,x2,y2,x3,y3,P[1],_ct_)}
      function rectangle(context,x,y,w,h)
       {caml_call1(bisect_visit,407);
        function _cs_(c)
         {caml_call1(bisect_visit,406);return caml_call5(C[44],c,x,y,w,h)}
        return caml_call8(Context[2],context,_Q_,x,y,w,h,P[1],_cs_)}
      function arc(context,x,y,r,a1,a2)
       {caml_call1(bisect_visit,409);
        function _cr_(c)
         {caml_call1(bisect_visit,408);return caml_call6(C[39],c,x,y,r,a1,a2)}
        return caml_call9(Context[2],context,_R_,x,y,r,a1,a2,P[1],_cr_)}
      function arc_negative(context,x,y,r,a1,a2)
       {caml_call1(bisect_visit,411);
        function _cq_(c)
         {caml_call1(bisect_visit,410);return caml_call6(C[40],c,x,y,r,a1,a2)}
        return caml_call9(Context[2],context,_S_,x,y,r,a1,a2,P[1],_cq_)}
      function get_current_point(context)
       {caml_call1(bisect_visit,412);
        return caml_call4(Context[2],context,_T_,P[4],C[38][1])}
      function clear(context)
       {caml_call1(bisect_visit,413);
        return caml_call4(Context[2],context,_U_,P[1],C[38][2])}
      function close(context)
       {caml_call1(bisect_visit,414);
        return caml_call4(Context[2],context,_V_,P[1],C[38][3])}
      var Path=[0,get_current_point,clear,close];
      function stroke_preserve(context)
       {caml_call1(bisect_visit,415);
        return caml_call4(Context[2],context,_W_,P[1],C[37])}
      function stroke(context)
       {caml_call1(bisect_visit,416);
        return caml_call4(Context[2],context,_X_,P[1],C[36])}
      function fill_preserve(context)
       {caml_call1(bisect_visit,417);
        return caml_call4(Context[2],context,_Y_,P[1],C[34])}
      function fill(context)
       {caml_call1(bisect_visit,418);
        return caml_call4(Context[2],context,_Z_,P[1],C[33])}
      function clip_preserve(context)
       {caml_call1(bisect_visit,419);
        return caml_call4(Context[2],context,___,P[1],C[32])}
      function clip(context)
       {caml_call1(bisect_visit,420);
        return caml_call4(Context[2],context,_$_,P[1],C[31])}
      function paint(alpha,context)
       {caml_call1(bisect_visit,421);
        var
         _cn_=caml_call1(C[35],alpha),
         _co_=P[1],
         _cp_=caml_call2(A[8],cst_alpha,P[2]);
        return caml_call6(Context[2],context,_aa_,_cp_,alpha,_co_,_cn_)}
      function set_line_width(context,line_width)
       {caml_call1(bisect_visit,423);
        function _cm_(c)
         {caml_call1(bisect_visit,422);return caml_call2(C[21],c,line_width)}
        return caml_call5(Context[2],context,_ab_,line_width,P[1],_cm_)}
      function get_line_width(context)
       {caml_call1(bisect_visit,424);
        return caml_call4(Context[2],context,_ac_,P[2],C[22])}
      function set_dash(context,ofs,dashes)
       {caml_call1(bisect_visit,426);
        function _ci_(c)
         {caml_call1(bisect_visit,425);return caml_call3(C[25],c,ofs,dashes)}
        var _cj_=P[1],_ck_=A[7],_cl_=caml_call2(A[8],cst_ofs,P[2]);
        return caml_call8
                (Context[2],context,_ad_,_cl_,ofs,_ck_,dashes,_cj_,_ci_)}
      function get_dash(context)
       {caml_call1(bisect_visit,427);
        return caml_call4(Context[2],context,_ae_,P[6],C[26])}
      function set_fill_rule(context,fill_rule)
       {caml_call1(bisect_visit,429);
        function _ch_(c)
         {caml_call1(bisect_visit,428);return caml_call2(C[29],c,fill_rule)}
        return caml_call6(Context[2],context,_af_,A[3],fill_rule,P[1],_ch_)}
      function get_fill_rule(context)
       {caml_call1(bisect_visit,430);
        return caml_call4(Context[2],context,_ag_,P[7],C[30])}
      function set_line_cap(context,line_cap)
       {caml_call1(bisect_visit,432);
        function _cg_(c)
         {caml_call1(bisect_visit,431);return caml_call2(C[17],c,line_cap)}
        return caml_call6(Context[2],context,_ah_,A[4],line_cap,P[1],_cg_)}
      function get_line_cap(context)
       {caml_call1(bisect_visit,433);
        return caml_call4(Context[2],context,_ai_,P[8],C[18])}
      function set_line_join(context,line_join)
       {caml_call1(bisect_visit,435);
        function _cf_(c)
         {caml_call1(bisect_visit,434);return caml_call2(C[19],c,line_join)}
        return caml_call6(Context[2],context,_aj_,A[5],line_join,P[1],_cf_)}
      function get_line_join(context)
       {caml_call1(bisect_visit,436);
        return caml_call4(Context[2],context,_ak_,P[9],C[20])}
      function set_miter_limit(context,miter_limit)
       {caml_call1(bisect_visit,438);
        function _ce_(c)
         {caml_call1(bisect_visit,437);return caml_call2(C[23],c,miter_limit)}
        return caml_call5(Context[2],context,_al_,miter_limit,P[1],_ce_)}
      function get_miter_limit(context)
       {caml_call1(bisect_visit,439);
        return caml_call4(Context[2],context,_am_,P[2],C[24])}
      function set_operator(context,operator)
       {caml_call1(bisect_visit,441);
        function _cd_(c)
         {caml_call1(bisect_visit,440);return caml_call2(C[27],c,operator)}
        return caml_call6(Context[2],context,_an_,A[2],operator,P[1],_cd_)}
      function get_operator(context)
       {caml_call1(bisect_visit,442);
        return caml_call4(Context[2],context,_ao_,P[10],C[28])}
      function set_source(context,source)
       {caml_call1(bisect_visit,444);
        function _cc_(c)
         {caml_call1(bisect_visit,443);return caml_call2(C[15],c,source)}
        return caml_call6(Context[2],context,_ap_,A[6],source,P[1],_cc_)}
      function get_source(context)
       {caml_call1(bisect_visit,445);
        return caml_call4(Context[2],context,_aq_,P[11],C[16])}
      function set_source_rgb(context,r,g,b)
       {caml_call1(bisect_visit,447);
        function _cb_(c)
         {caml_call1(bisect_visit,446);return caml_call4(C[13],c,r,g,b)}
        return caml_call7(Context[2],context,_ar_,r,g,b,P[1],_cb_)}
      function set_source_rgba(context,r,g,b,a)
       {caml_call1(bisect_visit,449);
        function _ca_(c)
         {caml_call1(bisect_visit,448);return caml_call5(C[14],c,r,g,b,a)}
        return caml_call8(Context[2],context,_as_,r,g,b,a,P[1],_ca_)}
      function select_font_face(context,slant,weight,family)
       {caml_call1(bisect_visit,451);
        function _b8_(c)
         {caml_call1(bisect_visit,450);
          return caml_call4(C[5],c,slant,weight,family)}
        var
         _b9_=P[1],
         _b__=caml_call2(A[8],cst_weight,P[15]),
         _b$_=caml_call2(A[8],cst_slant,P[14]);
        return caml_call9
                (Context[2],
                 context,
                 _at_,
                 _b$_,
                 slant,
                 _b__,
                 weight,
                 family,
                 _b9_,
                 _b8_)}
      function set_font_size(context,font_size)
       {caml_call1(bisect_visit,453);
        function _b7_(c)
         {caml_call1(bisect_visit,452);return caml_call2(C[6],c,font_size)}
        return caml_call5(Context[2],context,_au_,font_size,P[1],_b7_)}
      function show_text(context,s)
       {caml_call1(bisect_visit,455);
        function _b6_(c)
         {caml_call1(bisect_visit,454);return caml_call2(C[7],c,s)}
        return caml_call5(Context[2],context,_av_,s,P[1],_b6_)}
      function font_extents$0(context)
       {caml_call1(bisect_visit,456);
        return caml_call4(Context[2],context,_aw_,P[12],C[8])}
      function text_extents$0(context,s)
       {caml_call1(bisect_visit,458);
        function _b5_(c)
         {caml_call1(bisect_visit,457);return caml_call2(C[9],c,s)}
        return caml_call5(Context[2],context,_ax_,s,P[13],_b5_)}
      return [0,
              _bZ_,
              _b0_,
              _b1_,
              _b2_,
              _b3_,
              P,
              A,
              Context,
              _b4_,
              calls$0,
              save,
              restore,
              set_matrix,
              get_matrix,
              transform,
              scale,
              translate,
              rotate,
              identity_matrix,
              device_to_user,
              device_to_user_distance,
              user_to_device,
              user_to_device_distance,
              move_to,
              rel_move_to,
              line_to,
              rel_line_to,
              curve_to,
              rel_curve_to,
              rectangle,
              arc,
              arc_negative,
              Path,
              stroke_preserve,
              stroke,
              fill_preserve,
              fill,
              clip_preserve,
              clip,
              paint,
              set_line_width,
              get_line_width,
              set_dash,
              get_dash,
              set_fill_rule,
              get_fill_rule,
              set_line_cap,
              get_line_cap,
              set_line_join,
              get_line_join,
              set_miter_limit,
              get_miter_limit,
              set_operator,
              get_operator,
              set_source,
              get_source,
              set_source_rgb,
              set_source_rgba,
              select_font_face,
              set_font_size,
              show_text,
              font_extents$0,
              text_extents$0]}
    var
     include=
      Decorate
       ([0,
         Error,
         status_to_string,
         Unavailable,
         [0,
          init_identity,
          init_translate,
          init_scale,
          init_rotate,
          translate,
          scale,
          rotate,
          invert,
          multiply,
          transform_distance,
          transform_point],
         select_font_face,
         set_font_size,
         show_text,
         font_extents,
         text_extents,
         [0,
          add_color_stop_rgb,
          add_color_stop_rgba,
          get_color_stop_count,
          get_color_stop_rgba,
          create_rgb,
          create_rgba,
          get_rgba,
          create_linear,
          get_linear_points,
          create_radial,
          get_radial_circles],
         save,
         restore,
         set_source_rgb,
         set_source_rgba,
         set_source,
         get_source,
         set_line_cap,
         get_line_cap,
         set_line_join,
         get_line_join,
         set_line_width,
         get_line_width,
         set_miter_limit,
         get_miter_limit,
         set_dash,
         get_dash,
         set_operator,
         get_operator,
         set_fill_rule,
         get_fill_rule,
         clip,
         clip_preserve,
         fill,
         fill_preserve,
         paint,
         stroke,
         stroke_preserve,
         Path,
         arc,
         arc_negative,
         curve_to,
         line_to,
         move_to,
         rectangle,
         rel_curve_to,
         rel_line_to,
         rel_move_to,
         translate$0,
         scale$0,
         rotate$0,
         transform$0,
         set_matrix,
         get_matrix,
         identity_matrix,
         user_to_device,
         user_to_device_distance,
         device_to_user,
         device_to_user_distance]),
     Pattern=include[1],
     Matrix=include[2],
     Error$0=include[3],
     Unavailable$0=include[4],
     status_to_string$0=include[5],
     Context=include[8],
     calls=include[10],
     save$0=include[11],
     restore$0=include[12],
     set_matrix$0=include[13],
     get_matrix$0=include[14],
     transform$1=include[15],
     scale$1=include[16],
     translate$1=include[17],
     rotate$1=include[18],
     identity_matrix$0=include[19],
     device_to_user$0=include[20],
     device_to_user_distance$0=include[21],
     user_to_device$0=include[22],
     user_to_device_distance$0=include[23],
     move_to$0=include[24],
     rel_move_to$0=include[25],
     line_to$0=include[26],
     rel_line_to$0=include[27],
     curve_to$0=include[28],
     rel_curve_to$0=include[29],
     rectangle$0=include[30],
     arc$0=include[31],
     arc_negative$0=include[32],
     Path$0=include[33],
     stroke_preserve$0=include[34],
     stroke$0=include[35],
     fill_preserve$0=include[36],
     fill$0=include[37],
     clip_preserve$0=include[38],
     clip$0=include[39],
     paint$0=include[40],
     set_line_width$0=include[41],
     get_line_width$0=include[42],
     set_dash$0=include[43],
     get_dash$0=include[44],
     set_fill_rule$0=include[45],
     get_fill_rule$0=include[46],
     set_line_cap$0=include[47],
     get_line_cap$0=include[48],
     set_line_join$0=include[49],
     get_line_join$0=include[50],
     set_miter_limit$0=include[51],
     get_miter_limit$0=include[52],
     set_operator$0=include[53],
     get_operator$0=include[54],
     set_source$0=include[55],
     get_source$0=include[56],
     set_source_rgb$0=include[57],
     set_source_rgba$0=include[58],
     select_font_face$0=include[59],
     set_font_size$0=include[60],
     show_text$0=include[61],
     font_extents$0=include[62],
     text_extents$0=include[63];
    function create$0(param)
     {caml_call1(bisect_visit,459);
      var _bY_=create(0);
      return caml_call1(Context[1],_bY_)}
    var
     CairoMock=
      [0,
       [0,
        Error,
        status_to_string,
        Unavailable,
        [0,
         init_identity,
         init_translate,
         init_scale,
         init_rotate,
         translate,
         scale,
         rotate,
         invert,
         multiply,
         transform_distance,
         transform_point],
        select_font_face,
        set_font_size,
        show_text,
        font_extents,
        text_extents,
        [0,
         add_color_stop_rgb,
         add_color_stop_rgba,
         get_color_stop_count,
         get_color_stop_rgba,
         create_rgb,
         create_rgba,
         get_rgba,
         create_linear,
         get_linear_points,
         create_radial,
         get_radial_circles],
        save,
        restore,
        set_source_rgb,
        set_source_rgba,
        set_source,
        get_source,
        set_line_cap,
        get_line_cap,
        set_line_join,
        get_line_join,
        set_line_width,
        get_line_width,
        set_miter_limit,
        get_miter_limit,
        set_dash,
        get_dash,
        set_operator,
        get_operator,
        set_fill_rule,
        get_fill_rule,
        clip,
        clip_preserve,
        fill,
        fill_preserve,
        paint,
        stroke,
        stroke_preserve,
        Path,
        arc,
        arc_negative,
        curve_to,
        line_to,
        move_to,
        rectangle,
        rel_curve_to,
        rel_line_to,
        rel_move_to,
        translate$0,
        scale$0,
        rotate$0,
        transform$0,
        set_matrix,
        get_matrix,
        identity_matrix,
        user_to_device,
        user_to_device_distance,
        device_to_user,
        device_to_user_distance,
        create],
       function(_bW_)
        {var _bX_=Decorate(_bW_);
         return [0,
                 _bX_[3],
                 _bX_[5],
                 _bX_[4],
                 _bX_[2],
                 _bX_[59],
                 _bX_[60],
                 _bX_[61],
                 _bX_[62],
                 _bX_[63],
                 _bX_[1],
                 _bX_[11],
                 _bX_[12],
                 _bX_[57],
                 _bX_[58],
                 _bX_[55],
                 _bX_[56],
                 _bX_[47],
                 _bX_[48],
                 _bX_[49],
                 _bX_[50],
                 _bX_[41],
                 _bX_[42],
                 _bX_[51],
                 _bX_[52],
                 _bX_[43],
                 _bX_[44],
                 _bX_[53],
                 _bX_[54],
                 _bX_[45],
                 _bX_[46],
                 _bX_[39],
                 _bX_[38],
                 _bX_[37],
                 _bX_[36],
                 _bX_[40],
                 _bX_[35],
                 _bX_[34],
                 _bX_[33],
                 _bX_[31],
                 _bX_[32],
                 _bX_[28],
                 _bX_[26],
                 _bX_[24],
                 _bX_[30],
                 _bX_[29],
                 _bX_[27],
                 _bX_[25],
                 _bX_[17],
                 _bX_[16],
                 _bX_[18],
                 _bX_[15],
                 _bX_[13],
                 _bX_[14],
                 _bX_[19],
                 _bX_[22],
                 _bX_[23],
                 _bX_[20],
                 _bX_[21],
                 _bX_[9],
                 _bX_[10]]},
       Error$0,
       status_to_string$0,
       Unavailable$0,
       Matrix,
       select_font_face$0,
       set_font_size$0,
       show_text$0,
       font_extents$0,
       text_extents$0,
       Pattern,
       save$0,
       restore$0,
       set_source_rgb$0,
       set_source_rgba$0,
       set_source$0,
       get_source$0,
       set_line_cap$0,
       get_line_cap$0,
       set_line_join$0,
       get_line_join$0,
       set_line_width$0,
       get_line_width$0,
       set_miter_limit$0,
       get_miter_limit$0,
       set_dash$0,
       get_dash$0,
       set_operator$0,
       get_operator$0,
       set_fill_rule$0,
       get_fill_rule$0,
       clip$0,
       clip_preserve$0,
       fill$0,
       fill_preserve$0,
       paint$0,
       stroke$0,
       stroke_preserve$0,
       Path$0,
       arc$0,
       arc_negative$0,
       curve_to$0,
       line_to$0,
       move_to$0,
       rectangle$0,
       rel_curve_to$0,
       rel_line_to$0,
       rel_move_to$0,
       translate$1,
       scale$1,
       rotate$1,
       transform$1,
       set_matrix$0,
       get_matrix$0,
       identity_matrix$0,
       user_to_device$0,
       user_to_device_distance$0,
       device_to_user$0,
       device_to_user_distance$0,
       create$0,
       calls];
    caml_register_global(446,CairoMock,"CairoMock");
    var
     match$0=
      caml_call3
       (Bisect_Runtime[1],cst_src_JsOfOCairo_ml,389,point_definitions$0),
     bisect_visit$0=match$0[2],
     Error$1=[248,cst_JsOfOCairo_Error,caml_fresh_oo_id(0)];
    caml_call1(bisect_visit$0,37);
    function status_to_string$1(param)
     {switch(param)
       {case 0:
         caml_call1(bisect_visit$0,0);
         return cst_cairo_restore_without_matching_cairo_save$0;
        case 1:
         caml_call1(bisect_visit$0,1);
         return cst_no_saved_group_to_pop_i_e_cairo_pop_group_without_matching_cairo_push_group$0;
        case 2:
         caml_call1(bisect_visit$0,2);return cst_no_current_point_defined$0;
        case 3:
         caml_call1(bisect_visit$0,3);
         return cst_invalid_matrix_not_invertible$0;
        case 4:
         caml_call1(bisect_visit$0,4);
         return cst_invalid_value_for_an_input_cairo_status_t$0;
        case 5:caml_call1(bisect_visit$0,5);return cst_NULL_pointer$0;
        case 6:
         caml_call1(bisect_visit$0,6);
         return cst_input_string_not_valid_UTF_8$0;
        case 7:
         caml_call1(bisect_visit$0,7);return cst_input_path_data_not_valid$0;
        case 8:
         caml_call1(bisect_visit$0,8);
         return cst_error_while_reading_from_input_stream$0;
        case 9:
         caml_call1(bisect_visit$0,9);
         return cst_error_while_writing_to_output_stream$0;
        case 10:
         caml_call1(bisect_visit$0,10);
         return cst_the_target_surface_has_been_finished$0;
        case 11:
         caml_call1(bisect_visit$0,11);
         return cst_the_surface_type_is_not_appropriate_for_the_operation$0;
        case 12:
         caml_call1(bisect_visit$0,12);
         return cst_the_pattern_type_is_not_appropriate_for_the_operation$0;
        case 13:
         caml_call1(bisect_visit$0,13);
         return cst_invalid_value_for_an_input_cairo_content_t$0;
        case 14:
         caml_call1(bisect_visit$0,14);
         return cst_invalid_value_for_an_input_cairo_format_t$0;
        case 15:
         caml_call1(bisect_visit$0,15);
         return cst_invalid_value_for_an_input_Visual$0;
        case 16:caml_call1(bisect_visit$0,16);return cst_file_not_found$0;
        case 17:
         caml_call1(bisect_visit$0,17);
         return cst_invalid_value_for_a_dash_setting$0;
        case 18:
         caml_call1(bisect_visit$0,18);
         return cst_invalid_value_for_a_DSC_comment$0;
        case 19:
         caml_call1(bisect_visit$0,19);
         return cst_invalid_index_passed_to_getter$0;
        case 20:
         caml_call1(bisect_visit$0,20);
         return cst_clip_region_not_representable_in_desired_format$0;
        case 21:
         caml_call1(bisect_visit$0,21);
         return cst_error_creating_or_writing_to_a_temporary_file$0;
        case 22:
         caml_call1(bisect_visit$0,22);return cst_invalid_value_for_stride$0;
        case 23:
         caml_call1(bisect_visit$0,23);
         return cst_the_font_type_is_not_appropriate_for_the_operation$0;
        case 24:
         caml_call1(bisect_visit$0,24);
         return cst_the_user_font_is_immutable$0;
        case 25:
         caml_call1(bisect_visit$0,25);
         return cst_error_occurred_in_a_user_font_callback_function$0;
        case 26:
         caml_call1(bisect_visit$0,26);
         return cst_negative_number_used_where_it_is_not_allowed$0;
        case 27:
         caml_call1(bisect_visit$0,27);
         return cst_input_clusters_do_not_represent_the_accompanying_text_and_glyph_arrays$0;
        case 28:
         caml_call1(bisect_visit$0,28);
         return cst_invalid_value_for_an_input_cairo_font_slant_t$0;
        case 29:
         caml_call1(bisect_visit$0,29);
         return cst_invalid_value_for_an_input_cairo_font_weight_t$0;
        case 30:
         caml_call1(bisect_visit$0,30);
         return cst_invalid_value_typically_too_big_for_the_size_of_the_input_surface_pattern_etc$0;
        case 31:
         caml_call1(bisect_visit$0,31);
         return cst_user_font_method_not_implemented$0;
        case 32:
         caml_call1(bisect_visit$0,32);
         return cst_the_device_type_is_not_appropriate_for_the_operation$0;
        case 33:
         caml_call1(bisect_visit$0,33);
         return cst_an_operation_to_the_device_caused_an_unspecified_error$0;
        case 34:
         caml_call1(bisect_visit$0,34);
         return cst_invalid_operation_during_mesh_pattern_construction$0;
        case 35:
         caml_call1(bisect_visit$0,35);
         return cst_the_target_device_has_been_finished$0;
        default:
         caml_call1(bisect_visit$0,36);
         return cst_CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID_used_but_no_CAIRO_MIME_TYPE_JBIG2_GLOBAL_data_provided$0}}
    caml_call1(bisect_visit$0,40);
    var Unavailable$1=[248,cst_JsOfOCairo_Unavailable,caml_fresh_oo_id(0)];
    function init_identity$0(param)
     {caml_call1(bisect_visit$0,41);return [254,1,0,0,1,0,0]}
    function init_translate$0(x,y)
     {caml_call1(bisect_visit$0,42);return [254,1,0,0,1,x,y]}
    function init_scale$0(x,y)
     {caml_call1(bisect_visit$0,43);return [254,x,0,0,y,0,0]}
    function init_rotate$0(angle)
     {caml_call1(bisect_visit$0,44);
      return [254,
              Math.cos(angle),
              Math.sin(angle),
              - Math.sin(angle),
              Math.cos(angle),
              0,
              0]}
    function init_inverse$0(param)
     {var
       xx=param[1],
       yx=param[2],
       xy=param[3],
       yy=param[4],
       x0=param[5],
       y0=param[6];
      caml_call1(bisect_visit$0,56);
      caml_call1(bisect_visit$0,54);
      var d=xx * yy - xy * yx;
      caml_call1(bisect_visit$0,55);
      if(d == 0){caml_call1(bisect_visit$0,52);throw [0,Error$1,3]}
      caml_call1(bisect_visit$0,53);
      caml_call1(bisect_visit$0,45);
      var xx$0=yy / d;
      caml_call1(bisect_visit$0,46);
      var xy$0=- xy / d;
      caml_call1(bisect_visit$0,47);
      var yx$0=- yx / d;
      caml_call1(bisect_visit$0,48);
      var yy$0=xx / d;
      caml_call1(bisect_visit$0,49);
      var x0$0=(xy * y0 - yy * x0) / d;
      caml_call1(bisect_visit$0,50);
      var y0$0=(yx * x0 - xx * y0) / d;
      caml_call1(bisect_visit$0,51);
      return [254,xx$0,yx$0,xy$0,yy$0,x0$0,y0$0]}
    function multiply$0(param)
     {var
       xx=param[1],
       yx=param[2],
       xy=param[3],
       yy=param[4],
       x0=param[5],
       y0=param[6];
      return function(param)
       {var
         xx$0=param[1],
         yx$0=param[2],
         xy$0=param[3],
         yy$0=param[4],
         x0$0=param[5],
         y0$0=param[6];
        caml_call1(bisect_visit$0,64);
        caml_call1(bisect_visit$0,57);
        var xx$1=xx * xx$0 + xy * yx$0;
        caml_call1(bisect_visit$0,58);
        var xy$1=xx * xy$0 + xy * yy$0;
        caml_call1(bisect_visit$0,59);
        var yx$1=yx * xx$0 + yy * yx$0;
        caml_call1(bisect_visit$0,60);
        var yy$1=yx * xy$0 + yy * yy$0;
        caml_call1(bisect_visit$0,61);
        var x0$1=xx * x0$0 + xy * y0$0 + x0;
        caml_call1(bisect_visit$0,62);
        var y0$1=yx * x0$0 + yy * y0$0 + y0;
        caml_call1(bisect_visit$0,63);
        return [254,xx$1,yx$1,xy$1,yy$1,x0$1,y0$1]}}
    function transform_point$0(param)
     {var
       xx=param[1],
       yx=param[2],
       xy=param[3],
       yy=param[4],
       x0=param[5],
       y0=param[6];
      return function(x,y)
       {caml_call1(bisect_visit$0,65);
        return [0,xx * x + xy * y + x0,yx * x + yy * y + y0]}}
    function transform_distance$0(param)
     {var xx=param[1],yx=param[2],xy=param[3],yy=param[4];
      return function(dx,dy)
       {caml_call1(bisect_visit$0,66);
        return [0,xx * dx + xy * dy,yx * dx + yy * dy]}}
    function set$0(m,param)
     {var
       xx=param[1],
       yx=param[2],
       xy=param[3],
       yy=param[4],
       x0=param[5],
       y0=param[6];
      caml_call1(bisect_visit$0,72);
      m[1] = xx;
      caml_call1(bisect_visit$0,71);
      m[3] = xy;
      caml_call1(bisect_visit$0,70);
      m[2] = yx;
      caml_call1(bisect_visit$0,69);
      m[4] = yy;
      caml_call1(bisect_visit$0,68);
      m[5] = x0;
      caml_call1(bisect_visit$0,67);
      m[6] = y0;
      return 0}
    function scale$2(m,x,y)
     {caml_call1(bisect_visit$0,73);
      var _bV_=init_scale$0(x,y);
      return set$0(m,caml_call1(multiply$0(m),_bV_))}
    function translate$2(m,x,y)
     {caml_call1(bisect_visit$0,74);
      var _bU_=init_translate$0(x,y);
      return set$0(m,caml_call1(multiply$0(m),_bU_))}
    function rotate$2(m,angle)
     {caml_call1(bisect_visit$0,75);
      var _bT_=init_rotate$0(angle);
      return set$0(m,caml_call1(multiply$0(m),_bT_))}
    function invert$0(m)
     {caml_call1(bisect_visit$0,76);return set$0(m,init_inverse$0(m))}
    caml_call1(bisect_visit$0,80);
    caml_call1(bisect_visit$0,81);
    var size$0=Stdlib_listLabels[1],empty$0=0;
    function add$0(xs,stop_point)
     {caml_call1(bisect_visit$0,90);
      caml_call1(bisect_visit$0,88);
      var param=[0,caml_call1(Stdlib_listLabels[1],xs),stop_point];
      caml_call1(bisect_visit$0,89);
      var aux=function _bS_(_bR_){return _bS_.fun(_bR_)};
      caml_call1(bisect_visit$0,86);
      caml_update_dummy
       (aux,
        function(xxs)
         {if(xxs)
           {var xs=xxs[2],x=xxs[1];
            caml_call1(bisect_visit$0,85);
            var
             position_b=x[2][1],
             added_b=x[1],
             match=param[2],
             position_a=match[1],
             added_a=param[1];
            caml_call1(bisect_visit$0,79);
            var
             n=caml_float_compare(position_a,position_b),
             match$0=
              0 === n
               ?(caml_call1(bisect_visit$0,77),
                 caml_int_compare(added_a,added_b))
               :(caml_call1(bisect_visit$0,78),n);
            return -1 === match$0
                    ?(caml_call1(bisect_visit$0,82),[0,param,xxs])
                    :(caml_call1(bisect_visit$0,83),[0,x,caml_call1(aux,xs)])}
          caml_call1(bisect_visit$0,84);
          return [0,param,0]});
      caml_call1(bisect_visit$0,87);
      return caml_call1(aux,xs)}
    function to_list(xs)
     {caml_call1(bisect_visit$0,92);
      function _bQ_(param)
       {var stop_point=param[2];
        caml_call1(bisect_visit$0,91);
        return stop_point}
      return caml_call2(Stdlib_listLabels[17],_bQ_,xs)}
    caml_call1(bisect_visit$0,97);
    var _az_=add$0(empty$0,_ay_);
    caml_call1(bisect_visit$0,96);
    to_list(_az_);
    function create_rgba$0(r,g,b,a)
     {caml_call1(bisect_visit$0,98);return [0,[0,[0,r,g,b,a]]]}
    function create_rgb$0(r,g,b)
     {caml_call1(bisect_visit$0,99);return create_rgba$0(r,g,b,1)}
    function get_rgba$0(pattern)
     {caml_call1(bisect_visit$0,104);
      var _bP_=pattern[1];
      if(typeof _bP_ !== "number" && 0 === _bP_[0])
       {var color=_bP_[1];caml_call1(bisect_visit$0,100);return color}
      if(typeof _bP_ === "number")
       caml_call1(bisect_visit$0,103);
      else
       switch(_bP_[0])
        {case 0:break;
         case 1:caml_call1(bisect_visit$0,101);break;
         default:caml_call1(bisect_visit$0,102)}
      throw [0,Error$1,12]}
    function create_linear$0(x0,y0,x1,y1)
     {caml_call1(bisect_visit$0,105);
      return [0,[1,[0,[0,x0,y0,x1,y1],empty$0]]]}
    function get_linear_points$0(pattern)
     {caml_call1(bisect_visit$0,110);
      var _bO_=pattern[1];
      if(typeof _bO_ !== "number" && 1 === _bO_[0])
       {var match=_bO_[1],points=match[1];
        caml_call1(bisect_visit$0,106);
        return points}
      if(typeof _bO_ === "number")
       caml_call1(bisect_visit$0,109);
      else
       switch(_bO_[0])
        {case 0:caml_call1(bisect_visit$0,107);break;
         case 1:break;
         default:caml_call1(bisect_visit$0,108)}
      throw [0,Error$1,12]}
    function create_radial$0(x0,y0,r0,x1,y1,r1)
     {caml_call1(bisect_visit$0,111);
      return [0,[2,[0,[0,x0,y0,r0,x1,y1,r1],empty$0]]]}
    function get_radial_circles$0(pattern)
     {caml_call1(bisect_visit$0,116);
      var _bN_=pattern[1];
      if(typeof _bN_ !== "number" && 2 === _bN_[0])
       {var match=_bN_[1],circles=match[1];
        caml_call1(bisect_visit$0,112);
        return circles}
      if(typeof _bN_ === "number")
       caml_call1(bisect_visit$0,115);
      else
       switch(_bN_[0])
        {case 0:caml_call1(bisect_visit$0,114);break;
         case 1:caml_call1(bisect_visit$0,113);break
         }
      throw [0,Error$1,12]}
    function add_color_stop_rgba$0(pattern,opt,r,g,b,a)
     {if(opt)
       var sth=opt[1],ofs=sth;
      else
       {caml_call1(bisect_visit$0,124);var ofs=0}
      caml_call1(bisect_visit$0,123);
      caml_call1(bisect_visit$0,121);
      var stop_point=[0,ofs,r,g,b,a];
      caml_call1(bisect_visit$0,122);
      var _bK_=pattern[1];
      if(typeof _bK_ === "number")
       {caml_call1(bisect_visit$0,120);return 0}
      else
       switch(_bK_[0])
        {case 0:caml_call1(bisect_visit$0,119);pattern[1] = 0;return 0;
         case 1:
          var gradient=_bK_[1];
          caml_call1(bisect_visit$0,117);
          var _bL_=add$0(gradient[2],stop_point);
          pattern[1] = [1,[0,gradient[1],_bL_]];
          return 0;
         default:
          var gradient$0=_bK_[1];
          caml_call1(bisect_visit$0,118);
          var _bM_=add$0(gradient$0[2],stop_point);
          pattern[1] = [2,[0,gradient$0[1],_bM_]];
          return 0}}
    function add_color_stop_rgb$0(pattern,ofs,r,g,b)
     {caml_call1(bisect_visit$0,125);
      return add_color_stop_rgba$0(pattern,ofs,r,g,b,1)}
    function get_color_stop_count$0(pattern)
     {caml_call1(bisect_visit$0,130);
      var _bJ_=pattern[1];
      if(typeof _bJ_ !== "number" && 0 !== _bJ_[0])
       {var match=_bJ_[1],stop_points=match[2];
        if(typeof _bJ_ === "number")
         var switch$0=0;
        else
         switch(_bJ_[0])
          {case 1:caml_call1(bisect_visit$0,126);var switch$0=1;break;
           case 2:caml_call1(bisect_visit$0,127);var switch$0=1;break;
           default:var switch$0=0}
        return caml_call1(size$0,stop_points)}
      if(typeof _bJ_ === "number")
       caml_call1(bisect_visit$0,129);
      else
       if(0 === _bJ_[0])caml_call1(bisect_visit$0,128);
      throw [0,Error$1,12]}
    function get_color_stop_rgba$0(pattern,idx)
     {caml_call1(bisect_visit$0,135);
      var _bI_=pattern[1];
      if(typeof _bI_ !== "number" && 0 !== _bI_[0])
       {var match$0=_bI_[1],stop_points=match$0[2];
        if(typeof _bI_ === "number")
         var switch$0=0;
        else
         switch(_bI_[0])
          {case 1:caml_call1(bisect_visit$0,131);var switch$0=1;break;
           case 2:caml_call1(bisect_visit$0,132);var switch$0=1;break;
           default:var switch$0=0}
        caml_call1(bisect_visit$0,95);
        caml_call1(bisect_visit$0,93);
        var
         match=caml_call2(Stdlib_listLabels[7],stop_points,idx),
         stop_point=match[2];
        caml_call1(bisect_visit$0,94);
        return stop_point}
      if(typeof _bI_ === "number")
       caml_call1(bisect_visit$0,134);
      else
       if(0 === _bI_[0])caml_call1(bisect_visit$0,133);
      throw [0,Error$1,12]}
    caml_call1(bisect_visit$0,149);
    function _aA_(param)
     {if(param[1] === Error$1)
       {var status=param[2];
        caml_call1(bisect_visit$0,147);
        switch(status)
         {case 0:
           caml_call1(bisect_visit$0,38);var _bH_=cst_INVALID_RESTORE$0;break;
          case 1:var _bH_=cst_INVALID_POP_GROUP$0;break;
          case 2:
           caml_call1(bisect_visit$0,39);
           var _bH_=cst_NO_CURRENT_POINT$0;
           break;
          case 3:var _bH_=cst_INVALID_MATRIX$0;break;
          case 4:var _bH_=cst_INVALID_STATUS$0;break;
          case 5:var _bH_=cst_NULL_POINTER$0;break;
          case 6:var _bH_=cst_INVALID_STRING$0;break;
          case 7:var _bH_=cst_INVALID_PATH_DATA$0;break;
          case 8:var _bH_=cst_READ_ERROR$0;break;
          case 9:var _bH_=cst_WRITE_ERROR$0;break;
          case 10:var _bH_=cst_SURFACE_FINISHED$0;break;
          case 11:var _bH_=cst_SURFACE_TYPE_MISMATCH$0;break;
          case 12:var _bH_=cst_PATTERN_TYPE_MISMATCH$0;break;
          case 13:var _bH_=cst_INVALID_CONTENT$0;break;
          case 14:var _bH_=cst_INVALID_FORMAT$0;break;
          case 15:var _bH_=cst_INVALID_VISUAL$0;break;
          case 16:var _bH_=cst_FILE_NOT_FOUND$0;break;
          case 17:var _bH_=cst_INVALID_DASH$0;break;
          case 18:var _bH_=cst_INVALID_DSC_COMMENT$0;break;
          case 19:var _bH_=cst_INVALID_INDEX$0;break;
          case 20:var _bH_=cst_CLIP_NOT_REPRESENTABLE$0;break;
          case 21:var _bH_=cst_TEMP_FILE_ERROR$0;break;
          case 22:var _bH_=cst_INVALID_STRIDE$0;break;
          case 23:var _bH_=cst_FONT_TYPE_MISMATCH$0;break;
          case 24:var _bH_=cst_USER_FONT_IMMUTABLE$0;break;
          case 25:var _bH_=cst_USER_FONT_ERROR$0;break;
          case 26:var _bH_=cst_NEGATIVE_COUNT$0;break;
          case 27:var _bH_=cst_INVALID_CLUSTERS$0;break;
          case 28:var _bH_=cst_INVALID_SLANT$0;break;
          case 29:var _bH_=cst_INVALID_WEIGHT$0;break;
          case 30:var _bH_=cst_INVALID_SIZE$0;break;
          case 31:var _bH_=cst_USER_FONT_NOT_IMPLEMENTED$0;break;
          case 32:var _bH_=cst_DEVICE_TYPE_MISMATCH$0;break;
          case 33:var _bH_=cst_DEVICE_ERROR$0;break;
          case 34:var _bH_=cst_INVALID_MESH_CONSTRUCTION$0;break;
          case 35:var _bH_=cst_DEVICE_FINISHED$0;break;
          default:var _bH_=cst_JBIG2_GLOBAL_MISSING$0}
        return [0,caml_call2(Stdlib_printf[4],_aB_,_bH_)]}
      caml_call1(bisect_visit$0,148);
      return 0}
    caml_call1(Stdlib_printexc[8],_aA_);
    function state$0(context)
     {caml_call1(bisect_visit$0,151);
      return caml_call1(Stdlib_listLabels[2],context[2])}
    function set_state(context,state)
     {caml_call1(bisect_visit$0,152);
      context[2] = [0,state,caml_call1(Stdlib_listLabels[6],context[2])];
      return 0}
    function transformation(context)
     {caml_call1(bisect_visit$0,160);return state$0(context)[1]}
    function font(context)
     {caml_call1(bisect_visit$0,162);return state$0(context)[2]}
    function fill_rule(context)
     {caml_call1(bisect_visit$0,166);return state$0(context)[4]}
    function set_start_point_if_none(context,param)
     {var y=param[2],x=param[1];
      caml_call1(bisect_visit$0,174);
      caml_call1(bisect_visit$0,172);
      var transformation$0=transformation(context);
      caml_call1(bisect_visit$0,173);
      var _bG_=context[1];
      caml_call1(bisect_visit$0,139);
      var
       _bE_=0 === _bG_[1]?1:0,
       _bF_=
        _bE_
         ?(caml_call1(bisect_visit$0,138),
           _bG_[1]
           =
           [0,caml_call2(transform_point$0(transformation$0),x,y)],
           0)
         :_bE_;
      return _bF_}
    function set_start_point_as_current_point(context)
     {caml_call1(bisect_visit$0,175);
      var _bD_=context[1];
      caml_call1(bisect_visit$0,142);
      _bD_[2] = _bD_[1];
      return 0}
    function current_point(context)
     {caml_call1(bisect_visit$0,178);
      caml_call1(bisect_visit$0,176);
      var transformation$0=transformation(context);
      caml_call1(bisect_visit$0,177);
      var _bC_=context[1];
      caml_call1(bisect_visit$0,146);
      var _bB_=_bC_[2];
      if(_bB_)
       {var match=_bB_[1],y=match[2],x=match[1];
        caml_call1(bisect_visit$0,145);
        return [0,
                caml_call2
                 (transform_point$0(init_inverse$0(transformation$0)),x,y)]}
      caml_call1(bisect_visit$0,144);
      return 0}
    function set_current_point(context,param)
     {var y=param[2],x=param[1];
      caml_call1(bisect_visit$0,181);
      caml_call1(bisect_visit$0,179);
      var transformation$0=transformation(context);
      caml_call1(bisect_visit$0,180);
      var _bA_=context[1];
      caml_call1(bisect_visit$0,141);
      _bA_[2] = [0,caml_call2(transform_point$0(transformation$0),x,y)];
      return 0}
    function save$1(context)
     {caml_call1(bisect_visit$0,184);
      context[1].save();
      caml_call1(bisect_visit$0,183);
      var _bz_=context[2];
      caml_call1(bisect_visit$0,153);
      var _by_=_bz_[2];
      _bz_[2] = [0,state$0(_bz_),_by_];
      return 0}
    function restore$1(context)
     {caml_call1(bisect_visit$0,186);
      context[1].restore();
      caml_call1(bisect_visit$0,185);
      var _bx_=context[2];
      caml_call1(bisect_visit$0,159);
      caml_call1(bisect_visit$0,157);
      var _bv_=_bx_[2];
      if(_bv_)
       {var _bw_=_bv_[2];
        if(_bw_)
         {caml_call1(bisect_visit$0,156);
          caml_call1(bisect_visit$0,158);
          _bx_[2] = _bw_;
          return 0}}
      if(_bv_)
       {if(! _bv_[2])caml_call1(bisect_visit$0,155)}
      else
       caml_call1(bisect_visit$0,154);
      throw [0,Error$1,0]}
    function set_matrix$1(context,transformation)
     {var
       xx=transformation[1],
       yx=transformation[2],
       xy=transformation[3],
       yy=transformation[4],
       x0=transformation[5],
       y0=transformation[6];
      caml_call1(bisect_visit$0,188);
      context[1].setTransform(xx,yx,xy,yy,x0,y0);
      caml_call1(bisect_visit$0,187);
      var _bu_=context[2];
      caml_call1(bisect_visit$0,161);
      var _bt_=state$0(_bu_);
      return set_state(_bu_,[0,transformation,_bt_[2],_bt_[3],_bt_[4]])}
    function get_matrix$1(context)
     {caml_call1(bisect_visit$0,189);return transformation(context[2])}
    function transform$2(context,m)
     {caml_call1(bisect_visit$0,190);
      return set_matrix$1
              (context,caml_call1(multiply$0(transformation(context[2])),m))}
    function scale$3(context,x,y)
     {caml_call1(bisect_visit$0,191);
      return transform$2(context,init_scale$0(x,y))}
    function translate$3(context,x,y)
     {caml_call1(bisect_visit$0,192);
      return transform$2(context,init_translate$0(x,y))}
    function rotate$3(context,angle)
     {caml_call1(bisect_visit$0,193);
      return transform$2(context,init_rotate$0(angle))}
    function identity_matrix$1(context)
     {caml_call1(bisect_visit$0,194);
      return set_matrix$1(context,init_identity$0(0))}
    function device_to_user$1(context,x,y)
     {caml_call1(bisect_visit$0,195);
      return caml_call2
              (transform_point$0(init_inverse$0(transformation(context[2]))),
               x,
               y)}
    function device_to_user_distance$1(context,dx,dy)
     {caml_call1(bisect_visit$0,196);
      return caml_call2
              (transform_distance$0
                (init_inverse$0(transformation(context[2]))),
               dx,
               dy)}
    function user_to_device$1(context,x,y)
     {caml_call1(bisect_visit$0,197);
      return caml_call2(transform_point$0(transformation(context[2])),x,y)}
    function user_to_device_distance$1(context,dx,dy)
     {caml_call1(bisect_visit$0,198);
      return caml_call2
              (transform_distance$0(transformation(context[2])),dx,dy)}
    function make_rel(context,dx,dy)
     {caml_call1(bisect_visit$0,201);
      var match=current_point(context[2]);
      if(match)
       {var match$0=match[1],y=match$0[2],x=match$0[1];
        caml_call1(bisect_visit$0,200);
        return [0,x + dx,y + dy]}
      caml_call1(bisect_visit$0,199);
      throw [0,Error$1,2]}
    function move_to$1(context,x,y)
     {caml_call1(bisect_visit$0,204);
      context[1].moveTo(x,y);
      caml_call1(bisect_visit$0,203);
      var _bs_=context[2];
      caml_call1(bisect_visit$0,170);
      caml_call1(bisect_visit$0,168);
      var transformation$0=transformation(_bs_);
      caml_call1(bisect_visit$0,169);
      var _br_=_bs_[1];
      caml_call1(bisect_visit$0,137);
      _br_[1] = [0,caml_call2(transform_point$0(transformation$0),x,y)];
      caml_call1(bisect_visit$0,202);
      return set_start_point_as_current_point(context[2])}
    function rel_move_to$1(context,x,y)
     {caml_call1(bisect_visit$0,207);
      caml_call1(bisect_visit$0,205);
      var match=make_rel(context,x,y),y$0=match[2],x$0=match[1];
      caml_call1(bisect_visit$0,206);
      return move_to$1(context,x$0,y$0)}
    function line_to$1(context,x,y)
     {caml_call1(bisect_visit$0,210);
      context[1].lineTo(x,y);
      caml_call1(bisect_visit$0,209);
      set_start_point_if_none(context[2],[0,x,y]);
      caml_call1(bisect_visit$0,208);
      return set_current_point(context[2],[0,x,y])}
    function rel_line_to$1(context,x,y)
     {caml_call1(bisect_visit$0,213);
      caml_call1(bisect_visit$0,211);
      var match=make_rel(context,x,y),y$0=match[2],x$0=match[1];
      caml_call1(bisect_visit$0,212);
      return line_to$1(context,x$0,y$0)}
    function curve_to$1(context,x1,y1,x2,y2,x3,y3)
     {caml_call1(bisect_visit$0,216);
      context[1].bezierCurveTo(x1,y1,x2,y2,x3,y3);
      caml_call1(bisect_visit$0,215);
      set_start_point_if_none(context[2],[0,x1,y1]);
      caml_call1(bisect_visit$0,214);
      return set_current_point(context[2],[0,x3,y3])}
    function rel_curve_to$1(context,x1,y1,x2,y2,x3,y3)
     {caml_call1(bisect_visit$0,221);
      caml_call1(bisect_visit$0,217);
      var match=make_rel(context,x1,y1),_bn_=match[2],_bo_=match[1];
      caml_call1(bisect_visit$0,218);
      var match$0=make_rel(context,x2,y2),_bp_=match$0[2],_bq_=match$0[1];
      caml_call1(bisect_visit$0,219);
      var match$1=make_rel(context,x3,y3),y3$0=match$1[2],x3$0=match$1[1];
      caml_call1(bisect_visit$0,220);
      return curve_to$1(context,_bo_,_bn_,_bq_,_bp_,x3$0,y3$0)}
    function rectangle$1(context,x,y,w,h)
     {caml_call1(bisect_visit$0,223);
      set_current_point(context[2],[0,x,y]);
      caml_call1(bisect_visit$0,222);
      return context[1].rect(x,y,w,h)}
    function arc$1(dir,context,x,y,r,a1,a2)
     {caml_call1(bisect_visit$0,226);
      context[1].arc(x,y,r,a1,a2,dir);
      caml_call1(bisect_visit$0,225);
      set_start_point_if_none
       (context[2],[0,x + r * Math.cos(a1),y + r * Math.sin(a1)]);
      caml_call1(bisect_visit$0,224);
      return set_current_point
              (context[2],[0,x + r * Math.cos(a2),y + r * Math.sin(a2)])}
    caml_call1(bisect_visit$0,227);
    var _aD_=Js[8];
    function arc$2(_bh_,_bi_,_bj_,_bk_,_bl_,_bm_)
     {return arc$1(_aD_,_bh_,_bi_,_bj_,_bk_,_bl_,_bm_)}
    caml_call1(bisect_visit$0,228);
    var _aE_=Js[7];
    function arc_negative$1(_bb_,_bc_,_bd_,_be_,_bf_,_bg_)
     {return arc$1(_aE_,_bb_,_bc_,_bd_,_be_,_bf_,_bg_)}
    function get_current_point$0(context)
     {caml_call1(bisect_visit$0,231);
      var match=current_point(context[2]);
      if(match)
       {var match$0=match[1],y=match$0[2],x=match$0[1];
        caml_call1(bisect_visit$0,230);
        return [0,x,y]}
      caml_call1(bisect_visit$0,229);
      return _aF_}
    function clear$0(context)
     {caml_call1(bisect_visit$0,234);
      context[1].beginPath();
      caml_call1(bisect_visit$0,233);
      var _a$_=context[2];
      caml_call1(bisect_visit$0,171);
      var _a9_=_a$_[1];
      caml_call1(bisect_visit$0,140);
      _a9_[1] = 0;
      caml_call1(bisect_visit$0,232);
      var _ba_=context[2];
      caml_call1(bisect_visit$0,182);
      var _a__=_ba_[1];
      caml_call1(bisect_visit$0,143);
      _a__[2] = 0;
      return 0}
    function close$0(context)
     {caml_call1(bisect_visit$0,236);
      context[1].closePath();
      caml_call1(bisect_visit$0,235);
      return set_start_point_as_current_point(context[2])}
    var Path$1=[0,get_current_point$0,clear$0,close$0];
    function stroke_preserve$1(context)
     {caml_call1(bisect_visit$0,237);return context[1].stroke()}
    function stroke$1(context)
     {caml_call1(bisect_visit$0,239);
      stroke_preserve$1(context);
      caml_call1(bisect_visit$0,238);
      return caml_call1(Path$1[2],context)}
    function fill_preserve$1(context)
     {caml_call1(bisect_visit$0,242);
      var match=fill_rule(context[2]);
      return 0 === match
              ?(caml_call1(bisect_visit$0,240),context[1].fill())
              :(caml_call1(bisect_visit$0,241),context[1].fill("evenodd"))}
    function fill$1(context)
     {caml_call1(bisect_visit$0,244);
      fill_preserve$1(context);
      caml_call1(bisect_visit$0,243);
      return caml_call1(Path$1[2],context)}
    function clip_preserve$1(context)
     {caml_call1(bisect_visit$0,245);return context[1].clip()}
    function clip$1(context)
     {caml_call1(bisect_visit$0,247);
      clip_preserve$1(context);
      caml_call1(bisect_visit$0,246);
      return caml_call1(Path$1[2],context)}
    function paint$1(opt,context)
     {if(opt)
       var sth=opt[1],alpha=sth;
      else
       {caml_call1(bisect_visit$0,256);var alpha=1}
      caml_call1(bisect_visit$0,255);
      save$1(context);
      caml_call1(bisect_visit$0,254);
      context[1].globalAlpha = alpha;
      caml_call1(bisect_visit$0,253);
      identity_matrix$1(context);
      caml_call1(bisect_visit$0,252);
      caml_call1(bisect_visit$0,249);
      var width=context[1].canvas.width;
      caml_call1(bisect_visit$0,250);
      var height=context[1].canvas.height;
      caml_call1(bisect_visit$0,251);
      context[1].fillRect(0,0,width,height);
      caml_call1(bisect_visit$0,248);
      return restore$1(context)}
    function set_line_width$1(context,width)
     {caml_call1(bisect_visit$0,257);return context[1].lineWidth = width}
    function get_line_width$1(context)
     {caml_call1(bisect_visit$0,258);return context[1].lineWidth}
    function set_dash$1(context,opt,dashes)
     {if(opt)
       var sth=opt[1],ofs=sth;
      else
       {caml_call1(bisect_visit$0,263);var ofs=0}
      caml_call1(bisect_visit$0,262);
      caml_call1(bisect_visit$0,260);
      var html=context[1];
      caml_call1(bisect_visit$0,261);
      html.lineDashOffset = ofs;
      caml_call1(bisect_visit$0,259);
      return html.setLineDash(runtime.caml_js_from_array(dashes))}
    function get_dash$1(context)
     {caml_call1(bisect_visit$0,266);
      caml_call1(bisect_visit$0,264);
      var html=context[1];
      caml_call1(bisect_visit$0,265);
      var _a8_=html.lineDashOffset;
      return [0,runtime.caml_js_to_array(html.getLineDash()),_a8_]}
    function set_fill_rule$1(context,fill_rule)
     {caml_call1(bisect_visit$0,267);
      var _a7_=context[2];
      caml_call1(bisect_visit$0,167);
      var _a6_=state$0(_a7_);
      return set_state(_a7_,[0,_a6_[1],_a6_[2],_a6_[3],fill_rule])}
    function get_fill_rule$1(context)
     {caml_call1(bisect_visit$0,268);return fill_rule(context[2])}
    function set_line_cap$1(context,cap)
     {caml_call1(bisect_visit$0,274);
      caml_call1(bisect_visit$0,272);
      switch(cap)
       {case 0:caml_call1(bisect_visit$0,269);var cap$0=cst_butt;break;
        case 1:caml_call1(bisect_visit$0,270);var cap$0=cst_round;break;
        default:caml_call1(bisect_visit$0,271);var cap$0=cst_square}
      caml_call1(bisect_visit$0,273);
      return context[1].lineCap = cap$0.toString()}
    function get_line_cap$1(context)
     {caml_call1(bisect_visit$0,278);
      var match=caml_js_to_string(context[1].lineCap);
      return caml_string_notequal(match,cst_round$0)
              ?caml_string_notequal(match,cst_square$0)
                ?(caml_call1(bisect_visit$0,277),0)
                :(caml_call1(bisect_visit$0,276),2)
              :(caml_call1(bisect_visit$0,275),1)}
    function set_line_join$1(context,join)
     {caml_call1(bisect_visit$0,284);
      caml_call1(bisect_visit$0,282);
      switch(join)
       {case 0:caml_call1(bisect_visit$0,279);var join$0=cst_miter;break;
        case 1:caml_call1(bisect_visit$0,280);var join$0=cst_round$1;break;
        default:caml_call1(bisect_visit$0,281);var join$0=cst_bevel}
      caml_call1(bisect_visit$0,283);
      return context[1].lineJoin = join$0.toString()}
    function get_line_join$1(context)
     {caml_call1(bisect_visit$0,288);
      var match=caml_js_to_string(context[1].lineJoin);
      return caml_string_notequal(match,cst_bevel$0)
              ?caml_string_notequal(match,cst_round$2)
                ?(caml_call1(bisect_visit$0,287),0)
                :(caml_call1(bisect_visit$0,285),1)
              :(caml_call1(bisect_visit$0,286),2)}
    function set_miter_limit$1(context,l)
     {caml_call1(bisect_visit$0,289);return context[1].miterLimit = l}
    function get_miter_limit$1(context)
     {caml_call1(bisect_visit$0,290);return context[1].miterLimit}
    function set_operator$1(context,operator)
     {caml_call1(bisect_visit$0,307);
      caml_call1(bisect_visit$0,305);
      switch(operator)
       {case 0:
         caml_call1(bisect_visit$0,291);
         var operator$0=caml_call1(Stdlib[3],cst_Unsupported_operator_CLEAR);
         break;
        case 1:
         caml_call1(bisect_visit$0,292);
         var operator$0=caml_call1(Stdlib[3],cst_Unsupported_operator_SOURCE);
         break;
        case 2:
         caml_call1(bisect_visit$0,293);var operator$0=cst_source_over;break;
        case 3:
         caml_call1(bisect_visit$0,295);var operator$0=cst_source_in;break;
        case 4:
         caml_call1(bisect_visit$0,296);var operator$0=cst_source_out;break;
        case 5:
         caml_call1(bisect_visit$0,294);var operator$0=cst_source_atop;break;
        case 6:
         caml_call1(bisect_visit$0,303);
         var operator$0=caml_call1(Stdlib[3],cst_Unsupported_operator_DEST);
         break;
        case 7:
         caml_call1(bisect_visit$0,297);
         var operator$0=cst_destination_over;
         break;
        case 8:
         caml_call1(bisect_visit$0,299);
         var operator$0=cst_destination_in;
         break;
        case 9:
         caml_call1(bisect_visit$0,300);
         var operator$0=cst_destination_out;
         break;
        case 10:
         caml_call1(bisect_visit$0,298);
         var operator$0=cst_destination_atop;
         break;
        case 11:caml_call1(bisect_visit$0,302);var operator$0=cst_xor;break;
        case 12:
         caml_call1(bisect_visit$0,301);var operator$0=cst_lighter;break;
        default:
         caml_call1(bisect_visit$0,304);
         var
          operator$0=
           caml_call1(Stdlib[3],cst_Unsupported_operator_SATURATE)}
      caml_call1(bisect_visit$0,306);
      return context[1].globalCompositeOperation = operator$0.toString()}
    function get_operator$1(context)
     {caml_call1(bisect_visit$0,321);
      var
       op=caml_js_to_string(context[1].globalCompositeOperation),
       switch$0=runtime.caml_string_compare(op,cst_over);
      if(0 <= switch$0)
       {if(! (0 < switch$0)){caml_call1(bisect_visit$0,308);return 2}
        if(! caml_string_notequal(op,cst_source_atop$0))
         {caml_call1(bisect_visit$0,311);return 5}
        if(! caml_string_notequal(op,cst_source_in$0))
         {caml_call1(bisect_visit$0,312);return 3}
        if(! caml_string_notequal(op,cst_source_out$0))
         {caml_call1(bisect_visit$0,313);return 4}
        if(! caml_string_notequal(op,cst_source_over$0))
         {caml_call1(bisect_visit$0,310);return 2}
        if(! caml_string_notequal(op,cst_xor$0))
         {caml_call1(bisect_visit$0,319);return 11}}
      else
       {if(! caml_string_notequal(op,cst_add))
         {caml_call1(bisect_visit$0,309);return 12}
        if(! caml_string_notequal(op,cst_destination_atop$0))
         {caml_call1(bisect_visit$0,315);return 10}
        if(! caml_string_notequal(op,cst_destination_in$0))
         {caml_call1(bisect_visit$0,316);return 8}
        if(! caml_string_notequal(op,cst_destination_out$0))
         {caml_call1(bisect_visit$0,317);return 9}
        if(! caml_string_notequal(op,cst_destination_over$0))
         {caml_call1(bisect_visit$0,314);return 7}
        if(! caml_string_notequal(op,cst_lighter$0))
         {caml_call1(bisect_visit$0,318);return 12}}
      caml_call1(bisect_visit$0,320);
      var _a5_=caml_call2(Stdlib_printf[4],_aG_,op);
      return caml_call1(Stdlib[3],_a5_)}
    function set_source$1(context,pattern)
     {caml_call1(bisect_visit$0,350);
      function convert(x)
       {caml_call1(bisect_visit$0,348);
        return caml_call1(Stdlib[22],255 * x | 0)}
      caml_call1(bisect_visit$0,349);
      function convert_rgba(r,g,b,a)
       {caml_call1(bisect_visit$0,346);
        var _a2_=convert(b),_a3_=convert(g),_a4_=convert(r);
        return caml_call5(Stdlib_printf[4],_aH_,_a4_,_a3_,_a2_,a).toString()}
      caml_call1(bisect_visit$0,347);
      caml_call1(bisect_visit$0,344);
      var source=pattern[1];
      caml_call1(bisect_visit$0,345);
      var _aV_=context[2];
      caml_call1(bisect_visit$0,165);
      var _aU_=state$0(_aV_);
      set_state(_aV_,[0,_aU_[1],_aU_[2],source,_aU_[4]]);
      caml_call1(bisect_visit$0,343);
      if(typeof source === "number")
       {caml_call1(bisect_visit$0,342);return 0}
      else
       switch(source[0])
        {case 0:
          var match=source[1],a=match[4],b=match[3],g=match[2],r=match[1];
          caml_call1(bisect_visit$0,339);
          caml_call1(bisect_visit$0,323);
          var color=convert_rgba(r,g,b,a);
          caml_call1(bisect_visit$0,324);
          context[1].fillStyle = color;
          caml_call1(bisect_visit$0,322);
          return context[1].strokeStyle = color;
         case 1:
          var
           _aW_=source[1],
           stop_points=_aW_[2],
           match$0=_aW_[1],
           y1=match$0[4],
           x1=match$0[3],
           y0=match$0[2],
           x0=match$0[1];
          caml_call1(bisect_visit$0,340);
          caml_call1(bisect_visit$0,330);
          var gradient=context[1].createLinearGradient(x0,y0,x1,y1);
          caml_call1(bisect_visit$0,331);
          caml_call1(bisect_visit$0,326);
          var _aX_=to_list(stop_points);
          caml_call1(bisect_visit$0,328);
          var
           _aY_=
            function(param)
             {var
               a=param[5],
               b=param[4],
               g=param[3],
               r=param[2],
               position=param[1];
              caml_call1(bisect_visit$0,327);
              return gradient.addColorStop(position,convert_rgba(r,g,b,a))};
          caml_call1(caml_call1(Stdlib_listLabels[15],_aY_),_aX_);
          caml_call1(bisect_visit$0,329);
          context[1].fillStyle = gradient;
          caml_call1(bisect_visit$0,325);
          return context[1].strokeStyle = gradient;
         default:
          var
           _aZ_=source[1],
           stop_points$0=_aZ_[2],
           match$1=_aZ_[1],
           r1=match$1[6],
           y1$0=match$1[5],
           x1$0=match$1[4],
           r0=match$1[3],
           y0$0=match$1[2],
           x0$0=match$1[1];
          caml_call1(bisect_visit$0,341);
          caml_call1(bisect_visit$0,337);
          var
           gradient$0=
            context[1].createRadialGradient(x0$0,y0$0,r0,x1$0,y1$0,r1);
          caml_call1(bisect_visit$0,338);
          caml_call1(bisect_visit$0,333);
          var _a0_=to_list(stop_points$0);
          caml_call1(bisect_visit$0,335);
          var
           _a1_=
            function(param)
             {var
               a=param[5],
               b=param[4],
               g=param[3],
               r=param[2],
               position=param[1];
              caml_call1(bisect_visit$0,334);
              return gradient$0.addColorStop(position,convert_rgba(r,g,b,a))};
          caml_call1(caml_call1(Stdlib_listLabels[15],_a1_),_a0_);
          caml_call1(bisect_visit$0,336);
          context[1].fillStyle = gradient$0;
          caml_call1(bisect_visit$0,332);
          return context[1].strokeStyle = gradient$0}}
    function get_source$1(context)
     {caml_call1(bisect_visit$0,351);
      var _aT_=context[2];
      caml_call1(bisect_visit$0,164);
      return [0,state$0(_aT_)[3]]}
    function set_source_rgb$1(context,r,g,b)
     {caml_call1(bisect_visit$0,352);
      return set_source$1(context,create_rgb$0(r,g,b))}
    function set_source_rgba$1(context,r,g,b,a)
     {caml_call1(bisect_visit$0,353);
      return set_source$1(context,create_rgba$0(r,g,b,a))}
    function set_font(context,font)
     {var family=font[4],size=font[3],weight=font[2],slant=font[1];
      caml_call1(bisect_visit$0,365);
      var _aR_=context[2];
      caml_call1(bisect_visit$0,163);
      var _aQ_=state$0(_aR_);
      set_state(_aR_,[0,_aQ_[1],font,_aQ_[3],_aQ_[4]]);
      caml_call1(bisect_visit$0,364);
      caml_call1(bisect_visit$0,361);
      switch(slant)
       {case 0:caml_call1(bisect_visit$0,356);var _aS_=cst_normal;break;
        case 1:caml_call1(bisect_visit$0,357);var _aS_=cst_italic;break;
        default:caml_call1(bisect_visit$0,358);var _aS_=cst_oblique}
      caml_call1(bisect_visit$0,362);
      var
       font_weight=
        0 === weight
         ?(caml_call1(bisect_visit$0,359),cst_normal$0)
         :(caml_call1(bisect_visit$0,360),cst_bold);
      caml_call1(bisect_visit$0,363);
      caml_call1(bisect_visit$0,354);
      var
       font$0=
        caml_call5(Stdlib_printf[4],_aI_,_aS_,font_weight,size | 0,family);
      caml_call1(bisect_visit$0,355);
      return context[1].font = font$0.toString()}
    function select_font_face$1(context,opt,_aP_,family)
     {if(opt)
       var sth=opt[1],slant=sth;
      else
       {caml_call1(bisect_visit$0,368);var slant=0}
      if(_aP_)
       var sth$0=_aP_[1],weight=sth$0;
      else
       {caml_call1(bisect_visit$0,367);var weight=0}
      caml_call1(bisect_visit$0,366);
      return set_font(context,[0,slant,weight,font(context[2])[3],family])}
    function set_font_size$1(context,size)
     {caml_call1(bisect_visit$0,369);
      var _aO_=font(context[2]);
      return set_font(context,[0,_aO_[1],_aO_[2],size,_aO_[4]])}
    function show_text$1(context,s)
     {caml_call1(bisect_visit$0,374);
      caml_call1(bisect_visit$0,371);
      var match=caml_call1(Path$1[1],context),_aM_=match[2],_aN_=match[1];
      caml_call1(bisect_visit$0,372);
      var w=context[1].measureText(s.toString()).width;
      caml_call1(bisect_visit$0,373);
      set_current_point(context[2],[0,_aN_ + w,_aM_]);
      caml_call1(bisect_visit$0,370);
      return context[1].fillText(s.toString(),_aN_,_aM_)}
    function font_extents$1(context)
     {caml_call1(bisect_visit$0,377);
      caml_call1(bisect_visit$0,375);
      var match=font(context[2]),size=match[3];
      caml_call1(bisect_visit$0,376);
      return [254,size,size / 4,0,2 * size,0]}
    function text_extents$1(context,s)
     {caml_call1(bisect_visit$0,381);
      caml_call1(bisect_visit$0,378);
      var match=font(context[2]),_aL_=match[3];
      caml_call1(bisect_visit$0,379);
      var w=context[1].measureText(s.toString()).width;
      caml_call1(bisect_visit$0,380);
      return [254,0,0,w,_aL_,w,0]}
    function create$1(canvas)
     {caml_call1(bisect_visit$0,388);
      caml_call1(bisect_visit$0,385);
      var html=canvas.getContext(Dom_html[1]);
      caml_call1(bisect_visit$0,386);
      caml_call1(bisect_visit$0,150);
      var
       _aJ_=create_rgb$0(0,0,0)[1],
       _aK_=[0,[0,init_identity$0(0),_aC_,_aJ_,0],0];
      caml_call1(bisect_visit$0,136);
      var local=[0,[0,0,0],_aK_];
      caml_call1(bisect_visit$0,387);
      caml_call1(bisect_visit$0,383);
      var context=[0,html,local];
      caml_call1(bisect_visit$0,384);
      set_line_width$1(context,2);
      caml_call1(bisect_visit$0,382);
      return context}
    var
     JsOfOCairo=
      [0,
       Error$1,
       status_to_string$1,
       Unavailable$1,
       [0,
        init_identity$0,
        init_translate$0,
        init_scale$0,
        init_rotate$0,
        translate$2,
        scale$2,
        rotate$2,
        invert$0,
        multiply$0,
        transform_distance$0,
        transform_point$0],
       select_font_face$1,
       set_font_size$1,
       show_text$1,
       font_extents$1,
       text_extents$1,
       [0,
        add_color_stop_rgb$0,
        add_color_stop_rgba$0,
        get_color_stop_count$0,
        get_color_stop_rgba$0,
        create_rgb$0,
        create_rgba$0,
        get_rgba$0,
        create_linear$0,
        get_linear_points$0,
        create_radial$0,
        get_radial_circles$0],
       save$1,
       restore$1,
       set_source_rgb$1,
       set_source_rgba$1,
       set_source$1,
       get_source$1,
       set_line_cap$1,
       get_line_cap$1,
       set_line_join$1,
       get_line_join$1,
       set_line_width$1,
       get_line_width$1,
       set_miter_limit$1,
       get_miter_limit$1,
       set_dash$1,
       get_dash$1,
       set_operator$1,
       get_operator$1,
       set_fill_rule$1,
       get_fill_rule$1,
       clip$1,
       clip_preserve$1,
       fill$1,
       fill_preserve$1,
       paint$1,
       stroke$1,
       stroke_preserve$1,
       Path$1,
       arc$2,
       arc_negative$1,
       curve_to$1,
       line_to$1,
       move_to$1,
       rectangle$1,
       rel_curve_to$1,
       rel_line_to$1,
       rel_move_to$1,
       translate$3,
       scale$3,
       rotate$3,
       transform$2,
       set_matrix$1,
       get_matrix$1,
       identity_matrix$1,
       user_to_device$1,
       user_to_device_distance$1,
       device_to_user$1,
       device_to_user_distance$1,
       create$1];
    caml_register_global(450,JsOfOCairo,"JsOfOCairo");
    return}
  (function(){return this}()));


//# 1 "Tests/Tests.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_EVEN_ODD=caml_new_string("EVEN_ODD"),
     cst_WINDING=caml_new_string("WINDING"),
     cst_BUTT=caml_new_string("BUTT"),
     cst_ROUND=caml_new_string("ROUND"),
     cst_SQUARE=caml_new_string("SQUARE"),
     cst_JOIN_MITER=caml_new_string("JOIN_MITER"),
     cst_JOIN_ROUND=caml_new_string("JOIN_ROUND"),
     cst_JOIN_BEVEL=caml_new_string("JOIN_BEVEL"),
     cst_CLEAR=caml_new_string("CLEAR"),
     cst_SOURCE=caml_new_string("SOURCE"),
     cst_OVER=caml_new_string("OVER"),
     cst_IN=caml_new_string("IN"),
     cst_OUT=caml_new_string("OUT"),
     cst_ATOP=caml_new_string("ATOP"),
     cst_DEST=caml_new_string("DEST"),
     cst_DEST_OVER=caml_new_string("DEST_OVER"),
     cst_DEST_IN=caml_new_string("DEST_IN"),
     cst_DEST_OUT=caml_new_string("DEST_OUT"),
     cst_DEST_ATOP=caml_new_string("DEST_ATOP"),
     cst_XOR=caml_new_string("XOR"),
     cst_ADD=caml_new_string("ADD"),
     cst_SATURATE=caml_new_string("SATURATE"),
     cst_Not_found=caml_new_string("Not_found"),
     cst_Hello=caml_new_string("Hello"),
     partial=[11,caml_new_string(", "),[8,0,0,0,[12,41,0]]],
     partial$0=[12,41,0],
     partial$1=[11,caml_new_string("; y0="),[8,0,0,0,[12,125,0]]],
     cst_JsOfOCairo=caml_new_string("JsOfOCairo"),
     cst_Cairo=caml_new_string("Cairo"),
     cst_CairoMock=caml_new_string("CairoMock"),
     cst_create_radial_get_linear_points=
      caml_new_string("create_radial, get_linear_points"),
     cst_create_radial_get_rgba=caml_new_string("create_radial, get_rgba"),
     cst_create_linear_get_radial_circles=
      caml_new_string("create_linear, get_radial_circles"),
     cst_create_linear_get_rgba=caml_new_string("create_linear, get_rgba"),
     cst_create_rgb_get_color_stop_rgba=
      caml_new_string("create_rgb, get_color_stop_rgba"),
     cst_create_rgb_get_color_stop_count=
      caml_new_string("create_rgb, get_color_stop_count"),
     cst_create_rgb_get_radial_circles=
      caml_new_string("create_rgb, get_radial_circles"),
     cst_create_rgb_get_linear_points=
      caml_new_string("create_rgb, get_linear_points"),
     cst_mismatch=caml_new_string("mismatch"),
     cst_create_rgb_add_color_stop_rgb=
      caml_new_string("create_rgb, add_color_stop_rgb"),
     cst_multiple_color_stops=caml_new_string("multiple color stops"),
     cst_create_radial_add_color_stop_rgb_get_color_stop_count_get_color_stop_rgba=
      caml_new_string
       ("create_radial, add_color_stop_rgb, get_color_stop_count, get_color_stop_rgba"),
     cst_create_linear_add_color_stop_rgba_get_color_stop_count_get_color_stop_rgba=
      caml_new_string
       ("create_linear, add_color_stop_rgba, get_color_stop_count, get_color_stop_rgba"),
     cst_create_radial_get_radial_circles=
      caml_new_string("create_radial, get_radial_circles"),
     cst_create_linear_get_linear_points=
      caml_new_string("create_linear, get_linear_points"),
     cst_set_source_rgba_get_rgba=caml_new_string("set_source_rgba, get_rgba"),
     cst_create_rgba_get_rgba=caml_new_string("create_rgba, get_rgba"),
     cst_set_source_rgb_get_rgba=caml_new_string("set_source_rgb, get_rgba"),
     cst_create_rgb_get_rgba=caml_new_string("create_rgb, get_rgba"),
     cst_patterns=caml_new_string("patterns"),
     cst_show_text=caml_new_string("show_text"),
     cst_clip_preserve=caml_new_string("clip_preserve"),
     cst_fill_preserve=caml_new_string("fill_preserve"),
     cst_stroke_preserve=caml_new_string("stroke_preserve"),
     cst_Path_close=caml_new_string("Path.close"),
     cst_rel_line_to=caml_new_string("rel_line_to"),
     cst_curve_to=caml_new_string("curve_to"),
     cst_pi_2=caml_new_string("pi / 2"),
     cst_pi_4=caml_new_string("pi / 4"),
     cst_pi_6=caml_new_string("pi / 6"),
     cst_0=caml_new_string("0"),
     cst_arc_negative=caml_new_string("arc_negative"),
     cst_3_pi=caml_new_string("3 pi"),
     cst_pi_2$0=caml_new_string("pi / 2"),
     cst_pi_4$0=caml_new_string("pi / 4"),
     cst_pi_6$0=caml_new_string("pi / 6"),
     cst_0$0=caml_new_string("0"),
     cst_arc=caml_new_string("arc"),
     cst_rectangle=caml_new_string("rectangle"),
     cst_rel_line_to$0=caml_new_string("rel_line_to"),
     cst_line_to=caml_new_string("line_to"),
     cst_rel_move_to=caml_new_string("rel_move_to"),
     cst_save_scale_move_to_restore=
      caml_new_string("save, scale, move_to, restore"),
     cst_save_move_to_restore=caml_new_string("save, move_to, restore"),
     cst_move_to_paint=caml_new_string("move_to, paint"),
     cst_paint=caml_new_string("paint"),
     cst_move_to=caml_new_string("move_to"),
     cst_no_op=caml_new_string("no-op"),
     cst_current_point=caml_new_string("current point"),
     cst_clip=caml_new_string("clip"),
     cst_fill=caml_new_string("fill"),
     cst_stroke=caml_new_string("stroke"),
     cst_Path_clear=caml_new_string("Path.clear"),
     cst_rel_curve_to=caml_new_string("rel_curve_to"),
     cst_rel_line_to$1=caml_new_string("rel_line_to"),
     cst_rel_move_to$0=caml_new_string("rel_move_to"),
     cst_no_current_point=caml_new_string("no current point"),
     cst_invalid_restore=caml_new_string("invalid restore"),
     cst_coordinates_transformation=
      caml_new_string("coordinates transformation"),
     cst_rotate=caml_new_string("rotate"),
     cst_translate=caml_new_string("translate"),
     cst_scale=caml_new_string("scale"),
     cst_invertible=caml_new_string("invertible"),
     cst_non_invertible=caml_new_string("non invertible"),
     cst_invert=caml_new_string("invert"),
     cst_init_rotate=caml_new_string("init_rotate"),
     cst_init_scale=caml_new_string("init_scale"),
     cst_init_translate=caml_new_string("init_translate"),
     cst_init_identity=caml_new_string("init_identity"),
     cst_matrix=caml_new_string("matrix"),
     cst_transform=caml_new_string("transform"),
     cst_set_matrix=caml_new_string("set_matrix"),
     cst_rotate$0=caml_new_string("rotate"),
     cst_scale$0=caml_new_string("scale"),
     cst_translate$0=caml_new_string("translate"),
     cst_transformations=caml_new_string("transformations"),
     cst_Not_Cairo=caml_new_string("Not Cairo"),
     cst_Cairo_Error=caml_new_string("Cairo Error"),
     cst_exceptions=caml_new_string("exceptions"),
     cst_CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID_used_but_no_CAIRO_MIME_TYPE_JBIG2_GLOBAL_data_provided=
      caml_new_string
       ("CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID used but no CAIRO_MIME_TYPE_JBIG2_GLOBAL data provided"),
     cst_JBIG2_GLOBAL_MISSING=caml_new_string("JBIG2_GLOBAL_MISSING"),
     cst_the_target_device_has_been_finished=
      caml_new_string("the target device has been finished"),
     cst_DEVICE_FINISHED=caml_new_string("DEVICE_FINISHED"),
     cst_invalid_operation_during_mesh_pattern_construction=
      caml_new_string("invalid operation during mesh pattern construction"),
     cst_INVALID_MESH_CONSTRUCTION=
      caml_new_string("INVALID_MESH_CONSTRUCTION"),
     cst_an_operation_to_the_device_caused_an_unspecified_error=
      caml_new_string
       ("an operation to the device caused an unspecified error"),
     cst_DEVICE_ERROR=caml_new_string("DEVICE_ERROR"),
     cst_the_device_type_is_not_appropriate_for_the_operation=
      caml_new_string("the device type is not appropriate for the operation"),
     cst_DEVICE_TYPE_MISMATCH=caml_new_string("DEVICE_TYPE_MISMATCH"),
     cst_user_font_method_not_implemented=
      caml_new_string("user-font method not implemented"),
     cst_USER_FONT_NOT_IMPLEMENTED=
      caml_new_string("USER_FONT_NOT_IMPLEMENTED"),
     cst_invalid_value_typically_too_big_for_the_size_of_the_input_surface_pattern_etc=
      caml_new_string
       ("invalid value (typically too big) for the size of the input (surface, pattern, etc.)"),
     cst_INVALID_SIZE=caml_new_string("INVALID_SIZE"),
     cst_invalid_value_for_an_input_cairo_font_weight_t=
      caml_new_string("invalid value for an input cairo_font_weight_t"),
     cst_INVALID_WEIGHT=caml_new_string("INVALID_WEIGHT"),
     cst_invalid_value_for_an_input_cairo_font_slant_t=
      caml_new_string("invalid value for an input cairo_font_slant_t"),
     cst_INVALID_SLANT=caml_new_string("INVALID_SLANT"),
     cst_input_clusters_do_not_represent_the_accompanying_text_and_glyph_arrays=
      caml_new_string
       ("input clusters do not represent the accompanying text and glyph arrays"),
     cst_INVALID_CLUSTERS=caml_new_string("INVALID_CLUSTERS"),
     cst_negative_number_used_where_it_is_not_allowed=
      caml_new_string("negative number used where it is not allowed"),
     cst_NEGATIVE_COUNT=caml_new_string("NEGATIVE_COUNT"),
     cst_error_occurred_in_a_user_font_callback_function=
      caml_new_string("error occurred in a user-font callback function"),
     cst_USER_FONT_ERROR=caml_new_string("USER_FONT_ERROR"),
     cst_the_user_font_is_immutable=
      caml_new_string("the user-font is immutable"),
     cst_USER_FONT_IMMUTABLE=caml_new_string("USER_FONT_IMMUTABLE"),
     cst_the_font_type_is_not_appropriate_for_the_operation=
      caml_new_string("the font type is not appropriate for the operation"),
     cst_FONT_TYPE_MISMATCH=caml_new_string("FONT_TYPE_MISMATCH"),
     cst_invalid_value_for_stride=caml_new_string("invalid value for stride"),
     cst_INVALID_STRIDE=caml_new_string("INVALID_STRIDE"),
     cst_error_creating_or_writing_to_a_temporary_file=
      caml_new_string("error creating or writing to a temporary file"),
     cst_TEMP_FILE_ERROR=caml_new_string("TEMP_FILE_ERROR"),
     cst_clip_region_not_representable_in_desired_format=
      caml_new_string("clip region not representable in desired format"),
     cst_CLIP_NOT_REPRESENTABLE=caml_new_string("CLIP_NOT_REPRESENTABLE"),
     cst_invalid_index_passed_to_getter=
      caml_new_string("invalid index passed to getter"),
     cst_INVALID_INDEX=caml_new_string("INVALID_INDEX"),
     cst_invalid_value_for_a_DSC_comment=
      caml_new_string("invalid value for a DSC comment"),
     cst_INVALID_DSC_COMMENT=caml_new_string("INVALID_DSC_COMMENT"),
     cst_invalid_value_for_a_dash_setting=
      caml_new_string("invalid value for a dash setting"),
     cst_INVALID_DASH=caml_new_string("INVALID_DASH"),
     cst_file_not_found=caml_new_string("file not found"),
     cst_FILE_NOT_FOUND=caml_new_string("FILE_NOT_FOUND"),
     cst_invalid_value_for_an_input_Visual=
      caml_new_string("invalid value for an input Visual*"),
     cst_INVALID_VISUAL=caml_new_string("INVALID_VISUAL"),
     cst_invalid_value_for_an_input_cairo_format_t=
      caml_new_string("invalid value for an input cairo_format_t"),
     cst_INVALID_FORMAT=caml_new_string("INVALID_FORMAT"),
     cst_invalid_value_for_an_input_cairo_content_t=
      caml_new_string("invalid value for an input cairo_content_t"),
     cst_INVALID_CONTENT=caml_new_string("INVALID_CONTENT"),
     cst_the_pattern_type_is_not_appropriate_for_the_operation=
      caml_new_string("the pattern type is not appropriate for the operation"),
     cst_PATTERN_TYPE_MISMATCH=caml_new_string("PATTERN_TYPE_MISMATCH"),
     cst_the_surface_type_is_not_appropriate_for_the_operation=
      caml_new_string("the surface type is not appropriate for the operation"),
     cst_SURFACE_TYPE_MISMATCH=caml_new_string("SURFACE_TYPE_MISMATCH"),
     cst_the_target_surface_has_been_finished=
      caml_new_string("the target surface has been finished"),
     cst_SURFACE_FINISHED=caml_new_string("SURFACE_FINISHED"),
     cst_error_while_writing_to_output_stream=
      caml_new_string("error while writing to output stream"),
     cst_WRITE_ERROR=caml_new_string("WRITE_ERROR"),
     cst_error_while_reading_from_input_stream=
      caml_new_string("error while reading from input stream"),
     cst_READ_ERROR=caml_new_string("READ_ERROR"),
     cst_input_path_data_not_valid=
      caml_new_string("input path data not valid"),
     cst_INVALID_PATH_DATA=caml_new_string("INVALID_PATH_DATA"),
     cst_input_string_not_valid_UTF_8=
      caml_new_string("input string not valid UTF-8"),
     cst_INVALID_STRING=caml_new_string("INVALID_STRING"),
     cst_NULL_pointer=caml_new_string("NULL pointer"),
     cst_NULL_POINTER=caml_new_string("NULL_POINTER"),
     cst_invalid_value_for_an_input_cairo_status_t=
      caml_new_string("invalid value for an input cairo_status_t"),
     cst_INVALID_STATUS=caml_new_string("INVALID_STATUS"),
     cst_invalid_matrix_not_invertible=
      caml_new_string("invalid matrix (not invertible)"),
     cst_INVALID_MATRIX=caml_new_string("INVALID_MATRIX"),
     cst_no_current_point_defined=caml_new_string("no current point defined"),
     cst_NO_CURRENT_POINT=caml_new_string("NO_CURRENT_POINT"),
     cst_no_saved_group_to_pop_i_e_cairo_pop_group_without_matching_cairo_push_group=
      caml_new_string
       ("no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group()"),
     cst_INVALID_POP_GROUP=caml_new_string("INVALID_POP_GROUP"),
     cst_cairo_restore_without_matching_cairo_save=
      caml_new_string("cairo_restore() without matching cairo_save()"),
     cst_INVALID_RESTORE=caml_new_string("INVALID_RESTORE"),
     cst_status_to_string=caml_new_string("status_to_string"),
     cst_source=caml_new_string("source"),
     cst_offset=caml_new_string("offset"),
     cst_dashes=caml_new_string("dashes"),
     cst_dash=caml_new_string("dash"),
     cst_operator=caml_new_string("operator"),
     cst_line_join=caml_new_string("line_join"),
     cst_line_cap=caml_new_string("line_cap"),
     cst_fill_rule=caml_new_string("fill_rule"),
     cst_miter_limit=caml_new_string("miter_limit"),
     cst_line_width=caml_new_string("line_width"),
     cst_saved_and_restored_settings=
      caml_new_string("saved-and-restored settings"),
     point_definitions=
      caml_new_string
       ("\x84\x95\xa6\xbe\0\0\x05\x96\0\0\0\xe8\0\0\x03\x9d\0\0\x03\x9d\b\0\x03\x9c\0\xa0\x01\x01!B\xa0\x01\x01<@\xa0\x01\x01\x9dA\xa0\x01\x01\xd1K\xa0\x01\x01\xfeI\xa0\x01\x02\bH\xa0\x01\x02+G\xa0\x01\x02NF\xa0\x01\x02qE\xa0\x01\x02\x94D\xa0\x01\x02\xb7C\xa0\x01\x03|J\xa0\x01\x03\xb4P\xa0\x01\x03\xd8N\xa0\x01\x03\xd9M\xa0\x01\x03\xfdL\xa0\x01\x04\x82O\xa0\x01\x04\xb6R\xa0\x01\x05'Q\xa0\x01\x05YT\xa0\x01\x05\xd3S\xa0\x01\x06\x05V\xa0\x01\x06\x88U\xa0\x01\x06\xa7\x01\0\xe6\xa0\x01\x07Mp\xa0\x01\x07qn\xa0\x01\x07\x8ao\xa0\x01\x07\xc0m\xa0\x01\x07\xf8l\xa0\x01\b\x1dk\xa0\x01\b;j\xa0\x01\bki\xa0\x01\b\x81h\xa0\x01\b\xb1g\xa0\x01\b\xd5f\xa0\x01\t\x0be\xa0\x01\t$d\xa0\x01\tnq\xa0\x01\n5W\xa0\x01\n\xd7X\xa0\x01\x0bAY\xa0\x01\x0b\xf6Z\xa0\x01\f][\xa0\x01\r0\\\xa0\x01\r\xa9]\xa0\x01\x13#^\xa0\x01\x13K`\xa0\x01\x13Y_\xa0\x01\x13\xcea\xa0\x01\x13\xfdc\xa0\x01\x14\rb\xa0\x01\x14\xf8r\xa0\x01\x15]s\xa0\x01$\xd3\0H\xa0\x01%\x07\0I\xa0\x01%*\0F\xa0\x01%N\0D\xa0\x01%g\0E\xa0\x01%\xa3\0C\xa0\x01%\xb4\0B\xa0\x01%\xe7\0A\xa0\x01%\xfb\0@\xa0\x01&.\x7f\xa0\x01&M~\xa0\x01&\x89}\xa0\x01&\xa0|\xa0\x01&\xe3\0G\xa0\x01'\bt\xa0\x01'fu\xa0\x01'\xc1v\xa0\x01'\xe2w\xa0\x01'\xf7x\xa0\x01(Hy\xa0\x01(\xd0{\xa0\x01(\xdfz\xa0\x01,c\0J\xa0\x01,\x9d\0K\xa0\x01,\xf8\0M\xa0\x01-0\0N\xa0\x01-K\0L\xa0\x01-\xd9\0P\xa0\x01.\x0f\0Q\xa0\x01.-\0O\xa0\x01.\xab\0S\xa0\x01.\xe1\0T\xa0\x01/\x03\0R\xa0\x01/}\0X\xa0\x01/\xb3\0Y\xa0\x01/\xda\0W\xa0\x01/\xe2\0U\xa0\x01/\xfe\0V\xa0\x010\xbf\0`\xa0\x010\xd9\0a\xa0\x011\r\0b\xa0\x011%\0_\xa0\x011h\0^\xa0\x011\xb5\0]\xa0\x011\xf9\0\\\xa0\x012F\0[\xa0\x012\x90\0Z\xa0\x013\x18\0c\xa0\x013-\0d\xa0\x013\xba\0y\xa0\x013\xde\0w\xa0\x013\xf7\0x\xa0\x014T\0z\xa0\x014{\0e\xa0\x014\xb6\0f\xa0\x014\xf2\0g\xa0\x0159\0j\xa0\x015J\0i\xa0\x015X\0h\xa0\x015\x8e\0n\xa0\x015\x9f\0m\xa0\x015\xb0\0l\xa0\x015\xba\0k\xa0\x015\xee\0r\xa0\x015\xff\0q\xa0\x016\x10\0p\xa0\x016\x18\0o\xa0\x016L\0v\xa0\x016]\0u\xa0\x016n\0t\xa0\x016v\0s\xa0\x016\xdc\x01\0\xae\xa0\x017\0\x01\0\xac\xa0\x017\x19\x01\0\xad\xa0\x017*\x01\0\xab\xa0\x017g\x01\0\xaf\xa0\x017\xd1\x01\0\xa9\xa0\x018\x16\x01\0\xaa\xa0\x0187\0{\xa0\x018f\0|\xa0\x018\xce\0~\xa0\x018\xdf\0}\xa0\x0198\x01\0\x81\xa0\x019L\x01\0\x80\xa0\x019i\0\x7f\xa0\x019\xe1\x01\0\x85\xa0\x019\xf5\x01\0\x84\xa0\x01:\x10\x01\0\x83\xa0\x01:-\x01\0\x82\xa0\x01:}\x01\0\x87\xa0\x01:\x8e\x01\0\x86\xa0\x01:\xce\x01\0\x88\xa0\x01;\x0e\x01\0\x8a\xa0\x01;\x1f\x01\0\x89\xa0\x01;a\x01\0\x8b\xa0\x01;\xbb\x01\0\x8c\xa0\x01<\x0b\x01\0\x8d\xa0\x01<\x8e\x01\0\x8e\xa0\x01=\x1c\x01\0\x8f\xa0\x01=u\x01\0\x90\xa0\x01=\xfc\x01\0\x91\xa0\x01>U\x01\0\x92\xa0\x01>\xe1\x01\0\x93\xa0\x01?x\x01\0\x94\xa0\x01?\xe7\x01\0\x95\xa0\x01@4\x01\0\x97\xa0\x01@E\x01\0\x96\xa0\x01@\x95\x01\0\x9b\xa0\x01@\xa6\x01\0\x9a\xa0\x01@\xb7\x01\0\x99\xa0\x01@\xc8\x01\0\x98\xa0\x01A\t\x01\0\x9e\xa0\x01A\x1a\x01\0\x9d\xa0\x01A+\x01\0\x9c\xa0\x01Ao\x01\0\xa1\xa0\x01A\x80\x01\0\xa0\xa0\x01A\x91\x01\0\x9f\xa0\x01A\xd3\x01\0\xa4\xa0\x01A\xe4\x01\0\xa3\xa0\x01A\xf5\x01\0\xa2\xa0\x01B4\x01\0\xa6\xa0\x01BE\x01\0\xa5\xa0\x01Bs\x01\0\xa8\xa0\x01B\xa2\x01\0\xa7\xa0\x01C,\x01\0\xb0\xa0\x01CN\x01\0\xb1\xa0\x01C\xd5\x01\0\xb5\xa0\x01C\xec\x01\0\xb6\xa0\x01D\x14\x01\0\xb4\xa0\x01D\x1c\x01\0\xb2\xa0\x01D6\x01\0\xb3\xa0\x01D\xb8\x01\0\xb7\xa0\x01D\xdf\x01\0\xb8\xa0\x01Eh\x01\0\xbc\xa0\x01E\x7f\x01\0\xbd\xa0\x01E\xac\x01\0\xbb\xa0\x01E\xb4\x01\0\xb9\xa0\x01E\xce\x01\0\xba\xa0\x01F\\\x01\0\xbe\xa0\x01F\x91\x01\0\xbf\xa0\x01G%\x01\0\xc0\xa0\x01Gh\x01\0\xc1\xa0\x01H1\x01\0\xc4\xa0\x01Hf\x01\0\xc5\xa0\x01H\x9e\x01\0\xc3\xa0\x01H\xd6\x01\0\xc2\xa0\x01I\xa7\x01\0\xc8\xa0\x01I\xea\x01\0\xc9\xa0\x01J\x14\x01\0\xc7\xa0\x01JL\x01\0\xc6\xa0\x01J\xe3\x01\0\xd2\xa0\x01K\x18\x01\0\xd3\xa0\x01KK\x01\0\xd1\xa0\x01K~\x01\0\xd0\xa0\x01K\xb4\x01\0\xcf\xa0\x01K\xe7\x01\0\xce\xa0\x01L\x1f\x01\0\xcd\xa0\x01L~\x01\0\xcc\xa0\x01L\xdd\x01\0\xcb\xa0\x01M?\x01\0\xca\xa0\x01M\xe3\x01\0\xdd\xa0\x01M\xfa\x01\0\xde\xa0\x01N+\x01\0\xdc\xa0\x01N3\x01\0\xda\xa0\x01N\xcd\x01\0\xdb\xa0\x01O\0\x01\0\xd9\xa0\x01O3\x01\0\xd8\xa0\x01O\x89\x01\0\xd7\xa0\x01O\xeb\x01\0\xd6\xa0\x01PJ\x01\0\xd5\xa0\x01P\xaa\x01\0\xd4\xa0\x01QQ\x01\0\xe4\xa0\x01Qw\x01\0\xe2\xa0\x01Q\xb0\x01\0\xe3\xa0\x01Q\xce\x01\0\xe1\xa0\x01Q\xd6\x01\0\xdf\xa0\x01Q\xf4\x01\0\xe0\xa0\x01RZ\x01\0\xe5"),
     cst_tst_Tests_Universal_ml=caml_new_string("tst/Tests/Universal.ml"),
     cst_foo_bar$3=caml_new_string("foo-bar"),
     cst_foo_bar$2=caml_new_string("foo-bar"),
     cst_foo_bar$1=caml_new_string("foo-bar"),
     cst_foo_bar$0=caml_new_string("foo-bar"),
     cst_foo_bar=caml_new_string("foo-bar"),
     cst_flibidiboo=caml_new_string("flibidiboo"),
     cst_abcd=caml_new_string("abcd"),
     cst_JsOfOCairo$0=caml_new_string("JsOfOCairo"),
     cst_Cairo$0=caml_new_string("Cairo"),
     cst_CairoMock$0=caml_new_string("CairoMock"),
     partial$2=[12,125,0],
     cst_font_extents=caml_new_string("font_extents"),
     partial$3=[11,caml_new_string("; y_advance="),[8,0,0,0,[12,125,0]]],
     cst_text_extents=caml_new_string("text_extents"),
     cst_show_text$0=caml_new_string("show_text"),
     cst_select_font_face_Italic_Bold=
      caml_new_string("select_font_face Italic Bold"),
     cst_select_font_face_Normal=caml_new_string("select_font_face Normal"),
     cst_select_font_face_Oblique=caml_new_string("select_font_face Oblique"),
     cst_select_font_face_Upright=caml_new_string("select_font_face Upright"),
     cst_select_font_face=caml_new_string("select_font_face"),
     cst_set_font_size=caml_new_string("set_font_size"),
     cst_get_source=caml_new_string("get_source"),
     cst_set_source_RadialGradient=
      caml_new_string("set_source RadialGradient"),
     cst_set_source_LinearGradient=
      caml_new_string("set_source LinearGradient"),
     cst_set_source_Rgba=caml_new_string("set_source Rgba"),
     cst_set_source_rgba=caml_new_string("set_source_rgba"),
     cst_set_source_rgb=caml_new_string("set_source_rgb"),
     cst_get_operator=caml_new_string("get_operator"),
     cst_set_operator_SATURATE=caml_new_string("set_operator SATURATE"),
     cst_set_operator_SOURCE=caml_new_string("set_operator SOURCE"),
     cst_set_operator_CLEAR=caml_new_string("set_operator CLEAR"),
     cst_set_operator_DEST=caml_new_string("set_operator DEST"),
     cst_set_operator_ADD=caml_new_string("set_operator ADD"),
     cst_set_operator_XOR=caml_new_string("set_operator XOR"),
     cst_set_operator_DEST_ATOP=caml_new_string("set_operator DEST_ATOP"),
     cst_set_operator_DEST_OUT=caml_new_string("set_operator DEST_OUT"),
     cst_set_operator_DEST_IN=caml_new_string("set_operator DEST_IN"),
     cst_set_operator_DEST_OVER=caml_new_string("set_operator DEST_OVER"),
     cst_set_operator_ATOP=caml_new_string("set_operator ATOP"),
     cst_set_operator_OUT=caml_new_string("set_operator OUT"),
     cst_set_operator_IN=caml_new_string("set_operator IN"),
     cst_get_miter_limit=caml_new_string("get_miter_limit"),
     cst_set_miter_limit=caml_new_string("set_miter_limit"),
     cst_get_line_join=caml_new_string("get_line_join"),
     cst_set_line_join_JOIN_BEVEL=caml_new_string("set_line_join JOIN_BEVEL"),
     cst_set_line_join_JOIN_ROUND=caml_new_string("set_line_join JOIN_ROUND"),
     cst_get_line_cap=caml_new_string("get_line_cap"),
     cst_set_line_cap_SQUARE=caml_new_string("set_line_cap SQUARE"),
     cst_set_line_cap_ROUND=caml_new_string("set_line_cap ROUND"),
     cst_get_fill_rule=caml_new_string("get_fill_rule"),
     cst_set_fill_rule=caml_new_string("set_fill_rule"),
     cst_get_dash=caml_new_string("get_dash"),
     cst_set_dash_with_ofs=caml_new_string("set_dash with ofs"),
     cst_set_dash=caml_new_string("set_dash"),
     cst_get_line_width=caml_new_string("get_line_width"),
     cst_set_line_width=caml_new_string("set_line_width"),
     cst_paint_with_alpha=caml_new_string("paint with alpha"),
     cst_paint$0=caml_new_string("paint"),
     cst_clip_preserve$0=caml_new_string("clip_preserve"),
     cst_clip$0=caml_new_string("clip"),
     cst_fill_preserve$0=caml_new_string("fill_preserve"),
     cst_fill$0=caml_new_string("fill"),
     cst_stroke_preserve$0=caml_new_string("stroke_preserve"),
     cst_stroke$0=caml_new_string("stroke"),
     cst_move_to_Path_get_current_point=
      caml_new_string("move_to, Path.get_current_point"),
     cst_Path_get_current_point=caml_new_string("Path.get_current_point"),
     cst_Path_clear$0=caml_new_string("Path.clear"),
     cst_Path_close$0=caml_new_string("Path.close"),
     cst_arc_negative$0=caml_new_string("arc_negative"),
     cst_arc$0=caml_new_string("arc"),
     cst_rectangle$0=caml_new_string("rectangle"),
     cst_rel_curve_to$0=caml_new_string("rel_curve_to"),
     cst_invalid_rel_curve_to=caml_new_string("invalid rel_curve_to"),
     cst_curve_to$0=caml_new_string("curve_to"),
     cst_rel_line_to$2=caml_new_string("rel_line_to"),
     cst_invalid_rel_line_to=caml_new_string("invalid rel_line_to"),
     cst_line_to$0=caml_new_string("line_to"),
     cst_rel_move_to$1=caml_new_string("rel_move_to"),
     cst_invalid_rel_move_to=caml_new_string("invalid rel_move_to"),
     cst_move_to$0=caml_new_string("move_to"),
     cst_device_to_user_distance=caml_new_string("device_to_user_distance"),
     cst_device_to_user=caml_new_string("device_to_user"),
     cst_user_to_device_distance=caml_new_string("user_to_device_distance"),
     cst_user_to_device=caml_new_string("user_to_device"),
     cst_get_matrix=caml_new_string("get_matrix"),
     cst_identity_matrix=caml_new_string("identity_matrix"),
     cst_set_matrix$0=caml_new_string("set_matrix"),
     cst_transform$0=caml_new_string("transform"),
     cst_rotate$1=caml_new_string("rotate"),
     cst_translate$1=caml_new_string("translate"),
     cst_scale$1=caml_new_string("scale"),
     cst_invalid_restore$0=caml_new_string("invalid restore"),
     cst_save_restore=caml_new_string("save, restore"),
     point_definitions$0=
      caml_new_string
       ('\x84\x95\xa6\xbe\0\0\x01\xb7\0\0\0T\0\0\x01M\0\0\x01M\b\0\x01L\0\xa0\x01\x01VB\xa0\x01\x01q@\xa0\x01\x01\xd2A\xa0\x01\x02\x10I\xa0\x01\x02.G\xa0\x01\x02LH\xa0\x01\x02aE\xa0\x01\x02yF\xa0\x01\x02\xa7D\xa0\x01\x02\xd2C\xa0\x01\x03\x0eJ\xa0\x01\x03LL\xa0\x01\x03xK\xa0\x01\x03\xbcN\xa0\x01\x03\xe7M\xa0\x01\x040O\xa0\x01\x04v\0R\xa0\x01\x05\x85P\xa0\x01\x05\xc6Q\xa0\x01\x06\fR\xa0\x01\x06GS\xa0\x01\x06\xe3T\xa0\x01\b,U\xa0\x01\b\x9dV\xa0\x01\t\x17W\xa0\x01\t\x88X\xa0\x01\t\xfcY\xa0\x01\nhZ\xa0\x01\n\xf3[\xa0\x01\x0b\x0e\\\xa0\x01\x0bp]\xa0\x01\x0b\xdc^\xa0\x01\fg_\xa0\x01\f\x82`\xa0\x01\f\xe5a\xa0\x01\rob\xa0\x01\x0e\x18c\xa0\x01\x0e3d\xa0\x01\x0e\xb9e\xa0\x01\x0f\x18f\xa0\x01\x0f\x86g\xa0\x01\x10\xddh\xa0\x01\x12\xe6i\xa0\x01\x13sj\xa0\x01\x13\xcck\xa0\x01\x14ll\xa0\x01\x15\x0bm\xa0\x01\x15`n\xa0\x01\x15\xf9o\xa0\x01\x16_p\xa0\x01\x17\x02q\xa0\x01\x17\x9cr\xa0\x01\x17\xe8s\xa0\x01\x187t\xa0\x01\x18\x8du\xa0\x01\x18\xebv\xa0\x01\x19Fw\xa0\x01\x19\xa4x\xa0\x01\x19\xfey\xa0\x01\x1aLz\xa0\x01\x1b\0{\xa0\x01\x1bR|\xa0\x01\x1b\xa7}\xa0\x01\x1c\0~\xa0\x01\x1c\x9d\x7f\xa0\x01\x1d\x01\0@\xa0\x01\x1dp\0A\xa0\x01\x1e\x18\0E\xa0\x01\x1e \0C\xa0\x01\x1e]\0D\xa0\x01\x1e\x8f\0B\xa0\x01\x1fc\0F\xa0\x01 \x96\0G\xa0\x01 \xe6\0H\xa0\x01!R\0I\xa0\x01!\xdc\0J\xa0\x01"e\0K\xa0\x01"\xf3\0L\xa0\x01#\x86\0M\xa0\x01#\xe5\0N\xa0\x01$\xad\0O\xa0\x01%\xc2\0Q\xa0\x01%\xf5\0P'),
     cst_tst_Tests_Decoration_ml=caml_new_string("tst/Tests/Decoration.ml"),
     cst_paint_with_alpha_4=caml_new_string("paint with alpha 4"),
     cst_paint_with_alpha_3=caml_new_string("paint with alpha 3"),
     cst_paint_with_alpha_2=caml_new_string("paint with alpha 2"),
     cst_paint_with_alpha_1=caml_new_string("paint with alpha 1"),
     cst_set_source_radial_gradient=
      caml_new_string("set_source radial gradient"),
     cst_set_source_linear_gradient=
      caml_new_string("set_source linear gradient"),
     cst_set_source_rgba$0=caml_new_string("set_source_rgba"),
     cst_set_source_rgb$0=caml_new_string("set_source_rgb"),
     cst_clip_paint=caml_new_string("clip paint"),
     cst_drawing_functions=caml_new_string("drawing functions"),
     cst_scale_identity_matrix=caml_new_string("scale identity_matrix"),
     cst_scale_rotate_translate_save_restore=
      caml_new_string("scale rotate translate save restore"),
     cst_set_dash$0=caml_new_string("set_dash"),
     cst_set_operator=caml_new_string("set_operator"),
     cst_set_line_join=caml_new_string("set_line_join"),
     cst_set_line_cap=caml_new_string("set_line_cap"),
     cst_set_fill_rule$0=caml_new_string("set_fill_rule"),
     cst_set_miter_limit$0=caml_new_string("set_miter_limit"),
     cst_set_line_width$0=caml_new_string("set_line_width"),
     point_definitions$1=
      caml_new_string
       ('\x84\x95\xa6\xbe\0\0\x03\xac\0\0\0\xa2\0\0\x02\x85\0\0\x02\x85\b\0\x02\x84\0\xa0\x01\0\xfd@\xa0\x01\x01NI\xa0\x01\x01\x91H\xa0\x01\x01\xa1G\xa0\x01\x01\xc2F\xa0\x01\x01\xd6E\xa0\x01\x02 D\xa0\x01\x025C\xa0\x01\x02NB\xa0\x01\x02fA\xa0\x01\x02\xaa\x01\0\xa0\xa0\x01\x02\xf9M\xa0\x01\x03 L\xa0\x01\x03=K\xa0\x01\x03ZJ\xa0\x01\x03\xc2W\xa0\x01\x03\xebV\xa0\x01\x04\x13U\xa0\x01\x042T\xa0\x01\x04OS\xa0\x01\x04lR\xa0\x01\x04\x89Q\xa0\x01\x04\xa6P\xa0\x01\x04\xc3O\xa0\x01\x04\xe0N\xa0\x01\x05Kc\xa0\x01\x05pb\xa0\x01\x05\x8da\xa0\x01\x05\xaa`\xa0\x01\x05\xc7_\xa0\x01\x05\xe4^\xa0\x01\x06\x01]\xa0\x01\x06\x1e\\\xa0\x01\x06;[\xa0\x01\x06XZ\xa0\x01\x06uY\xa0\x01\x06\x92X\xa0\x01\x06\xfbh\xa0\x01\x07\x1eg\xa0\x01\x07>f\xa0\x01\x07[e\xa0\x01\x07xd\xa0\x01\x07\xf4n\xa0\x01\b\x19m\xa0\x01\b9l\xa0\x01\bVk\xa0\x01\bsj\xa0\x01\b\x90i\xa0\x01\t.u\xa0\x01\tYt\xa0\x01\t\x86s\xa0\x01\t\x99r\xa0\x01\t\xbcq\xa0\x01\t\xe7p\xa0\x01\n o\xa0\x01\n\xb5z\xa0\x01\n\xd7y\xa0\x01\n\xf7x\xa0\x01\x0b\x14w\xa0\x01\x0b1v\xa0\x01\x0b\x96\0O\xa0\x01\x0b\xa4\0M\xa0\x01\x0b\xb7\0K\xa0\x01\x0b\xe5\0@\xa0\x01\f\x06\0L\xa0\x01\f+\0J\xa0\x01\fX\0I\xa0\x01\fo\0H\xa0\x01\f\x97\0G\xa0\x01\f\xae\0F\xa0\x01\f\xda\0E\xa0\x01\f\xf1\0D\xa0\x01\r\x19\0C\xa0\x01\r0\0B\xa0\x01\rI\0A\xa0\x01\ro\0N\xa0\x01\r\x8e\x7f\xa0\x01\r\xab~\xa0\x01\r\xc6}\xa0\x01\r\xd3|\xa0\x01\r\xf0{\xa0\x01\x0eG\0U\xa0\x01\x0ed\0T\xa0\x01\x0e\x81\0S\xa0\x01\x0e\x9b\0R\xa0\x01\x0e\xb9\0Q\xa0\x01\x0e\xd6\0P\xa0\x01\x0f\xb4\0e\xa0\x01\x0f\xd1\0d\xa0\x01\x0f\xee\0c\xa0\x01\x10\x1c\0b\xa0\x01\x10=\0a\xa0\x01\x10w\0`\xa0\x01\x10\x94\0_\xa0\x01\x10\xc2\0^\xa0\x01\x10\xda\0]\xa0\x01\x11\x07\0\\\xa0\x01\x11+\0[\xa0\x01\x11a\0Z\xa0\x01\x11\x80\0Y\xa0\x01\x11\xa7\0X\xa0\x01\x11\xb5\0W\xa0\x01\x11\xdc\0V\xa0\x01\x12 \0h\xa0\x01\x12Q\0g\xa0\x01\x12c\0f\xa0\x01\x13\xe2\0k\xa0\x01\x14\x06\0j\xa0\x01\x143\0i\xa0\x01\x17X\0p\xa0\x01\x17\x82\0o\xa0\x01\x17\x97\0n\xa0\x01\x17\xbe\0m\xa0\x01\x17\xeb\0l\xa0\x01\x18K\0z\xa0\x01\x18p\0y\xa0\x01\x18\x83\0x\xa0\x01\x18\x8b\0v\xa0\x01\x18\xcc\0w\xa0\x01\x19\x03\0u\xa0\x01\x19?\0t\xa0\x01\x19w\0s\xa0\x01\x19\x91\0r\xa0\x01\x19\xbc\0q\xa0\x01\x1a\x16\x01\0\x87\xa0\x01\x1a5\x01\0\x85\xa0\x01\x1a_\x01\0\x86\xa0\x01\x1ag\x01\0\x83\xa0\x01\x1a\xa0\x01\0\x84\xa0\x01\x1a\xd7\x01\0\x82\xa0\x01\x1b\x0e\x01\0\x81\xa0\x01\x1b(\x01\0\x80\xa0\x01\x1b;\0\x7f\xa0\x01\x1b`\0~\xa0\x01\x1b\x8d\0}\xa0\x01\x1b\xa1\0|\xa0\x01\x1b\xce\0{\xa0\x01\x1c"\x01\0\x8b\xa0\x01\x1cR\x01\0\x8a\xa0\x01\x1cd\x01\0\x89\xa0\x01\x1c\x89\x01\0\x88\xa0\x01\x1c\xe7\x01\0\x8f\xa0\x01\x1d\x17\x01\0\x8e\xa0\x01\x1d)\x01\0\x8d\xa0\x01\x1dS\x01\0\x8c\xa0\x01\x1d\xb1\x01\0\x97\xa0\x01\x1d\xe1\x01\0\x96\xa0\x01\x1d\xf3\x01\0\x95\xa0\x01\x1d\xfb\x01\0\x93\xa0\x01\x1e<\x01\0\x94\xa0\x01\x1es\x01\0\x92\xa0\x01\x1e\xaa\x01\0\x91\xa0\x01\x1e\xc4\x01\0\x90\xa0\x01\x1f"\x01\0\x9f\xa0\x01\x1fR\x01\0\x9e\xa0\x01\x1fd\x01\0\x9d\xa0\x01\x1fl\x01\0\x9b\xa0\x01\x1f\xad\x01\0\x9c\xa0\x01\x1f\xe9\x01\0\x9a\xa0\x01 %\x01\0\x99\xa0\x01 ?\x01\0\x98'),
     cst_tst_Tests_Drawing_ml=caml_new_string("tst/Tests/Drawing.ml"),
     cst_Hello$0=caml_new_string("Hello"),
     cst_He=caml_new_string("He"),
     cst_llo=caml_new_string("llo"),
     cst_reuse_canvas_line_cap=caml_new_string("reuse_canvas_line_cap"),
     cst_reuse_canvas_transformation=
      caml_new_string("reuse_canvas_transformation"),
     cst_show_text$1=caml_new_string("show_text"),
     cst_text_extents$0=caml_new_string("text_extents"),
     cst_font_extents$0=caml_new_string("font_extents"),
     cst_arc_more_than_2pi=caml_new_string("arc_more_than_2pi"),
     point_definitions$2=
      caml_new_string
       ('\x84\x95\xa6\xbe\0\0\0\xaa\0\0\0"\0\0\0\x85\0\0\0\x85\b\0\0\x84\0\xa0\x01\x013H\xa0\x01\x01EF\xa0\x01\x01TE\xa0\x01\x01sD\xa0\x01\x01\x88C\xa0\x01\x01\x92A\xa0\x01\x01\xb5B\xa0\x01\x01\xc9@\xa0\x01\x01\xf1G\xa0\x01\x02#`\xa0\x01\x02hL\xa0\x01\x02\x94K\xa0\x01\x02\xbfJ\xa0\x01\x02\xdaI\xa0\x01\x03\x1dM\xa0\x01\x03oN\xa0\x01\x03\xc7V\xa0\x01\x03\xe4U\xa0\x01\x051T\xa0\x01\x05dS\xa0\x01\x05\x81R\xa0\x01\x05\xb5Q\xa0\x01\x05\xd1P\xa0\x01\x05\xeeO\xa0\x01\x06UW\xa0\x01\x06\x81Z\xa0\x01\x06\x9eY\xa0\x01\x06\xbbX\xa0\x01\x07\x0b[\xa0\x01\x07>_\xa0\x01\x07^^\xa0\x01\x07{]\xa0\x01\x07\x98\\'),
     cst_tst_Tests_Limitations_ml=caml_new_string("tst/Tests/Limitations.ml"),
     name=caml_new_string("CairoMock"),
     name$0=caml_new_string("CairoMock.Mock"),
     name$1=caml_new_string("CairoMock.Mock"),
     point_definitions$3=
      caml_new_string
       ("\x84\x95\xa6\xbe\0\0\0^\0\0\0\x13\0\0\0I\0\0\0I\b\0\0H\0\xa0\0{A\xa0\x01\0\xc5@\xa0\x01\x03TB\xa0\x01\x03\x94Q\xa0\x01\x03\xf5C\xa0\x01\x04\x1bD\xa0\x01\x04GE\xa0\x01\x05\x10F\xa0\x01\x056G\xa0\x01\x05bH\xa0\x01\x05\xdeI\xa0\x01\x05\xffJ\xa0\x01\x06&K\xa0\x01\x07!L\xa0\x01\x07dM\xa0\x01\x07\x9aN\xa0\x01\bTP\xa0\x01\bsO"),
     cst_tst_Tests_Tests_ml=caml_new_string("tst/Tests/Tests.ml"),
     General=global_data.General,
     Not_found=global_data.Not_found,
     Bisect_Runtime=global_data.Bisect__Runtime,
     CairoMock=global_data.CairoMock,
     Tests=[0,0,0,0,0,0];
    caml_register_global(1351,Tests,"Tests__");
    var
     match=
      caml_call3
       (Bisect_Runtime[1],cst_tst_Tests_Universal_ml,231,point_definitions),
     bisect_visit=match[2],
     Bisect_visit_tst_Tests_Universal_ml=[0,bisect_visit],
     _ad_=
      [0,
       [11,caml_new_string("[|"),[2,0,[11,caml_new_string("|]"),0]]],
       caml_new_string("[|%s|]")],
     _ae_=[0,caml_new_string("; ")],
     ___=
      [0,
       [2,0,[11,caml_new_string(".Error(INVALID_RESTORE)"),0]],
       caml_new_string("%s.Error(INVALID_RESTORE)")],
     _U_=[0,-2,2],
     _V_=[0,-6,6.5],
     _W_=[0,28,59],
     _X_=[0,23,53],
     _Y_=[0,28,59],
     _Z_=[0,23,53],
     _y_=[0,0.001],
     _x_=[0,0.1,0.2,0.3,1],
     _w_=[0,0.1,0.2,0.3,1],
     _v_=[0,0.1,0.2,0.3,0.4],
     _u_=[0,0.1,0.2,0.3,0.4],
     _t_=[0,1,2,3,4],
     _s_=[0,1,2,3,4,5,6],
     _q_=[0,0.1],
     _r_=[0,0.1,0.2,0.3,0.4,0.5],
     _p_=[0,0,0.2,0.3,0.4,1],
     _h_=[0,0.2],
     _i_=[0,0.1],
     _j_=[0,0.2],
     _k_=[0,0.3],
     _l_=[0,0.1,0.1,0.1,0.1,1],
     _m_=[0,0.2,0.2,0.2,0.2,1],
     _n_=[0,0.2,0.21,0.21,0.21,1],
     _o_=[0,0.3,0.3,0.3,0.3,1],
     _f_=[0,0.1],
     _g_=[0,0.2],
     _e_=
      [0,
       [12,
        40,
        [8,
         0,
         0,
         0,
         [11,
          caml_new_string(", "),
          [8,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [8,
             0,
             0,
             0,
             [11,
              caml_new_string(", "),
              [8,0,0,0,[11,caml_new_string(", "),[8,0,0,0,partial]]]]]]]]]],
       caml_new_string("(%f, %f, %f, %f, %f, %f)")],
     _d_=
      [0,
       [12,
        40,
        [8,
         0,
         0,
         0,
         [11,
          caml_new_string(", "),
          [8,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [8,
             0,
             0,
             0,
             [11,
              caml_new_string(", "),
              [8,0,0,0,[11,caml_new_string(", "),[8,0,0,0,partial$0]]]]]]]]]],
       caml_new_string("(%f, %f, %f, %f, %f)")],
     _c_=
      [0,
       [12,
        40,
        [8,
         0,
         0,
         0,
         [11,
          caml_new_string(", "),
          [8,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [8,0,0,0,[11,caml_new_string(", "),[8,0,0,0,[12,41,0]]]]]]]]],
       caml_new_string("(%f, %f, %f, %f)")],
     _b_=
      [0,
       [12,40,[8,0,0,0,[11,caml_new_string(", "),[8,0,0,0,[12,41,0]]]]],
       caml_new_string("(%f, %f)")],
     _a_=
      [0,
       [11,
        caml_new_string("{xx="),
        [8,
         0,
         0,
         0,
         [11,
          caml_new_string("; xy="),
          [8,
           0,
           0,
           0,
           [11,
            caml_new_string("; yx="),
            [8,
             0,
             0,
             0,
             [11,
              caml_new_string("; yy="),
              [8,0,0,0,[11,caml_new_string("; x0="),[8,0,0,0,partial$1]]]]]]]]]],
       caml_new_string("{xx=%f; xy=%f; yx=%f; yy=%f; x0=%f; y0=%f}")],
     _z_=[0,3,4],
     _A_=[0,3,4],
     _B_=[0,3,4],
     _C_=[0,1,2],
     _D_=[0,6,8],
     _E_=[0,5,6],
     _F_=[0,1,5],
     _G_=[0,4,2],
     _H_=[0,-2,2],
     _I_=[0,1,5],
     _J_=[0,4,2],
     _K_=[0,1,2],
     _L_=[0,4,6],
     _M_=[0,1,2],
     _N_=[0,4,6],
     _O_=[0,3,8],
     _P_=[0,1,2],
     _Q_=[0,1,2],
     _R_=[0,0,0],
     _S_=[0,1,2],
     _T_=[0,0,0],
     _$_=[0,[0,0,0,1,0.7],0],
     _aa_=[0,1,0,0,0.5],
     _ab_=[0,0,0,0,1],
     _ac_=[0,3,0],
     _af_=[254,7,8,9,10,11,12],
     _am_=[0,0,[0,1,[0,6,[0,13,0]]]],
     _ag_=[0,4,[0,5,[0,7,[0,8,[0,9,[0,10,[0,11,[0,12,0]]]]]]]],
     _ah_=[0,2,0],
     _ai_=[0,2,0],
     _aj_=[0,20,0],
     _ak_=[0,4,0],
     _al_=
      [0,
       [11,caml_new_string("Universal tests on "),[2,0,0]],
       caml_new_string("Universal tests on %s")],
     _a3_=[0,2],
     _ay_=[0,0],
     _aw_=[0,2],
     _au_=[0,0],
     _ar_=[0,1],
     _as_=[0,1],
     _an_=
      [0,
       [11,
        caml_new_string("font_extents -> {ascent="),
        [8,
         0,
         0,
         0,
         [11,
          caml_new_string("; descent="),
          [8,
           0,
           0,
           0,
           [11,
            caml_new_string("; baseline="),
            [8,
             0,
             0,
             0,
             [11,
              caml_new_string("; max_x_advance="),
              [8,
               0,
               0,
               0,
               [11,caml_new_string("; max_y_advance="),[8,0,0,0,partial$2]]]]]]]]]],
       caml_new_string
        ("font_extents -> {ascent=%f; descent=%f; baseline=%f; max_x_advance=%f; max_y_advance=%f}")],
     _ao_=
      [0,
       [11,
        caml_new_string('text_extents "abcd" -> {x_bearing='),
        [8,
         0,
         0,
         0,
         [11,
          caml_new_string("; y_bearing="),
          [8,
           0,
           0,
           0,
           [11,
            caml_new_string("; width="),
            [8,
             0,
             0,
             0,
             [11,
              caml_new_string("; height="),
              [8,
               0,
               0,
               0,
               [11,caml_new_string("; x_advance="),[8,0,0,0,partial$3]]]]]]]]]],
       caml_new_string
        ('text_extents "abcd" -> {x_bearing=%f; y_bearing=%f; width=%f; height=%f; x_advance=%f; y_advance=%f}')],
     _ap_=
      [0,
       [11,caml_new_string('show_text "flibidiboo"'),0],
       caml_new_string('show_text "flibidiboo"')],
     _aq_=
      [0,
       [11,
        caml_new_string
         ('select_font_face ~slant:Italic ~weight:Bold "foo-bar"'),
        0],
       caml_new_string
        ('select_font_face ~slant:Italic ~weight:Bold "foo-bar"')],
     _at_=
      [0,
       [11,caml_new_string('select_font_face ~weight:Normal "foo-bar"'),0],
       caml_new_string('select_font_face ~weight:Normal "foo-bar"')],
     _av_=
      [0,
       [11,caml_new_string('select_font_face ~slant:Oblique "foo-bar"'),0],
       caml_new_string('select_font_face ~slant:Oblique "foo-bar"')],
     _ax_=
      [0,
       [11,caml_new_string('select_font_face ~slant:Upright "foo-bar"'),0],
       caml_new_string('select_font_face ~slant:Upright "foo-bar"')],
     _az_=
      [0,
       [11,caml_new_string('select_font_face "foo-bar"'),0],
       caml_new_string('select_font_face "foo-bar"')],
     _aA_=
      [0,
       [11,caml_new_string("set_font_size 3.00"),0],
       caml_new_string("set_font_size 3.00")],
     _aB_=
      [0,
       [11,
        caml_new_string
         ("get_source -> (Rgba {r=0.00; g=0.00; b=0.00; a=1.00})"),
        0],
       caml_new_string
        ("get_source -> (Rgba {r=0.00; g=0.00; b=0.00; a=1.00})")],
     _aC_=
      [0,
       [11,
        caml_new_string
         ("set_source (RadialGradient {x0=1.00; y0=2.00; r0=5.00; x1=3.00; y1=4.00; r16.00; stop_points=[]})"),
        0],
       caml_new_string
        ("set_source (RadialGradient {x0=1.00; y0=2.00; r0=5.00; x1=3.00; y1=4.00; r16.00; stop_points=[]})")],
     _aD_=
      [0,
       [11,
        caml_new_string
         ("set_source (LinearGradient {x0=1.00; y0=2.00; x1=3.00; y1=4.00; stop_points=[{position=0.00; r=0.10; g=0.20; b=0.30; a=1.00}]})"),
        0],
       caml_new_string
        ("set_source (LinearGradient {x0=1.00; y0=2.00; x1=3.00; y1=4.00; stop_points=[{position=0.00; r=0.10; g=0.20; b=0.30; a=1.00}]})")],
     _aE_=
      [0,
       [11,
        caml_new_string("set_source (Rgba {r=0.50; g=0.60; b=0.70; a=1.00})"),
        0],
       caml_new_string("set_source (Rgba {r=0.50; g=0.60; b=0.70; a=1.00})")],
     _aF_=
      [0,
       [11,caml_new_string("set_source_rgba 0.50 0.60 0.70 0.80"),0],
       caml_new_string("set_source_rgba 0.50 0.60 0.70 0.80")],
     _aG_=
      [0,
       [11,caml_new_string("set_source_rgb 0.50 0.60 0.70"),0],
       caml_new_string("set_source_rgb 0.50 0.60 0.70")],
     _aH_=
      [0,
       [11,caml_new_string("get_operator -> OVER"),0],
       caml_new_string("get_operator -> OVER")],
     _bI_=
      [0,
       [11,caml_new_string("set_operator SATURATE"),0],
       caml_new_string("set_operator SATURATE")],
     _bJ_=
      [0,
       [11,caml_new_string("set_operator SOURCE"),0],
       caml_new_string("set_operator SOURCE")],
     _bK_=
      [0,
       [11,caml_new_string("set_operator CLEAR"),0],
       caml_new_string("set_operator CLEAR")],
     _bL_=
      [0,
       [11,caml_new_string("set_operator DEST"),0],
       caml_new_string("set_operator DEST")],
     _aI_=
      [0,
       [11,caml_new_string("set_operator ADD"),0],
       caml_new_string("set_operator ADD")],
     _aJ_=
      [0,
       [11,caml_new_string("set_operator XOR"),0],
       caml_new_string("set_operator XOR")],
     _aK_=
      [0,
       [11,caml_new_string("set_operator DEST_ATOP"),0],
       caml_new_string("set_operator DEST_ATOP")],
     _aL_=
      [0,
       [11,caml_new_string("set_operator DEST_OUT"),0],
       caml_new_string("set_operator DEST_OUT")],
     _aM_=
      [0,
       [11,caml_new_string("set_operator DEST_IN"),0],
       caml_new_string("set_operator DEST_IN")],
     _aN_=
      [0,
       [11,caml_new_string("set_operator DEST_OVER"),0],
       caml_new_string("set_operator DEST_OVER")],
     _aO_=
      [0,
       [11,caml_new_string("set_operator ATOP"),0],
       caml_new_string("set_operator ATOP")],
     _aP_=
      [0,
       [11,caml_new_string("set_operator OUT"),0],
       caml_new_string("set_operator OUT")],
     _aQ_=
      [0,
       [11,caml_new_string("set_operator IN"),0],
       caml_new_string("set_operator IN")],
     _aR_=
      [0,
       [11,caml_new_string("get_miter_limit -> 10.00"),0],
       caml_new_string("get_miter_limit -> 10.00")],
     _aS_=
      [0,
       [11,caml_new_string("set_miter_limit 3.00"),0],
       caml_new_string("set_miter_limit 3.00")],
     _aT_=
      [0,
       [11,caml_new_string("get_line_join -> JOIN_MITER"),0],
       caml_new_string("get_line_join -> JOIN_MITER")],
     _aU_=
      [0,
       [11,caml_new_string("set_line_join JOIN_BEVEL"),0],
       caml_new_string("set_line_join JOIN_BEVEL")],
     _aV_=
      [0,
       [11,caml_new_string("set_line_join JOIN_ROUND"),0],
       caml_new_string("set_line_join JOIN_ROUND")],
     _aW_=
      [0,
       [11,caml_new_string("get_line_cap -> BUTT"),0],
       caml_new_string("get_line_cap -> BUTT")],
     _aX_=
      [0,
       [11,caml_new_string("set_line_cap SQUARE"),0],
       caml_new_string("set_line_cap SQUARE")],
     _aY_=
      [0,
       [11,caml_new_string("set_line_cap ROUND"),0],
       caml_new_string("set_line_cap ROUND")],
     _aZ_=
      [0,
       [11,caml_new_string("get_fill_rule -> WINDING"),0],
       caml_new_string("get_fill_rule -> WINDING")],
     _a0_=
      [0,
       [11,caml_new_string("set_fill_rule EVEN_ODD"),0],
       caml_new_string("set_fill_rule EVEN_ODD")],
     _a1_=
      [0,
       [11,caml_new_string("get_dash -> ([||], 0.00)"),0],
       caml_new_string("get_dash -> ([||], 0.00)")],
     _a2_=
      [0,
       [11,caml_new_string("set_dash ~ofs:2.00 [|3.00; 4.00|]"),0],
       caml_new_string("set_dash ~ofs:2.00 [|3.00; 4.00|]")],
     _a4_=
      [0,
       [11,caml_new_string("set_dash [|2.00; 3.00|]"),0],
       caml_new_string("set_dash [|2.00; 3.00|]")],
     _a5_=
      [0,
       [11,caml_new_string("get_line_width -> 2.00"),0],
       caml_new_string("get_line_width -> 2.00")],
     _a6_=
      [0,
       [11,caml_new_string("set_line_width 3.00"),0],
       caml_new_string("set_line_width 3.00")],
     _a7_=
      [0,
       [11,caml_new_string("paint ~alpha:0.50"),0],
       caml_new_string("paint ~alpha:0.50")],
     _a8_=[0,0.5],
     _a9_=[0,[11,caml_new_string("paint"),0],caml_new_string("paint")],
     _a__=
      [0,
       [11,caml_new_string("clip_preserve"),0],
       caml_new_string("clip_preserve")],
     _a$_=[0,[11,caml_new_string("clip"),0],caml_new_string("clip")],
     _ba_=
      [0,
       [11,caml_new_string("fill_preserve"),0],
       caml_new_string("fill_preserve")],
     _bb_=[0,[11,caml_new_string("fill"),0],caml_new_string("fill")],
     _bc_=
      [0,
       [11,caml_new_string("stroke_preserve"),0],
       caml_new_string("stroke_preserve")],
     _bd_=[0,[11,caml_new_string("stroke"),0],caml_new_string("stroke")],
     _be_=
      [0,
       caml_new_string("move_to 1.00 2.00"),
       [0,caml_new_string("Path.get_current_point -> (1.00, 2.00)"),0]],
     _bf_=
      [0,
       [11,caml_new_string("Path.get_current_point -> (0.00, 0.00)"),0],
       caml_new_string("Path.get_current_point -> (0.00, 0.00)")],
     _bg_=
      [0,[11,caml_new_string("Path.clear"),0],caml_new_string("Path.clear")],
     _bh_=
      [0,[11,caml_new_string("Path.close"),0],caml_new_string("Path.close")],
     _bi_=
      [0,
       [11,
        caml_new_string("arc_negative 1.00 2.00 ~r:3.00 ~a1:4.00 ~a2:5.00"),
        0],
       caml_new_string("arc_negative 1.00 2.00 ~r:3.00 ~a1:4.00 ~a2:5.00")],
     _bj_=
      [0,
       [11,caml_new_string("arc 1.00 2.00 ~r:3.00 ~a1:4.00 ~a2:5.00"),0],
       caml_new_string("arc 1.00 2.00 ~r:3.00 ~a1:4.00 ~a2:5.00")],
     _bk_=
      [0,
       [11,caml_new_string("rectangle 2.00 3.00 ~w:4.00 ~h:5.00"),0],
       caml_new_string("rectangle 2.00 3.00 ~w:4.00 ~h:5.00")],
     _bl_=
      [0,
       caml_new_string("move_to 1.00 2.00"),
       [0,caml_new_string("rel_curve_to 1.00 2.00 3.00 4.00 5.00 6.00"),0]],
     _bm_=
      [0,
       [11,
        caml_new_string
         ("rel_curve_to 1.00 2.00 3.00 4.00 5.00 6.00 -> raise ("),
        [2,0,[11,caml_new_string(".Error(NO_CURRENT_POINT))"),0]]],
       caml_new_string
        ("rel_curve_to 1.00 2.00 3.00 4.00 5.00 6.00 -> raise (%s.Error(NO_CURRENT_POINT))")],
     _bn_=
      [0,
       [11,caml_new_string("curve_to 1.00 2.00 3.00 4.00 5.00 6.00"),0],
       caml_new_string("curve_to 1.00 2.00 3.00 4.00 5.00 6.00")],
     _bo_=
      [0,
       caml_new_string("move_to 1.00 2.00"),
       [0,caml_new_string("rel_line_to 3.00 4.00"),0]],
     _bp_=
      [0,
       [11,
        caml_new_string("rel_line_to 4.05 2.96 -> raise ("),
        [2,0,[11,caml_new_string(".Error(NO_CURRENT_POINT))"),0]]],
       caml_new_string
        ("rel_line_to 4.05 2.96 -> raise (%s.Error(NO_CURRENT_POINT))")],
     _bq_=
      [0,
       [11,caml_new_string("line_to 4.05 2.96"),0],
       caml_new_string("line_to 4.05 2.96")],
     _br_=
      [0,
       caml_new_string("move_to 1.00 2.00"),
       [0,caml_new_string("rel_move_to 3.00 4.00"),0]],
     _bs_=
      [0,
       [11,
        caml_new_string("rel_move_to 4.05 2.96 -> raise ("),
        [2,0,[11,caml_new_string(".Error(NO_CURRENT_POINT))"),0]]],
       caml_new_string
        ("rel_move_to 4.05 2.96 -> raise (%s.Error(NO_CURRENT_POINT))")],
     _bt_=
      [0,
       [11,caml_new_string("move_to 4.05 2.96"),0],
       caml_new_string("move_to 4.05 2.96")],
     _bu_=
      [0,
       [11,
        caml_new_string("device_to_user_distance 2.00 3.00 -> (2.00, 3.00)"),
        0],
       caml_new_string("device_to_user_distance 2.00 3.00 -> (2.00, 3.00)")],
     _bv_=
      [0,
       [11,caml_new_string("device_to_user 2.00 3.00 -> (2.00, 3.00)"),0],
       caml_new_string("device_to_user 2.00 3.00 -> (2.00, 3.00)")],
     _bw_=
      [0,
       [11,
        caml_new_string("user_to_device_distance 2.00 3.00 -> (2.00, 3.00)"),
        0],
       caml_new_string("user_to_device_distance 2.00 3.00 -> (2.00, 3.00)")],
     _bx_=
      [0,
       [11,caml_new_string("user_to_device 2.00 3.00 -> (2.00, 3.00)"),0],
       caml_new_string("user_to_device 2.00 3.00 -> (2.00, 3.00)")],
     _by_=
      [0,
       [11,
        caml_new_string
         ("get_matrix -> {xx=1.00; xy=0.00; yx=0.00; yy=1.00; x0=0.00; y0=0.00}"),
        0],
       caml_new_string
        ("get_matrix -> {xx=1.00; xy=0.00; yx=0.00; yy=1.00; x0=0.00; y0=0.00}")],
     _bz_=
      [0,
       [11,caml_new_string("identity_matrix"),0],
       caml_new_string("identity_matrix")],
     _bA_=
      [0,
       [11,
        caml_new_string
         ("set_matrix {xx=1.00; xy=2.00; yx=3.00; yy=4.00; x0=5.00; y0=6.00}"),
        0],
       caml_new_string
        ("set_matrix {xx=1.00; xy=2.00; yx=3.00; yy=4.00; x0=5.00; y0=6.00}")],
     _bB_=
      [0,
       [11,
        caml_new_string
         ("transform {xx=1.00; xy=2.00; yx=3.00; yy=4.00; x0=5.00; y0=6.00}"),
        0],
       caml_new_string
        ("transform {xx=1.00; xy=2.00; yx=3.00; yy=4.00; x0=5.00; y0=6.00}")],
     _bC_=
      [0,[11,caml_new_string("rotate 3.00"),0],caml_new_string("rotate 3.00")],
     _bD_=
      [0,
       [11,caml_new_string("translate 3.00 2.00"),0],
       caml_new_string("translate 3.00 2.00")],
     _bE_=
      [0,
       [11,caml_new_string("scale 3.00 2.00"),0],
       caml_new_string("scale 3.00 2.00")],
     _bF_=
      [0,
       [11,
        caml_new_string("restore -> raise ("),
        [2,0,[11,caml_new_string(".Error(INVALID_RESTORE))"),0]]],
       caml_new_string("restore -> raise (%s.Error(INVALID_RESTORE))")],
     _bG_=[0,caml_new_string("save"),[0,caml_new_string("restore"),0]],
     _bH_=
      [0,
       [11,
        caml_new_string("Decoration tests on CairoMock.Decorate("),
        [2,0,[12,41,0]]],
       caml_new_string("Decoration tests on CairoMock.Decorate(%s)")],
     _bW_=[0,0],
     _bX_=[0,1],
     _bY_=[0,0.4],
     _bU_=[0,0],
     _bV_=[0,1],
     _bT_=[0,0.5],
     _bS_=[0,0.5],
     _bP_=[0,0],
     _bQ_=[0,1],
     _bR_=[0,0.5],
     _bM_=[0,0],
     _bN_=[0,1],
     _bO_=[0,0.5],
     _bZ_=
      caml_list_of_js_array
       ([[0,0,0,0,0.7],
         [0,0.5,0.5,0.5,0.7],
         [0,1,1,1,0.7],
         [0,0.5,0,0,0.7],
         [0,0,0.5,0,0.7],
         [0,0,0,0.5,0.7],
         [0,1,0,0,0.7],
         [0,0,1,0,0.7],
         [0,0,0,1,0.7],
         [0,0.5,0.5,0,0.7],
         [0,0,0.5,0.5,0.7],
         [0,0.5,0,0.5,0.7],
         [0,1,1,0,0.7],
         [0,0,1,1,0.7],
         [0,1,0,1,0.7],
         [0,0,0,0,0.3],
         [0,0.5,0.5,0.5,0.3],
         [0,1,1,1,0.3],
         [0,0.5,0,0,0.3],
         [0,0,0.5,0,0.3],
         [0,0,0,0.5,0.3],
         [0,1,0,0,0.3],
         [0,0,1,0,0.3],
         [0,0,0,1,0.3],
         [0,0.5,0.5,0,0.3],
         [0,0,0.5,0.5,0.3],
         [0,0.5,0,0.5,0.3],
         [0,1,1,0,0.3],
         [0,0,1,1,0.3],
         [0,1,0,1,0.3]]),
     _b0_=
      caml_list_of_js_array
       ([[0,0,0,0],
         [0,0.5,0.5,0.5],
         [0,1,1,1],
         [0,0.5,0,0],
         [0,0,0.5,0],
         [0,0,0,0.5],
         [0,1,0,0],
         [0,0,1,0],
         [0,0,0,1],
         [0,0.5,0.5,0],
         [0,0,0.5,0.5],
         [0,0.5,0,0.5],
         [0,1,1,0],
         [0,0,1,1],
         [0,1,0,1]]),
     _b1_=[0,2,[0,3,[0,4,[0,5,[0,7,[0,8,[0,9,[0,10,[0,11,[0,12,0]]]]]]]]]],
     _b2_=[0,1,[0,2,[0,0,0]]],
     _b3_=[0,1,[0,2,[0,0,0]]],
     _b4_=[0,1,[0,0,0]],
     _b5_=[0,8,[0,9,[0,10,0]]],
     _b6_=[0,5,[0,10,0]],
     _b7_=
      [0,
       [0,0,0,caml_new_string("sans-serif")],
       [0,
        [0,1,0,caml_new_string("sans-serif")],
        [0,
         [0,2,0,caml_new_string("sans-serif")],
         [0,
          [0,0,1,caml_new_string("sans-serif")],
          [0,
           [0,1,1,caml_new_string("sans-serif")],
           [0,
            [0,2,1,caml_new_string("sans-serif")],
            [0,
             [0,0,0,caml_new_string("serif")],
             [0,[0,0,0,caml_new_string("monospace")],0]]]]]]]],
     _b9_=
      [0,
       [11,caml_new_string("Drawing tests on "),[2,0,0]],
       caml_new_string("Drawing tests on %s")],
     _b__=
      [0,
       [11,caml_new_string("CairoMock.Decorate("),[2,0,[12,41,0]]],
       caml_new_string("CairoMock.Decorate(%s)")];
    function Make(C,N)
     {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],2);
      var _fH_=N[3];
      if(553448210 === _fH_)
       {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],1);
        var _fI_=cst_CairoMock}
      else
       if(-733568919 <= _fH_)
        {if(95560584 !== _fH_)870528546 === _fH_;var _fI_=cst_JsOfOCairo}
       else
        {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],0);
         var _fI_=cst_Cairo}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],11);
      function equal(param)
       {var
         xx=param[1],
         yx=param[2],
         xy=param[3],
         yy=param[4],
         x0=param[5],
         y0=param[6];
        return function(m)
         {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],9);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],7);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],6);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],5);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],4);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],3);
          var _k4_=caml_call3(General[24][33],0,m[6],y0);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],4);
          var
           _k5_=caml_call3(General[24][33],0,m[5],x0),
           _k6_=caml_call2(General[69][253],_k5_,_k4_);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],5);
          var
           _k7_=caml_call3(General[24][33],0,m[4],yy),
           _k8_=caml_call2(General[69][253],_k7_,_k6_);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],6);
          var
           _k9_=caml_call3(General[24][33],0,m[2],yx),
           _k__=caml_call2(General[69][253],_k9_,_k8_);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],7);
          var
           _k$_=caml_call3(General[24][33],0,m[3],xy),
           _la_=caml_call2(General[69][253],_k$_,_k__);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],8);
          var _lb_=caml_call3(General[24][33],0,m[1],xx);
          return caml_call2(General[69][253],_lb_,_la_)}}
      function repr(param)
       {var
         xx=param[1],
         yx=param[2],
         xy=param[3],
         yy=param[4],
         x0=param[5],
         y0=param[6];
        return caml_call7(General[59][2],_a_,xx,xy,yx,yy,x0,y0)}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],10);
      var check_matrix=caml_call2(General[67][11],repr,equal);
      function check_coords(precision)
       {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],16);
        function equal(param,_k1_)
         {var y1=_k1_[2],x1=_k1_[1],y0=param[2],x0=param[1];
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],14);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],12);
          var _k2_=caml_call3(General[24][33],precision,y0,y1);
          caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],13);
          var _k3_=caml_call3(General[24][33],precision,x0,x1);
          return caml_call2(General[69][253],_k3_,_k2_)}
        function repr(param)
         {var y=param[2],x=param[1];return caml_call3(General[59][2],_b_,x,y)}
        caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],15);
        return caml_call2(General[67][11],repr,equal)}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],18);
      function repr$0(param)
       {var d=param[4],c=param[3],b=param[2],a=param[1];
        return caml_call5(General[59][2],_c_,a,b,c,d)}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],17);
      var check_float_tuple_4=caml_call1(General[67][12],repr$0);
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],20);
      function repr$1(param)
       {var e=param[5],d=param[4],c=param[3],b=param[2],a=param[1];
        return caml_call6(General[59][2],_d_,a,b,c,d,e)}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],19);
      var check_float_tuple_5=caml_call1(General[67][12],repr$1);
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],22);
      function repr$2(param)
       {var f=param[6],e=param[5],d=param[4],c=param[3],b=param[2],a=param[1];
        return caml_call7(General[59][2],_e_,a,b,c,d,e,f)}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],21);
      var check_float_tuple_6=caml_call1(General[67][12],repr$2);
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],230);
      var _fJ_=0,_fK_=0;
      function make(name,p,f)
       {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],228);
        var
         _kX_=
          [246,
           function(_kY_)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],226);
             var ctx=caml_call1(N[2],0);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],227);
             caml_call2(C[15],ctx,p);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],225);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],223);
             var p$0=caml_call1(C[16],ctx);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],224);
             var _kZ_=[246,function(_k0_){return caml_call1(f,p$0)}];
             return caml_call2(General[67][9],[0,C[1],12],_kZ_)}];
        return caml_call2(General[67][5],name,_kX_)}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],229);
      var
       _fL_=C[10][9],
       _fM_=
        [0,
         make
          (cst_create_radial_get_linear_points,
           caml_call6(C[10][10],1,2,3,4,5,6),
           _fL_),
         0],
       _fN_=C[10][7],
       _fO_=
        [0,
         make
          (cst_create_radial_get_rgba,caml_call6(C[10][10],1,2,3,4,5,6),_fN_),
         _fM_],
       _fP_=C[10][11],
       _fQ_=
        [0,
         make
          (cst_create_linear_get_radial_circles,
           caml_call4(C[10][8],1,2,3,4),
           _fP_),
         _fO_],
       _fR_=C[10][7],
       _fS_=
        [0,
         make(cst_create_linear_get_rgba,caml_call4(C[10][8],1,2,3,4),_fR_),
         _fQ_],
       _fT_=C[10][4];
      function _fU_(_kW_){return caml_call2(_fT_,_kW_,0)}
      var
       _fV_=
        [0,
         make
          (cst_create_rgb_get_color_stop_rgba,
           caml_call3(C[10][5],0.1,0.2,0.3),
           _fU_),
         _fS_],
       _fW_=C[10][3],
       _fX_=
        [0,
         make
          (cst_create_rgb_get_color_stop_count,
           caml_call3(C[10][5],0.1,0.2,0.3),
           _fW_),
         _fV_],
       _fY_=C[10][11],
       _fZ_=
        [0,
         make
          (cst_create_rgb_get_radial_circles,
           caml_call3(C[10][5],0.1,0.2,0.3),
           _fY_),
         _fX_],
       _f0_=C[10][9],
       _f1_=
        [0,
         make
          (cst_create_rgb_get_linear_points,
           caml_call3(C[10][5],0.1,0.2,0.3),
           _f0_),
         _fZ_],
       _f2_=[0,caml_call2(General[67][4],cst_mismatch,_f1_),_fK_],
       _f3_=
        [246,
         function(_kK_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],221);
           var ctx=caml_call1(N[2],0);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],222);
           var _kL_=caml_call3(C[10][5],0.1,0.2,0.3);
           caml_call2(C[15],ctx,_kL_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],220);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],218);
           var p=caml_call1(C[16],ctx);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],219);
           caml_call5(C[10][1],p,_f_,0.1,0.1,0.1);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],217);
           caml_call5(C[10][1],p,_g_,0.2,0.2,0.2);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],216);
           var _kM_=[246,function(_kV_){return caml_call1(C[10][7],p)}];
           caml_call2(General[67][9],[0,C[1],12],_kM_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],215);
           var _kN_=[246,function(_kU_){return caml_call1(C[10][3],p)}];
           caml_call2(General[67][9],[0,C[1],12],_kN_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],214);
           var _kO_=[246,function(_kT_){return caml_call1(C[10][9],p)}];
           caml_call2(General[67][9],[0,C[1],12],_kO_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],213);
           var _kP_=[246,function(_kS_){return caml_call1(C[10][11],p)}];
           caml_call2(General[67][9],[0,C[1],12],_kP_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],212);
           var _kQ_=[246,function(_kR_){return caml_call2(C[10][4],p,0)}];
           return caml_call2(General[67][9],[0,C[1],12],_kQ_)}],
       _f4_=
        [0,
         caml_call2(General[67][5],cst_create_rgb_add_color_stop_rgb,_f3_),
         _f2_],
       _f5_=
        [246,
         function(_kI_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],210);
           var p=caml_call4(C[10][8],1,2,3,4);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],211);
           caml_call5(C[10][1],p,_h_,0.2,0.2,0.2);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],209);
           caml_call5(C[10][1],p,_i_,0.1,0.1,0.1);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],208);
           caml_call5(C[10][1],p,_j_,0.21,0.21,0.21);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],207);
           caml_call5(C[10][1],p,_k_,0.3,0.3,0.3);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],206);
           var _kJ_=caml_call1(C[10][3],p);
           caml_call2(General[67][17],4,_kJ_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],205);
           caml_call2(check_float_tuple_5,_l_,caml_call2(C[10][4],p,0));
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],204);
           caml_call2(check_float_tuple_5,_m_,caml_call2(C[10][4],p,1));
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],203);
           caml_call2(check_float_tuple_5,_n_,caml_call2(C[10][4],p,2));
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],202);
           return caml_call2(check_float_tuple_5,_o_,caml_call2(C[10][4],p,3))}],
       _f6_=[0,caml_call2(General[67][5],cst_multiple_color_stops,_f5_),_f4_],
       _f7_=
        [246,
         function(_kG_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],200);
           var p=caml_call6(C[10][10],1,2,3,4,5,6);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],201);
           caml_call5(C[10][1],p,0,0.2,0.3,0.4);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],199);
           var _kH_=caml_call1(C[10][3],p);
           caml_call2(General[67][17],1,_kH_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],198);
           return caml_call2(check_float_tuple_5,_p_,caml_call2(C[10][4],p,0))}],
       _f8_=
        [0,
         caml_call2
          (General[67][5],
           cst_create_radial_add_color_stop_rgb_get_color_stop_count_get_color_stop_rgba,
           _f7_),
         _f6_],
       _f9_=
        [246,
         function(_kE_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],196);
           var p=caml_call4(C[10][8],1,2,3,4);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],197);
           caml_call6(C[10][2],p,_q_,0.2,0.3,0.4,0.5);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],195);
           var _kF_=caml_call1(C[10][3],p);
           caml_call2(General[67][17],1,_kF_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],194);
           return caml_call2(check_float_tuple_5,_r_,caml_call2(C[10][4],p,0))}],
       _f__=
        [0,
         caml_call2
          (General[67][5],
           cst_create_linear_add_color_stop_rgba_get_color_stop_count_get_color_stop_rgba,
           _f9_),
         _f8_],
       _f$_=
        [246,
         function(_kD_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],192);
           var p=caml_call6(C[10][10],1,2,3,4,5,6);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],193);
           return caml_call2(check_float_tuple_6,_s_,caml_call1(C[10][11],p))}],
       _ga_=
        [0,
         caml_call2(General[67][5],cst_create_radial_get_radial_circles,_f$_),
         _f__],
       _gb_=
        [246,
         function(_kC_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],190);
           var p=caml_call4(C[10][8],1,2,3,4);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],191);
           return caml_call2(check_float_tuple_4,_t_,caml_call1(C[10][9],p))}],
       _gc_=
        [0,
         caml_call2(General[67][5],cst_create_linear_get_linear_points,_gb_),
         _ga_],
       _gd_=
        [246,
         function(_kB_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],188);
           var ctx=caml_call1(N[2],0);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],189);
           caml_call5(C[14],ctx,0.1,0.2,0.3,0.4);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],187);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],185);
           var p=caml_call1(C[16],ctx);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],186);
           return caml_call2(check_float_tuple_4,_u_,caml_call1(C[10][7],p))}],
       _ge_=
        [0,caml_call2(General[67][5],cst_set_source_rgba_get_rgba,_gd_),_gc_],
       _gf_=
        [246,
         function(_kA_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],183);
           var p=caml_call4(C[10][6],0.1,0.2,0.3,0.4);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],184);
           return caml_call2(check_float_tuple_4,_v_,caml_call1(C[10][7],p))}],
       _gg_=[0,caml_call2(General[67][5],cst_create_rgba_get_rgba,_gf_),_ge_],
       _gh_=
        [246,
         function(_kz_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],181);
           var ctx=caml_call1(N[2],0);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],182);
           caml_call4(C[13],ctx,0.1,0.2,0.3);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],180);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],178);
           var p=caml_call1(C[16],ctx);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],179);
           return caml_call2(check_float_tuple_4,_w_,caml_call1(C[10][7],p))}],
       _gi_=
        [0,caml_call2(General[67][5],cst_set_source_rgb_get_rgba,_gh_),_gg_],
       _gj_=
        [246,
         function(_ky_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],176);
           var p=caml_call3(C[10][5],0.1,0.2,0.3);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],177);
           return caml_call2(check_float_tuple_4,_x_,caml_call1(C[10][7],p))}],
       _gk_=[0,caml_call2(General[67][5],cst_create_rgb_get_rgba,_gj_),_gi_],
       _gl_=[0,caml_call2(General[67][4],cst_patterns,_gk_),_fJ_];
      function make$0(name,f,check)
       {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],174);
        var
         _kw_=
          [246,
           function(_kx_)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],172);
             var ctx=caml_call1(N[2],0);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],173);
             caml_call1(f,ctx);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],171);
             return caml_call1(check,caml_call1(C[38][1],ctx))}];
        return caml_call2(General[67][5],name,_kw_)}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],175);
      function make$1(name,f,expected)
       {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],169);
        return make$0(name,f,caml_call1(check_coords(_y_),expected))}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],170);
      var _gm_=0;
      function _gn_(param)
       {var y=param[2],x=param[1];
        caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],168);
        caml_call3(General[67][19],10,50,x);
        caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],167);
        return caml_call3(General[67][18],0,2,y)}
      var
       _go_=
        [0,
         make$0
          (cst_show_text,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],166);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],165);
             return caml_call2(C[7],c,cst_Hello)},
           _gn_),
         _gm_],
       _gp_=
        [0,
         make$1
          (cst_clip_preserve,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],164);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],163);
             caml_call3(C[42],c,3,4);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],162);
             return caml_call1(C[32],c)},
           _z_),
         _go_],
       _gq_=
        [0,
         make$1
          (cst_fill_preserve,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],161);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],160);
             caml_call3(C[42],c,3,4);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],159);
             return caml_call1(C[34],c)},
           _A_),
         _gp_],
       _gr_=
        [0,
         make$1
          (cst_stroke_preserve,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],158);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],157);
             caml_call3(C[42],c,3,4);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],156);
             return caml_call1(C[37],c)},
           _B_),
         _gq_],
       _gs_=
        [0,
         make$1
          (cst_Path_close,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],155);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],154);
             caml_call3(C[42],c,3,4);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],153);
             caml_call3(C[42],c,5,6);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],152);
             return caml_call1(C[38][3],c)},
           _C_),
         _gr_],
       _gt_=
        [0,
         make$1
          (cst_rel_line_to,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],151);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],150);
             return caml_call7(C[45],c,1,2,3,4,5,6)},
           _D_),
         _gs_],
       _gu_=
        [0,
         make$1
          (cst_curve_to,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],149);
             return caml_call7(C[41],c,1,2,3,4,5,6)},
           _E_),
         _gt_],
       _gv_=0,
       _gw_=
        [0,
         make$1
          (cst_pi_2,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],148);
             var _kv_=caml_call2(General[69][267],General[24][40],2);
             return caml_call6(C[40],c,1,2,3,-1,_kv_)},
           _F_),
         _gv_],
       _gx_=caml_call1(General[24][45],2),
       _gy_=caml_call2(General[69][266],3,_gx_),
       _gz_=caml_call2(General[69][267],_gy_,2),
       _gA_=caml_call2(General[69][264],2,_gz_),
       _gB_=caml_call1(General[24][45],2),
       _gC_=caml_call2(General[69][266],3,_gB_),
       _gD_=caml_call2(General[69][267],_gC_,2),
       _gE_=[0,caml_call2(General[69][264],1,_gD_),_gA_],
       _gF_=
        [0,
         make$1
          (cst_pi_4,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],147);
             var _ku_=caml_call2(General[69][267],General[24][40],4);
             return caml_call6(C[40],c,1,2,3,0,_ku_)},
           _gE_),
         _gw_],
       _gG_=caml_call2(General[69][266],3,0.5),
       _gH_=caml_call2(General[69][264],2,_gG_),
       _gI_=caml_call1(General[24][45],3),
       _gJ_=caml_call2(General[69][266],3,_gI_),
       _gK_=caml_call2(General[69][267],_gJ_,2),
       _gL_=[0,caml_call2(General[69][264],1,_gK_),_gH_],
       _gM_=
        [0,
         make$1
          (cst_pi_6,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],146);
             var _kt_=caml_call2(General[69][267],General[24][40],6);
             return caml_call6(C[40],c,1,2,3,-1,_kt_)},
           _gL_),
         _gF_],
       _gN_=
        [0,
         make$1
          (cst_0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],145);
             return caml_call6(C[40],c,1,2,3,-1,0)},
           _G_),
         _gM_],
       _gO_=[0,caml_call2(General[67][4],cst_arc_negative,_gN_),_gu_],
       _gP_=0,
       _gQ_=
        [0,
         make$1
          (cst_3_pi,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],144);
             var
              _kr_=caml_call2(General[69][266],3,General[24][40]),
              _ks_=caml_call2(General[69][267],General[24][40],2);
             return caml_call6(C[39],c,1,2,3,_ks_,_kr_)},
           _H_),
         _gP_],
       _gR_=
        [0,
         make$1
          (cst_pi_2$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],143);
             var _kq_=caml_call2(General[69][267],General[24][40],2);
             return caml_call6(C[39],c,1,2,3,-1,_kq_)},
           _I_),
         _gQ_],
       _gS_=caml_call1(General[24][45],2),
       _gT_=caml_call2(General[69][266],3,_gS_),
       _gU_=caml_call2(General[69][267],_gT_,2),
       _gV_=caml_call2(General[69][264],2,_gU_),
       _gW_=caml_call1(General[24][45],2),
       _gX_=caml_call2(General[69][266],3,_gW_),
       _gY_=caml_call2(General[69][267],_gX_,2),
       _gZ_=[0,caml_call2(General[69][264],1,_gY_),_gV_],
       _g0_=
        [0,
         make$1
          (cst_pi_4$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],142);
             var _kp_=caml_call2(General[69][267],General[24][40],4);
             return caml_call6(C[39],c,1,2,3,0,_kp_)},
           _gZ_),
         _gR_],
       _g1_=caml_call2(General[69][266],3,0.5),
       _g2_=caml_call2(General[69][264],2,_g1_),
       _g3_=caml_call1(General[24][45],3),
       _g4_=caml_call2(General[69][266],3,_g3_),
       _g5_=caml_call2(General[69][267],_g4_,2),
       _g6_=[0,caml_call2(General[69][264],1,_g5_),_g2_],
       _g7_=
        [0,
         make$1
          (cst_pi_6$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],141);
             var _ko_=caml_call2(General[69][267],General[24][40],6);
             return caml_call6(C[39],c,1,2,3,-1,_ko_)},
           _g6_),
         _g0_],
       _g8_=
        [0,
         make$1
          (cst_0$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],140);
             return caml_call6(C[39],c,1,2,3,-1,0)},
           _J_),
         _g7_],
       _g9_=[0,caml_call2(General[67][4],cst_arc,_g8_),_gO_],
       _g__=
        [0,
         make$1
          (cst_rectangle,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],139);
             return caml_call5(C[44],c,1,2,3,4)},
           _K_),
         _g9_],
       _g$_=
        [0,
         make$1
          (cst_rel_line_to$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],138);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],137);
             return caml_call3(C[46],c,3,4)},
           _L_),
         _g__],
       _ha_=
        [0,
         make$1
          (cst_line_to,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],136);
             return caml_call3(C[42],c,1,2)},
           _M_),
         _g$_],
       _hb_=
        [0,
         make$1
          (cst_rel_move_to,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],135);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],134);
             return caml_call3(C[47],c,3,4)},
           _N_),
         _ha_],
       _hc_=
        [0,
         make$1
          (cst_save_scale_move_to_restore,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],133);
             caml_call1(C[11],c);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],132);
             caml_call3(C[49],c,3,4);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],131);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],130);
             return caml_call1(C[12],c)},
           _O_),
         _hb_],
       _hd_=
        [0,
         make$1
          (cst_save_move_to_restore,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],129);
             caml_call1(C[11],c);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],128);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],127);
             return caml_call1(C[12],c)},
           _P_),
         _hc_],
       _he_=
        [0,
         make$1
          (cst_move_to_paint,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],126);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],125);
             return caml_call2(C[35],0,c)},
           _Q_),
         _hd_],
       arg=C[35],
       _hf_=
        [0,
         make$1(cst_paint,function(eta){return caml_call2(arg,0,eta)},_R_),
         _he_],
       _hg_=
        [0,
         make$1
          (cst_move_to,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],124);
             return caml_call3(C[43],c,1,2)},
           _S_),
         _hf_],
       _hh_=
        [0,
         make$1
          (cst_no_op,
           function(param)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],123);return 0},
           _T_),
         _hg_],
       _hi_=[0,caml_call2(General[67][4],cst_current_point,_hh_),_gl_];
      function make$2(name,f)
       {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],121);
        var
         _kk_=
          [246,
           function(_kl_)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],119);
             var ctx=caml_call1(N[2],0);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],120);
             var _km_=[246,function(_kn_){return caml_call1(f,ctx)}];
             return caml_call2(General[67][9],[0,C[1],2],_km_)}];
        return caml_call2(General[67][5],name,_kk_)}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],122);
      var
       _hj_=0,
       _hk_=
        [0,
         make$2
          (cst_clip,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],118);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],117);
             caml_call3(C[42],c,3,4);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],116);
             caml_call1(C[31],c);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],115);
             return caml_call3(C[47],c,3,4)}),
         _hj_],
       _hl_=
        [0,
         make$2
          (cst_fill,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],114);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],113);
             caml_call3(C[42],c,3,4);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],112);
             caml_call1(C[33],c);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],111);
             return caml_call3(C[47],c,3,4)}),
         _hk_],
       _hm_=
        [0,
         make$2
          (cst_stroke,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],110);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],109);
             caml_call3(C[42],c,3,4);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],108);
             caml_call1(C[36],c);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],107);
             return caml_call3(C[47],c,3,4)}),
         _hl_],
       _hn_=
        [0,
         make$2
          (cst_Path_clear,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],106);
             caml_call3(C[43],c,1,2);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],105);
             caml_call1(C[38][2],c);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],104);
             return caml_call3(C[47],c,3,4)}),
         _hm_],
       _ho_=
        [0,
         make$2
          (cst_rel_curve_to,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],103);
             return caml_call7(C[45],c,1,2,3,4,5,6)}),
         _hn_],
       _hp_=
        [0,
         make$2
          (cst_rel_line_to$1,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],102);
             return caml_call3(C[46],c,1,2)}),
         _ho_],
       _hq_=
        [0,
         make$2
          (cst_rel_move_to$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],101);
             return caml_call3(C[47],c,1,2)}),
         _hp_],
       _hr_=[0,caml_call2(General[67][4],cst_no_current_point,_hq_),_hi_],
       _hs_=
        [246,
         function(_kh_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],99);
           var ctx=caml_call1(N[2],0);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],100);
           var _ki_=[246,function(_kj_){return caml_call1(C[12],ctx)}];
           return caml_call2(General[67][9],[0,C[1],0],_ki_)}],
       _ht_=[0,caml_call2(General[67][5],cst_invalid_restore,_hs_),_hr_],
       _hu_=
        [246,
         function(_ka_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],96);
           var ctx=caml_call1(N[2],0);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],97);
           var m=[254,1,3,2,4,5,6];
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],98);
           caml_call2(C[52],ctx,m);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],95);
           var _kb_=caml_call3(C[57],ctx,7,8);
           caml_call2(check_coords(0),_U_,_kb_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],94);
           var _kc_=caml_call3(C[58],ctx,7,8);
           caml_call2(check_coords(0),_V_,_kc_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],93);
           var _kd_=caml_call3(C[55],ctx,7,8);
           caml_call2(check_coords(0),_W_,_kd_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],92);
           var _ke_=caml_call3(C[56],ctx,7,8);
           caml_call2(check_coords(0),_X_,_ke_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],91);
           var _kf_=caml_call3(C[4][11],m,7,8);
           caml_call2(check_coords(0),_Y_,_kf_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],90);
           var _kg_=caml_call3(C[4][10],m,7,8);
           return caml_call2(check_coords(0),_Z_,_kg_)}],
       _hv_=
        [0,
         caml_call2(General[67][5],cst_coordinates_transformation,_hu_),
         _ht_],
       _hw_=0,
       _hx_=
        [246,
         function(_j3_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],88);
           var m=[254,1,3,2,4,5,6];
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],89);
           var _j4_=caml_call2(General[69][267],General[24][40],6);
           caml_call2(C[4][7],m,_j4_);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],87);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],85);
           var
            _j5_=caml_call1(General[24][45],3),
            s=caml_call2(General[69][267],_j5_,2);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],86);
           var
            _j6_=caml_call2(General[69][266],4,s),
            _j7_=caml_call2(General[69][265],_j6_,1.5),
            _j8_=caml_call2(General[69][266],2,s),
            _j9_=caml_call2(General[69][265],_j8_,0.5),
            _j__=caml_call2(General[69][266],3,s),
            _j$_=caml_call2(General[69][264],_j__,2);
           return caml_call2
                   (check_matrix,
                    [254,caml_call2(General[69][264],s,1),_j$_,_j9_,_j7_,5,6],
                    m)}],
       _hy_=[0,caml_call2(General[67][5],cst_rotate,_hx_),_hw_],
       _hz_=
        [246,
         function(_j2_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],83);
           var m=[254,1,3,2,4,5,6];
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],84);
           caml_call3(C[4][5],m,7,8);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],82);
           return caml_call2(check_matrix,[254,1,3,2,4,28,59],m)}],
       _hA_=[0,caml_call2(General[67][5],cst_translate,_hz_),_hy_],
       _hB_=
        [246,
         function(_j1_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],80);
           var m=[254,1,3,2,4,5,6];
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],81);
           caml_call3(C[4][6],m,7,8);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],79);
           return caml_call2(check_matrix,[254,7,21,16,32,5,6],m)}],
       _hC_=[0,caml_call2(General[67][5],cst_scale,_hB_),_hA_],
       _hD_=0,
       _hE_=
        [246,
         function(_j0_)
          {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],77);
           var m=[254,1,3,2,4,5,6];
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],78);
           caml_call1(C[4][8],m);
           caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],76);
           return caml_call2(check_matrix,[254,-2,1.5,1,-0.5,4,-4.5],m)}],
       _hF_=[0,caml_call2(General[67][5],cst_invertible,_hE_),_hD_],
       _hG_=
        [246,
         function(_jX_)
          {var
            _jY_=
             [246,
              function(_jZ_)
               {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],74);
                var m=[254,1,1,2,2,3,4];
                caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],75);
                return caml_call1(C[4][8],m)}];
           return caml_call2(General[67][9],[0,C[1],3],_jY_)}],
       _hH_=[0,caml_call2(General[67][5],cst_non_invertible,_hG_),_hF_],
       _hI_=[0,caml_call2(General[67][4],cst_invert,_hH_),_hC_],
       _hJ_=
        [246,
         function(_jR_)
          {var
            _jS_=caml_call2(General[69][267],General[24][40],6),
            _jT_=caml_call1(C[4][4],_jS_),
            _jU_=caml_call1(General[24][45],3),
            _jV_=caml_call2(General[69][267],_jU_,2),
            _jW_=caml_call1(General[24][45],3);
           return caml_call2
                   (check_matrix,
                    [254,caml_call2(General[69][267],_jW_,2),0.5,-0.5,_jV_,0,0],
                    _jT_)}],
       _hK_=[0,caml_call2(General[67][5],cst_init_rotate,_hJ_),_hI_],
       _hL_=
        [246,
         function(_jQ_)
          {return caml_call2
                   (check_matrix,[254,2,0,0,3,0,0],caml_call2(C[4][3],2,3))}],
       _hM_=[0,caml_call2(General[67][5],cst_init_scale,_hL_),_hK_],
       _hN_=
        [246,
         function(_jP_)
          {return caml_call2
                   (check_matrix,[254,1,0,0,1,2,3],caml_call2(C[4][2],2,3))}],
       _hO_=[0,caml_call2(General[67][5],cst_init_translate,_hN_),_hM_],
       _hP_=
        [246,
         function(_jO_)
          {return caml_call2
                   (check_matrix,[254,1,0,0,1,0,0],caml_call1(C[4][1],0))}],
       _hQ_=[0,caml_call2(General[67][5],cst_init_identity,_hP_),_hO_],
       _hR_=[0,caml_call2(General[67][4],cst_matrix,_hQ_),_hv_];
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],72);
      var identity=[254,1,0,0,1,0,0];
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],73);
      function make$3(name,f,expected)
       {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],70);
        var
         _jM_=
          [246,
           function(_jN_)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],68);
             var ctx=caml_call1(N[2],0);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],69);
             caml_call2(check_matrix,identity,caml_call1(C[53],ctx));
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],67);
             caml_call1(f,ctx);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],66);
             caml_call2(check_matrix,expected,caml_call1(C[53],ctx));
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],65);
             caml_call1(C[11],ctx);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],64);
             caml_call2(check_matrix,expected,caml_call1(C[53],ctx));
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],63);
             caml_call1(C[54],ctx);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],62);
             caml_call2(check_matrix,identity,caml_call1(C[53],ctx));
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],61);
             caml_call1(C[12],ctx);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],60);
             return caml_call2(check_matrix,expected,caml_call1(C[53],ctx))}];
        return caml_call2(General[67][5],name,_jM_)}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],71);
      var
       _hS_=0,
       _hT_=[254,2,9,4,12,10,18],
       _hU_=
        [0,
         make$3
          (cst_transform,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],59);
             caml_call3(C[49],c,2,3);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],58);
             return caml_call2(C[51],c,[254,1,3,2,4,5,6])},
           _hT_),
         _hS_],
       _hV_=[254,1,3,2,4,5,6],
       _hW_=
        [0,
         make$3
          (cst_set_matrix,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],57);
             return caml_call2(C[52],c,[254,1,3,2,4,5,6])},
           _hV_),
         _hU_];
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],55);
      var
       _hX_=caml_call1(General[24][45],2),
       s=caml_call2(General[69][267],_hX_,2);
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],56);
      var
       _hY_=[254,s,s,caml_call1(General[69][262],s),s,0,0],
       _hZ_=
        [0,
         make$3
          (cst_rotate$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],54);
             var _jL_=caml_call2(General[69][267],General[24][40],4);
             return caml_call2(C[50],c,_jL_)},
           _hY_),
         _hW_],
       _h0_=[254,2,0,0,3,0,0],
       _h1_=
        [0,
         make$3
          (cst_scale$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],53);
             return caml_call3(C[49],c,2,3)},
           _h0_),
         _hZ_],
       _h2_=[254,1,0,0,1,2,3],
       _h3_=
        [0,
         make$3
          (cst_translate$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],52);
             return caml_call3(C[48],c,2,3)},
           _h2_),
         _h1_],
       _h4_=[0,caml_call2(General[67][4],cst_transformations,_h3_),_hR_],
       _h5_=0,
       _h6_=
        [246,
         function(_jJ_)
          {var _jK_=caml_call1(General[9][5],Not_found);
           return caml_call2(General[67][13],cst_Not_found,_jK_)}],
       _h7_=[0,caml_call2(General[67][5],cst_Not_Cairo,_h6_),_h5_],
       _h8_=
        [246,
         function(_jG_)
          {var
            _jH_=caml_call1(General[9][5],[0,C[1],0]),
            _jI_=caml_call2(General[59][2],___,_fI_);
           return caml_call2(General[67][13],_jI_,_jH_)}],
       _h9_=[0,caml_call2(General[67][5],cst_Cairo_Error,_h8_),_h7_],
       _h__=[0,caml_call2(General[67][4],cst_exceptions,_h9_),_h4_];
      function make$4(name,status,expected)
       {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],50);
        var
         _jD_=
          [246,
           function(_jE_)
            {var _jF_=caml_call1(C[2],status);
             return caml_call2(General[67][13],expected,_jF_)}];
        return caml_call2(General[67][5],name,_jD_)}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],51);
      var
       _h$_=
        [0,
         make$4
          (cst_JBIG2_GLOBAL_MISSING,
           36,
           cst_CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID_used_but_no_CAIRO_MIME_TYPE_JBIG2_GLOBAL_data_provided),
         0],
       _ia_=
        [0,
         make$4
          (cst_DEVICE_FINISHED,35,cst_the_target_device_has_been_finished),
         _h$_],
       _ib_=
        [0,
         make$4
          (cst_INVALID_MESH_CONSTRUCTION,
           34,
           cst_invalid_operation_during_mesh_pattern_construction),
         _ia_],
       _ic_=
        [0,
         make$4
          (cst_DEVICE_ERROR,
           33,
           cst_an_operation_to_the_device_caused_an_unspecified_error),
         _ib_],
       _id_=
        [0,
         make$4
          (cst_DEVICE_TYPE_MISMATCH,
           32,
           cst_the_device_type_is_not_appropriate_for_the_operation),
         _ic_],
       _ie_=
        [0,
         make$4
          (cst_USER_FONT_NOT_IMPLEMENTED,
           31,
           cst_user_font_method_not_implemented),
         _id_],
       _if_=
        [0,
         make$4
          (cst_INVALID_SIZE,
           30,
           cst_invalid_value_typically_too_big_for_the_size_of_the_input_surface_pattern_etc),
         _ie_],
       _ig_=
        [0,
         make$4
          (cst_INVALID_WEIGHT,
           29,
           cst_invalid_value_for_an_input_cairo_font_weight_t),
         _if_],
       _ih_=
        [0,
         make$4
          (cst_INVALID_SLANT,
           28,
           cst_invalid_value_for_an_input_cairo_font_slant_t),
         _ig_],
       _ii_=
        [0,
         make$4
          (cst_INVALID_CLUSTERS,
           27,
           cst_input_clusters_do_not_represent_the_accompanying_text_and_glyph_arrays),
         _ih_],
       _ij_=
        [0,
         make$4
          (cst_NEGATIVE_COUNT,
           26,
           cst_negative_number_used_where_it_is_not_allowed),
         _ii_],
       _ik_=
        [0,
         make$4
          (cst_USER_FONT_ERROR,
           25,
           cst_error_occurred_in_a_user_font_callback_function),
         _ij_],
       _il_=
        [0,
         make$4(cst_USER_FONT_IMMUTABLE,24,cst_the_user_font_is_immutable),
         _ik_],
       _im_=
        [0,
         make$4
          (cst_FONT_TYPE_MISMATCH,
           23,
           cst_the_font_type_is_not_appropriate_for_the_operation),
         _il_],
       _in_=
        [0,make$4(cst_INVALID_STRIDE,22,cst_invalid_value_for_stride),_im_],
       _io_=
        [0,
         make$4
          (cst_TEMP_FILE_ERROR,
           21,
           cst_error_creating_or_writing_to_a_temporary_file),
         _in_],
       _ip_=
        [0,
         make$4
          (cst_CLIP_NOT_REPRESENTABLE,
           20,
           cst_clip_region_not_representable_in_desired_format),
         _io_],
       _iq_=
        [0,
         make$4(cst_INVALID_INDEX,19,cst_invalid_index_passed_to_getter),
         _ip_],
       _ir_=
        [0,
         make$4
          (cst_INVALID_DSC_COMMENT,18,cst_invalid_value_for_a_DSC_comment),
         _iq_],
       _is_=
        [0,
         make$4(cst_INVALID_DASH,17,cst_invalid_value_for_a_dash_setting),
         _ir_],
       _it_=[0,make$4(cst_FILE_NOT_FOUND,16,cst_file_not_found),_is_],
       _iu_=
        [0,
         make$4(cst_INVALID_VISUAL,15,cst_invalid_value_for_an_input_Visual),
         _it_],
       _iv_=
        [0,
         make$4
          (cst_INVALID_FORMAT,
           14,
           cst_invalid_value_for_an_input_cairo_format_t),
         _iu_],
       _iw_=
        [0,
         make$4
          (cst_INVALID_CONTENT,
           13,
           cst_invalid_value_for_an_input_cairo_content_t),
         _iv_],
       _ix_=
        [0,
         make$4
          (cst_PATTERN_TYPE_MISMATCH,
           12,
           cst_the_pattern_type_is_not_appropriate_for_the_operation),
         _iw_],
       _iy_=
        [0,
         make$4
          (cst_SURFACE_TYPE_MISMATCH,
           11,
           cst_the_surface_type_is_not_appropriate_for_the_operation),
         _ix_],
       _iz_=
        [0,
         make$4
          (cst_SURFACE_FINISHED,10,cst_the_target_surface_has_been_finished),
         _iy_],
       _iA_=
        [0,
         make$4(cst_WRITE_ERROR,9,cst_error_while_writing_to_output_stream),
         _iz_],
       _iB_=
        [0,
         make$4(cst_READ_ERROR,8,cst_error_while_reading_from_input_stream),
         _iA_],
       _iC_=
        [0,make$4(cst_INVALID_PATH_DATA,7,cst_input_path_data_not_valid),_iB_],
       _iD_=
        [0,make$4(cst_INVALID_STRING,6,cst_input_string_not_valid_UTF_8),_iC_],
       _iE_=[0,make$4(cst_NULL_POINTER,5,cst_NULL_pointer),_iD_],
       _iF_=
        [0,
         make$4
          (cst_INVALID_STATUS,4,cst_invalid_value_for_an_input_cairo_status_t),
         _iE_],
       _iG_=
        [0,
         make$4(cst_INVALID_MATRIX,3,cst_invalid_matrix_not_invertible),
         _iF_],
       _iH_=
        [0,make$4(cst_NO_CURRENT_POINT,2,cst_no_current_point_defined),_iG_],
       _iI_=
        [0,
         make$4
          (cst_INVALID_POP_GROUP,
           1,
           cst_no_saved_group_to_pop_i_e_cairo_pop_group_without_matching_cairo_push_group),
         _iH_],
       _iJ_=
        [0,
         make$4
          (cst_INVALID_RESTORE,
           0,
           cst_cairo_restore_without_matching_cairo_save),
         _iI_],
       _iK_=[0,caml_call2(General[67][4],cst_status_to_string,_iJ_),_h__];
      function make$5
       (name,setter,getter,check,initial_value,other_value,other_values)
       {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],48);
        var
         _jx_=
          [246,
           function(_jy_)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],46);
             var ctx=caml_call1(N[2],0);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],47);
             caml_call2(check,initial_value,caml_call1(getter,ctx));
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],45);
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],44);
             var _jz_=General[40][40];
             function _jA_(value)
              {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],43);
               caml_call2(setter,ctx,value);
               caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],42);
               caml_call2(check,value,caml_call1(getter,ctx));
               caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],41);
               caml_call1(C[11],ctx);
               caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],40);
               caml_call2(check,value,caml_call1(getter,ctx));
               caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],39);
               caml_call2(setter,ctx,other_value);
               caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],38);
               caml_call2(check,other_value,caml_call1(getter,ctx));
               caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],37);
               caml_call1(C[12],ctx);
               caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],36);
               return caml_call2(check,value,caml_call1(getter,ctx))}
             function _jB_(_jC_){return caml_call2(_jz_,_jC_,_jA_)}
             return caml_call2
                     (General[69][270],
                      [0,initial_value,[0,other_value,other_values]],
                      _jB_)}];
        return caml_call2(General[67][5],name,_jx_)}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],49);
      var _iL_=0;
      function _iM_(c)
       {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],35);
        caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],34);
        var _jv_=C[10][7],_jw_=caml_call1(C[16],c);
        return caml_call2(General[69][270],_jw_,_jv_)}
      var
       _iN_=
        [0,
         make$5
          (cst_source,
           function(c,param)
            {var a=param[4],b=param[3],g=param[2],r=param[1];
             caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],33);
             return caml_call5(C[14],c,r,g,b,a)},
           _iM_,
           check_float_tuple_4,
           _ab_,
           _aa_,
           _$_),
         _iL_],
       _iO_=0,
       _iP_=2,
       _iQ_=0,
       _iR_=General[67][20];
      function _iS_(c)
       {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],32);
        caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],31);
        var _jt_=General[30][16],_ju_=caml_call1(C[26],c);
        return caml_call2(General[69][270],_ju_,_jt_)}
      var
       _iT_=
        [0,
         make$5
          (cst_offset,
           function(c,ofs)
            {caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],30);
             return caml_call3(C[25],c,[0,ofs],[254,10,10])},
           _iS_,
           _iR_,
           _iQ_,
           _iP_,
           _ac_),
         _iO_];
      function repr$3(dashes)
       {var
         _jk_=caml_call1(General[59][2],_ad_),
         _jl_=caml_call1(General[50][82],_ae_),
         _jm_=General[40][19],
         _jn_=General[24][7];
        function _jo_(_js_){return caml_call2(_jm_,_js_,_jn_)}
        var
         _jp_=caml_call2(General[69][270],dashes,General[40][6]),
         _jq_=caml_call2(General[69][270],_jp_,_jo_),
         _jr_=caml_call2(General[69][270],_jq_,_jl_);
        return caml_call2(General[69][270],_jr_,_jk_)}
      var
       _iU_=caml_call2(General[69][275],N[3],95560584),
       _iV_=caml_call2(General[69][275],N[3],870528546),
       _iW_=
        caml_call2(General[69][254],_iV_,_iU_)?0:[0,[254,3],[0,[254,4,5,6],0]],
       _iX_=
        caml_call2(General[69][283],[0,[254,3,4,5,6],[0,_af_.slice(),0]],_iW_),
       _iY_=[254,1,2],
       _iZ_=[0],
       _i0_=caml_call1(General[67][12],repr$3);
      function _i1_(c)
       {var _ji_=General[30][15],_jj_=caml_call1(C[26],c);
        return caml_call2(General[69][270],_jj_,_ji_)}
      var
       _i2_=
        [0,
         make$5
          (cst_dashes,
           function(c,dashes){return caml_call3(C[25],c,0,dashes)},
           _i1_,
           _i0_,
           _iZ_,
           _iY_,
           _iX_),
         _iT_],
       _i3_=[0,caml_call2(General[67][4],cst_dash,_i2_),_iN_];
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],29);
      function repr$4(param)
       {switch(param)
         {case 0:return cst_CLEAR;
          case 1:return cst_SOURCE;
          case 2:return cst_OVER;
          case 3:return cst_IN;
          case 4:return cst_OUT;
          case 5:return cst_ATOP;
          case 6:return cst_DEST;
          case 7:return cst_DEST_OVER;
          case 8:return cst_DEST_IN;
          case 9:return cst_DEST_OUT;
          case 10:return cst_DEST_ATOP;
          case 11:return cst_XOR;
          case 12:return cst_ADD;
          default:return cst_SATURATE}}
      var
       _i4_=caml_call2(General[69][275],N[3],95560584),
       _i5_=caml_call2(General[69][275],N[3],870528546),
       _i6_=caml_call2(General[69][254],_i5_,_i4_)?0:_am_,
       _i7_=caml_call2(General[69][283],_ag_,_i6_),
       _i8_=caml_call1(General[67][12],repr$4),
       _i9_=[0,make$5(cst_operator,C[27],C[28],_i8_,2,3,_i7_),_i3_];
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],27);
      function repr$5(param)
       {switch(param)
         {case 0:return cst_JOIN_MITER;
          case 1:return cst_JOIN_ROUND;
          default:return cst_JOIN_BEVEL}}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],28);
      var
       _i__=caml_call1(General[67][12],repr$5),
       _i$_=[0,make$5(cst_line_join,C[19],C[20],_i__,0,1,_ah_),_i9_];
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],25);
      function repr$6(param)
       {switch(param)
         {case 0:return cst_BUTT;
          case 1:return cst_ROUND;
          default:return cst_SQUARE}}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],26);
      var
       _ja_=caml_call1(General[67][12],repr$6),
       _jb_=[0,make$5(cst_line_cap,C[17],C[18],_ja_,0,1,_ai_),_i$_];
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],23);
      function repr$7(param){return 0 === param?cst_WINDING:cst_EVEN_ODD}
      caml_call1(Bisect_visit_tst_Tests_Universal_ml[1],24);
      var
       _jc_=caml_call1(General[67][12],repr$7),
       _jd_=[0,make$5(cst_fill_rule,C[29],C[30],_jc_,0,1,0),_jb_],
       _je_=
        [0,make$5(cst_miter_limit,C[23],C[24],General[67][20],10,5,_aj_),_jd_],
       _jf_=
        [0,make$5(cst_line_width,C[21],C[22],General[67][20],2,1,_ak_),_je_],
       _jg_=
        [0,
         caml_call2(General[67][4],cst_saved_and_restored_settings,_jf_),
         _iK_],
       _jh_=N[1],
       test=caml_call2(caml_call1(General[67][7],_al_),_jh_,_jg_);
      return [0,
              _fI_,
              check_matrix,
              check_coords,
              check_float_tuple_4,
              check_float_tuple_5,
              check_float_tuple_6,
              test]}
    var Tests_Universal=[0,Bisect_visit_tst_Tests_Universal_ml,Make];
    caml_register_global(1355,Tests_Universal,"Tests__Universal");
    var
     match$0=
      caml_call3
       (Bisect_Runtime[1],cst_tst_Tests_Decoration_ml,83,point_definitions$0),
     bisect_visit$0=match$0[2],
     Bisect_visit_tst_Tests_Decoration_ml=[0,bisect_visit$0];
    function Make$0(_dx_,N)
     {var DecoratedC=caml_call1(CairoMock[2],_dx_);
      caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],2);
      var _dy_=N[3];
      if(553448210 === _dy_)
       {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],1);
        var _dz_=cst_CairoMock$0}
      else
       if(-733568919 <= _dy_)
        {if(95560584 !== _dy_)870528546 === _dy_;var _dz_=cst_JsOfOCairo$0}
       else
        {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],0);
         var _dz_=cst_Cairo$0}
      function make_n(name,fs,checks)
       {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],9);
        var
         _fw_=
          [246,
           function(_fx_)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],7);
             var _fy_=caml_call1(N[2],0),c=caml_call1(DecoratedC[59],_fy_);
             caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],8);
             function _fz_(f)
              {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],5);
               var _fG_=caml_call1(f,c);
               return caml_call1(General[69][281],_fG_)}
             caml_call2(General[40][40],fs,_fz_);
             caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],6);
             caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],4);
             var _fA_=General[40][40];
             function _fB_(param)
              {var actual=param[2],check=param[1];
               caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],3);
               return caml_call1(check,actual)}
             function _fC_(_fF_){return caml_call2(_fA_,_fF_,_fB_)}
             var
              _fD_=caml_call1(DecoratedC[60],c),
              _fE_=caml_call2(General[40][82][1],checks,_fD_);
             return caml_call2(General[69][270],_fE_,_fC_)}];
        return caml_call2(General[67][5],name,_fw_)}
      function make(name,f,check)
       {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],10);
        return make_n(name,[0,f,0],[0,check,0])}
      function make_n$0(name,fs,expected)
       {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],12);
        function _fv_(expected)
         {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],11);
          return caml_call1(General[67][13],expected)}
        return make_n(name,fs,caml_call2(General[40][19],expected,_fv_))}
      function make$0(name,f,expected)
       {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],14);
        function _fu_(expected)
         {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],13);
          return make_n$0(name,[0,f,0],[0,expected,0])}
        return caml_call2(General[59][1],expected,_fu_)}
      function catch$0(error,f,ctx)
       {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],15);
        var _fs_=[246,function(_ft_){return caml_call1(f,ctx)}];
        return caml_call2(General[67][9],[0,DecoratedC[1],error],_fs_)}
      caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],82);
      var _dA_=0;
      function _dB_(ascent,descent,param,_fr_,_fq_)
       {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],81);
        caml_call3(General[67][19],5,15,ascent);
        caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],80);
        return caml_call3(General[67][19],1,7,descent)}
      var
       _dC_=caml_call2(General[59][6],_an_,_dB_),
       _dD_=[0,make(cst_font_extents,DecoratedC[8],_dC_),_dA_];
      function _dE_(param,_fp_,width,_fo_,_fn_,_fm_)
       {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],79);
        return caml_call3(General[67][19],10,50,width)}
      var
       _dF_=caml_call2(General[59][6],_ao_,_dE_),
       _dG_=
        [0,
         make
          (cst_text_extents,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],78);
             return caml_call2(DecoratedC[9],c,cst_abcd)},
           _dF_),
         _dD_],
       _dH_=
        [0,
         make$0
          (cst_show_text$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],77);
             return caml_call2(DecoratedC[7],c,cst_flibidiboo)},
           _ap_),
         _dG_],
       _dI_=
        [0,
         make$0
          (cst_select_font_face_Italic_Bold,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],76);
             return caml_call4(DecoratedC[5],c,_as_,_ar_,cst_foo_bar)},
           _aq_),
         _dH_],
       _dJ_=
        [0,
         make$0
          (cst_select_font_face_Normal,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],75);
             return caml_call4(DecoratedC[5],c,0,_au_,cst_foo_bar$0)},
           _at_),
         _dI_],
       _dK_=
        [0,
         make$0
          (cst_select_font_face_Oblique,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],74);
             return caml_call4(DecoratedC[5],c,_aw_,0,cst_foo_bar$1)},
           _av_),
         _dJ_],
       _dL_=
        [0,
         make$0
          (cst_select_font_face_Upright,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],73);
             return caml_call4(DecoratedC[5],c,_ay_,0,cst_foo_bar$2)},
           _ax_),
         _dK_],
       _dM_=
        [0,
         make$0
          (cst_select_font_face,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],72);
             return caml_call4(DecoratedC[5],c,0,0,cst_foo_bar$3)},
           _az_),
         _dL_],
       _dN_=
        [0,
         make$0
          (cst_set_font_size,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],71);
             return caml_call2(DecoratedC[6],c,3)},
           _aA_),
         _dM_],
       _dO_=[0,make$0(cst_get_source,DecoratedC[16],_aB_),_dN_],
       _dP_=
        [0,
         make$0
          (cst_set_source_RadialGradient,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],70);
             var _fl_=caml_call6(DecoratedC[10][10],1,2,5,3,4,6);
             return caml_call2(DecoratedC[15],c,_fl_)},
           _aC_),
         _dO_],
       _dQ_=
        [0,
         make$0
          (cst_set_source_LinearGradient,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],69);
             caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],67);
             var p=caml_call4(DecoratedC[10][8],1,2,3,4);
             caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],68);
             caml_call5(DecoratedC[10][1],p,0,0.1,0.2,0.3);
             caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],66);
             return caml_call2(DecoratedC[15],c,p)},
           _aD_),
         _dP_],
       _dR_=
        [0,
         make$0
          (cst_set_source_Rgba,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],65);
             var _fk_=caml_call3(DecoratedC[10][5],0.5,0.6,0.7);
             return caml_call2(DecoratedC[15],c,_fk_)},
           _aE_),
         _dQ_],
       _dS_=
        [0,
         make$0
          (cst_set_source_rgba,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],64);
             return caml_call5(DecoratedC[14],c,0.5,0.6,0.7,0.8)},
           _aF_),
         _dR_],
       _dT_=
        [0,
         make$0
          (cst_set_source_rgb,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],63);
             return caml_call4(DecoratedC[13],c,0.5,0.6,0.7)},
           _aG_),
         _dS_],
       _dU_=[0,make$0(cst_get_operator,DecoratedC[28],_aH_),_dT_],
       _dV_=caml_call2(General[69][275],N[3],95560584),
       _dW_=caml_call2(General[69][275],N[3],870528546);
      if(caml_call2(General[69][254],_dW_,_dV_))
       var _dX_=0;
      else
       var
        _fc_=0,
        _fd_=
         [0,
          make$0
           (cst_set_operator_SATURATE,
            function(c)
             {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],62);
              return caml_call2(DecoratedC[27],c,13)},
            _bI_),
          _fc_],
        _fe_=
         [0,
          make$0
           (cst_set_operator_SOURCE,
            function(c)
             {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],61);
              return caml_call2(DecoratedC[27],c,1)},
            _bJ_),
          _fd_],
        _ff_=
         [0,
          make$0
           (cst_set_operator_CLEAR,
            function(c)
             {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],60);
              return caml_call2(DecoratedC[27],c,0)},
            _bK_),
          _fe_],
        _dX_=
         [0,
          make$0
           (cst_set_operator_DEST,
            function(c)
             {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],59);
              return caml_call2(DecoratedC[27],c,6)},
            _bL_),
          _ff_];
      var
       _dY_=caml_call2(General[69][283],_dX_,_dU_),
       _dZ_=0,
       _d0_=
        [0,
         make$0
          (cst_set_operator_ADD,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],58);
             return caml_call2(DecoratedC[27],c,12)},
           _aI_),
         _dZ_],
       _d1_=
        [0,
         make$0
          (cst_set_operator_XOR,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],57);
             return caml_call2(DecoratedC[27],c,11)},
           _aJ_),
         _d0_],
       _d2_=
        [0,
         make$0
          (cst_set_operator_DEST_ATOP,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],56);
             return caml_call2(DecoratedC[27],c,10)},
           _aK_),
         _d1_],
       _d3_=
        [0,
         make$0
          (cst_set_operator_DEST_OUT,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],55);
             return caml_call2(DecoratedC[27],c,9)},
           _aL_),
         _d2_],
       _d4_=
        [0,
         make$0
          (cst_set_operator_DEST_IN,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],54);
             return caml_call2(DecoratedC[27],c,8)},
           _aM_),
         _d3_],
       _d5_=
        [0,
         make$0
          (cst_set_operator_DEST_OVER,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],53);
             return caml_call2(DecoratedC[27],c,7)},
           _aN_),
         _d4_],
       _d6_=
        [0,
         make$0
          (cst_set_operator_ATOP,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],52);
             return caml_call2(DecoratedC[27],c,5)},
           _aO_),
         _d5_],
       _d7_=
        [0,
         make$0
          (cst_set_operator_OUT,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],51);
             return caml_call2(DecoratedC[27],c,4)},
           _aP_),
         _d6_],
       _d8_=
        [0,
         make$0
          (cst_set_operator_IN,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],50);
             return caml_call2(DecoratedC[27],c,3)},
           _aQ_),
         _d7_],
       _d9_=[0,make$0(cst_get_miter_limit,DecoratedC[24],_aR_),_d8_],
       _d__=
        [0,
         make$0
          (cst_set_miter_limit,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],49);
             return caml_call2(DecoratedC[23],c,3)},
           _aS_),
         _d9_],
       _d$_=[0,make$0(cst_get_line_join,DecoratedC[20],_aT_),_d__],
       _ea_=
        [0,
         make$0
          (cst_set_line_join_JOIN_BEVEL,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],48);
             return caml_call2(DecoratedC[19],c,2)},
           _aU_),
         _d$_],
       _eb_=
        [0,
         make$0
          (cst_set_line_join_JOIN_ROUND,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],47);
             return caml_call2(DecoratedC[19],c,1)},
           _aV_),
         _ea_],
       _ec_=[0,make$0(cst_get_line_cap,DecoratedC[18],_aW_),_eb_],
       _ed_=
        [0,
         make$0
          (cst_set_line_cap_SQUARE,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],46);
             return caml_call2(DecoratedC[17],c,2)},
           _aX_),
         _ec_],
       _ee_=
        [0,
         make$0
          (cst_set_line_cap_ROUND,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],45);
             return caml_call2(DecoratedC[17],c,1)},
           _aY_),
         _ed_],
       _ef_=[0,make$0(cst_get_fill_rule,DecoratedC[30],_aZ_),_ee_],
       _eg_=
        [0,
         make$0
          (cst_set_fill_rule,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],44);
             return caml_call2(DecoratedC[29],c,1)},
           _a0_),
         _ef_],
       _eh_=[0,make$0(cst_get_dash,DecoratedC[26],_a1_),_eg_],
       _ei_=
        [0,
         make$0
          (cst_set_dash_with_ofs,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],43);
             return caml_call3(DecoratedC[25],c,_a3_,[254,3,4])},
           _a2_),
         _eh_],
       _ej_=
        [0,
         make$0
          (cst_set_dash,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],42);
             return caml_call3(DecoratedC[25],c,0,[254,2,3])},
           _a4_),
         _ei_],
       _ek_=[0,make$0(cst_get_line_width,DecoratedC[22],_a5_),_ej_],
       _el_=
        [0,
         make$0
          (cst_set_line_width,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],41);
             return caml_call2(DecoratedC[21],c,3)},
           _a6_),
         _ek_],
       _em_=
        [0,
         make$0(cst_paint_with_alpha,caml_call1(DecoratedC[35],_a8_),_a7_),
         _el_],
       arg=DecoratedC[35],
       _en_=
        [0,
         make$0(cst_paint$0,function(eta){return caml_call2(arg,0,eta)},_a9_),
         _em_],
       _eo_=[0,make$0(cst_clip_preserve$0,DecoratedC[32],_a__),_en_],
       _ep_=[0,make$0(cst_clip$0,DecoratedC[31],_a$_),_eo_],
       _eq_=[0,make$0(cst_fill_preserve$0,DecoratedC[34],_ba_),_ep_],
       _er_=[0,make$0(cst_fill$0,DecoratedC[33],_bb_),_eq_],
       _es_=[0,make$0(cst_stroke_preserve$0,DecoratedC[37],_bc_),_er_],
       _et_=[0,make$0(cst_stroke$0,DecoratedC[36],_bd_),_es_],
       _eu_=
        [0,caml_call2(General[69][271],General[69][281],DecoratedC[38][1]),0],
       _ev_=
        [0,
         make_n$0
          (cst_move_to_Path_get_current_point,
           [0,
            function(c)
             {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],40);
              return caml_call3(DecoratedC[43],c,1,2)},
            _eu_],
           _be_),
         _et_],
       _ew_=[0,make$0(cst_Path_get_current_point,DecoratedC[38][1],_bf_),_ev_],
       _ex_=[0,make$0(cst_Path_clear$0,DecoratedC[38][2],_bg_),_ew_],
       _ey_=[0,make$0(cst_Path_close$0,DecoratedC[38][3],_bh_),_ex_],
       _ez_=
        [0,
         make$0
          (cst_arc_negative$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],39);
             return caml_call6(DecoratedC[40],c,1,2,3,4,5)},
           _bi_),
         _ey_],
       _eA_=
        [0,
         make$0
          (cst_arc$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],38);
             return caml_call6(DecoratedC[39],c,1,2,3,4,5)},
           _bj_),
         _ez_],
       _eB_=
        [0,
         make$0
          (cst_rectangle$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],37);
             return caml_call5(DecoratedC[44],c,2,3,4,5)},
           _bk_),
         _eA_],
       _eC_=0,
       _eD_=
        [0,
         function(c)
          {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],36);
           return caml_call7(DecoratedC[45],c,1,2,3,4,5,6)},
         _eC_],
       _eE_=
        [0,
         make_n$0
          (cst_rel_curve_to$0,
           [0,
            function(c)
             {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],35);
              return caml_call3(DecoratedC[43],c,1,2)},
            _eD_],
           _bl_),
         _eB_];
      function _eF_(c)
       {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],34);
        return caml_call7(DecoratedC[45],c,1,2,3,4,5,6)}
      var
       _eG_=2,
       _eH_=
        [0,
         caml_call1
          (make$0
            (cst_invalid_rel_curve_to,
             function(_fj_){return catch$0(_eG_,_eF_,_fj_)},
             _bm_),
           _dz_),
         _eE_],
       _eI_=
        [0,
         make$0
          (cst_curve_to$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],33);
             return caml_call7(DecoratedC[41],c,1,2,3,4,5,6)},
           _bn_),
         _eH_],
       _eJ_=0,
       _eK_=
        [0,
         function(c)
          {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],32);
           return caml_call3(DecoratedC[46],c,3,4)},
         _eJ_],
       _eL_=
        [0,
         make_n$0
          (cst_rel_line_to$2,
           [0,
            function(c)
             {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],31);
              return caml_call3(DecoratedC[43],c,1,2)},
            _eK_],
           _bo_),
         _eI_];
      function _eM_(c)
       {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],30);
        return caml_call3(DecoratedC[46],c,4.05,2.957)}
      var
       _eN_=2,
       _eO_=
        [0,
         caml_call1
          (make$0
            (cst_invalid_rel_line_to,
             function(_fi_){return catch$0(_eN_,_eM_,_fi_)},
             _bp_),
           _dz_),
         _eL_],
       _eP_=
        [0,
         make$0
          (cst_line_to$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],29);
             return caml_call3(DecoratedC[42],c,4.05,2.957)},
           _bq_),
         _eO_],
       _eQ_=0,
       _eR_=
        [0,
         function(c)
          {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],28);
           return caml_call3(DecoratedC[47],c,3,4)},
         _eQ_],
       _eS_=
        [0,
         make_n$0
          (cst_rel_move_to$1,
           [0,
            function(c)
             {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],27);
              return caml_call3(DecoratedC[43],c,1,2)},
            _eR_],
           _br_),
         _eP_];
      function _eT_(c)
       {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],26);
        return caml_call3(DecoratedC[47],c,4.05,2.957)}
      var
       _eU_=2,
       _eV_=
        [0,
         caml_call1
          (make$0
            (cst_invalid_rel_move_to,
             function(_fh_){return catch$0(_eU_,_eT_,_fh_)},
             _bs_),
           _dz_),
         _eS_],
       _eW_=
        [0,
         make$0
          (cst_move_to$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],25);
             return caml_call3(DecoratedC[43],c,4.05,2.957)},
           _bt_),
         _eV_],
       _eX_=
        [0,
         make$0
          (cst_device_to_user_distance,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],24);
             return caml_call3(DecoratedC[58],c,2,3)},
           _bu_),
         _eW_],
       _eY_=
        [0,
         make$0
          (cst_device_to_user,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],23);
             return caml_call3(DecoratedC[57],c,2,3)},
           _bv_),
         _eX_],
       _eZ_=
        [0,
         make$0
          (cst_user_to_device_distance,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],22);
             return caml_call3(DecoratedC[56],c,2,3)},
           _bw_),
         _eY_],
       _e0_=
        [0,
         make$0
          (cst_user_to_device,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],21);
             return caml_call3(DecoratedC[55],c,2,3)},
           _bx_),
         _eZ_],
       _e1_=[0,make$0(cst_get_matrix,DecoratedC[53],_by_),_e0_],
       _e2_=[0,make$0(cst_identity_matrix,DecoratedC[54],_bz_),_e1_],
       _e3_=
        [0,
         make$0
          (cst_set_matrix$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],20);
             return caml_call2(DecoratedC[52],c,[254,1,3,2,4,5,6])},
           _bA_),
         _e2_],
       _e4_=
        [0,
         make$0
          (cst_transform$0,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],19);
             return caml_call2(DecoratedC[51],c,[254,1,3,2,4,5,6])},
           _bB_),
         _e3_],
       _e5_=
        [0,
         make$0
          (cst_rotate$1,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],18);
             return caml_call2(DecoratedC[50],c,3)},
           _bC_),
         _e4_],
       _e6_=
        [0,
         make$0
          (cst_translate$1,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],17);
             return caml_call3(DecoratedC[48],c,3,2)},
           _bD_),
         _e5_],
       _e7_=
        [0,
         make$0
          (cst_scale$1,
           function(c)
            {caml_call1(Bisect_visit_tst_Tests_Decoration_ml[1],16);
             return caml_call3(DecoratedC[49],c,3,2)},
           _bE_),
         _e6_],
       _e8_=DecoratedC[12],
       _e9_=0,
       _e__=
        [0,
         caml_call1
          (make$0
            (cst_invalid_restore$0,
             function(_fg_){return catch$0(_e9_,_e8_,_fg_)},
             _bF_),
           _dz_),
         _e7_],
       _e$_=
        [0,
         make_n$0
          (cst_save_restore,[0,DecoratedC[11],[0,DecoratedC[12],0]],_bG_),
         _e__],
       _fa_=caml_call2(General[69][283],_e$_,_dY_),
       _fb_=N[1],
       test=caml_call2(caml_call1(General[67][7],_bH_),_fb_,_fa_);
      return [0,DecoratedC,_dz_,make_n,make,make_n$0,make$0,catch$0,test]}
    var Tests_Decoration=[0,Bisect_visit_tst_Tests_Decoration_ml,Make$0];
    caml_register_global(1357,Tests_Decoration,"Tests__Decoration");
    var
     match$1=
      caml_call3
       (Bisect_Runtime[1],cst_tst_Tests_Drawing_ml,161,point_definitions$1),
     bisect_visit$1=match$1[2],
     Bisect_visit_tst_Tests_Drawing_ml=[0,bisect_visit$1];
    function Make$1(C)
     {function make_simple(name,width,height,draw)
       {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],0);
        return [0,name,width,height,draw]}
      function make_list(name,width,height,values,draw)
       {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],9);
        function _do_(ctx)
         {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],8);
          caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],7);
          var _dq_=General[40][40];
          function _dr_(value)
           {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],6);
            caml_call1(C[11],ctx);
            caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],5);
            var
             _du_=caml_call1(General[24][17],height),
             _dv_=caml_call1(General[24][17],width);
            caml_call5(C[44],ctx,0,0,_dv_,_du_);
            caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],4);
            caml_call1(C[31],ctx);
            caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],3);
            caml_call2(draw,value,ctx);
            caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],2);
            caml_call1(C[12],ctx);
            caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],1);
            var _dw_=caml_call1(General[24][17],height);
            return caml_call3(C[48],ctx,0,_dw_)}
          function _ds_(_dt_){return caml_call2(_dq_,_dt_,_dr_)}
          return caml_call2(General[69][270],values,_ds_)}
        var _dp_=caml_call1(General[40][8],values);
        return make_simple
                (name,width,caml_call2(General[69][259],height,_dp_),_do_)}
      caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],160);
      var
       _cV_=0,
       _cW_=
        [0,
         make_simple
          (cst_paint_with_alpha_4,
           100,
           100,
           function(ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],159);
             caml_call6(C[39],ctx,50,50,40,0,6.28);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],158);
             caml_call1(C[33],ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],157);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],155);
             var p=caml_call4(C[10][8],0,0,100,100);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],156);
             caml_call6(C[10][2],p,_bM_,0,1,0,0.5);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],154);
             caml_call6(C[10][2],p,_bN_,0,0,1,0.5);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],153);
             caml_call2(C[15],ctx,p);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],152);
             return caml_call2(C[35],_bO_,ctx)}),
         _cV_],
       _cX_=
        [0,
         make_simple
          (cst_paint_with_alpha_3,
           100,
           100,
           function(ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],151);
             caml_call6(C[39],ctx,50,50,40,0,6.28);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],150);
             caml_call1(C[33],ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],149);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],147);
             var p=caml_call4(C[10][8],0,0,100,100);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],148);
             caml_call5(C[10][1],p,_bP_,0,1,0);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],146);
             caml_call5(C[10][1],p,_bQ_,0,0,1);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],145);
             caml_call2(C[15],ctx,p);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],144);
             return caml_call2(C[35],_bR_,ctx)}),
         _cW_],
       _cY_=
        [0,
         make_simple
          (cst_paint_with_alpha_2,
           100,
           100,
           function(ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],143);
             caml_call6(C[39],ctx,50,50,40,0,6.28);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],142);
             caml_call1(C[33],ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],141);
             caml_call5(C[14],ctx,0,1,1,0.5);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],140);
             return caml_call2(C[35],_bS_,ctx)}),
         _cX_],
       _cZ_=
        [0,
         make_simple
          (cst_paint_with_alpha_1,
           100,
           100,
           function(ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],139);
             caml_call6(C[39],ctx,50,50,40,0,6.28);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],138);
             caml_call1(C[33],ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],137);
             caml_call4(C[13],ctx,0,1,1);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],136);
             return caml_call2(C[35],_bT_,ctx)}),
         _cY_],
       _c0_=
        [0,
         make_simple
          (cst_set_source_radial_gradient,
           200,
           200,
           function(ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],135);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],133);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],134);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],131);
             var p=caml_call6(C[10][10],50,40,30,110,140,50);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],132);
             caml_call5(C[10][1],p,_bU_,1,0,0);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],130);
             caml_call5(C[10][1],p,_bV_,0,0,1);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],129);
             caml_call2(C[15],ctx,p);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],128);
             caml_call2(C[35],0,ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],127);
             caml_call4(C[13],ctx,0,0,0);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],126);
             caml_call6(C[39],ctx,50,40,30,0,6.28);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],125);
             caml_call1(C[36],ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],124);
             caml_call6(C[39],ctx,110,140,50,0,6.28);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],123);
             return caml_call1(C[36],ctx)}),
         _cZ_],
       _c1_=
        [0,
         make_simple
          (cst_set_source_linear_gradient,
           100,
           40,
           function(ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],122);
             caml_call4(C[13],ctx,1,0,0);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],121);
             caml_call2(C[35],0,ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],120);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],118);
             var p=caml_call4(C[10][8],10,20,90,30);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],119);
             caml_call5(C[10][1],p,_bW_,1,0,0);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],117);
             caml_call6(C[10][2],p,_bX_,0,0,1,0.2);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],116);
             caml_call5(C[10][1],p,_bY_,0,1,0);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],115);
             caml_call2(C[15],ctx,p);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],114);
             caml_call5(C[44],ctx,5,5,90,30);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],113);
             return caml_call1(C[33],ctx)}),
         _c0_],
       _c2_=
        [0,
         make_list
          (cst_set_source_rgba$0,
           50,
           50,
           _bZ_,
           function(param,ctx)
            {var a=param[4],b=param[3],g=param[2],r=param[1];
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],112);
             caml_call4(C[13],ctx,0.6,0.6,0.9);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],111);
             caml_call2(C[35],0,ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],110);
             caml_call5(C[14],ctx,r,g,b,a);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],109);
             caml_call5(C[44],ctx,5,5,40,40);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],108);
             return caml_call1(C[33],ctx)}),
         _c1_],
       _c3_=
        [0,
         make_list
          (cst_set_source_rgb$0,
           50,
           50,
           _b0_,
           function(param,ctx)
            {var b=param[3],g=param[2],r=param[1];
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],107);
             caml_call4(C[13],ctx,r,g,b);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],106);
             caml_call5(C[44],ctx,5,5,40,40);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],105);
             return caml_call1(C[33],ctx)}),
         _c2_],
       _c4_=
        [0,
         make_simple
          (cst_clip_paint,
           50,
           50,
           function(ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],104);
             caml_call6(C[39],ctx,25,25,20,1,-1);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],103);
             caml_call1(C[31],ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],102);
             return caml_call2(C[35],0,ctx)}),
         _c3_];
      function _c5_(param,ctx)
       {var f2=param[2],f1=param[1];
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],101);
        caml_call3(C[43],ctx,10,10);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],100);
        caml_call3(C[42],ctx,50,20);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],99);
        caml_call6(C[39],ctx,50,10,40,0,1);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],98);
        caml_call3(C[46],ctx,10,30);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],97);
        caml_call6(C[40],ctx,30,90,40,0,-1);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],96);
        caml_call3(C[42],ctx,50,90);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],95);
        caml_call7(C[41],ctx,30,90,10,80,20,30);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],94);
        caml_call1(C[38][3],ctx);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],93);
        caml_call5(C[44],ctx,40,50,30,20);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],92);
        caml_call3(C[47],ctx,10,-10);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],91);
        caml_call7(C[45],ctx,-10,0,20,0,20,-20);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],90);
        caml_call2(C[21],ctx,4);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],89);
        caml_call4(C[13],ctx,0.2,1,0.2);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],88);
        caml_call1(f1,ctx);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],87);
        caml_call4(C[13],ctx,0.2,0.2,1);
        caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],86);
        return caml_call1(f2,ctx)}
      var
       _c6_=
        [0,
         make_list
          (cst_drawing_functions,
           100,
           100,
           [0,
            [0,C[34],C[36]],
            [0,[0,C[37],C[33]],[0,[0,C[32],C[33]],[0,[0,C[32],C[36]],0]]]],
           _c5_),
         _c4_],
       _c7_=
        [0,
         make_simple
          (cst_scale_identity_matrix,
           100,
           100,
           function(ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],85);
             caml_call3(C[43],ctx,10,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],84);
             caml_call3(C[42],ctx,50,30);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],83);
             caml_call3(C[49],ctx,3,0.5);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],82);
             caml_call3(C[42],ctx,30,180);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],81);
             caml_call1(C[54],ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],80);
             return caml_call1(C[36],ctx)}),
         _c6_],
       _c8_=
        [0,
         make_simple
          (cst_scale_rotate_translate_save_restore,
           400,
           200,
           function(ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],79);
             var aux=function _dn_(_dm_){return _dn_.fun(_dm_)};
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],77);
             runtime.caml_update_dummy
              (aux,
               function(n)
                {if(0 === n)
                  {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],75);
                   caml_call3(C[42],ctx,1,0);
                   caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],64);
                   return caml_call3(C[48],ctx,1,0)}
                 caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],76);
                 caml_call1(C[11],ctx);
                 caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],74);
                 var
                  _de_=caml_call2(General[69][267],1,3),
                  _df_=caml_call2(General[69][267],1,3);
                 caml_call3(C[49],ctx,_df_,_de_);
                 caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],73);
                 caml_call1(aux,caml_call2(General[69][258],n,1));
                 caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],72);
                 var
                  _dg_=caml_call1(General[69][262],General[24][40]),
                  _dh_=caml_call2(General[69][267],_dg_,3);
                 caml_call2(C[50],ctx,_dh_);
                 caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],71);
                 caml_call1(aux,caml_call2(General[69][258],n,1));
                 caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],70);
                 var
                  _di_=caml_call2(General[69][266],2,General[24][40]),
                  _dj_=caml_call2(General[69][267],_di_,3);
                 caml_call2(C[50],ctx,_dj_);
                 caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],69);
                 caml_call1(aux,caml_call2(General[69][258],n,1));
                 caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],68);
                 var
                  _dk_=caml_call1(General[69][262],General[24][40]),
                  _dl_=caml_call2(General[69][267],_dk_,3);
                 caml_call2(C[50],ctx,_dl_);
                 caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],67);
                 caml_call1(aux,caml_call2(General[69][258],n,1));
                 caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],66);
                 caml_call1(C[12],ctx);
                 caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],65);
                 return caml_call3(C[48],ctx,1,0)});
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],78);
             caml_call3(C[48],ctx,0,150);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],63);
             caml_call3(C[49],ctx,400,400);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],62);
             caml_call3(C[43],ctx,0,0);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],61);
             caml_call1(aux,3);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],60);
             caml_call1(C[54],ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],59);
             return caml_call1(C[36],ctx)}),
         _c7_],
       _c9_=
        [0,
         make_list
          (cst_set_dash$0,
           100,
           20,
           [0,
            [0,0,[254,5,7,9,11]],
            [0,[0,0,[254,10,2]],[0,[0,3,[254,10,2]],0]]],
           function(param,ctx)
            {var dashes=param[2],ofs=param[1];
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],58);
             caml_call3(C[25],ctx,[0,ofs],dashes);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],57);
             caml_call2(C[21],ctx,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],56);
             caml_call3(C[43],ctx,10,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],55);
             caml_call3(C[42],ctx,90,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],54);
             return caml_call1(C[36],ctx)}),
         _c8_],
       _c__=
        [0,
         make_list
          (cst_set_operator,
           90,
           90,
           _b1_,
           function(operator,ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],53);
             caml_call5(C[14],ctx,0,0,0.8,0.8);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],52);
             caml_call5(C[44],ctx,10,10,50,50);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],51);
             caml_call1(C[33],ctx);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],50);
             caml_call2(C[27],ctx,operator);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],49);
             caml_call5(C[14],ctx,0.8,0,0,0.8);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],48);
             var _dd_=caml_call2(General[69][266],General[24][40],2);
             caml_call6(C[39],ctx,50,50,30,0,_dd_);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],47);
             return caml_call1(C[33],ctx)}),
         _c9_],
       _c$_=
        [0,
         make_list
          (cst_set_line_join,
           50,
           50,
           _b2_,
           function(line_join,ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],46);
             caml_call2(C[19],ctx,line_join);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],45);
             caml_call2(C[21],ctx,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],44);
             caml_call3(C[43],ctx,10,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],43);
             caml_call3(C[42],ctx,40,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],42);
             caml_call3(C[42],ctx,40,40);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],41);
             return caml_call1(C[36],ctx)}),
         _c__],
       _da_=
        [0,
         make_list
          (cst_set_line_cap,
           50,
           20,
           _b3_,
           function(line_cap,ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],40);
             caml_call2(C[17],ctx,line_cap);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],39);
             caml_call2(C[21],ctx,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],38);
             caml_call3(C[43],ctx,10,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],37);
             caml_call3(C[42],ctx,40,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],36);
             return caml_call1(C[36],ctx)}),
         _c$_],
       _db_=
        [0,
         make_list
          (cst_set_fill_rule$0,
           60,
           60,
           _b4_,
           function(fill_rule,ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],35);
             caml_call2(C[29],ctx,fill_rule);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],34);
             caml_call3(C[43],ctx,10,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],33);
             caml_call3(C[42],ctx,40,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],32);
             caml_call3(C[42],ctx,40,50);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],31);
             caml_call3(C[42],ctx,30,50);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],30);
             caml_call3(C[42],ctx,30,20);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],29);
             caml_call3(C[42],ctx,20,20);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],28);
             caml_call3(C[42],ctx,20,30);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],27);
             caml_call3(C[42],ctx,50,30);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],26);
             caml_call3(C[42],ctx,50,40);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],25);
             caml_call3(C[42],ctx,10,40);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],24);
             return caml_call1(C[33],ctx)}),
         _da_],
       _dc_=
        [0,
         make_list
          (cst_set_miter_limit$0,
           120,
           50,
           _b5_,
           function(miter_limit,ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],23);
             caml_call2(C[23],ctx,miter_limit);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],22);
             caml_call2(C[19],ctx,0);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],21);
             caml_call2(C[21],ctx,5);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],20);
             caml_call3(C[43],ctx,10,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],19);
             caml_call3(C[42],ctx,50,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],18);
             caml_call3(C[42],ctx,10,20);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],17);
             caml_call3(C[43],ctx,10,30);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],16);
             caml_call3(C[42],ctx,50,30);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],15);
             caml_call3(C[42],ctx,10,39);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],14);
             return caml_call1(C[36],ctx)}),
         _db_],
       tests=
        [0,
         make_list
          (cst_set_line_width$0,
           50,
           20,
           _b6_,
           function(line_width,ctx)
            {caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],13);
             caml_call2(C[21],ctx,line_width);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],12);
             caml_call3(C[43],ctx,10,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],11);
             caml_call3(C[42],ctx,40,10);
             caml_call1(Bisect_visit_tst_Tests_Drawing_ml[1],10);
             return caml_call1(C[36],ctx)}),
         _dc_];
      return [0,make_simple,make_list,tests]}
    var Tests_Drawing=[0,Bisect_visit_tst_Tests_Drawing_ml,Make$1];
    caml_register_global(1358,Tests_Drawing,"Tests__Drawing");
    var
     match$2=
      caml_call3
       (Bisect_Runtime[1],cst_tst_Tests_Limitations_ml,33,point_definitions$2),
     bisect_visit$2=match$2[2],
     Bisect_visit_tst_Tests_Limitations_ml=[0,bisect_visit$2];
    function Make$2(_cv_)
     {var DecoratedC=caml_call1(CairoMock[2],_cv_);
      function make(name,width,height,draws)
       {caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],8);
        caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],6);
        caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],5);
        var _cR_=General[40][19];
        function _cS_(draw)
         {caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],4);
          return function(ctx)
           {caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],3);
            caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],1);
            var ctx$0=caml_call1(DecoratedC[59],ctx);
            caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],2);
            caml_call1(draw,ctx$0);
            caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],0);
            return caml_call1(DecoratedC[60],ctx$0)}}
        function _cT_(_cU_){return caml_call2(_cR_,_cU_,_cS_)}
        var draws$0=caml_call2(General[69][270],draws,_cT_);
        caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],7);
        return [0,name,width,height,draws$0]}
      caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],32);
      var
       _cw_=0,
       _cx_=0,
       _cy_=
        [0,
         function(ctx)
          {caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],31);
           caml_call2(DecoratedC[21],ctx,20);
           caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],30);
           caml_call3(DecoratedC[43],ctx,30,30);
           caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],29);
           caml_call3(DecoratedC[42],ctx,70,30);
           caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],28);
           return caml_call1(DecoratedC[36],ctx)},
         _cx_],
       _cz_=
        [0,
         make
          (cst_reuse_canvas_line_cap,
           100,
           60,
           [0,
            function(ctx)
             {caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],27);
              return caml_call2(DecoratedC[17],ctx,1)},
            _cy_]),
         _cw_],
       _cA_=0,
       _cB_=
        [0,
         function(ctx)
          {caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],26);
           caml_call3(DecoratedC[43],ctx,10,10);
           caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],25);
           caml_call3(DecoratedC[42],ctx,40,10);
           caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],24);
           return caml_call1(DecoratedC[36],ctx)},
         _cA_],
       _cC_=
        [0,
         make
          (cst_reuse_canvas_transformation,
           100,
           60,
           [0,
            function(ctx)
             {caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],23);
              return caml_call3(DecoratedC[49],ctx,2,3)},
            _cB_]),
         _cz_],
       _cD_=0,
       _cE_=
        [0,
         make
          (cst_show_text$1,
           100,
           240,
           [0,
            function(ctx)
             {caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],22);
              caml_call2(DecoratedC[6],ctx,20);
              caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],21);
              caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],20);
              var _cN_=General[40][40];
              function _cO_(param)
               {var family=param[3],weight=param[2],slant=param[1];
                caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],19);
                caml_call3(DecoratedC[43],ctx,10,20);
                caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],18);
                caml_call4(DecoratedC[5],ctx,[0,slant],[0,weight],family);
                caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],17);
                caml_call2(DecoratedC[7],ctx,cst_He);
                caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],16);
                caml_call2(DecoratedC[7],ctx,cst_llo);
                caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],15);
                return caml_call3(DecoratedC[48],ctx,0,30)}
              function _cP_(_cQ_){return caml_call2(_cN_,_cQ_,_cO_)}
              return caml_call2(General[69][270],_b7_,_cP_)},
            _cD_]),
         _cC_],
       _cF_=0,
       _cG_=
        [0,
         make
          (cst_text_extents$0,
           100,
           10,
           [0,
            function(ctx)
             {caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],14);
              var _cM_=caml_call2(DecoratedC[9],ctx,cst_Hello$0);
              return caml_call1(General[69][281],_cM_)},
            _cF_]),
         _cE_],
       _cH_=0,
       _cI_=
        [0,
         make
          (cst_font_extents$0,
           100,
           10,
           [0,
            function(ctx)
             {caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],13);
              var _cL_=caml_call1(DecoratedC[8],ctx);
              return caml_call1(General[69][281],_cL_)},
            _cH_]),
         _cG_],
       _cJ_=0,
       limitations=
        [0,
         make
          (cst_arc_more_than_2pi,
           100,
           100,
           [0,
            function(ctx)
             {caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],12);
              caml_call6(DecoratedC[39],ctx,50,50,40,0,7);
              caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],11);
              var _cK_=caml_call1(DecoratedC[38][1],ctx);
              caml_call1(General[69][281],_cK_);
              caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],10);
              caml_call3(DecoratedC[42],ctx,50,50);
              caml_call1(Bisect_visit_tst_Tests_Limitations_ml[1],9);
              return caml_call1(DecoratedC[36],ctx)},
            _cJ_]),
         _cI_];
      return [0,DecoratedC,make,limitations]}
    var Tests_Limitations=[0,Bisect_visit_tst_Tests_Limitations_ml,Make$2];
    caml_register_global(1359,Tests_Limitations,"Tests__Limitations");
    var
     match$3=
      caml_call3
       (Bisect_Runtime[1],cst_tst_Tests_Tests_ml,18,point_definitions$3),
     bisect_visit$3=match$3[2];
    caml_call1(bisect_visit$3,1);
    var
     T=
      Make$1
       ([0,
         CairoMock[3],
         CairoMock[4],
         CairoMock[5],
         CairoMock[6],
         CairoMock[7],
         CairoMock[8],
         CairoMock[9],
         CairoMock[10],
         CairoMock[11],
         CairoMock[12],
         CairoMock[13],
         CairoMock[14],
         CairoMock[15],
         CairoMock[16],
         CairoMock[17],
         CairoMock[18],
         CairoMock[19],
         CairoMock[20],
         CairoMock[21],
         CairoMock[22],
         CairoMock[23],
         CairoMock[24],
         CairoMock[25],
         CairoMock[26],
         CairoMock[27],
         CairoMock[28],
         CairoMock[29],
         CairoMock[30],
         CairoMock[31],
         CairoMock[32],
         CairoMock[33],
         CairoMock[34],
         CairoMock[35],
         CairoMock[36],
         CairoMock[37],
         CairoMock[38],
         CairoMock[39],
         CairoMock[40],
         CairoMock[41],
         CairoMock[42],
         CairoMock[43],
         CairoMock[44],
         CairoMock[45],
         CairoMock[46],
         CairoMock[47],
         CairoMock[48],
         CairoMock[49],
         CairoMock[50],
         CairoMock[51],
         CairoMock[52],
         CairoMock[53],
         CairoMock[54],
         CairoMock[55],
         CairoMock[56],
         CairoMock[57],
         CairoMock[58],
         CairoMock[59],
         CairoMock[60]]);
    function _b8_(param)
     {var name=param[1];caml_call1(bisect_visit$3,0);return name}
    var
     drawing_tests=caml_call2(General[40][19],T[3],_b8_),
     Tests$0=
      [0,
       drawing_tests,
       function(X)
        {var Limitations=Make$2(X[2]),Limitation=caml_call1(X[5],[0]);
         caml_call1(bisect_visit$3,2);
         caml_call2(General[40][40],Limitations[3],Limitation[1]);
         caml_call1(bisect_visit$3,17);
         var T=Make$1(X[2]),DT=caml_call1(X[4],[0]);
         caml_call1(bisect_visit$3,16);
         var _b$_=0,_ca_=General[40][19];
         function _cb_(test)
          {caml_call1(bisect_visit$3,15);
           var _ct_=[246,function(_cu_){return caml_call1(DT[1],test)}];
           return caml_call2(General[67][5],test[1],_ct_)}
         function _cc_(_cs_){return caml_call2(_ca_,_cs_,_cb_)}
         var
          _cd_=caml_call2(General[69][270],T[3],_cc_),
          _ce_=X[3][1],
          _cf_=[0,caml_call2(caml_call1(General[67][7],_b9_),_ce_,_cd_),_b$_],
          DecoratedC=caml_call1(CairoMock[2],X[2]);
         caml_call1(bisect_visit$3,12);
         var name$2=caml_call2(General[59][2],_b__,X[3][1]);
         function create(param)
          {caml_call1(bisect_visit$3,13);
           var _cr_=caml_call1(X[3][2],0);
           return caml_call1(DecoratedC[59],_cr_)}
         caml_call1(bisect_visit$3,14);
         var
          backend=X[3][3],
          _cg_=
           [0,
            Make
              ([0,
                DecoratedC[1],
                DecoratedC[2],
                DecoratedC[3],
                DecoratedC[4],
                DecoratedC[5],
                DecoratedC[6],
                DecoratedC[7],
                DecoratedC[8],
                DecoratedC[9],
                DecoratedC[10],
                DecoratedC[11],
                DecoratedC[12],
                DecoratedC[13],
                DecoratedC[14],
                DecoratedC[15],
                DecoratedC[16],
                DecoratedC[17],
                DecoratedC[18],
                DecoratedC[19],
                DecoratedC[20],
                DecoratedC[21],
                DecoratedC[22],
                DecoratedC[23],
                DecoratedC[24],
                DecoratedC[25],
                DecoratedC[26],
                DecoratedC[27],
                DecoratedC[28],
                DecoratedC[29],
                DecoratedC[30],
                DecoratedC[31],
                DecoratedC[32],
                DecoratedC[33],
                DecoratedC[34],
                DecoratedC[35],
                DecoratedC[36],
                DecoratedC[37],
                DecoratedC[38],
                DecoratedC[39],
                DecoratedC[40],
                DecoratedC[41],
                DecoratedC[42],
                DecoratedC[43],
                DecoratedC[44],
                DecoratedC[45],
                DecoratedC[46],
                DecoratedC[47],
                DecoratedC[48],
                DecoratedC[49],
                DecoratedC[50],
                DecoratedC[51],
                DecoratedC[52],
                DecoratedC[53],
                DecoratedC[54],
                DecoratedC[55],
                DecoratedC[56],
                DecoratedC[57],
                DecoratedC[58]],
               [0,name$2,create,backend])
             [7],
            _cf_],
          _ch_=[0,Make(X[2],X[3])[7],_cg_];
         caml_call1(bisect_visit$3,9);
         caml_call1(bisect_visit$3,10);
         var _ci_=CairoMock[61];
         caml_call1(bisect_visit$3,11);
         var
          _cj_=
           [0,
            Make
              ([0,
                CairoMock[3],
                CairoMock[4],
                CairoMock[5],
                CairoMock[6],
                CairoMock[7],
                CairoMock[8],
                CairoMock[9],
                CairoMock[10],
                CairoMock[11],
                CairoMock[12],
                CairoMock[13],
                CairoMock[14],
                CairoMock[15],
                CairoMock[16],
                CairoMock[17],
                CairoMock[18],
                CairoMock[19],
                CairoMock[20],
                CairoMock[21],
                CairoMock[22],
                CairoMock[23],
                CairoMock[24],
                CairoMock[25],
                CairoMock[26],
                CairoMock[27],
                CairoMock[28],
                CairoMock[29],
                CairoMock[30],
                CairoMock[31],
                CairoMock[32],
                CairoMock[33],
                CairoMock[34],
                CairoMock[35],
                CairoMock[36],
                CairoMock[37],
                CairoMock[38],
                CairoMock[39],
                CairoMock[40],
                CairoMock[41],
                CairoMock[42],
                CairoMock[43],
                CairoMock[44],
                CairoMock[45],
                CairoMock[46],
                CairoMock[47],
                CairoMock[48],
                CairoMock[49],
                CairoMock[50],
                CairoMock[51],
                CairoMock[52],
                CairoMock[53],
                CairoMock[54],
                CairoMock[55],
                CairoMock[56],
                CairoMock[57],
                CairoMock[58],
                CairoMock[59],
                CairoMock[60]],
               [0,name,_ci_,553448210])
             [7],
            _ch_];
         caml_call1(bisect_visit$3,6);
         caml_call1(bisect_visit$3,7);
         var _ck_=CairoMock[1][59];
         caml_call1(bisect_visit$3,8);
         var
          _cl_=CairoMock[1],
          _cm_=
           [0,
            Make
              ([0,
                _cl_[1],
                _cl_[2],
                _cl_[3],
                _cl_[4],
                _cl_[5],
                _cl_[6],
                _cl_[7],
                _cl_[8],
                _cl_[9],
                _cl_[10],
                _cl_[11],
                _cl_[12],
                _cl_[13],
                _cl_[14],
                _cl_[15],
                _cl_[16],
                _cl_[17],
                _cl_[18],
                _cl_[19],
                _cl_[20],
                _cl_[21],
                _cl_[22],
                _cl_[23],
                _cl_[24],
                _cl_[25],
                _cl_[26],
                _cl_[27],
                _cl_[28],
                _cl_[29],
                _cl_[30],
                _cl_[31],
                _cl_[32],
                _cl_[33],
                _cl_[34],
                _cl_[35],
                _cl_[36],
                _cl_[37],
                _cl_[38],
                _cl_[39],
                _cl_[40],
                _cl_[41],
                _cl_[42],
                _cl_[43],
                _cl_[44],
                _cl_[45],
                _cl_[46],
                _cl_[47],
                _cl_[48],
                _cl_[49],
                _cl_[50],
                _cl_[51],
                _cl_[52],
                _cl_[53],
                _cl_[54],
                _cl_[55],
                _cl_[56],
                _cl_[57],
                _cl_[58]],
               [0,name$0,_ck_,553448210])
             [7],
            _cj_],
          _cn_=[0,Make$0(X[2],X[3])[8],_cm_];
         caml_call1(bisect_visit$3,3);
         caml_call1(bisect_visit$3,4);
         var _co_=CairoMock[1][59];
         caml_call1(bisect_visit$3,5);
         var
          _cp_=CairoMock[1],
          _cq_=
           [0,
            Make$0
              ([0,
                _cp_[1],
                _cp_[2],
                _cp_[3],
                _cp_[4],
                _cp_[5],
                _cp_[6],
                _cp_[7],
                _cp_[8],
                _cp_[9],
                _cp_[10],
                _cp_[11],
                _cp_[12],
                _cp_[13],
                _cp_[14],
                _cp_[15],
                _cp_[16],
                _cp_[17],
                _cp_[18],
                _cp_[19],
                _cp_[20],
                _cp_[21],
                _cp_[22],
                _cp_[23],
                _cp_[24],
                _cp_[25],
                _cp_[26],
                _cp_[27],
                _cp_[28],
                _cp_[29],
                _cp_[30],
                _cp_[31],
                _cp_[32],
                _cp_[33],
                _cp_[34],
                _cp_[35],
                _cp_[36],
                _cp_[37],
                _cp_[38],
                _cp_[39],
                _cp_[40],
                _cp_[41],
                _cp_[42],
                _cp_[43],
                _cp_[44],
                _cp_[45],
                _cp_[46],
                _cp_[47],
                _cp_[48],
                _cp_[49],
                _cp_[50],
                _cp_[51],
                _cp_[52],
                _cp_[53],
                _cp_[54],
                _cp_[55],
                _cp_[56],
                _cp_[57],
                _cp_[58]],
               [0,name$1,_co_,553448210])
             [8],
            _cn_],
          test=caml_call2(General[67][4],X[1],_cq_);
         return [0,test]}];
    caml_register_global(1360,Tests$0,"Tests");
    return}
  (function(){return this}()));


//# 1 ".tests_in_browser.eobjs/tests_in_browser.cmo.js"
(function(R){"use strict";var
y="success",x=272,l=274,p=275,w=273,v=284,h=270,u="failure",m=107,i=R.jsoo_runtime,e=i.caml_new_string;function
d(a,b){return a.length==1?a(b):i.caml_call_gen(a,[b])}function
c(a,b,c){return a.length==2?a(b,c):i.caml_call_gen(a,[b,c])}function
k(a,b,c,d){return a.length==3?a(b,c,d):i.caml_call_gen(a,[b,c,d])}function
W(a,b,c,d,e,f){return a.length==5?a(b,c,d,e,f):i.caml_call_gen(a,[b,c,d,e,f])}function
Q(a,b,c,d,e,f,g){return a.length==6?a(b,c,d,e,f,g):i.caml_call_gen(a,[b,c,d,e,f,g])}var
j=i.caml_get_global_data(),a=j.General,b=j.JsOfOCairo,f=j.Dom_html,g=j.Dom,q=j.Tests,n=j.Js,r=n[50][1].pixelmatch,K=[0,[11,e("<p>Context n\xc2\xb0"),[4,3,0,0,[11,e(":</p>"),0]]],e("<p>Context n\xc2\xb0%i:</p>")],G=[0,[11,e('<div class="cairo_pre" data-src="'),[2,0,[12,46,[4,3,0,0,[11,e('.txt"></div>'),0]]]]],e('<div class="cairo_pre" data-src="%s.%i.txt"></div>')],H=[0,[11,e("<pre>"),[2,0,[11,e("</pre>"),0]]],e("<pre>%s</pre>")],J=[0,[2,0,[12,10,0]],e("%s\n")],L=[0,[11,e("<h3>Cairo:</h3>"),[2,0,[11,e('<img src="'),[2,0,[11,e('.png"></img>'),0]]]]],e('<h3>Cairo:</h3>%s<img src="%s.png"></img>')],T=[0,[11,e("<h3>JsOfOCairo:</h3>"),[2,0,0]],e("<h3>JsOfOCairo:</h3>%s")],V=[0,[11,e("limitations_"),[2,0,0]],e("limitations_%s")],D=e("Tests in browser"),F=e("JsOfOCairo"),N=e("tests_in_browser"),P=e('\n    jQuery("#tests_in_browser ul ul ul").hide();\n    jQuery("#tests_in_browser p").click(function() {\n      jQuery(this).parent().children("ul").slideToggle();\n    });\n    jQuery("div.cairo_pre").each(function() {\n      var div = jQuery(this);\n      div.load(div.data("src"));\n    })\n  '),S=e("Drawing tests on JsOfOCairo"),B=e(y),I=e(u),E=[0,[2,0,[11,e(": "),[2,0,0]]],e("%s: %s")],M=e(y),U=e(u),O=[0,[2,0,[11,e(": (successes: "),[4,3,0,0,[11,e(", failures: "),[4,3,0,0,[11,e(", errors: "),[4,3,0,0,[12,41,0]]]]]]]],e("%s: (successes: %i, failures: %i, errors: %i)")],A=[0,[11,e(""),[2,0,[11,e(".png"),0]]],e("%s.png")],z=d(a[40][8],q[1]),s=[0,function(i){var
b=d(a[69][x],a[57][1]),e=a[40][40];function
j(h){var
e=d(f[64],f[2]);e.src=c(a[59][2],A,h).toString();function
j(o){var
f=d(a[69][l],b),g=k(a[57][8],f,h,e);c(a[69][w],b,g);var
j=d(a[69][l],b),m=d(a[57][6],j);if(c(a[69][p],m,z))d(i,d(a[69][l],b));return n[7]}return e.onload=d(g[10],j)}function
m(a){return c(e,a,j)}return c(a[69][h],q[1],m)}],o=d(a[69][x],a[57][1]);function
t(e){function
q(A,i){if(0===i[0]){var
r=i[1],s=r[2],t=r[1],b=d(f[46],f[2]),u=d(f[49],f[2]),C=c(a[69][p],s,0)?B:I;b.className=C.toString();var
D=d(a[67][1][1][1],s),F=k(a[59][2],E,t,D).toString();u.textContent=d(n[2],F);c(g[5],b,u);if(A){var
G=d(a[69][l],o),H=c(a[57][11],G,t);c(g[5],b,H)}return b}var
j=i[1],m=j[3],v=m[3],w=m[2],x=j[1],J=m[1],K=j[2],e=d(f[46],f[2]),y=d(f[49],f[2]),L=c(a[69][257],w,v),N=c(a[69][p],L,0)?M:U;e.className=N.toString();var
P=W(a[59][2],O,x,J,w,v).toString();y.textContent=d(n[2],P);c(g[5],e,y);var
z=d(f[43],f[2]);c(g[5],e,z);var
Q=a[40][40];function
R(b){var
d=q(c(a[69][p],x,S),b);return c(g[5],z,d)}function
T(a){return c(Q,a,R)}c(a[69][h],K,T);return e}var
b=d(f[43],f[2]),i=q(0,e);c(g[5],b,i);return b}function
C(x){var
e=[0,F,function(c){var
a=d(f[m],f[2]);a.width=10;a.height=10;return d(b[59],a)},95560584];function
j(e){return[0,function(j){var
e=j[3],h=j[2],s=j[1],y=j[4],z=c(a[57][11],x,s),n=d(f[m],f[2]);n.width=h;n.height=e;var
t=n.getContext(f[1]);t.drawImage(z,0,0);var
A=d(a[24][17],e),B=t.getImageData(0,0,d(a[24][17],h),A),i=d(f[m],f[2]);i.width=h;i.height=e;d(y,d(b[59],i));var
C=d(a[24][17],e),D=d(a[24][17],h),E=i.getContext(f[1]).getImageData(0,0,D,C),p=d(f[m],f[2]);p.width=h;p.height=e;var
u=p.getContext(f[1]),v=u.createImageData(h,e),F=Q(r,B.data,E.data,v.data,h,e,{"threshold":0.09,"includeAA":0});u.putImageData(v,0,0);var
q=d(f[49],f[2]);c(g[5],q,n);c(g[5],q,i);c(g[5],q,p);var
G=d(a[69][l],o),H=k(a[57][8],G,s,q);c(a[69][w],o,H);return c(a[67][17],0,F)}]}function
n(e){function
p(b){var
a=d(f[47],f[2]);a.setAttribute("class","col");a.innerHTML=b.toString();return a}return[0,function(e){var
i=e[4],l=e[1],t=e[3],u=e[2],j=d(f[m],f[2]);j.width=u;j.height=t;function
q(f,e){var
g=k(a[59][2],G,l,f),i=d(a[59][2],H),m=a[50][82];function
n(a){return c(m,0,a)}var
o=a[40][19],p=d(a[59][2],J);function
q(a){return c(o,a,p)}var
r=d(e,d(b[59],j)),s=c(a[69][h],r,q),t=c(a[69][h],s,n);return[0,g,c(a[69][h],t,i)]}if(i)if(i[2])var
o=0;else
var
n=[0,q(0,i[1]),0],o=1;else
var
o=0;if(!o)var
w=a[40][20],x=function(b,f){var
d=q(b,f),g=d[2],h=d[1],e=c(a[59][2],K,b),i=c(a[69][v],e,g);return[0,c(a[69][v],e,h),i]},y=function(a){return c(w,a,x)},n=c(a[69][h],i,y);var
z=a[50][82];function
A(a){return c(z,0,a)}var
B=a[40][19],C=a[30][15];function
D(a){return c(B,a,C)}var
E=c(a[69][h],n,D),F=c(a[69][h],E,A),I=p(k(a[59][2],L,F,l)),M=a[50][82];function
N(a){return c(M,0,a)}var
O=a[40][19],P=a[30][16];function
Q(a){return c(O,a,P)}var
R=c(a[69][h],n,Q),S=c(a[69][h],R,N),r=p(c(a[59][2],T,S));c(g[5],r,j);var
U=c(a[59][2],V,l),s=d(f[6],U);c(g[5],s,I);return c(g[5],s,r)}]}var
p=d(q[2],[0,D,[0,b[1],b[2],b[3],b[4],b[5],b[6],b[7],b[8],b[9],b[10],b[11],b[12],b[13],b[14],b[15],b[16],b[17],b[18],b[19],b[20],b[21],b[22],b[23],b[24],b[25],b[26],b[27],b[28],b[29],b[30],b[31],b[32],b[33],b[34],b[35],b[36],b[37],b[38],b[39],b[40],b[41],b[42],b[43],b[44],b[45],b[46],b[47],b[48],b[49],b[50],b[51],b[52],b[53],b[54],b[55],b[56],b[57],b[58]],e,j,n]),s=d(f[6],N),u=d(g[5],s),y=a[67][2][1];function
z(a){return c(y,0,a)}var
A=c(a[69][h],p[1],z),B=c(a[69][h],A,t);c(a[69][h],B,u);var
C=i.caml_js_eval_string(P);return d(a[69][281],C)}d(s[1],C);i.caml_register_global(72,[0,r,s,o,t],"Tests_in_browser");return}(function(){return this}()));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0ZXN0c19pbl9icm93c2VyLmJjLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVycl9ub19wcmVkIiwiZXJyX25vX3N1Y2MiLCJ6ZXJvJDAiLCJvbmUkMCIsIm1pbnVzX29uZSQwIiwibWluX2ludCQxIiwibWF4X2ludCQxIiwiZHVtbXlfcG9zIiwiemVyb19wb3MiLCJzdWJfZm9ybWF0IiwiZm9ybWF0dGluZ19saXQiLCJsb2NmbXQiLCJjdXJyZW50X2Rpcl9uYW1lIiwicGFyZW50X2Rpcl9uYW1lIiwiZGlyX3NlcCIsInF1b3RlcXVvdGUiLCJjdXJyZW50X2Rpcl9uYW1lJDAiLCJwYXJlbnRfZGlyX25hbWUkMCIsImRpcl9zZXAkMCIsImN1cnJlbnRfZGlyX25hbWUkMSIsInBhcmVudF9kaXJfbmFtZSQxIiwiZGlyX3NlcCQxIiwiemVybyQyIiwib25lJDIiLCJpIiwiZXJhc2VfcmVsIiwicmVzdCIsInJlc3QkMCIsInJlc3QkMSIsInJlc3QkMiIsInJlc3QkMyIsInJlc3QkNCIsInJlc3QkNSIsInJlc3QkNiIsInJlc3QkNyIsInR5IiwicmVzdCQ4IiwidHkxIiwicmVzdCQ5IiwicmVzdCQxMCIsInJlc3QkMTEiLCJyZXN0JDEyIiwicmVzdCQxMyIsImNvbmNhdF9mbXR0eSIsImZtdHR5MSIsImZtdHR5MiIsInR5MiIsImNvbmNhdF9mbXQiLCJmbXQxIiwiZm10MiIsInBhZCIsInBhZCQwIiwicHJlYyIsInBhZCQxIiwiaWNvbnYiLCJwcmVjJDAiLCJwYWQkMiIsImljb252JDAiLCJwcmVjJDEiLCJwYWQkMyIsImljb252JDEiLCJwcmVjJDIiLCJwYWQkNCIsImljb252JDIiLCJwcmVjJDMiLCJwYWQkNSIsImZjb252IiwicGFkJDYiLCJzdHIiLCJjaHIiLCJmbXR0eSIsInBhZCQ3IiwiZm10dHkkMCIsInBhZCQ4IiwicmVzdCQxNCIsInJlc3QkMTUiLCJyZXN0JDE2IiwiZm10aW5nX2xpdCIsInJlc3QkMTciLCJmbXRpbmdfZ2VuIiwicmVzdCQxOCIsInJlc3QkMTkiLCJjaGFyX3NldCIsIndpZHRoX29wdCIsInJlc3QkMjAiLCJjb3VudGVyIiwicmVzdCQyMSIsInJlc3QkMjIiLCJpZ24iLCJyZXN0JDIzIiwiZiIsImFyaXR5IiwiZmFpbHdpdGgiLCJzIiwiaW52YWxpZF9hcmciLCJtaW4iLCJ4IiwieSIsIm1heCIsImFicyIsImxub3QiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb25fZmxvYXQiLCJtYXhfaW50IiwibWluX2ludCIsIl9nXyIsInMxIiwiczIiLCJsMSIsImwyIiwiY2hhcl9vZl9pbnQiLCJuIiwic3RyaW5nX29mX2Jvb2wiLCJiIiwiYm9vbF9vZl9zdHJpbmciLCJib29sX29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJ2YWxpZF9mbG9hdF9sZXhlbSIsImwiLCJpJDAiLCJzdHJpbmdfb2ZfZmxvYXQiLCJmbG9hdF9vZl9zdHJpbmdfb3B0IiwiYXBwZW5kIiwidGwiLCJoZCIsInN0ZGluIiwic3Rkb3V0Iiwic3RkZXJyIiwib3Blbl9vdXRfZ2VuIiwibW9kZSIsInBlcm0iLCJuYW1lIiwiYyIsIm9wZW5fb3V0Iiwib3Blbl9vdXRfYmluIiwiZmx1c2hfYWxsIiwiaXRlciIsImEiLCJvdXRwdXRfYnl0ZXMiLCJvYyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXQiLCJvZnMiLCJsZW4iLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0X3ZhbHVlIiwiY2hhbiIsInYiLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJvcGVuX2luX2dlbiIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsImlucHV0IiwiaWMiLCJ1bnNhZmVfcmVhbGx5X2lucHV0Iiwib2ZzJDAiLCJsZW4kMCIsInIiLCJsZW4kMSIsIm9mcyQxIiwicmVhbGx5X2lucHV0IiwicmVhbGx5X2lucHV0X3N0cmluZyIsImlucHV0X2xpbmUiLCJidWlsZF9yZXN1bHQiLCJidWYiLCJhY2N1IiwiYmVnIiwiYWNjdSQwIiwicmVzIiwiY2xvc2VfaW5fbm9lcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50IiwicmVhZF9pbnRfb3B0IiwicmVhZF9mbG9hdCIsInJlYWRfZmxvYXRfb3B0Iiwic3RyaW5nX29mX2Zvcm1hdCIsIl9uXyIsInN0cjIiLCJzdHIxIiwiZXhpdF9mdW5jdGlvbiIsImF0X2V4aXQiLCJnIiwiZl9hbHJlYWR5X3JhbiIsImRvX2F0X2V4aXQiLCJleGl0IiwicmV0Y29kZSIsImVtcHR5IiwicmV0dXJuJDAiLCJtYXAiLCJzZXEiLCJuZXh0IiwiZmlsdGVyX21hcCIsInNlcSQwIiwiZmlsdGVyIiwiZmxhdF9tYXAkMCIsImZsYXRfbWFwX2FwcCQwIiwidGFpbCIsImZsYXRfbWFwX2FwcCIsImZsYXRfbWFwIiwiZm9sZF9sZWZ0IiwiYWNjIiwiYWNjJDAiLCJhY2MkMSIsImVzY2FwZWQiLCJzJDAiLCJsb3dlcmNhc2UiLCJ1cHBlcmNhc2UiLCJsb3dlcmNhc2VfYXNjaWkiLCJ1cHBlcmNhc2VfYXNjaWkiLCJjb21wYXJlIiwiYzEiLCJjMiIsImVxdWFsIiwibWluJDAiLCJtYXgkMCIsImxvX2JvdW5kIiwiaGlfYm91bmQiLCJib20iLCJyZXAiLCJzdWNjIiwidSIsInByZWQiLCJpc192YWxpZCIsIm9mX2ludCIsImlzX2NoYXIiLCJvZl9jaGFyIiwidG9fY2hhciIsInVuc2FmZV90b19jaGFyIiwiZXF1YWwkMCIsImNvbXBhcmUkMCIsImhhc2giLCJzaXplIiwibGVuZ3RoIiwicGFyYW0kMCIsImNvbnMiLCJudGgiLCJsJDAiLCJuJDAiLCJsJDEiLCJuJDEiLCJudGhfb3B0IiwicmV2X2FwcGVuZCIsImwxJDAiLCJsMiQwIiwibDEkMSIsImwyJDEiLCJyZXYiLCJpbml0X2F1eCIsInJldl9pbml0X3RocmVzaG9sZCIsInBhcmFtIiwiYWNjdSQxIiwiYTIiLCJhMSIsInAiLCJwYWlyIiwicnkiLCJyeCIsImNtcCIsIm1hdGNoIiwidDIiLCJoMiIsInQxIiwiaDEiLCJjaG9wIiwiayIsImskMCIsImskMSIsInNvcnQiLCJ4MiIsIngxIiwieDMiLCJ4MiQwIiwieDEkMCIsIm4xIiwibjIiLCJyZXZfc29ydCIsImMkMCIsImMkMSIsImMkMiIsImMkMyIsImMkNCIsImMkNSIsImMkNiIsImFjY3UkMiIsImF1eCIsImRpcmVjdCIsImRlcHRoIiwiX3ZfIiwibGVmdCIsInJpZ2h0Iiwic3Jjb2ZmIiwiZHN0b2ZmIiwiY3B5bGVuIiwib2ZzMSIsIm9mczIiLCJzZXAiLCJzZXBsZW4iLCJkc3QiLCJpc19zcGFjZSIsImoiLCJhcHBseTEiLCJpbmRleF9yZWMiLCJsaW0iLCJpJDEiLCJpbmRleF9yZWNfb3B0IiwicmluZGV4X3JlYyIsInJpbmRleF9yZWNfb3B0IiwibmV3X2xlbiIsIm5ld19idWYiLCJpc19zcGFjZSQwIiwiaW5kZXhfcmVjJDAiLCJpbmRleF9yZWNfb3B0JDAiLCJyaW5kZXhfcmVjJDAiLCJyaW5kZXhfcmVjX29wdCQwIiwibWVyZ2UkMCIsIm9yZGVyIiwibGlzdCIsImluaXRsaXN0IiwiZTIiLCJtZXJnZTIiLCJzd2FwIiwiYXJyIiwidG1wIiwiYXJyYXkiLCJxc29ydCIsImxvIiwiaGkiLCJsbyQwIiwiaGkkMCIsIm1pZCIsInBpdm90IiwibG8kMSIsImhpJDEiLCJ2YWxfaSIsInRvX2J1ZmZlciIsImJ1ZmYiLCJmbGFncyIsImhlYWRlcl9zaXplIiwiZGF0YV9zaXplIiwidG90YWxfc2l6ZSIsImZyb21fYnl0ZXMiLCJmcm9tX3N0cmluZyIsImlzX2Jsb2NrIiwiZG91YmxlX2ZpZWxkIiwic2V0X2RvdWJsZV9maWVsZCIsIm1hcnNoYWwiLCJvYmoiLCJ1bm1hcnNoYWwiLCJwb3MiLCJmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnIiwibGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnIiwibGF6eV90YWciLCJjbG9zdXJlX3RhZyIsIm9iamVjdF90YWciLCJpbmZpeF90YWciLCJmb3J3YXJkX3RhZyIsIm5vX3NjYW5fdGFnIiwiYWJzdHJhY3RfdGFnIiwic3RyaW5nX3RhZyIsImRvdWJsZV90YWciLCJkb3VibGVfYXJyYXlfdGFnIiwiY3VzdG9tX3RhZyIsImludF90YWciLCJvdXRfb2ZfaGVhcF90YWciLCJ1bmFsaWduZWRfdGFnIiwiZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwic2xvdCIsImV4dGVuc2lvbl9uYW1lIiwiZXh0ZW5zaW9uX2lkIiwibGVuZ3RoJDAiLCJpbmZpbml0eSQwIiwibmVnX2luZmluaXR5JDAiLCJuYW4kMCIsIm1heF9mbG9hdCQwIiwibWluX2Zsb2F0JDAiLCJlcHNpbG9uIiwib2Zfc3RyaW5nX29wdCIsInRvX3N0cmluZyQwIiwicGkiLCJlcXVhbCQzIiwiaGFzaCQwIiwic3giLCJzeSIsImluaXQiLCJsYSIsImxiIiwicmVzJDAiLCJsaXN0X2xlbmd0aCIsInBhcmFtJDEiLCJ0bCQwIiwiaGQkMCIsIm1heHNvbiIsImkzMSIsInRyaWNrbGVkb3duIiwiZSIsInRyaWNrbGUiLCJidWJibGVkb3duIiwiYnViYmxlIiwiaSQyIiwiZSQwIiwiZmF0aGVyIiwibWVyZ2UiLCJzcmMxb2ZzIiwic3JjMWxlbiIsInNyYzIiLCJzcmMyb2ZzIiwic3JjMmxlbiIsImRzdG9mcyIsInNyYzFyIiwic3JjMnIiLCJzMiQxIiwiczEkMSIsImkxIiwiaTIiLCJkIiwiaTIkMCIsImQkMCIsInMyJDAiLCJpMSQwIiwiZCQxIiwiczEkMCIsImlzb3J0dG8iLCJzcmNvZnMiLCJzb3J0dG8iLCJ0IiwiemVybyIsIm9uZSIsIm1pbnVzX29uZSIsInN1Y2MkMCIsInByZWQkMCIsImFicyQwIiwibWluX2ludCQwIiwibWF4X2ludCQwIiwibG9nbm90IiwidG9fc3RyaW5nJDEiLCJvZl9zdHJpbmdfb3B0JDAiLCJjb21wYXJlJDMiLCJlcXVhbCQ0Iiwic3VjYyQxIiwicHJlZCQxIiwiYWJzJDEiLCJsb2dub3QkMCIsInRvX3N0cmluZyQyIiwib2Zfc3RyaW5nX29wdCQxIiwiY29tcGFyZSQ0IiwiZXF1YWwkNSIsInplcm8kMSIsIm9uZSQxIiwibWludXNfb25lJDEiLCJzdWNjJDIiLCJwcmVkJDIiLCJhYnMkMiIsIm1pbl9pbnQkMiIsIm1heF9pbnQkMiIsImxvZ25vdCQxIiwidG9fc3RyaW5nJDMiLCJvZl9zdHJpbmdfb3B0JDIiLCJjb21wYXJlJDUiLCJlcXVhbCQ2IiwiZW5naW5lIiwidGJsIiwic3RhdGUiLCJyZXN1bHQiLCJuZXdfZW5naW5lIiwiZnJvbV9mdW5jdGlvbiIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwiZnJvbV9zdHJpbmckMCIsImxleGVtZSIsInN1Yl9sZXhlbWUiLCJzdWJfbGV4ZW1lX29wdCIsInN1Yl9sZXhlbWVfY2hhciIsInN1Yl9sZXhlbWVfY2hhcl9vcHQiLCJsZXhlbWVfY2hhciIsImxleGVtZV9zdGFydCIsImxleGVtZV9lbmQiLCJsZXhlbWVfc3RhcnRfcCIsImxleGVtZV9lbmRfcCIsIm5ld19saW5lIiwibGNwIiwiZmx1c2hfaW5wdXQiLCJlbnYiLCJncm93X3N0YWNrcyIsIm9sZHNpemUiLCJuZXdzaXplIiwibmV3X3MiLCJuZXdfdiIsIm5ld19zdGFydCIsIm5ld19lbmQiLCJjbGVhcl9wYXJzZXIiLCJjdXJyZW50X2xvb2thaGVhZF9mdW4iLCJ5eXBhcnNlIiwidGFibGVzIiwic3RhcnQiLCJsZXhlciIsImluaXRfYXNwIiwiaW5pdF9zcCIsImluaXRfc3RhY2tiYXNlIiwiaW5pdF9zdGF0ZSIsImluaXRfY3Vycl9jaGFyIiwiaW5pdF9sdmFsIiwiaW5pdF9lcnJmbGFnIiwiY21kIiwiYXJnIiwiYXJnJDAiLCJjbWQkMCIsImFyZyQxIiwiZXhuIiwiY3Vycl9jaGFyIiwidG9rIiwicGVla192YWwiLCJzeW1ib2xfc3RhcnRfcG9zIiwic3QiLCJlbiIsInN5bWJvbF9lbmRfcG9zIiwicmhzX3N0YXJ0X3BvcyIsInJoc19lbmRfcG9zIiwic3ltYm9sX3N0YXJ0Iiwic3ltYm9sX2VuZCIsInJoc19zdGFydCIsInJoc19lbmQiLCJpc19jdXJyZW50X2xvb2thaGVhZCIsInBhcnNlX2Vycm9yIiwiaGVpZ2h0IiwiaCIsImNyZWF0ZSIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJhZGQiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJqb2luIiwicmgiLCJsaCIsIm1pbl9lbHQiLCJtaW5fZWx0X29wdCIsIm1heF9lbHQiLCJtYXhfZWx0X29wdCIsInJlbW92ZV9taW5fZWx0IiwiciQwIiwiY29uY2F0Iiwic3BsaXQiLCJwcmVzIiwicHJlcyQwIiwiaXNfZW1wdHkiLCJtZW0iLCJyZW1vdmUiLCJ1bmlvbiIsInIyIiwidjIiLCJyMSIsInYxIiwicjIkMCIsInIxJDAiLCJpbnRlciIsImRpZmYiLCJjb25zX2VudW0iLCJzJDEiLCJlJDEiLCJlMiQyIiwiZTEkMiIsImUxIiwiZTIkMCIsImUxJDAiLCJlMiQxIiwiZTEkMSIsInN1YnNldCIsImZvbGQiLCJmb3JfYWxsIiwiZXhpc3RzIiwicHYiLCJwYXJ0aXRpb24iLCJsZiIsImx0IiwicmYiLCJydCIsImNhcmRpbmFsIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJmaW5kIiwiZmluZF9maXJzdCIsInYkMCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0Iiwib2ZfbGlzdCIsInN1YiIsImwkMyIsIngwIiwibCQ0IiwieDAkMCIsImwkNSIsIngwJDEiLCJubCIsImwkMiIsIng0IiwiYWRkX3NlcSIsIm0iLCJvZl9zZXEiLCJzZXFfb2ZfZW51bSIsInRvX3NlcSIsInRvX3NlcV9mcm9tIiwibG93IiwibGQiLCJscmQiLCJyZCIsInJsZCIsImRhdGEiLCJtaW5fYmluZGluZyIsIm1pbl9iaW5kaW5nX29wdCIsIm1heF9iaW5kaW5nIiwibWF4X2JpbmRpbmdfb3B0IiwicmVtb3ZlX21pbl9iaW5kaW5nIiwidXBkYXRlIiwiZGF0YSQwIiwibWFwaSIsIm0kMCIsImFkZF9taW5fYmluZGluZyIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJtJDEiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjbGVhciIsImNvcHkkMiIsInB1c2giLCJwb3AiLCJ0b3AiLCJsZW5ndGgkMSIsIml0ZXIkNCIsInRvX3NlcSQzIiwicSIsIm9mX3NlcSQzIiwiY3JlYXRlJDAiLCJjbGVhciQwIiwiY2VsbCIsInBlZWsiLCJjb250ZW50IiwidGFrZSIsImNvcHkkMyIsInFfcmVzIiwicHJldiIsImlzX2VtcHR5JDAiLCJsZW5ndGgkMiIsIml0ZXIkNSIsImZvbGQkMCIsInRyYW5zZmVyIiwicTEiLCJxMiIsInRvX3NlcSQ0IiwiYWRkX3NlcSQwIiwib2Zfc2VxJDQiLCJyYWlzZV91bmRlZmluZWQiLCJmb3JjZV9sYXp5X2Jsb2NrIiwiYmxrIiwiY2xvc3VyZSIsImZvcmNlX3ZhbF9sYXp5X2Jsb2NrIiwiZm9yY2UiLCJsenYiLCJmb3JjZV92YWwiLCJmcm9tX2Z1biIsImZyb21fdmFsIiwiaXNfdmFsIiwiY291bnQiLCJmaWxsX2J1ZmYiLCJnZXRfZGF0YSIsImQxMSIsImEkMCIsImEkMSIsInBlZWtfZGF0YSIsInBlZWskMCIsImp1bmtfZGF0YSIsImp1bmsiLCJuZ2V0X2RhdGEiLCJhbCIsIm5wZWVrIiwiZW1wdHkkMSIsIml0ZXIkNiIsInN0cm0iLCJmcm9tIiwib2ZfbGlzdCQwIiwib2Zfc3RyaW5nJDAiLCJvZl9ieXRlcyIsIm9mX2NoYW5uZWwiLCJpYXBwIiwiaWNvbnMiLCJpc2luZyIsImxhcHAiLCJsY29ucyIsImxzaW5nIiwic2VtcHR5Iiwic2xhenkiLCJkdW1wIiwiZHVtcF9kYXRhIiwiY3JlYXRlJDEiLCJjb250ZW50cyIsInRvX2J5dGVzIiwic3ViJDIiLCJibGl0JDIiLCJzcmMiLCJudGgkMCIsImxlbmd0aCQzIiwiY2xlYXIkMSIsInJlc2V0IiwicmVzaXplIiwibW9yZSIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsImFkZF91dGZfOF91Y2hhciIsInBvcyQwIiwicG9zJDEiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJ1JDAiLCJhZGRfdXRmXzE2bGVfdWNoYXIiLCJhZGRfc3Vic3RyaW5nIiwib2Zmc2V0IiwibmV3X3Bvc2l0aW9uIiwiYWRkX3N1YmJ5dGVzIiwiYWRkX3N0cmluZyIsImFkZF9ieXRlcyIsImFkZF9idWZmZXIiLCJicyIsImFkZF9jaGFubmVsIiwib3V0cHV0X2J1ZmZlciIsImFkZF9zdWJzdGl0dXRlIiwibGltJDEiLCJwcmV2aW91cyIsImkkNyIsImN1cnJlbnQiLCJpJDgiLCJvcGVuaW5nIiwiaSQ2IiwibGltJDAiLCJpJDMiLCJzdG9wIiwiaSQ0IiwiaSQ1IiwiayQyIiwibmV4dF9pIiwiaWRlbnQiLCJpJDkiLCJpJDEwIiwiaSQxMSIsInRydW5jYXRlIiwidG9fc2VxJDUiLCJ0b19zZXFpJDIiLCJhZGRfc2VxJDEiLCJvZl9zZXEkNSIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImJwcmludF9wYWR0eSIsInBhZHR5IiwiYnByaW50X2lnbm9yZWRfZmxhZyIsImlnbl9mbGFnIiwiYnByaW50X3BhZF9vcHQiLCJicHJpbnRfcGFkZGluZyIsInBhZHR5JDAiLCJicHJpbnRfcHJlY2lzaW9uIiwiYnByaW50X2ljb252X2ZsYWciLCJicHJpbnRfYWx0aW50X2ZtdCIsImJwcmludF9mY29udl9mbGFnIiwic3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0Iiwic3RyJDAiLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19nZW4iLCJmb3JtYXR0aW5nX2dlbiIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJzdWJfZm10dHkiLCJzdWJfZm10dHkkMCIsImludF9vZl9jdXN0b21fYXJpdHkiLCJzdHJpbmdfb2ZfZm10IiwiZm10JDEiLCJjaHIkMCIsImlzX2Fsb25lJDAiLCJpc19hbG9uZSIsImokMCIsImokMSIsImZtdCQwIiwic3ltbSIsImZtdHR5X3JlbF9kZXQiLCJkZSIsImVkIiwiYWYiLCJmYSIsImRlJDAiLCJlZCQwIiwiYWYkMCIsImZhJDAiLCJkZSQxIiwiZWQkMSIsImFmJDEiLCJmYSQxIiwiZGUkMiIsImVkJDIiLCJhZiQyIiwiZmEkMiIsImRlJDMiLCJlZCQzIiwiYWYkMyIsImZhJDMiLCJkZSQ0IiwiZWQkNCIsImFmJDQiLCJmYSQ0IiwiZGUkNSIsImVkJDUiLCJhZiQ1IiwiZmEkNSIsImRlJDYiLCJlZCQ2IiwiYWYkNiIsImZhJDYiLCJkZSQ3IiwiZWQkNyIsImFmJDciLCJmYSQ3IiwiZGUkOCIsImVkJDgiLCJhZiQ4IiwiZmEkOCIsInRyYW5zIiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJyZXN0MiIsInJlc3QyJDAiLCJyZXN0MiQxIiwicmVzdDIkMiIsInJlc3QyJDMiLCJyZXN0MiQ0IiwicmVzdDIkNSIsInJlc3QyJDYiLCJyZXN0MiQ3IiwicmVzdDIkOCIsInR5MjIiLCJ0eTIxIiwiZjQiLCJmMiIsInJlc3QyJDkiLCJyZXN0MiQxMCIsInJlc3QyJDExIiwicmVzdDIkMTIiLCJyZXN0MiQxMyIsImZtdHR5X29mX3BhZGRpbmdfZm10dHkiLCJmbXR0eV9vZl9jdXN0b20iLCJhcml0eSQwIiwiZm10dHlfb2ZfZm10IiwidHlfcmVzdCIsInByZWNfdHkiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJ0eV9yZXN0JDAiLCJwcmVjX3R5JDAiLCJ0eV9yZXN0JDEiLCJwcmVjX3R5JDEiLCJ0eV9yZXN0JDIiLCJwcmVjX3R5JDIiLCJ0eV9yZXN0JDMiLCJwcmVjX3R5JDMiLCJmbXR0eSQxIiwiZm10dHkkMiIsImZtdHR5JDMiLCJ0eSQwIiwiZm10dHkkNCIsImZtdHR5JDUiLCJ0eXBlX3BhZGRpbmciLCJ3IiwidHlwZV9wYWRwcmVjIiwidHlwZV9mb3JtYXQiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJ0eXBlX2lnbm9yZWRfcGFyYW1fb25lIiwiZm10dHlfcmVzdCIsImZtdF9yZXN0IiwiZm10dHlfcmVzdCQwIiwiZm10X3Jlc3QkMCIsImZtdF9yZXN0JDEiLCJmbXR0eV9yZXN0JDEiLCJmbXQkMiIsImZtdF9yZXN0JDIiLCJmbXR0eV9yZXN0JDIiLCJmbXQkMyIsImZtdF9yZXN0JDMiLCJmbXR0eV9yZXN0JDMiLCJmbXQkNCIsImZtdF9yZXN0JDQiLCJmbXR0eV9yZXN0JDQiLCJmbXQkNSIsImZtdF9yZXN0JDUiLCJmbXR0eV9yZXN0JDUiLCJmbXR0eSQ2IiwiZm10JDYiLCJmbXRfcmVzdCQ2IiwiZm10dHlfcmVzdCQ2IiwiZm10dHkkNyIsImZtdCQ3IiwiZm10X3Jlc3QkNyIsImZtdHR5X3Jlc3QkNyIsImZtdHR5JDgiLCJmbXQkOCIsImZtdF9yZXN0JDgiLCJmbXR0eV9yZXN0JDgiLCJmbXR0eSQ5IiwiZm10JDkiLCJmbXRfcmVzdCQ5IiwiZm10dHkkMTAiLCJmbXQkMTAiLCJmbXRfcmVzdCQxMCIsImZtdHR5JDExIiwiZm10JDExIiwiZm10X3Jlc3QkMTEiLCJmbXR0eSQxMiIsImZtdCQxMiIsImZtdHR5X3Jlc3QkOSIsImZtdF9yZXN0JDEyIiwiZm10dHkkMTMiLCJmbXQkMTMiLCJmbXR0eV9yZXN0JDEwIiwic3ViX2ZtdHR5MSIsImZtdF9yZXN0JDEzIiwic3ViX2ZtdHR5JDEiLCJmbXR0eSQxNCIsImZtdCQxNCIsImZtdHR5X3Jlc3QkMTEiLCJmbXRfcmVzdCQxNCIsImZtdHR5JDE1IiwiZm10JDE1IiwiZm10dHlfcmVzdCQxMiIsImZtdF9yZXN0JDE1IiwiZm10dHkkMTYiLCJmbXQkMTYiLCJmbXRfcmVzdCQxNiIsImZtdHR5JDE3IiwiZm10JDE3IiwiZm10X3Jlc3QkMTciLCJmbXR0eTMiLCJmbXQzIiwic3RyJDEiLCJmbXQxJDAiLCJmbXR0eTIkMCIsImZtdDIkMCIsImZtdHR5MyQwIiwiZm10MyQwIiwiZm10dHlfcmVzdCQxMyIsImZtdF9yZXN0JDE4IiwiZm10dHkkMTgiLCJmbXQkMTgiLCJmbXR0eV9yZXN0JDE0IiwiZm10X3Jlc3QkMTkiLCJmbXR0eSQxOSIsImZtdCQxOSIsImZtdHR5X3Jlc3QkMTUiLCJmbXRfcmVzdCQyMCIsImZtdHR5JDIwIiwiZm10JDIwIiwiZm10dHlfcmVzdCQxNiIsImZtdHR5JDIxIiwiZm10JDIxIiwic3ViX2ZtdHR5JDIiLCJzdWJfZm10dHkkMyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIiwiZm10dHkkMjIiLCJmbXQkMjIiLCJzdWJfZm10dHkkNCIsInN1Yl9mbXR0eV9yZXN0Iiwic3ViX2ZtdHR5X3Jlc3QkMCIsInN1Yl9mbXR0eV9yZXN0JDEiLCJzdWJfZm10dHlfcmVzdCQyIiwic3ViX2ZtdHR5X3Jlc3QkMyIsInN1Yl9mbXR0eV9yZXN0JDQiLCJzdWJfZm10dHlfcmVzdCQ1Iiwic3ViX2ZtdHR5X3Jlc3QkNiIsInN1Yl9mbXR0eV9yZXN0JDciLCJzdWJfZm10dHlfcmVzdCQ4Iiwic3ViX2ZtdHR5X3Jlc3QkOSIsInN1Yl9mbXR0eV9yZXN0JDEwIiwic3ViX2ZtdHR5X3Jlc3QkMTEiLCJzdWJfZm10dHlfcmVzdCQxMiIsInN1Yl9mbXR0eV9yZXN0JDEzIiwic3ViX2ZtdHR5X3Jlc3QkMTQiLCJzdWIyX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTUiLCJzdWIyX2ZtdHR5JDAiLCJzdWJfZm10dHlfcmVzdCQxNiIsInN1YjJfZm10dHkkMSIsInN1YjFfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNyIsInN1YjJfZm10dHkkMiIsInN1YjFfZm10dHkkMCIsInN1Yl9mbXR0eV9yZXN0JDE4Iiwic3ViX2ZtdHR5X3Jlc3QkMTkiLCJzdWJfZm10dHlfcmVzdCQyMCIsInN1Yl9mbXR0eV9yZXN0JDIxIiwic3ViX2ZtdHR5X3Jlc3QkMjIiLCJzdWJfZm10dHlfcmVzdCQyMyIsInN1Yl9mbXR0eV9yZXN0JDI0Iiwic3ViX2ZtdHR5X3Jlc3QkMjUiLCJzdWJfZm10dHlfcmVzdCQyNiIsInJlY2FzdCIsImZpeF9wYWRkaW5nIiwiZml4X2ludF9wcmVjaXNpb24iLCJyZXMkMSIsInN0cmluZ190b19jYW1sX3N0cmluZyIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJzaWduIiwic3ltYiIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIiwibyIsIm1ha2VfcHJpbnRmIiwicCQwIiwicCQxIiwibWFrZV9wYWRkaW5nIiwibmV3X2FjYyIsIm1ha2VfcHJpbnRmJDAiLCJhY2MkMiIsImFjYyQzIiwiYWNjJDQiLCJrJDMiLCJrb2MiLCJrYWNjIiwiayQ0IiwibWFrZV9pZ25vcmVkX3BhcmFtJDAiLCJtYWtlX2N1c3RvbSQwIiwibWFrZV9pbnZhbGlkX2FyZyIsIm1ha2VfZnJvbV9mbXR0eSQwIiwibWFrZV9mcm9tX2ZtdHR5IiwibWFrZV9jdXN0b20iLCJtYWtlX2lnbm9yZWRfcGFyYW0iLCJmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiIsIm1ha2VfaXByaW50ZiIsIm1ha2VfaXByaW50ZiQwIiwicmVzdCQyNCIsInJlc3QkMjUiLCJmbl9vZl9jdXN0b21fYXJpdHkkMCIsImZuX29mX2N1c3RvbV9hcml0eSIsIm91dHB1dF9hY2MiLCJwJDIiLCJwJDMiLCJtc2ciLCJwJDQiLCJidWZwdXRfYWNjIiwic3RycHV0X2FjYyIsImZhaWx3aXRoX21lc3NhZ2UiLCJvcGVuX2JveF9vZl9zdHJpbmciLCJpbnZhbGlkX2JveCIsInBhcnNlX3NwYWNlcyIsInBhcnNlX2x3b3JkIiwicGFyc2VfaW50Iiwid3N0YXJ0Iiwid2VuZCIsImJveF9uYW1lIiwibnN0YXJ0IiwibmVuZCIsImluZGVudCIsImV4cF9lbmQiLCJib3hfdHlwZSIsIm1ha2VfcGFkZGluZ19mbXRfZWJiIiwibWFrZV9wYWRwcmVjX2ZtdF9lYmIiLCJmbXRfZWJiX29mX3N0cmluZyIsImxlZ2FjeV9iZWhhdmlvciIsImZsYWciLCJsZWdhY3lfYmVoYXZpb3IkMCIsImludmFsaWRfZm9ybWF0X21lc3NhZ2UiLCJ1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQiLCJlbmRfaW5kIiwiaW52YWxpZF9mb3JtYXRfd2l0aG91dCIsImV4cGVjdGVkX2NoYXJhY3RlciIsImV4cGVjdGVkIiwiYWRkX2xpdGVyYWwiLCJsaXRfc3RhcnQiLCJwYXJzZSIsInN0cl9pbmQkMiIsInBhcnNlX2ZsYWdzIiwic3RyX2luZCQwIiwicGFyc2VfdGFnIiwicGFyc2VfZ29vZF9icmVhayIsInBhcnNlX21hZ2ljX3NpemUiLCJzdHJfaW5kJDEiLCJwYXJzZV9jb252ZXJzaW9uIiwicGN0X2luZCIsInBsdXMiLCJzcGFjZSIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImluY29tcGF0aWJsZV9mbGFnIiwiY2hlY2tfbm9fMCIsIm9wdF9vZl9wYWQiLCJ3aWR0aCQwIiwid2lkdGgkMSIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZm10X3Jlc3VsdCIsInN1Yl9lbmQiLCJzZWFyY2hfc3ViZm9ybWF0X2VuZCIsInN1Yl9mbXQiLCJpZ25vcmVkJDIiLCJjb3VudGVyJDAiLCJpZ25vcmVkJDYiLCJpZ25vcmVkJDciLCJhZGRfcmFuZ2UiLCJmYWlsX3NpbmdsZV9wZXJjZW50IiwicGFyc2VfY2hhcl9zZXRfY29udGVudCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIkMCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIiLCJyZXZlcnNlIiwibmV4dF9pbmQiLCJjaGFyX3NldCQxIiwiaWdub3JlZCQ5IiwiY2hhcl9mb3JtYXQiLCJmbXRfcmVzdCQyMSIsImZtdF9yZXN0JDIyIiwicGFkJDkiLCJmbXRfcmVzdCQyMyIsImlnbm9yZWQkMTAiLCJmbXRfcmVzdCQyNCIsInBhZCQxMCIsImZtdF9yZXN0JDI1Iiwic3ViX2VuZCQwIiwic3ViX2ZtdCQwIiwiZm10X3Jlc3QkMjYiLCJpZ25vcmVkJDExIiwiaWdub3JlZCQzIiwic3ltYiQwIiwiaWdub3JlZCQ1IiwiY29tcHV0ZV9pbnRfY29udiIsImlnbm9yZWQkOCIsInByZWMkNCIsInNwYWNlJDEiLCJwbHVzJDIiLCJwbHVzJDMiLCJzcGFjZSQyIiwiaWdub3JlZCQ0IiwiaWdub3JlZCIsImlnbm9yZWQkMCIsImlnbm9yZWQkMSIsInBsdXMkMCIsInNwYWNlJDAiLCJwbHVzJDEiLCJpZ24kMCIsInBhcnNlX2FmdGVyX3ByZWNpc2lvbiIsIm1pbnVzIiwicGFyc2VfY29udiIsInBhcnNlX2FmdGVyX3BhZGRpbmciLCJwYXJzZV9saXRlcmFsIiwicGFyc2VfcG9zaXRpdmUiLCJuZXdfaW5kIiwibWludXMkMCIsInNldF9mbGFnIiwic3RyX2luZCQzIiwic3RyX2luZCQ0Iiwic3RyX2luZCQ1IiwiaXNfb3Blbl90YWciLCJpbmQiLCJzdWJfc3RyIiwic3ViX2Zvcm1hdCQwIiwiZm9ybWF0dGluZyQwIiwiZm9ybWF0dGluZyIsInN0cl9pbmRfMSIsInBhcnNlX2ludGVnZXIiLCJzdHJfaW5kXzIiLCJzdHJfaW5kXzMiLCJmb3JtYXR0aW5nX2xpdCQwIiwic3RyX2luZF80Iiwic3RyX2luZF81Iiwic3ViX2VuZCQxIiwic3ViX2VuZCQyIiwic3RyX2luZCQ2Iiwic3RyX2luZCQ3Iiwib3B0aW9uIiwic3ViZm10IiwiZm9ybWF0X29mX3N0cmluZ19mbXR0eSIsImZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0Iiwia2ZwcmludGYiLCJrYnByaW50ZiIsImlrZnByaW50ZiIsImZwcmludGYiLCJicHJpbnRmIiwiaWZwcmludGYiLCJwcmludGYiLCJlcHJpbnRmIiwia3NwcmludGYiLCJzcHJpbnRmIiwiYXNzb2MzIiwieTIiLCJ5MSIsInNwbGl0JDAiLCJtYWtlX3N5bWxpc3QiLCJwcmVmaXgiLCJzdWZmaXgiLCJoZWxwX2FjdGlvbiIsImFkZF9oZWxwIiwic3BlY2xpc3QiLCJhZGQyIiwidXNhZ2VfYiIsImVycm1zZyIsImRvYyIsInNwZWMiLCJrZXkiLCJ1c2FnZV9zdHJpbmciLCJ1c2FnZSIsImJvb2xfb2Zfc3RyaW5nX29wdCQwIiwiaW50X29mX3N0cmluZ19vcHQkMCIsImZsb2F0X29mX3N0cmluZ19vcHQkMCIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCIsImFsbG93X2V4cGFuZCIsImFyZ3YiLCJhbm9uZnVuIiwiaW5pdHBvcyIsImNvbnZlcnRfZXJyb3IiLCJlcnJvciIsInByb2duYW1lIiwib3B0IiwiYWN0aW9uIiwiZm9sbG93JDAiLCJrZXl3b3JkIiwibm9fYXJnJDAiLCJmb2xsb3ciLCJub19hcmciLCJnZXRfYXJnJDAiLCJnZXRfYXJnIiwiY29uc3VtZV9hcmckMCIsImNvbnN1bWVfYXJnIiwidHJlYXRfYWN0aW9uJDAiLCJ0cmVhdF9hY3Rpb24iLCJmJDAiLCJmJDEiLCJyJDEiLCJmJDIiLCJyJDIiLCJhcmckMiIsIngkMCIsImYkMyIsImFyZyQzIiwieCQxIiwiciQzIiwiYXJnJDQiLCJ4JDIiLCJzcGVjcyIsImYkNCIsImFyZyQ1IiwiZiQ1IiwiZiQ2IiwiYXJnJDYiLCJuZXdhcmciLCJiZWZvcmUiLCJhZnRlciIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIiwicGFyc2VfYXJndl9keW5hbWljIiwic3RoIiwiY3VycmVudCQwIiwicGFyc2VfYXJndiIsIm1zZyQwIiwibXNnJDEiLCJwYXJzZV9keW5hbWljIiwicGFyc2VfZXhwYW5kIiwic2Vjb25kX3dvcmQiLCJsb29wIiwibWF4X2FyZ19sZW4iLCJjdXIiLCJrd2QiLCJyZXBsYWNlX2xlYWRpbmdfdGFiIiwic2VlbiIsImFsaWduIiwibGltaXQiLCJjb21wbGV0ZWQiLCJrc2QiLCJjdXRjb2wkMCIsInNwYWNlcyQwIiwiY3V0Y29sIiwia3dkX2xlbiIsInNwYWNlcyIsInJlYWRfYXV4IiwidHJpbSIsImZpbGUiLCJ3b3JkcyIsInN0YXNoIiwid29yZCIsInJlYWRfYXJnIiwicmVhZF9hcmcwIiwid3JpdGVfYXV4IiwiYXJncyIsIndyaXRlX2FyZyIsIndyaXRlX2FyZzAiLCJwcmludGVycyIsImZpZWxkIiwib3RoZXJfZmllbGRzIiwiZmllbGRzIiwidG9fc3RyaW5nJDQiLCJjb252IiwiY2hhciQwIiwibGluZSIsImNoYXIkMSIsImxpbmUkMCIsImZpbGUkMCIsImNoYXIkMiIsImxpbmUkMSIsImZpbGUkMSIsImNvbnN0cnVjdG9yIiwicHJpbnQiLCJmY3QiLCJjYXRjaCQwIiwiY29udmVydF9yYXdfYmFja3RyYWNlIiwiYnQiLCJmb3JtYXRfYmFja3RyYWNlX3Nsb3QiLCJpbmZvIiwiaXNfcmFpc2UiLCJwcmludF9yYXdfYmFja3RyYWNlIiwib3V0Y2hhbiIsInJhd19iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJwcmludF9iYWNrdHJhY2UiLCJyYXdfYmFja3RyYWNlX3RvX3N0cmluZyIsImJhY2t0cmFjZV9zbG90X2lzX3JhaXNlIiwiYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lIiwiYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24iLCJiYWNrdHJhY2Vfc2xvdHMiLCJnZXRfYmFja3RyYWNlIiwicmVnaXN0ZXJfcHJpbnRlciIsImZuIiwiZXhuX3Nsb3QiLCJleG5fc2xvdF9pZCIsImV4bl9zbG90X25hbWUiLCJ1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsInNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsInByaW50X3N0YXQiLCJhbGxvY2F0ZWRfYnl0ZXMiLCJtYSIsInBybyIsIm1pIiwiY3JlYXRlX2FsYXJtIiwiZGVsZXRlX2FsYXJtIiwic3RyaW5nIiwiYnl0ZXMiLCJzdWJzdHJpbmciLCJzdWJieXRlcyIsImZpbGVuYW1lIiwib3V0cHV0JDAiLCJkaWdlc3QiLCJpbnB1dCQwIiwiY2hhcl9oZXgiLCJ0b19oZXgiLCJmcm9tX2hleCIsImRpZ2l0IiwibmV3X3N0YXRlIiwiYXNzaWduIiwic3QxIiwic3QyIiwiZnVsbF9pbml0Iiwic2VlZCIsInNlZWQkMCIsIm1ha2UkMSIsIm1ha2Vfc2VsZl9pbml0IiwiY29weSQ0IiwiYml0cyIsImN1cnZhbCIsIm5ld3ZhbCIsIm5ld3ZhbDMwIiwiaW50JDAiLCJib3VuZCIsImludDMyIiwiYjEiLCJiMiIsImludDY0IiwiYjMiLCJuYXRpdmVpbnQiLCJmbG9hdCQwIiwiYm9vbCIsImRlZmF1bHQkMCIsImJpdHMkMCIsImludCQxIiwiaW50MzIkMCIsIm5hdGl2ZWludCQwIiwiaW50NjQkMCIsImZsb2F0JDEiLCJzY2FsZSIsImJvb2wkMCIsImZ1bGxfaW5pdCQwIiwiaW5pdCQzIiwic2VsZl9pbml0IiwiZ2V0X3N0YXRlIiwic2V0X3N0YXRlIiwiaGFzaCQxIiwiaGFzaF9wYXJhbSIsInNlZWRlZF9oYXNoIiwib25nb2luZ190cmF2ZXJzYWwiLCJmbGlwX29uZ29pbmdfdHJhdmVyc2FsIiwicGFyYW1zIiwicmFuZG9taXplZF9kZWZhdWx0IiwicmFuZG9taXplZCIsInJhbmRvbWl6ZSIsImlzX3JhbmRvbWl6ZWQiLCJwcm5nIiwiY3JlYXRlJDIiLCJpbml0aWFsX3NpemUiLCJyYW5kb20iLCJjbGVhciQyIiwicmVzZXQkMCIsImNvcHlfYnVja2V0bGlzdCIsImtleSQwIiwibmV4dCQwIiwiY29weSQ1IiwibGVuZ3RoJDQiLCJyZXNpemUkMCIsImluZGV4ZnVuIiwib2RhdGEiLCJvc2l6ZSIsIm5zaXplIiwibmRhdGEiLCJuZGF0YV90YWlsIiwiaW5wbGFjZSIsImNlbGwkMCIsIm5pZHgiLCJtYXRjaCQwIiwia2V5X2luZGV4IiwiYWRkJDAiLCJidWNrZXQiLCJmaW5kJDAiLCJrMSIsIm5leHQxIiwiazIiLCJuZXh0MiIsImszIiwiZDMiLCJuZXh0MyIsImZpbmRfb3B0JDAiLCJmaW5kX2FsbCQwIiwiZmluZF9pbl9idWNrZXQiLCJyZXBsYWNlIiwibWVtJDEiLCJpdGVyJDciLCJkb19idWNrZXQiLCJvbGRfdHJhdiIsImZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQiLCJmaWx0ZXJfbWFwX2lucGxhY2UiLCJmb2xkJDEiLCJiJDAiLCJidWNrZXRfbGVuZ3RoIiwic3RhdHMiLCJtYmwiLCJoaXN0byIsInRvX3NlcSQ2IiwidGJsX2RhdGEiLCJidWNrIiwiYnVjayQwIiwiYnVjayQxIiwidG9fc2VxX2tleXMiLCJ0b19zZXFfdmFsdWVzIiwiYWRkX3NlcSQyIiwicmVwbGFjZV9zZXEiLCJvZl9zZXEkNiIsImZpbmRfYWxsIiwiY29weSIsInN6IiwibGVuZ3RoJDUiLCJmaWxsJDEiLCJhciIsImVtcHR5YnVja2V0IiwiZ2V0X2luZGV4Iiwic3okMCIsInN6JDEiLCJjb3VudF9idWNrZXQiLCJhZGRfYXV4Iiwic2V0dGVyIiwiaW5kZXgiLCJidWNrZXQkMCIsImhhc2hlcyIsIm5ld3N6IiwibmV3YnVja2V0IiwibmV3aGFzaGVzIiwiaGJ1Y2tldCIsInByZXZfbGVuIiwibGl2ZSIsImokMiIsIm5ld3QiLCJvYiIsIm9oIiwic2V0dGVyJDAiLCJuYiIsIm5pIiwiZmluZF9vciIsImlmbm90Zm91bmQiLCJmaW5kX3NoYWRvdyIsImlmZm91bmQiLCJsZW5zIiwidG90bGVuIiwiYWRkX3F1ZXVlIiwidGFrZV9xdWV1ZSIsInBwX2VucXVldWUiLCJ0b2tlbiIsInBwX2luZmluaXR5IiwicHBfb3V0cHV0X3N0cmluZyIsInBwX291dHB1dF9uZXdsaW5lIiwiYnJlYWtfbmV3X2xpbmUiLCJyZWFsX2luZGVudCIsImJyZWFrX2xpbmUiLCJicmVha19zYW1lX2xpbmUiLCJwcF9mb3JjZV9icmVha19saW5lIiwiYmxfdHkiLCJwcF9za2lwX3Rva2VuIiwiZm9ybWF0X3BwX3Rva2VuIiwidGFicyIsImFkZF90YWIiLCJscyIsImxzJDAiLCJ0YWdzIiwidGFnX25hbWUiLCJtYXJrZXIiLCJvZmYiLCJvZmYkMCIsImluc2VydGlvbl9wb2ludCIsInRhYnMkMCIsInRhYiIsIm9mZiQxIiwiaW5zZXJ0aW9uX3BvaW50JDAiLCJvZmZzZXQkMCIsImJsX3R5cGUiLCJ0Ym94IiwidGFnX25hbWUkMCIsIm1hcmtlciQwIiwiYWR2YW5jZV9sb29wIiwic2l6ZSQwIiwiYWR2YW5jZV9sZWZ0IiwiZW5xdWV1ZV9hZHZhbmNlIiwiZW5xdWV1ZV9zdHJpbmdfYXMiLCJxX2VsZW0iLCJzY2FuX3N0YWNrX2JvdHRvbSIsImNsZWFyX3NjYW5fc3RhY2siLCJzZXRfc2l6ZSIsInF1ZXVlX2VsZW0iLCJsZWZ0X3RvdCIsInNjYW5fcHVzaCIsInBwX29wZW5fYm94X2dlbiIsImJyX3R5IiwiZWxlbSIsInBwX2Nsb3NlX2JveCIsInBwX29wZW5fdGFnIiwicHBfY2xvc2VfdGFnIiwicHBfc2V0X3ByaW50X3RhZ3MiLCJwcF9zZXRfbWFya190YWdzIiwicHBfZ2V0X3ByaW50X3RhZ3MiLCJwcF9nZXRfbWFya190YWdzIiwicHBfc2V0X3RhZ3MiLCJwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJwY3QiLCJwb3QiLCJtY3QiLCJtb3QiLCJwcF9yaW5pdCIsInBwX2ZsdXNoX3F1ZXVlIiwicHBfcHJpbnRfYXNfc2l6ZSIsInBwX3ByaW50X2FzIiwiaXNpemUiLCJwcF9wcmludF9zdHJpbmciLCJwcF9wcmludF9pbnQiLCJwcF9wcmludF9mbG9hdCIsInBwX3ByaW50X2Jvb2wiLCJwcF9wcmludF9jaGFyIiwicHBfb3Blbl9oYm94IiwicHBfb3Blbl92Ym94IiwicHBfb3Blbl9odmJveCIsInBwX29wZW5faG92Ym94IiwicHBfb3Blbl9ib3giLCJwcF9wcmludF9uZXdsaW5lIiwicHBfcHJpbnRfZmx1c2giLCJwcF9mb3JjZV9uZXdsaW5lIiwicHBfcHJpbnRfaWZfbmV3bGluZSIsInBwX3ByaW50X2JyZWFrIiwicHBfcHJpbnRfc3BhY2UiLCJwcF9wcmludF9jdXQiLCJwcF9vcGVuX3Rib3giLCJwcF9jbG9zZV90Ym94IiwicHBfcHJpbnRfdGJyZWFrIiwicHBfcHJpbnRfdGFiIiwicHBfc2V0X3RhYiIsInBwX3NldF9tYXhfYm94ZXMiLCJwcF9nZXRfbWF4X2JveGVzIiwicHBfb3Zlcl9tYXhfYm94ZXMiLCJwcF9zZXRfZWxsaXBzaXNfdGV4dCIsInBwX2dldF9lbGxpcHNpc190ZXh0IiwicHBfbGltaXQiLCJwcF9zZXRfbWF4X2luZGVudCIsInBwX2dldF9tYXhfaW5kZW50IiwicHBfc2V0X21hcmdpbiIsIm5ld19tYXhfaW5kZW50IiwicHBfZ2V0X21hcmdpbiIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsImRpc3BsYXlfbmV3bGluZSIsImJsYW5rX2xpbmUiLCJkaXNwbGF5X2luZGVudCIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJkZWZhdWx0X3BwX21hcmtfb3Blbl90YWciLCJkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnIiwiZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnIiwicHBfbWFrZV9mb3JtYXR0ZXIiLCJwcF9xdWV1ZSIsInN5c190b2siLCJzeXNfc2Nhbl9zdGFjayIsImZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIiwib3V0X2Z1bnMiLCJtYWtlX2Zvcm1hdHRlciIsImZsdXNoIiwicHBmIiwiZm9ybWF0dGVyX29mX291dF9jaGFubmVsIiwiZm9ybWF0dGVyX29mX2J1ZmZlciIsInBwX2J1ZmZlcl9zaXplIiwicHBfbWFrZV9idWZmZXIiLCJzdGRidWYiLCJzdGRfZm9ybWF0dGVyIiwiZXJyX2Zvcm1hdHRlciIsInN0cl9mb3JtYXR0ZXIiLCJmbHVzaF9idWZmZXJfZm9ybWF0dGVyIiwiZmx1c2hfc3RyX2Zvcm1hdHRlciIsIm1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJzb2IiLCJnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImZsdXNoX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJpdGVtcyIsImFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSIsIml0ZW0iLCJmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsIm9wZW5faGJveCIsIm9wZW5fdmJveCIsIm9wZW5faHZib3giLCJvcGVuX2hvdmJveCIsIm9wZW5fYm94IiwiY2xvc2VfYm94Iiwib3Blbl90YWciLCJjbG9zZV90YWciLCJwcmludF9hcyIsInByaW50X3N0cmluZyQwIiwicHJpbnRfaW50JDAiLCJwcmludF9mbG9hdCQwIiwicHJpbnRfY2hhciQwIiwicHJpbnRfYm9vbCIsInByaW50X2JyZWFrIiwicHJpbnRfY3V0IiwicHJpbnRfc3BhY2UiLCJmb3JjZV9uZXdsaW5lIiwicHJpbnRfZmx1c2giLCJwcmludF9uZXdsaW5lJDAiLCJwcmludF9pZl9uZXdsaW5lIiwib3Blbl90Ym94IiwiY2xvc2VfdGJveCIsInByaW50X3RicmVhayIsInNldF90YWIiLCJwcmludF90YWIiLCJzZXRfbWFyZ2luIiwiZ2V0X21hcmdpbiIsInNldF9tYXhfaW5kZW50IiwiZ2V0X21heF9pbmRlbnQiLCJzZXRfbWF4X2JveGVzIiwiZ2V0X21heF9ib3hlcyIsIm92ZXJfbWF4X2JveGVzIiwic2V0X2VsbGlwc2lzX3RleHQiLCJnZXRfZWxsaXBzaXNfdGV4dCIsInNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJzZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2xpc3QiLCJwcF92Iiwib3B0JDAiLCJwcF9zZXAiLCJvcHQkMSIsInBwX3ByaW50X3RleHQiLCJjb21wdXRlX3RhZyIsInRhZ19hY2MiLCJvdXRwdXRfZm9ybWF0dGluZ19saXQiLCJvdXRwdXRfYWNjJDAiLCJidHkiLCJwJDUiLCJwJDYiLCJzdHJwdXRfYWNjJDAiLCJzaXplJDEiLCJrZnByaW50ZiQwIiwiaWtmcHJpbnRmJDAiLCJmcHJpbnRmJDAiLCJpZnByaW50ZiQwIiwicHJpbnRmJDAiLCJlcHJpbnRmJDAiLCJrc3ByaW50ZiQwIiwic3ByaW50ZiQwIiwia2FzcHJpbnRmIiwiYXNwcmludGYiLCJwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwicHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJnZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiYnByaW50ZiQwIiwibnVsbF9jaGFyIiwibmV4dF9jaGFyIiwiaWIiLCJwZWVrX2NoYXIiLCJjaGVja2VkX3BlZWtfY2hhciIsImVuZF9vZl9pbnB1dCIsImJlZ2lubmluZ19vZl9pbnB1dCIsIm5hbWVfb2ZfaW5wdXQiLCJmbmFtZSIsImNoYXJfY291bnQiLCJyZXNldF90b2tlbiIsImludmFsaWRhdGVfY3VycmVudF9jaGFyIiwidG9rZW5fc3RyaW5nIiwidG9rZW5fYnVmZmVyIiwic2tpcF9jaGFyIiwiaWdub3JlX2NoYXIiLCJzdG9yZV9jaGFyIiwiZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSIsImNyZWF0ZSQzIiwiaW5hbWUiLCJmcm9tX3N0cmluZyQxIiwiZnJvbV9mdW5jdGlvbiQwIiwic2Nhbl9jbG9zZV9hdF9lbmQiLCJzY2FuX3JhaXNlX2F0X2VuZCIsImZyb21faWMiLCJzY2FuX2Nsb3NlX2ljIiwiZW9mIiwic3RkaWIiLCJvcGVuX2luX2ZpbGUiLCJmcm9tX2ZpbGUiLCJmcm9tX2ZpbGVfYmluIiwiZnJvbV9jaGFubmVsJDAiLCJjbG9zZV9pbiIsImljJDAiLCJtZW1vIiwibWVtb19mcm9tX2ljIiwibWVtb19mcm9tX2NoYW5uZWwiLCJiYWRfaW5wdXQiLCJiYWRfaW5wdXRfZXNjYXBlIiwiYmFkX3Rva2VuX2xlbmd0aCIsIm1lc3NhZ2UiLCJiYWRfZmxvYXQiLCJiYWRfaGV4X2Zsb2F0IiwiY2hhcmFjdGVyX21pc21hdGNoIiwiY2kiLCJjaGVja190aGlzX2NoYXIiLCJjaGVja19jaGFyIiwidG9rZW5fY2hhciIsInRva2VuX2Jvb2wiLCJpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciIsInRva2VuX2ludF9saXRlcmFsIiwidG9rZW5fZmxvYXQiLCJzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciIsIndpZHRoJDIiLCJzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50Iiwic2Nhbl9kaWdpdF9wbHVzIiwiYmFzaXMiLCJkaWdpdHAiLCJ3aWR0aCQzIiwiaXNfYmluYXJ5X2RpZ2l0Iiwic2Nhbl9iaW5hcnlfaW50IiwiaXNfb2N0YWxfZGlnaXQiLCJzY2FuX29jdGFsX2ludCIsImlzX2hleGFfZGlnaXQiLCJzY2FuX2hleGFkZWNpbWFsX2ludCIsInNjYW5fc2lnbiIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQiLCJzY2FuX2ludF9jb252ZXJzaW9uIiwic2Nhbl9mcmFjdGlvbmFsX3BhcnQiLCJzY2FuX2V4cG9uZW50X3BhcnQiLCJzY2FuX2Zsb2F0IiwicHJlY2lzaW9uIiwicHJlY2lzaW9uJDAiLCJjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyIsInNjYW5faGV4X2Zsb2F0Iiwid2lkdGgkNCIsIndpZHRoJDUiLCJ3aWR0aCQ2Iiwid2lkdGgkMTAiLCJ3aWR0aCQ3Iiwid2lkdGgkOCIsIndpZHRoJDkiLCJzY2FuX2NhbWxfZmxvYXRfcmVzdCIsIndpZHRoX3ByZWNpc2lvbiIsImZyYWNfd2lkdGgiLCJzY2FuX2NhbWxfZmxvYXQiLCJzY2FuX3N0cmluZyIsInN0cCIsInNjYW5fY2hhciIsImhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIiLCJjaGVja19uZXh0X2NoYXIiLCJjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIiLCJjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyIsInNjYW5fYmFja3NsYXNoX2NoYXIiLCJjMCIsImdldF9kaWdpdCIsImdldF9kaWdpdCQwIiwiYzEkMCIsImMyJDAiLCJzY2FuX2NhbWxfY2hhciIsImZpbmRfc3RvcCIsInNjYW5fY2FtbF9zdHJpbmciLCJmaW5kX3N0b3AkMCIsInNraXBfc3BhY2VzIiwic2Nhbl9jaGFyc19pbl9jaGFyX3NldCIsInNjYW5faW5kaWMiLCJzY2FuX2NoYXJzIiwic2NhbmZfYmFkX2lucHV0IiwiZ2V0X2NvdW50ZXIiLCJ3aWR0aF9vZl9wYWRfb3B0Iiwic3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCIsImZtdGluZyIsInRha2VfZm9ybWF0X3JlYWRlcnMkMCIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMkMCIsInJlYWRlciIsIm5ld19rIiwicmVhZGVyc19yZXN0IiwidGFrZV9mb3JtYXRfcmVhZGVycyIsImZtdCQyMyIsImZtdCQyNCIsImZtdCQyNSIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMiLCJwYWRfcHJlY19zY2FuZiIsInJlYWRlcnMiLCJzY2FuIiwibWFrZV9zY2FuZiIsInNjYW4kMCIsInN0cl9yZXN0Iiwic2NhbiQxIiwic2NhbiQyIiwic2NhbiQzIiwic2NhbiQ0IiwiY29udiQwIiwic2NhbiQ1IiwiY29udiQxIiwic2NhbiQ2IiwiY29udiQyIiwic2NhbiQ3IiwicHJlYyQ1Iiwic2NhbiQ4IiwiZm10aW5nX2xpdCQwIiwic3RwJDAiLCJzJDIiLCJzdHJfcmVzdCQwIiwiYXJnX3Jlc3QiLCJrc2NhbmYiLCJlZiIsImFwcGx5IiwiYXJncyQwIiwiZXhjIiwiYnNjYW5mIiwia3NzY2FuZiIsInNzY2FuZiIsInNjYW5mIiwiYnNjYW5mX2Zvcm1hdCIsImZvcm1hdCIsInNzY2FuZl9mb3JtYXQiLCJmb3JtYXRfZnJvbV9zdHJpbmciLCJ1bmVzY2FwZWQiLCJrZnNjYW5mIiwiZnNjYW5mIiwicmVnaXN0ZXIiLCJyZWdpc3Rlcl9leGNlcHRpb24iLCJvJDAiLCJwYXJhbXMkMCIsImluaXRpYWxfb2JqZWN0X3NpemUiLCJkdW1teV9pdGVtIiwidGFnIiwiY29tcGFyZSQ2IiwiY29tcGFyZSQ3IiwiY29tcGFyZSQ4IiwiZHVtbXlfdGFibGUiLCJ0YWJsZV9jb3VudCIsImR1bW15X21ldCIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJyZXNpemUkMSIsIm5ld19zaXplIiwib2xkX3NpemUiLCJuZXdfYnVjayIsIm1ldGhvZF9jb3VudCIsImluc3RfdmFyX2NvdW50IiwibmV3X21ldGhvZCIsInRhYmxlIiwiZ2V0X21ldGhvZF9sYWJlbCIsImxhYmVsIiwiZ2V0X21ldGhvZF9sYWJlbHMiLCJuYW1lcyIsInNldF9tZXRob2QiLCJlbGVtZW50IiwiZ2V0X21ldGhvZCIsInRvX2xpc3QkMCIsIm5hcnJvdyIsInZhcnMiLCJ2aXJ0X21ldGhzIiwiY29uY3JfbWV0aHMiLCJ2YXJzJDAiLCJ2aXJ0X21ldGhzJDAiLCJjb25jcl9tZXRocyQwIiwidmlydF9tZXRoX2xhYnMiLCJjb25jcl9tZXRoX2xhYnMiLCJsYWIiLCJ0dmFycyIsImJ5X25hbWUiLCJieV9sYWJlbCIsIm1ldCIsImhtIiwid2lkZW4iLCJzYXZlZF92YXJzIiwic2F2ZWRfaGlkZGVuX21ldGhzIiwibmV3X3Nsb3QiLCJuZXdfdmFyaWFibGUiLCJ0b19hcnJheSIsIm5ld19tZXRob2RzX3ZhcmlhYmxlcyIsIm1ldGhzIiwidmFscyIsIm1ldGhzJDAiLCJubWV0aHMiLCJudmFscyIsImdldF92YXJpYWJsZSIsImdldF92YXJpYWJsZXMiLCJhZGRfaW5pdGlhbGl6ZXIiLCJjcmVhdGVfdGFibGUiLCJwdWJsaWNfbWV0aG9kcyIsImluaXRfY2xhc3MiLCJpbmhlcml0cyIsImNsYSIsInN1cGVyJDAiLCJubSIsIm1ha2VfY2xhc3MiLCJwdWJfbWV0aHMiLCJjbGFzc19pbml0IiwiZW52X2luaXQiLCJtYWtlX2NsYXNzX3N0b3JlIiwiaW5pdF90YWJsZSIsImR1bW15X2NsYXNzIiwibG9jIiwidW5kZWYiLCJjcmVhdGVfb2JqZWN0IiwiY3JlYXRlX29iamVjdF9vcHQiLCJvYmpfMCIsIml0ZXJfZiIsInJ1bl9pbml0aWFsaXplcnMiLCJpbml0cyIsInJ1bl9pbml0aWFsaXplcnNfb3B0IiwiY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpemVycyIsImdldF9kYXRhJDAiLCJidWlsZF9wYXRoIiwia2V5cyIsImxvb2t1cF90YWJsZXMiLCJyb290IiwidGFibGVzJDIiLCJ0YWJsZXMkMCIsInRhYmxlcyQxIiwibmV3X2NhY2hlIiwic2V0X21ldGhvZHMiLCJjbG8iLCJjbG8kMCIsIm4kMiIsIm4kMyIsIm4kNCIsIm4kNSIsIm4kNiIsIngkMyIsIm4kNyIsIngkNCIsIm4kOCIsImYkNyIsIm4kOSIsIngkNSIsImYkOCIsImUkMiIsIm4kMTAiLCJ4JDYiLCJmJDkiLCJuJDExIiwieCQ3IiwibiQxMiIsIngkOCIsIm4kMTMiLCJuJDE0IiwiZSQzIiwibiQxNSIsIm0kMiIsIngkOSIsIm0kMyIsIm4kMTYiLCJtJDQiLCJlJDQiLCJuJDE3IiwibSQ1IiwibiQxOCIsInN0YXRzJDAiLCJpbml0aWFsX2J1ZmZlciIsImJ1ZmZlciIsImJ1ZnBvcyIsInJlc2V0X2J1ZmZlciIsInN0b3JlIiwibmV3YnVmZmVyIiwiZ2V0X3N0cmluZyIsIm1ha2VfbGV4ZXIiLCJrZXl3b3JkcyIsImt3ZF90YWJsZSIsImlkZW50X29yX2tleXdvcmQiLCJpZCIsImtleXdvcmRfb3JfZXJyb3IiLCJlbmRfZXhwb25lbnRfcGFydCIsImV4cG9uZW50X3BhcnQiLCJudW1iZXIiLCJpZGVudDIiLCJuZWdfbnVtYmVyIiwibmV4dF90b2tlbiQwIiwiZXNjYXBlIiwibWF5YmVfY29tbWVudCIsImNvbW1lbnQiLCJuZXh0X3Rva2VuIiwiaGtleSIsImNsZWFuIiwiaW5zZXJ0X2J1Y2tldCIsImNvbnRhaW5lciIsInJlbW92ZV9idWNrZXQiLCJoayIsInJlcGxhY2VfYnVja2V0IiwiaXRlciQwIiwibmV3X2QiLCJidWNrZXRfbGVuZ3RoX2FsaXZlIiwic3RhdHNfYWxpdmUiLCJjcmVhdGUkNCIsImdldF9rZXkiLCJnZXRfa2V5X2NvcHkiLCJzZXRfa2V5IiwidW5zZXRfa2V5IiwiY2hlY2tfa2V5IiwiYmxpdF9rZXkiLCJnZXRfZGF0YSQxIiwiZ2V0X2RhdGFfY29weSIsInNldF9kYXRhIiwidW5zZXRfZGF0YSIsImNoZWNrX2RhdGEiLCJibGl0X2RhdGEiLCJzZXRfa2V5X2RhdGEiLCJjcmVhdGUkNSIsImdldF9rZXkxIiwiZ2V0X2tleTFfY29weSIsInNldF9rZXkxIiwidW5zZXRfa2V5MSIsImNoZWNrX2tleTEiLCJnZXRfa2V5MiIsImdldF9rZXkyX2NvcHkiLCJzZXRfa2V5MiIsInVuc2V0X2tleTIiLCJjaGVja19rZXkyIiwiYmxpdF9rZXkxIiwiYmxpdF9rZXkyIiwiYmxpdF9rZXkxMiIsImdldF9kYXRhJDIiLCJnZXRfZGF0YV9jb3B5JDAiLCJzZXRfZGF0YSQwIiwidW5zZXRfZGF0YSQwIiwiY2hlY2tfZGF0YSQwIiwiYmxpdF9kYXRhJDAiLCJrMiQwIiwiazEkMCIsImNyZWF0ZSQ2IiwibGVuZ3RoJDYiLCJnZXRfa2V5JDAiLCJnZXRfa2V5X2NvcHkkMCIsInNldF9rZXkkMCIsInVuc2V0X2tleSQwIiwiY2hlY2tfa2V5JDAiLCJibGl0X2tleSQwIiwibzEiLCJvMiIsImdldF9kYXRhJDMiLCJnZXRfZGF0YV9jb3B5JDEiLCJzZXRfZGF0YSQxIiwidW5zZXRfZGF0YSQxIiwiY2hlY2tfZGF0YSQxIiwiYmxpdF9kYXRhJDEiLCJraSIsImswIiwiZ2VuZXJpY19iYXNlbmFtZSIsImlzX2Rpcl9zZXAiLCJnZW5lcmljX2Rpcm5hbWUiLCJpc19yZWxhdGl2ZSIsImlzX2ltcGxpY2l0IiwiY2hlY2tfc3VmZml4Iiwic3VmZiIsInF1b3RlIiwiYmFzZW5hbWUiLCJkaXJuYW1lIiwiaXNfZGlyX3NlcCQwIiwiaXNfcmVsYXRpdmUkMCIsImlzX2ltcGxpY2l0JDAiLCJjaGVja19zdWZmaXgkMCIsInRlbXBfZGlyX25hbWUiLCJxdW90ZSQwIiwiYWRkX2JzIiwibG9vcCQwIiwibG9vcF9icyIsImRyaXZlX2FuZF9wYXRoIiwiZGlybmFtZSQwIiwicGF0aCIsImRyaXZlIiwiZGlyIiwiYmFzZW5hbWUkMCIsImJhc2VuYW1lJDEiLCJkaXJuYW1lJDEiLCJjdXJyZW50X2Rpcl9uYW1lJDIiLCJwYXJlbnRfZGlyX25hbWUkMiIsImRpcl9zZXAkMiIsImlzX2Rpcl9zZXAkMSIsImlzX3JlbGF0aXZlJDEiLCJpc19pbXBsaWNpdCQxIiwiY2hlY2tfc3VmZml4JDEiLCJ0ZW1wX2Rpcl9uYW1lJDAiLCJxdW90ZSQxIiwiYmFzZW5hbWUkMiIsImRpcm5hbWUkMiIsImNvbmNhdCQyIiwiY2hvcF9zdWZmaXgiLCJleHRlbnNpb25fbGVuIiwiZXh0ZW5zaW9uIiwiY2hvcF9leHRlbnNpb24iLCJyZW1vdmVfZXh0ZW5zaW9uIiwicHJuZyQwIiwidGVtcF9maWxlX25hbWUiLCJ0ZW1wX2RpciIsInJuZCIsImN1cnJlbnRfdGVtcF9kaXJfbmFtZSIsInNldF90ZW1wX2Rpcl9uYW1lIiwiZ2V0X3RlbXBfZGlyX25hbWUiLCJ0ZW1wX2ZpbGUiLCJ0cnlfbmFtZSIsImNvdW50ZXIkMSIsIm9wZW5fdGVtcF9maWxlIiwic3RoJDAiLCJwZXJtcyIsInN0aCQxIiwiYWRkJDEiLCJzdWIkMyIsIm5lZyIsImNvbmoiLCJtdWwiLCJkaXYiLCJpbnYiLCJub3JtMiIsIm5vcm0iLCJxJDAiLCJwb2xhciIsInNxcnQiLCJ3JDAiLCJleHAiLCJsb2ciLCJwb3ciLCJlbmFibGVkIiwiaWZfc3BhY2V0aW1lX2VuYWJsZWQiLCJjcmVhdGUkNyIsImNoYW5uZWwiLCJzYXZlX2V2ZW50IiwidGltZSIsImV2ZW50X25hbWUiLCJzYXZlX2FuZF9jbG9zZSIsInRha2UkMCIsImNsb3NlZCIsInNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHMiLCJmbG9hdDMyIiwiZmxvYXQ2NCIsImludDhfc2lnbmVkIiwiaW50OF91bnNpZ25lZCIsImludDE2X3NpZ25lZCIsImludDE2X3Vuc2lnbmVkIiwiaW50MzIkMSIsImludDY0JDEiLCJpbnQkMiIsIm5hdGl2ZWludCQxIiwiY29tcGxleDMyIiwiY29tcGxleDY0Iiwia2luZF9zaXplX2luX2J5dGVzIiwiY19sYXlvdXQiLCJmb3J0cmFuX2xheW91dCIsImRpbXMiLCJzaXplX2luX2J5dGVzIiwiY3JlYXRlJDgiLCJraW5kIiwibGF5b3V0IiwiZ2V0Iiwic2V0Iiwic2l6ZV9pbl9ieXRlcyQwIiwib2ZfdmFsdWUiLCJjcmVhdGUkOSIsImRpbSIsInNpemVfaW5fYnl0ZXMkMSIsInNsaWNlIiwib2ZfYXJyYXkiLCJiYSIsImNyZWF0ZSQxMCIsImRpbTEiLCJkaW0yIiwic2l6ZV9pbl9ieXRlcyQyIiwic2xpY2VfbGVmdCIsInNsaWNlX3JpZ2h0Iiwib2ZfYXJyYXkkMCIsInJvdyIsImNyZWF0ZSQxMSIsImRpbTMiLCJzaXplX2luX2J5dGVzJDMiLCJzbGljZV9sZWZ0XzEiLCJzbGljZV9yaWdodF8xIiwic2xpY2VfbGVmdF8yIiwic2xpY2VfcmlnaHRfMiIsIm9mX2FycmF5JDEiLCJjb2wiLCJhcnJheTBfb2ZfZ2VuYXJyYXkiLCJhcnJheTFfb2ZfZ2VuYXJyYXkiLCJhcnJheTJfb2ZfZ2VuYXJyYXkiLCJhcnJheTNfb2ZfZ2VuYXJyYXkiLCJyZXNoYXBlXzAiLCJyZXNoYXBlXzEiLCJyZXNoYXBlXzIiLCJyZXNoYXBlXzMiLCJwb2ludF9kZWZpbml0aW9ucyIsInBvaW50X2RlZmluaXRpb25zJDAiLCJiaXNlY3RfdmlzaXQiLCJzdGF0dXNfdG9fc3RyaW5nIiwiaW5pdF9pZGVudGl0eSIsImluaXRfdHJhbnNsYXRlIiwieCIsInkiLCJpbml0X3NjYWxlIiwiaW5pdF9yb3RhdGUiLCJhbmdsZSIsImluaXRfaW52ZXJzZSIsInh4IiwieXgiLCJ4eSIsInl5IiwieDAiLCJ5MCIsImQiLCJ4eCQwIiwieHkkMCIsInl4JDAiLCJ5eSQwIiwieDAkMCIsInkwJDAiLCJtdWx0aXBseSIsInh4JDEiLCJ4eSQxIiwieXgkMSIsInl5JDEiLCJ4MCQxIiwieTAkMSIsInRyYW5zZm9ybV9wb2ludCIsInRyYW5zZm9ybV9kaXN0YW5jZSIsImR4IiwiZHkiLCJzZXQiLCJtIiwic2NhbGUiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJpbnZlcnQiLCJzaXplIiwiZW1wdHkiLCJhZGQiLCJ4cyIsInN0b3BfcG9pbnQiLCJwYXJhbSIsImF1eCIsInh4cyIsInBvc2l0aW9uX2IiLCJhZGRlZF9iIiwicG9zaXRpb25fYSIsImFkZGVkX2EiLCJuIiwiY3JlYXRlX3JnYmEiLCJyIiwiZyIsImIiLCJhIiwiY3JlYXRlX3JnYiIsImdldF9yZ2JhIiwicGF0dGVybiIsImNvbG9yIiwiY3JlYXRlX2xpbmVhciIsIngxIiwieTEiLCJnZXRfbGluZWFyX3BvaW50cyIsInBvaW50cyIsImNyZWF0ZV9yYWRpYWwiLCJyMCIsInIxIiwiZ2V0X3JhZGlhbF9jaXJjbGVzIiwiY2lyY2xlcyIsImFkZF9jb2xvcl9zdG9wX3JnYmEiLCJvcHQiLCJzdGgiLCJvZnMiLCJncmFkaWVudCIsImdyYWRpZW50JDAiLCJhZGRfY29sb3Jfc3RvcF9yZ2IiLCJnZXRfY29sb3Jfc3RvcF9jb3VudCIsImdldF9jb2xvcl9zdG9wX3JnYmEiLCJpZHgiLCJzZXRfc3RhcnQiLCJ0cmFuc2Zvcm1hdGlvbiIsInNldF9jdXJyZW50IiwiY3VycmVudCIsInN0YXR1cyIsImNyZWF0ZSIsInN0YXRlIiwic3RhdGVzIiwibXV0YXRlX3N0YXRlIiwiY29udGV4dCIsImYiLCJzdGF0ZSQwIiwic2F2ZSIsInJlc3RvcmUiLCJzZXRfbWF0cml4IiwicyIsImdldF9tYXRyaXgiLCJ0cmFuc2Zvcm0iLCJpbml0IiwidHJhbnNmb3JtJDAiLCJzY2FsZSQwIiwidHJhbnNsYXRlJDAiLCJyb3RhdGUkMCIsImlkZW50aXR5X21hdHJpeCIsImRldmljZV90b191c2VyIiwiZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2UiLCJ1c2VyX3RvX2RldmljZSIsInVzZXJfdG9fZGV2aWNlX2Rpc3RhbmNlIiwibXV0YXRlX3BvaW50cyIsInN0YXJ0IiwiY3VycmVudCQwIiwibWFrZV9yZWxhdGl2ZSIsImR5JDAiLCJkeCQwIiwieSQxIiwieCQxIiwieSQyIiwieCQyIiwieSQzIiwieCQzIiwieSQwIiwieCQwIiwibW92ZV90byIsInJlbF9tb3ZlX3RvIiwibGluZV90byIsInJlbF9saW5lX3RvIiwiY3VydmVfdG8iLCJ4MyIsInkzIiwicmVsX2N1cnZlX3RvIiwicmVjdGFuZ2xlIiwiYXJjIiwiYTEiLCJhMiIsImFyY19uZWdhdGl2ZSIsImdldF9jdXJyZW50X3BvaW50IiwiY2xlYXIiLCJjbG9zZSIsInN0cm9rZV9wcmVzZXJ2ZSIsInN0cm9rZSIsImZpbGxfcHJlc2VydmUiLCJmaWxsIiwiY2xpcF9wcmVzZXJ2ZSIsImNsaXAiLCJwYWludCIsInNldF9saW5lX3dpZHRoIiwibGluZV93aWR0aCIsImdldF9saW5lX3dpZHRoIiwic2V0X2Rhc2giLCJkYXNoZXMiLCJnZXRfZGFzaCIsInNldF9maWxsX3J1bGUiLCJmaWxsX3J1bGUiLCJnZXRfZmlsbF9ydWxlIiwic2V0X2xpbmVfY2FwIiwibGluZV9jYXAiLCJnZXRfbGluZV9jYXAiLCJzZXRfbGluZV9qb2luIiwibGluZV9qb2luIiwiZ2V0X2xpbmVfam9pbiIsInNldF9taXRlcl9saW1pdCIsIm1pdGVyX2xpbWl0IiwiZ2V0X21pdGVyX2xpbWl0Iiwic2V0X29wZXJhdG9yIiwib3BlcmF0b3IiLCJnZXRfb3BlcmF0b3IiLCJzZXRfc291cmNlIiwic291cmNlIiwiZ2V0X3NvdXJjZSIsInNldF9zb3VyY2VfcmdiIiwic2V0X3NvdXJjZV9yZ2JhIiwic2VsZWN0X2ZvbnRfZmFjZSIsImZhbWlseSIsInNsYW50Iiwic3RoJDAiLCJ3ZWlnaHQiLCJzZXRfZm9udF9zaXplIiwic2hvd190ZXh0Iiwid2lkdGgiLCJmb250X2V4dGVudHMiLCJhc2NlbnQiLCJ0ZXh0X2V4dGVudHMiLCJoZWlnaHQiLCJ1bml0IiwiZmxvYXQkMCIsIm1hdHJpeCIsImNvb3JkcyIsImRhc2hlc19vZnMiLCJkcyIsImdldCIsInN0b3BfcG9pbnRzIiwiY291bnQiLCJwb3NpdGlvbiIsInkyIiwieDIiLCJyMiIsInkyJDAiLCJ4MiQwIiwieTEkMCIsIngxJDAiLCJtYXhfeV9hZHZhbmNlIiwibWF4X3hfYWR2YW5jZSIsImJhc2VsaW5lIiwiZGVzY2VudCIsInlfYWR2YW5jZSIsInhfYWR2YW5jZSIsInlfYmVhcmluZyIsInhfYmVhcmluZyIsIm1hdHJpeCQwIiwib3BlcmF0b3IkMCIsImZpbGxfcnVsZSQwIiwibGluZV9jYXAkMCIsImxpbmVfam9pbiQwIiwic291cmNlJDAiLCJkYXNoZXMkMCIsIm9wdGlvbiIsIm5hbWUiLCJwIiwiYyIsImNhbGxzIiwiY2FsbCIsImZvcm1hdCIsInByaW50X3JldCIsInJldCIsInByaW50ZWRfcmV0IiwiY2FsbCQxIiwiZXgiLCJjYWxsJDAiLCJjYWxscyQwIiwidyIsImgiLCJhbHBoYSIsImZvbnRfc2l6ZSIsImZvbnRfZXh0ZW50cyQwIiwidGV4dF9leHRlbnRzJDAiLCJzdGF0dXNfdG9fc3RyaW5nJDAiLCJzYXZlJDAiLCJyZXN0b3JlJDAiLCJzZXRfbWF0cml4JDAiLCJnZXRfbWF0cml4JDAiLCJ0cmFuc2Zvcm0kMSIsInNjYWxlJDEiLCJ0cmFuc2xhdGUkMSIsInJvdGF0ZSQxIiwiaWRlbnRpdHlfbWF0cml4JDAiLCJkZXZpY2VfdG9fdXNlciQwIiwiZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2UkMCIsInVzZXJfdG9fZGV2aWNlJDAiLCJ1c2VyX3RvX2RldmljZV9kaXN0YW5jZSQwIiwibW92ZV90byQwIiwicmVsX21vdmVfdG8kMCIsImxpbmVfdG8kMCIsInJlbF9saW5lX3RvJDAiLCJjdXJ2ZV90byQwIiwicmVsX2N1cnZlX3RvJDAiLCJyZWN0YW5nbGUkMCIsImFyYyQwIiwiYXJjX25lZ2F0aXZlJDAiLCJzdHJva2VfcHJlc2VydmUkMCIsInN0cm9rZSQwIiwiZmlsbF9wcmVzZXJ2ZSQwIiwiZmlsbCQwIiwiY2xpcF9wcmVzZXJ2ZSQwIiwiY2xpcCQwIiwicGFpbnQkMCIsInNldF9saW5lX3dpZHRoJDAiLCJnZXRfbGluZV93aWR0aCQwIiwic2V0X2Rhc2gkMCIsImdldF9kYXNoJDAiLCJzZXRfZmlsbF9ydWxlJDAiLCJnZXRfZmlsbF9ydWxlJDAiLCJzZXRfbGluZV9jYXAkMCIsImdldF9saW5lX2NhcCQwIiwic2V0X2xpbmVfam9pbiQwIiwiZ2V0X2xpbmVfam9pbiQwIiwic2V0X21pdGVyX2xpbWl0JDAiLCJnZXRfbWl0ZXJfbGltaXQkMCIsInNldF9vcGVyYXRvciQwIiwiZ2V0X29wZXJhdG9yJDAiLCJzZXRfc291cmNlJDAiLCJnZXRfc291cmNlJDAiLCJzZXRfc291cmNlX3JnYiQwIiwic2V0X3NvdXJjZV9yZ2JhJDAiLCJzZWxlY3RfZm9udF9mYWNlJDAiLCJzZXRfZm9udF9zaXplJDAiLCJzaG93X3RleHQkMCIsImNyZWF0ZSQwIiwiYmlzZWN0X3Zpc2l0JDAiLCJzdGF0dXNfdG9fc3RyaW5nJDEiLCJpbml0X2lkZW50aXR5JDAiLCJpbml0X3RyYW5zbGF0ZSQwIiwiaW5pdF9zY2FsZSQwIiwiaW5pdF9yb3RhdGUkMCIsImluaXRfaW52ZXJzZSQwIiwibXVsdGlwbHkkMCIsInRyYW5zZm9ybV9wb2ludCQwIiwidHJhbnNmb3JtX2Rpc3RhbmNlJDAiLCJzZXQkMCIsInNjYWxlJDIiLCJ0cmFuc2xhdGUkMiIsInJvdGF0ZSQyIiwiaW52ZXJ0JDAiLCJzaXplJDAiLCJlbXB0eSQwIiwiYWRkJDAiLCJ0b19saXN0IiwiY3JlYXRlX3JnYmEkMCIsImNyZWF0ZV9yZ2IkMCIsImdldF9yZ2JhJDAiLCJjcmVhdGVfbGluZWFyJDAiLCJnZXRfbGluZWFyX3BvaW50cyQwIiwiY3JlYXRlX3JhZGlhbCQwIiwiZ2V0X3JhZGlhbF9jaXJjbGVzJDAiLCJhZGRfY29sb3Jfc3RvcF9yZ2JhJDAiLCJhZGRfY29sb3Jfc3RvcF9yZ2IkMCIsImdldF9jb2xvcl9zdG9wX2NvdW50JDAiLCJnZXRfY29sb3Jfc3RvcF9yZ2JhJDAiLCJzZXRfc3RhdGUiLCJmb250Iiwic2V0X3N0YXJ0X3BvaW50X2lmX25vbmUiLCJ0cmFuc2Zvcm1hdGlvbiQwIiwic2V0X3N0YXJ0X3BvaW50X2FzX2N1cnJlbnRfcG9pbnQiLCJjdXJyZW50X3BvaW50Iiwic2V0X2N1cnJlbnRfcG9pbnQiLCJzYXZlJDEiLCJyZXN0b3JlJDEiLCJzZXRfbWF0cml4JDEiLCJnZXRfbWF0cml4JDEiLCJ0cmFuc2Zvcm0kMiIsInNjYWxlJDMiLCJ0cmFuc2xhdGUkMyIsInJvdGF0ZSQzIiwiaWRlbnRpdHlfbWF0cml4JDEiLCJkZXZpY2VfdG9fdXNlciQxIiwiZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2UkMSIsInVzZXJfdG9fZGV2aWNlJDEiLCJ1c2VyX3RvX2RldmljZV9kaXN0YW5jZSQxIiwibWFrZV9yZWwiLCJtb3ZlX3RvJDEiLCJyZWxfbW92ZV90byQxIiwibGluZV90byQxIiwicmVsX2xpbmVfdG8kMSIsImN1cnZlX3RvJDEiLCJyZWxfY3VydmVfdG8kMSIsInkzJDAiLCJ4MyQwIiwicmVjdGFuZ2xlJDEiLCJhcmMkMSIsImRpciIsImFyYyQyIiwiYXJjX25lZ2F0aXZlJDEiLCJnZXRfY3VycmVudF9wb2ludCQwIiwiY2xlYXIkMCIsImNsb3NlJDAiLCJzdHJva2VfcHJlc2VydmUkMSIsInN0cm9rZSQxIiwiZmlsbF9wcmVzZXJ2ZSQxIiwiZmlsbCQxIiwiY2xpcF9wcmVzZXJ2ZSQxIiwiY2xpcCQxIiwicGFpbnQkMSIsInNldF9saW5lX3dpZHRoJDEiLCJnZXRfbGluZV93aWR0aCQxIiwic2V0X2Rhc2gkMSIsImh0bWwiLCJnZXRfZGFzaCQxIiwic2V0X2ZpbGxfcnVsZSQxIiwiZ2V0X2ZpbGxfcnVsZSQxIiwic2V0X2xpbmVfY2FwJDEiLCJjYXAiLCJjYXAkMCIsImdldF9saW5lX2NhcCQxIiwic2V0X2xpbmVfam9pbiQxIiwiam9pbiIsImpvaW4kMCIsImdldF9saW5lX2pvaW4kMSIsInNldF9taXRlcl9saW1pdCQxIiwibCIsImdldF9taXRlcl9saW1pdCQxIiwic2V0X29wZXJhdG9yJDEiLCJnZXRfb3BlcmF0b3IkMSIsIm9wIiwic2V0X3NvdXJjZSQxIiwiY29udmVydCIsImNvbnZlcnRfcmdiYSIsInN0b3BfcG9pbnRzJDAiLCJnZXRfc291cmNlJDEiLCJzZXRfc291cmNlX3JnYiQxIiwic2V0X3NvdXJjZV9yZ2JhJDEiLCJzZXRfZm9udCIsImZvbnRfd2VpZ2h0IiwiZm9udCQwIiwic2VsZWN0X2ZvbnRfZmFjZSQxIiwic2V0X2ZvbnRfc2l6ZSQxIiwic2hvd190ZXh0JDEiLCJmb250X2V4dGVudHMkMSIsInRleHRfZXh0ZW50cyQxIiwiY3JlYXRlJDEiLCJjYW52YXMiLCJsb2NhbCIsInBvaW50X2RlZmluaXRpb25zIiwicG9pbnRfZGVmaW5pdGlvbnMkMCIsInBvaW50X2RlZmluaXRpb25zJDEiLCJwb2ludF9kZWZpbml0aW9ucyQyIiwibmFtZSIsIm5hbWUkMCIsIm5hbWUkMSIsInBvaW50X2RlZmluaXRpb25zJDMiLCJiaXNlY3RfdmlzaXQiLCJlcXVhbCIsInh4IiwieXgiLCJ4eSIsInl5IiwieDAiLCJ5MCIsIm0iLCJyZXByIiwiY2hlY2tfbWF0cml4IiwiY2hlY2tfY29vcmRzIiwicHJlY2lzaW9uIiwieTEiLCJ4MSIsInkiLCJ4IiwicmVwciQwIiwiZCIsImMiLCJiIiwiYSIsImNoZWNrX2Zsb2F0X3R1cGxlXzQiLCJyZXByJDEiLCJlIiwiY2hlY2tfZmxvYXRfdHVwbGVfNSIsInJlcHIkMiIsImYiLCJjaGVja19mbG9hdF90dXBsZV82IiwibWFrZSIsInAiLCJjdHgiLCJwJDAiLCJtYWtlJDAiLCJjaGVjayIsIm1ha2UkMSIsImV4cGVjdGVkIiwibWFrZSQyIiwicyIsImlkZW50aXR5IiwibWFrZSQzIiwibWFrZSQ0Iiwic3RhdHVzIiwibWFrZSQ1Iiwic2V0dGVyIiwiZ2V0dGVyIiwiaW5pdGlhbF92YWx1ZSIsIm90aGVyX3ZhbHVlIiwib3RoZXJfdmFsdWVzIiwidmFsdWUiLCJnIiwiciIsIm9mcyIsInJlcHIkMyIsImRhc2hlcyIsInJlcHIkNCIsInJlcHIkNSIsInJlcHIkNiIsInJlcHIkNyIsInRlc3QiLCJiaXNlY3RfdmlzaXQkMCIsIm1ha2VfbiIsImZzIiwiY2hlY2tzIiwiYWN0dWFsIiwibWFrZV9uJDAiLCJjYXRjaCQwIiwiZXJyb3IiLCJhc2NlbnQiLCJkZXNjZW50Iiwid2lkdGgiLCJiaXNlY3RfdmlzaXQkMSIsIm1ha2Vfc2ltcGxlIiwiaGVpZ2h0IiwiZHJhdyIsIm1ha2VfbGlzdCIsInZhbHVlcyIsImYyIiwiZjEiLCJhdXgiLCJuIiwib3BlcmF0b3IiLCJsaW5lX2pvaW4iLCJsaW5lX2NhcCIsImZpbGxfcnVsZSIsIm1pdGVyX2xpbWl0IiwidGVzdHMiLCJsaW5lX3dpZHRoIiwiYmlzZWN0X3Zpc2l0JDIiLCJkcmF3cyIsImN0eCQwIiwiZHJhd3MkMCIsImZhbWlseSIsIndlaWdodCIsInNsYW50IiwibGltaXRhdGlvbnMiLCJiaXNlY3RfdmlzaXQkMyIsImRyYXdpbmdfdGVzdHMiLCJuYW1lJDIiLCJjcmVhdGUiLCJiYWNrZW5kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7STs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWlCSUE7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDd0JBQztLQUNBQztLQUNBQztLQUlBQztLQUNBQzs7OztLQ3pCQUM7S0FvSEFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0N5N0VNQztLQVFRQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDMWpGZEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NxREVDO0tBQ0FDO0tBQ0FDOzs7S0EzRFlDO0tBOEVaQztLQUNBQztLQUNBQzs7O0tBK0RBQztLQUNBQztLQUNBQzs7O0tDN0lGQztLQUNBQztLQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7YUNtZklDOztPQWtDWTs7T0FsQ1o7Z0JBS0osSUFEUUMsY0FDQSxvQkFEQUE7Z0JBR1IsSUFEVUMsZ0JBQ0Esb0JBREFBO2dCQUdWLElBRE9DLGdCQUNBLG9CQURBQTtnQkFHUCxJQURTQyxnQkFDQSxvQkFEQUE7Z0JBS1QsSUFEYUMsZ0JBQ0Esb0JBREFBO2dCQURiLElBRFNDLGdCQUNBLG9CQURBQTtnQkFLVCxJQURTQyxnQkFDQSxvQkFEQUE7Z0JBR1QsSUFEUUMsZ0JBQ0Esb0JBREFBOztjQUVXQyxnQkFBSkMsWUFDSSxVQURKQSxHQUNJLFVBREFEOztjQUVTRSxnQkFBWEM7VUFDVSxVQURWQSxRQUNVLFVBRENEO2lCQUc1QixJQURTRSxnQkFDQSxxQkFEQUE7aUJBR1QsSUFEU0MsaUJBQ0EscUJBREFBO2lCQUdULElBRE9DLGlCQUNBLHFCQURBQTtpQkFHUCxJQURVQyxpQkFDQSxxQkFEQUE7aUJBR1YsSUFEa0JDLGlCQUNBLHFCQURBQSxVQUVVO2FBaUJ4QkMsYUFXSkMsT0FBT0M7TUFBVSxVQUFqQkQ7T0ErQmdCLE9BL0JUQzs7T0FBVSxPQUFqQkQ7Z0JBRUEsSUFEUWxCLEtBRFJrQixVQUVRLHVCQURBbEIsS0FERG1CO2dCQUlQLElBRFVsQixPQUhWaUIsVUFJVSx1QkFEQWpCLE9BSEhrQjtnQkFNUCxJQURPakIsT0FMUGdCLFVBTU8sdUJBREFoQixPQUxBaUI7Z0JBUVAsSUFEU2hCLE9BUFRlLFVBUVMsdUJBREFmLE9BUEZnQjtnQkFVUCxJQURhZixPQVRiYyxVQVVhLHVCQURBZCxPQVROZTtnQkFZUCxJQURTZCxPQVhUYSxVQVlTLHVCQURBYixPQVhGYztnQkFjUCxJQURTYixPQWJUWSxVQWNTLHVCQURBWixPQWJGYTtnQkFnQlAsSUFEUVosT0FmUlcsVUFnQlEsdUJBREFYLE9BZkRZOztjQTJCWVgsT0EzQm5CVSxVQTJCZVQsR0EzQmZTO1VBNEJtQixVQURKVCxHQUNJLGFBREFELE9BM0JaVzs7Y0E2Qm9CVCxPQTdCM0JRLFVBNkJzQkUsSUE3QnRCRixVQTZCaUJQLElBN0JqQk87VUE4QjJCLFVBRFZQLElBQUtTLElBQ0ssYUFEQVYsT0E3QnBCUztpQkFrQlAsSUFEU1AsT0FqQlRNLFVBa0JTLHdCQURBTixPQWpCRk87O1VBb0JQLElBRFNOLFFBbkJUSyxVQW9CUyx3QkFEQUwsUUFuQkZNOztVQXNCUCxJQURPTCxRQXJCUEksVUFzQk8sd0JBREFKLFFBckJBSzs7VUF3QlAsSUFEVUosUUF2QlZHLFVBd0JVLHdCQURBSCxRQXZCSEk7O1VBMEJQLElBRGtCSCxRQXpCbEJFLFVBMEJrQix3QkFEQUYsUUF6QlhHLFNBK0JlO2FBTWxCRSxXQUlKQyxLQUFLQztNQUFRLFVBQWJEO09BMkRBLE9BM0RLQzs7T0FBUSxPQUFiRDtnQkFrQkEsSUFES3RCLEtBakJMc0IsUUFrQksscUJBREF0QixLQWpCQXVCO2dCQW9CTCxJQURVdEIsT0FuQlZxQixRQW9CVSxxQkFEQXJCLE9BbkJMc0I7O2NBQ1FyQixPQURib0IsUUFDUUUsSUFEUkY7VUFFYSxVQURMRSxJQUNLLFdBREF0QixPQURScUI7O2NBR2FwQixPQUhsQm1CLFFBR2FHLE1BSGJIO1VBSWtCLFVBRExHLE1BQ0ssV0FEQXRCLE9BSGJvQjs7Y0FNa0JuQixPQU52QmtCLFFBTWlCSSxLQU5qQkosUUFNWUssTUFOWkwsUUFNS00sTUFOTE47VUFPdUIsVUFEbEJNLE1BQU9ELE1BQUtELEtBQ00sV0FEQXRCLE9BTmxCbUI7O2NBUW9CbEIsT0FSekJpQixRQVFtQk8sT0FSbkJQLFFBUWNRLE1BUmRSLFFBUU9TLFFBUlBUO1VBU3lCLFVBRGxCUyxRQUFPRCxNQUFLRCxPQUNNLFdBREF4QixPQVJwQmtCOztjQVV3QmpCLE9BVjdCZ0IsUUFVdUJVLE9BVnZCVixRQVVrQlcsTUFWbEJYLFFBVVdZLFFBVlhaO1VBVzZCLFVBRGxCWSxRQUFPRCxNQUFLRCxPQUNNLFdBREExQixPQVZ4QmlCOztjQVlvQmhCLE9BWnpCZSxRQVltQmEsT0FabkJiLFFBWWNjLE1BWmRkLFFBWU9lLFFBWlBmO1VBYXlCLFVBRGxCZSxRQUFPRCxNQUFLRCxPQUNNLFdBREE1QixPQVpwQmdCOztjQWNvQmYsT0FkekJjLFFBY21CZ0IsT0FkbkJoQixRQWNjaUIsTUFkZGpCLFFBY09rQixNQWRQbEI7VUFleUIsVUFEbEJrQixNQUFPRCxNQUFLRCxPQUNNLFdBREE5QixPQWRwQmU7O2NBcUJNYixPQXJCWFksUUFxQk1tQixNQXJCTm5CO1VBc0JXLFVBRExtQixNQUNLLFdBREEvQixPQXJCTmE7aUJBZ0NMLElBRE1YLE9BL0JOVSxRQWdDTSxzQkFEQVYsT0EvQkRXOztjQWtDZ0JWLFFBbENyQlMsUUFrQ2dCb0IsSUFsQ2hCcEI7VUFtQ3FCLFdBRExvQixJQUNLLFdBREE3QixRQWxDaEJVOztjQW9DY1QsUUFwQ25CUSxRQW9DY3FCLElBcENkckI7VUFxQ3FCLFdBRFBxQixJQUNPLFdBREY3QixRQXBDZFM7O2NBdUNtQlIsUUF2Q3hCTyxRQXVDaUJzQixNQXZDakJ0QixRQXVDWXVCLE1BdkNadkI7VUF3QzBCLFdBRGR1QixNQUFLRCxNQUNTLFdBREY3QixRQXZDbkJROztjQXlDcUJQLFFBekMxQk0sUUF5Q21Cd0IsUUF6Q25CeEIsUUF5Q2N5QixNQXpDZHpCO1VBMEMwQixXQURaeUIsTUFBS0QsUUFDTyxXQURBOUIsUUF6Q3JCTztpQkF3QkwsSUFETXlCLFFBdkJOMUIsUUF3Qk0sc0JBREEwQixRQXZCRHpCO2lCQTBCTCxJQURNMEIsUUF6Qk4zQixRQTBCTSxzQkFEQTJCLFFBekJEMUI7O2NBcUR1QjJCLFFBckQ1QjVCLFFBcURnQjZCLFdBckRoQjdCO1VBc0Q0QixXQURaNkIsV0FDWSxXQURBRCxRQXJEdkIzQjs7Y0F1RHVCNkIsUUF2RDVCOUIsUUF1RGdCK0IsV0F2RGhCL0I7VUF3RDRCLFdBRForQixXQUNZLFdBREFELFFBdkR2QjdCO2lCQThCTCxJQURPK0IsUUE3QlBoQyxRQThCTyxzQkFEQWdDLFFBN0JGL0I7O2NBNEMrQmdDLFFBNUNwQ2pDLFFBNEMwQmtDLFNBNUMxQmxDLFFBNENlbUMsVUE1Q2ZuQztVQTZDb0MsV0FEckJtQyxVQUFXRCxTQUNVLFdBREFELFFBNUMvQmhDOztjQThDc0JtQyxRQTlDM0JwQyxRQThDa0JxQyxRQTlDbEJyQztVQStDMkIsV0FEVHFDLFFBQ1MsV0FEQUQsUUE5Q3RCbkM7aUJBaURMLElBRGVxQyxRQWhEZnRDLFFBaURlLHNCQURBc0MsUUFoRFZyQzs7Y0FrRGVzQyxRQWxEcEJ2QyxRQWtEZXdDLElBbERmeEM7VUFtRG9CLFdBREx3QyxJQUNLLFdBREFELFFBbERmdEM7O2NBMkJhd0MsUUEzQmxCekMsUUEyQmUwQyxFQTNCZjFDLFFBMkJRMkMsTUEzQlIzQztVQTRCa0IsV0FEVjJDLE1BQU9ELEVBQ0csV0FEQUQsUUEzQmJ4QyxPQTJERDtvQ0EvR0FOLGFBbkRBbEIsVUFtR0FzQjs7O0lDbGxCTixTQU9FNkMsU0FBU0MsR0FBSSxpQkFBSkEsRUFBb0I7SUFQL0IsU0FRRUMsWUFBWUQsR0FBSSwwQkFBSkEsRUFBNkI7SUFSM0M7YUF1Q0VFLElBQUlDLEVBQUVDLEdBQU8sc0JBQVRELEVBQUVDLEdBQUZELEVBQUVDLENBQTJCO0lBdkNuQyxTQXdDRUMsSUFBSUYsRUFBRUMsR0FBTyx5QkFBVEQsRUFBRUMsR0FBRkQsRUFBRUMsQ0FBMkI7SUF4Q25DLFNBaUVFRSxJQUFJSCxHQUFJLFlBQUpBLFdBQTRCO0lBakVsQyxTQXVFRUksS0FBS0osR0FBSSxPQUFKQSxNQUFlO0lBc0V0Qjs7S0FFQTtLQUVBO0tBRUE7S0FFQTtLQUVBO0tBdkpBOztJQXVKQSxTQXNCRWEsSUFBTUMsR0FBR0M7TUFDWDtnQ0FEUUQ7T0FDUix5QkFEV0M7T0FDWCxvQkFBSUMsS0FBMEJDO01BRTlCLGlCQUhRSCxLQUVKakIsSUFEQW1CO01BR0osaUJBSldELEtBRVBsQixFQURBbUIsR0FBMEJDO01BRzlCLDRCQUZJcEIsRUFHb0I7SUEzQnhCLFNBaUNFcUIsWUFBWUM7TUFDZCxRQURjQSwwQkFDVyxtQ0FBbUQ7SUFsQzVFLFNBK0RFQyxlQUFlQyxHQUNqQixPQURpQkEsb0JBQ1k7SUFoRTdCLFNBaUVFQztNQUFpQjs7aUJBR1o7O2dCQUE0QjtJQXBFbkMsU0FzRUVDO01BQXFCOztrQkFHWjtJQXpFWCxTQTJFRUMsY0FBY0wsR0FDaEIsNEJBRGdCQSxFQUNDO0lBNUVqQixTQWdGRU0sa0JBQWtCNUI7TUFFcEI7UUFBUywrQkFGV0E7Ozs7UUFKcEIsV0FPc0I7SUFuRnRCLFNBdUZFNkIsa0JBQWtCN0I7TUFDcEIsNEJBRG9CQSxHQUVQckU7TUFDWDtXQUZFbUcsS0FDU25HLFNBQ0ksSUFIR3FFO1FBSVo7K0JBSllBLEVBRVByRTtTQUVMO1FENlBGLGFDNVBrQixRQUhYQTtRQUlKLE9BTldxRSxFQVFkO0lBL0ZOLFNBaUdFZ0MsZ0JBQWdCbkM7TUFBc0IsbURBQXRCQSxHQUE4QztJQWpHaEUsU0FxR0VvQyxvQkFBb0JqQztNQUV0QjtRQUFTLGlDQUZhQTs7OztRQUpBLFdBT0E7SUF4R3RCLFNDL0hFa0MsT0QyT1VmLEdBQUdDO01BQ2YsR0FEWUQsUUFHSmdCLEdBSEloQixNQUdWaUIsR0FIVWpCLE1BR1EsVUFBbEJpQixHQUFrQixPQUFaRCxHQUhPZixLQUVQLE9BRk9BLEVBR2M7SUFXbkI7O0tBQ0M7S0FDQTthQWNUb0IsYUFBYUMsS0FBS0MsS0FBS0M7TUFDRSxJQUF2QkMsRUFBdUIsMENBREZELEtBQVZGLEtBQUtDO01BRXBCLHlCQURJRSxFQURxQkQ7TUFFekIsT0FESUMsQ0FFSDtJQWpCVSxTQW1CVEMsU0FBU0YsTUFDWCw0QkFEV0EsS0FDNkQ7SUFwQjdELFNBc0JURyxhQUFhSCxNQUNmLDRCQURlQSxLQUMyRDtJQXZCL0QsU0E4QlRJO01BQ0YsU0FBUUM7UTtRQUFPOztnQkFFUmxCLGFBQUhtQjs7Y0FFTSxjQUZOQTs7Ozt3QkFBR25COztVQURHLFNBT0U7TUFDSixpREFBc0I7SUF4Q25CLFNBaURUb0IsYUFBYUMsR0FBR25EO01BQ2xCLDRCQURlbUQsR0FBR25ELElBQ2xCLHFCQURrQkEsR0FDbUI7SUFsRDFCLFNBb0RUb0QsY0FBY0QsR0FBR25EO01BQ25CLHNCQURnQm1ELEdBQUduRCxJQUNuQixzQkFEbUJBLEdBQzBCO0lBckRsQyxTQXVEVHFELE9BQU9GLEdBQUduRCxFQUFFc0QsSUFBSUM7TUFDbEIsUUFEY0Q7ZUFBSUM7b0NBQU52RCxLQUFNdUQsV0FBSkQ7Z0JBR1QscUJBSElILEdBQUduRCxFQUFFc0QsSUFBSUM7TUFFYiw4QkFDMEI7SUExRHBCLFNBNERUQyxpQkFBaUJMLEdBQUduRCxFQUFFc0QsSUFBSUM7TUFDNUIsUUFEd0JEO2VBQUlDO3FDQUFOdkQsS0FBTXVELFdBQUpEO2dCQUduQixlQUhjSCxHQUFHbkQsRUFBRXNELElBQUlDO01BRXZCLHdDQUNpQztJQS9EM0IsU0FzRVRFLGFBQWFDLEtBQUtDLEdBQUkseUJBQVRELEtBQUtDLElBQWdDO0lBdEV6QyxTQTRFVEMsVUFBVVQsSUFBSyxjQUFMQSxJQUFLLDZCQUFMQSxHQUFtQztJQTVFcEMsU0E2RVRVLGdCQUFnQlY7TUFDbEIsS0FBSyxjQURhQTtNQUVsQjtRQUFLLCtCQUZhQSxJQUVrQjsyQkFBRztJQS9FNUIsU0F3RlRXLFlBQVlyQixLQUFLQyxLQUFLQztNQUNFLElBQXRCQyxFQUFzQix5Q0FERkQsS0FBVkYsS0FBS0M7TUFFbkIseUJBRElFLEVBRG9CRDtNQUV4QixPQURJQyxDQUVIO0lBM0ZVLFNBNkZUbUIsUUFBUXBCLE1BQ1YseUJBRFVBLEtBQ2lDO0lBOUZoQyxTQWdHVHFCLFlBQVlyQixNQUNkLHlCQURjQSxLQUMrQjtJQWpHbEMsU0F3R1RzQixNQUFNQyxHQUFHbEUsRUFBRXNELElBQUlDO01BQ2pCLFFBRGFEO2VBQUlDO29DQUFOdkQsS0FBTXVELFdBQUpEO2dCQUdSLGNBSEdZLEdBQUdsRSxFQUFFc0QsSUFBSUM7TUFFWiw2QkFDeUI7SUEzR25CLFNBNkdMWSxvQkFBb0JELEdBQUdsRSxFQUFFc0QsSUFBSUM7VUFBSmEsVUFBSUM7TUFDbkM7ZUFEbUNBO1VBQ1YsSUFDbkJDLEVBRG1CLGNBRENKLEdBQUdsRSxFQUFFb0UsTUFBSUM7VUFDVixTQUNuQkM7VUFEbUIsSUFJbEIsTUFMNEJELFFBRTdCQyxNQUdDLE1BTHdCRixRQUV6QkUsTUFGeUJGLFlBQUlDOztRQUNsQixTQUtkO0lBbkhRLFNBcUhUSSxhQUFhUCxHQUFHbEUsRUFBRXNELElBQUlDO01BQ3hCLFFBRG9CRDtlQUFJQztvQ0FBTnZELEtBQU11RCxXQUFKRDtnQkFHZixvQkFIVVksR0FBR2xFLEVBQUVzRCxJQUFJQztNQUVuQixvQ0FDZ0M7SUF4SDFCLFNBMEhUbUIsb0JBQW9CUixHQUFHWDtNQUN6QixJQUFJdkQsRUFBSixrQkFEeUJ1RDtNQUV6QixhQUZzQlcsR0FDbEJsRSxJQURxQnVEO01BRXpCLDRCQURJdkQsRUFFb0I7SUE3SGIsU0FpSVQyRSxXQUFXakI7TUFDYixTQUFRa0IsYUFBYUM7Ozs7Z0JBRWIxQyxjQUFOQyxjQUNNbUIseUJBRE5uQjtZQUVFLGdCQUZGQSxLQUZtQnlDLFlBR2J0QjtZQUNKLGtCQURJQSw0QkFEQXBCOztVQURBLE9BRGEwQztVQU1SQyxPQUFLdkI7TUFDaEI7WUFBSWpDLEVBQUosZ0NBUldvQztRQVFYLFNBQUlwQztVQUNVLEtBRkh3RDttQkFLWSwrQkFMUHZCLFNBQUx1Qjs7VUFNRixVQUxMeEQ7WUFhSyxJQUNIeUQsSUFERyxvQkFiTHpEO1lBZUksY0F2QkdvQyxLQXNCTHFCLFFBZEZ6RDtZQWFLLElBRUQsTUFoQlFpQyxNQUNaakMsTUFlSSxVQURGeUQsSUFmS0Qsa0JBQUt2Qjs7VUFNTyxJQUNqQjBCLElBRGlCLGtCQUxuQjNEO1VBT0ssY0FmRW9DLEtBY0x1QixNQU5GM0Q7VUFRSyxtQkFoQkVvQztVQWdCRixHQVRFb0I7V0FZRDttQkFaTXZCLE1BQ1pqQztpQkFZbUIsK0JBRFQrQyxnQkFMUlksSUFQS0g7O29CQU9MRzswQ0FZNkI7SUEzSjFCLFNBb0tUQyxlQUFlaEI7TUFBSztRQUFLLCtCQUFWQSxJQUFnQzsyQkFBRztJQXBLekMsU0EwS1RpQixXQUFXdkMsR0FBSSwyQkEzS2ZOLE9BMktXTSxFQUF3QjtJQTFLMUIsU0EyS1R3QyxhQUFhcEYsR0FBSSxxQkE1S2pCc0MsT0E0S2F0QyxFQUEwQjtJQTNLOUIsU0E0S1RxRixZQUFZckYsR0FBSSxvQkE3S2hCc0MsT0E2S1l0QyxFQUF5QjtJQTVLNUIsU0E2S1RzRixVQUFVM0o7TUFBeUIscUJBOUtuQzJHLE9BOEttQyxxQkFBekIzRyxHQUEwQztJQTdLM0MsU0E4S1Q0SixZQUFZMUYsR0FBeUIscUJBL0tyQ3lDLE9BK0txQyxnQkFBekJ6QyxHQUE0QztJQTlLL0MsU0ErS1QyRixjQUFjeEY7TUFDaEIsY0FqTEVzQyxPQWdMY3RDO01BQ1Esb0JBakx0QnNDO01BaUxzQixxQkFqTHRCQSxPQWlMMkQ7SUFoTGxELFNBaUxUbUQ7TUFBbUIsb0JBbExuQm5ELFdBa0xtQixxQkFsTG5CQSxPQWtMd0Q7SUFqTC9DLFNBcUxUb0QsV0FBVzlDLEdBQUksMkJBckxmTCxPQXFMV0ssRUFBd0I7SUFyTDFCLFNBc0xUK0MsYUFBYTNGLEdBQUkscUJBdExqQnVDLE9Bc0xhdkMsRUFBMEI7SUF0TDlCLFNBdUxUNEYsWUFBWTVGLEdBQUksb0JBdkxoQnVDLE9BdUxZdkMsRUFBeUI7SUF2TDVCLFNBd0xUNkYsVUFBVWxLO01BQXlCLHFCQXhMbkM0RyxPQXdMbUMscUJBQXpCNUcsR0FBMEM7SUF4TDNDLFNBeUxUbUssWUFBWWpHLEdBQXlCLHFCQXpMckMwQyxPQXlMcUMsZ0JBQXpCMUMsR0FBNEM7SUF6TC9DLFNBMExUa0csY0FBYy9GO01BQ2hCLGNBM0xFdUMsT0EwTGN2QztNQUNRLG9CQTNMdEJ1QztNQTJMc0IscUJBM0x0QkEsT0EyTDJEO0lBM0xsRCxTQTRMVHlEO01BQW1CLG9CQTVMbkJ6RCxXQTRMbUIscUJBNUxuQkEsT0E0THdEO0lBNUwvQyxTQWdNVDBELGlCQUFlLGNBak1mM0QsUUFpTWUsa0JBbE1mRCxNQWtNNkM7SUFoTXBDLFNBaU1UNkQsZ0JBQTJCLHVDQUFhO0lBak0vQixTQWtNVEMsb0JBQW1DLHNDQUFhO0lBbE12QyxTQW1NVEMsa0JBQStCLHlDQUFhO0lBbk1uQyxTQW9NVEMsc0JBQXVDLHdDQUFhO0lBcE0zQzthQThOVEMsd0IsSUFBZ0MvSDtJQTlOdkIsU0FvT1RnSTtNQUVNO09BRnNDQztPQUFOcEo7T0FBaEJxSjtPQUFOdEo7T0FFVixTQUZnQnNKLEtBRVQsVUFGK0JEO01BQ3RDLHFCQURVckosS0FBc0JDO0lBcE83QixJQTRPVHNKLGlCQTlNQTNEO0lBOUJTLFNBOE9UNEQsUUFBUTlHO01BQ1YsTUFIRTZHLGlCQUdGOzs7O1FBS0ksT0FIQUcsa0JBRzJCLHFCQUE2QixXQU5sRGhIO1FBTXFELGtCQUwzRCtHLElBTUc7TUFOUCxRQU1RO0lBclBHLFNBdVBURSxrQkFBZ0Isa0JBWGhCSixtQkFXbUM7SUF2UDFCLFNBeVBUSyxLQUFLQztNQUNQLDJDQURPQSxRQUVTO0lBRVY7OztPQXhnQkovRztPQURBRjs7T0FnQ0FHO09BQ0FHO09BeUJBQztPQVlBUTtPQUNBQztPQVBBUjtPQXFFQUM7T0FFQUM7T0FFQUM7T0FFQUM7T0FFQUM7T0FFQUM7T0F1QkFHO09BV0FLO09BOEJBRTtPQUVBRTtPQUtBQztPQUtBQztPQUtBQztPQWlCQUk7T0FJQUM7T0NwT0FDO09EeVBBRztPQUNBQztPQUNBQztPQTBLQTRDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUFDO09BSUFDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUFDO09BSUFDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BakxBeEQ7T0FHQUM7T0FSQU47O09BZ0JBTzs7T0FzQkFLO09BSEFGO09BTUFHO09BS0FHOzs7T0FVQUM7Ozs7T0FNQUc7T0FDQUM7O09BZ0JBRTtPQUdBQztPQVJBRjs7T0F5Q0FhO09BekJBVjtPQWFBUTtPQUtBQzs7Ozs7Ozs7T0EwQ0FROzs7Ozs7Ozs7T0EwREFvQjtPQU1BQztPQXFCQVE7T0FYQUo7T0FuUkE5RTtPQWtKSXNDO09BMElKMkM7S0FNSTs7O09BeGdCSjdHO09BREFGOztPQWdDQUc7T0FDQUc7T0F5QkFDO09BWUFRO09BQ0FDO09BUEFSO09BcUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQXVCQUc7T0FXQUs7T0E4QkFFO09BRUFFO09BS0FDO09BS0FDO09BS0FDO09BaUJBSTtPQUlBQztPQ3BPQUM7T0R5UEFHO09BQ0FDO09BQ0FDO09BMEtBNEM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FFQUM7T0FJQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FFQUM7T0FJQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FqTEF4RDtPQUdBQztPQVJBTjs7T0FnQkFPOztPQXNCQUs7T0FIQUY7T0FNQUc7T0FLQUc7OztPQVVBQzs7OztPQU1BRztPQUNBQzs7T0FnQkFFO09BR0FDO09BUkFGOztPQXlDQWE7T0F6QkFWO09BYUFRO09BS0FDOzs7Ozs7OztPQTBDQVE7OztPQTBEQW9CO09BTUFDO09BcUJBUTtPQVhBSjtPQW5SQTlFO09Ba0pJc0M7T0EwSUoyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQU1JO2FFbGhCSkcsYUFBVyxRQUFHO2FBRWRDLFNBQU8vRyxTQUFPLFVBQVBBLEVBRlA4RyxNQUU2QjthQUV6QkUsSUFBSXRILEVBQUV1SDtNQUFlLHFCQUFmQTtNQUFlO1FBRUk7U0FBcEJDO1NBQUhsSDtTQUF1QixvQixPQUZ6QmdILElBQUl0SCxFQUVDd0g7UUFBZSxxQkFGaEJ4SCxFQUVGTTtNQURDLFFBQ2lDO2FBRXBDbUgsV0FBV3pILEVBQUV1SDtNLElBQUFHO01BQVM7UUFBTSxxQkFBZkE7UUFBZTtVQUd4QixJQURDRixjQUFIbEgsV0FDRSxtQkFIT04sRUFFVE07VUFDRTtZQUVRLElBQUxDO1lBQWMsVUFBZEEsaUIsT0FMUGtILFdBQVd6SCxFQUVOd0g7VUFDRCxJQUhTRSxNQUVSRjs7UUFERixTQUlvQzthQUV2Q0csT0FBTzNILEVBQUV1SDtNLElBQUFHO01BQVM7UUFBTSxxQkFBZkE7UUFBZTtjQUVuQkYsY0FBSGxIO1VBQ0QsY0FITU4sRUFFTE07c0MsT0FGRnFILE9BQU8zSCxFQUVGd0g7Y0FGSUUsTUFFSkY7O1FBREYsU0FJZ0I7YUFFbkJJLG1CQUFTNUgsRUFBRXVIO01BQWUscUJBQWZBO01BQWU7UUFHZixJQUROQyxjQUFIbEgsV0FDUyxnQkFIRk4sRUFFUE07UUFDUzs7aUJBR2Z1SCx5QkFOYTdILE9BRUp3SDtzQ0FJVEssa0JBTmE3SCxPQUVKd0g7TUFERixRQUVxQjthQUc1QkssdUJBQWE3SCxFQUFFdUgsSUFBSU87TUFBZ0IscUJBQXBCUDtNQUFvQjtZQUUxQkMsY0FBSGxIO1FBQ0csVUFESEEsaUIsT0FGTnlILGFBQWEvSCxFQUVKd0gsS0FGVU07TUFBZ0I7TUFDNUI7O2VBUEhGLHFCQU1TNUgsRUFBTThIO29DQU5mRixjQU1TNUgsRUFBTThILFdBR2U7YUFUOUJFLFNBQVNoSSxFQUFFdUg7TSx1QkFBWEssYUFBUzVILEVBQUV1SDthQU1mUSxhQUFhL0gsRUFBRXVILElBQUlPO00sdUJBQW5CRCxpQkFBYTdILEVBQUV1SCxJQUFJTzthQUtuQkcsVUFDVWpJLEVBQUVrSSxJQUFJWDtVQUFKWSxVQUFJVDtNQUFNO1FBQU0scUJBQVpBO1FBQVk7VUFHZDtXQURIRjtXQUFIbEg7V0FDTSxpQkFISk4sRUFBRW1JLE1BRUo3SDtXQUZJNkg7V0FBSVQsTUFFTEY7O1FBREYsT0FER1csTUFNRDthQUVYaEYsS0FBS25ELEVBQ0t1SDtNLElBQUFHO01BQU07UUFBTSxxQkFBWkE7UUFBWTtjQUVYRixjQUFIbEg7VUFDSixXQUpDTixFQUdHTTtjQUZFb0gsTUFFQ0Y7O1FBREYsU0FLSjs7O1NBakRMSixNQUVBQyxTQUVJQyxJQVdBSyxPQVBBRixXQWNBTyxTQVdKQyxVQVNBOUU7O2FDN0NBeEUsSUFBSThDO01BQ04sUUFETUEsMEJBQ21CLGdDQUF3QzthQU8vRDRHLFFBT0F0RjtNQVBVLFNBT1ZBOzs7Ozs7Ozs7O2tCQURRO2tCQUZBO21CQURBO21CQUVBOztNSnVlSjtRSXBlRixJQUFJdUYsSUFBSjs4QkFBSUEsTUFETnZGO1FBQ0UsNEJBQUl1RjtNQUlKLElBQ0luSSxFQURKOzRCQUNJQTtNQURKLHNCQUNJQSxVQU5ONEM7TUFLRSxzQkFDSTVDLFdBTk40QztNQUtFLHNCQUNJNUMsVUFOTjRDO01BS0UsNEJBQ0k1QyxFQUtjO2FBRXBCb0ksVUFBVXhGO01BQ1osbUJBRFlBO01Kd2ROOzRCSXhkTUE7OztNQUlQLE9BSk9BLFVBS047YUFFSnlGLFVBQVV6RjtNQUNaLG1CQURZQTtNSmlkTjs0QklqZE1BOzs7TUFJUCxPQUpPQSxVQUtOO2FBRUowRixnQkFBZ0IxRjtNQUNsQixTQURrQkEsa0NBR2IsT0FIYUEsQ0FHWjthQUVKMkYsZ0JBQWdCM0Y7TUFDbEIsU0FEa0JBLG1DQUdiLE9BSGFBLENBR1o7YUFJSjRGLFFBQVFDLEdBQUdDLElBQUssT0FBUkQsS0FBR0MsTUFBc0I7YUFDakNDLE1BQU9GLEdBQVFDLElBQVMsY0FBakJELEtBQVFDLFdBQTBCOzs7O09BdkR6Q2xLO09BUUEwSjtPQW9CQUU7T0FPQUM7T0FPQUM7T0FLQUM7T0FPQUM7T0FDQUc7OztLWG5EQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FFQUM7S0FDQUM7YUFFQUMsS0FBS0M7TUFDUCxPQURPQTtlQUxMSjtlQUtLSSxjQUVTLFlBaEJkL08sYUFjSytPLFNBR0Y7YUFFSEMsS0FBS0Q7TUFDUCxPQURPQSxZQVhMTCxTQVdLSyxRQUVTLFlBdEJkaFAsYUFvQktnUCxTQUdGO2FBRUhFLFNBQVMxTjtNQUFJLGNBQUpBLE1BQUksVUFBSkE7Ozs7O01BSlgsV0FJeUU7YUFDdkUyTixPQUFPM047TUFBTyxnQkFBUEE7O2VRVlBzRTtpQlJkZTt5Q0F3QlJ0RTt1REFBd0Q7YUFJL0Q0TixRQUFRSixHQUFJLE9BQUpBLFdBQVc7YUFDbkJLLFFBQVE1RyxHQUFJLE9BQUpBLENBQWU7YUFDdkI2RyxRQUFRTjtNQUNWLGFBRFVBO2VRaEJSbEo7aUJSYjBCOzs7NkNBNkJsQmtKO2dCQUVPO2FBRWZPLHFCQUhGLFdBQ2lCO2FBSWZDLG1CO1FBQ0FDO2FBQ0FDLFc7Ozs7O09BakNBakI7T0FDQUM7T0FJQUc7T0FDQUM7T0FFQUM7T0FLQUU7T0FLQUM7T0FDQUM7c0I7O09BSUFDO09BQ0FDO09BQ0FDO09BSUFDO09BRUFDO09BQ0FDO09BQ0FDOztJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09ZWEFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7STthSHpCQUMsT0FBT2pJOzs7O1VBRkMsdURBQUxrSTs7UUFERyxXQUdtQjthQUV6QkMsS0FBS2hILEVBQUVuQixHQUFJLFVBQU5tQixFQUFFbkIsRUFBUTthQUVmTTtNQUFLLFVBRUcsSUFBUmEsV0FBUSxPQUFSQSxFQURNLHVCQUNHO2FBRVRkO01BQUssVUFFRyxJQUFMTCxXQUFLLE9BQUxBLEVBREcsdUJBQ0c7YUFFVG9JLElBRWNwSSxFQUFFUjtNQURsQixRQUNrQkE7WUFBRjZJLE1BQUVDO1FBQ2hCO2FBRGNEO2dCQUdURSxJQUhTRixPQUdabEgsRUFIWWtIO3FCQUFFQyxXQUdkbkg7WUFBNkIsUUFIZm1ILFlBQUZELElBR1RFLElBSFdEOztVQUVSO01BSEksZ0NBS0E7YUFFWkcsUUFFY3pJLEVBQUVSO01BRGxCLFFBQ2tCQTtZQUFGNkksTUFBRUM7UUFDaEI7YUFEY0Q7Z0JBR1RFLElBSFNGLE9BR1psSCxFQUhZa0g7cUJBQUVDLGNBR2RuSDtZQUFrQyxRQUhwQm1ILFlBQUZELElBR1RFLElBSFdEOztVQUVSO01BSEksa0NBS0E7YUFJUkksV0FBV3JKLEdBQUdDO1VBQUhxSixRQUFHQztNQUNwQjtXQURpQkQ7MkJBR2Z4SCxFQUhld0gsUUFBR0csUUFHbEIzSCxFQUhrQnlILE1BQUhELFVBQUdDOztRQUVaLE9BRllBLEtBR2M7YUFFaENHLElBQUkvSSxHQUFJLGtCQUFKQSxJQUFtQjthQU1uQmdKLFNBQVNuUCxFQUFFMkYsRUFBRXpCO01BQ25CLEdBRGlCeUIsS0FBRjNGO01BR0wsSUFBSjJJLEVBQUksV0FIU3pFLEVBQUpsRTtNQUlSLFVBREQySSxFQUNDLFNBSlEzSSxVQUFFMkYsRUFBRXpCLEdBSU07UUFFdkJrTDtrQkFNS3hILElBQUkxRDtNQUNYLFFBRE8wRDtRQUVQLEdBUkV3SCxxQkFNS3hIO2NBaEJnQndFLE1BQUlwTTtVQUMzQjtlQWVPNEgsT0FoQm9CNUgsU0FGekJrUCxJQUVxQjlDO1lBRWxCLFFBRnNCcE0sVUFFSixvQkFjWmtFLEVBaEJnQmxFLEdBQUpvTSxlQUFJcE07O1FBbUJ0QixrQkFIRTRILElBQUkxRDtNQUNLLGlDQUVLOztNQUVMLGNBRVh5RSxXQUFIeEMsV0FBWSxjQUFaQSxFQUFZLFFBQVR3QztNQURHLFFBQ2U7bUJBSWJ6RTtNO1FBRVEsSUFBYmlDLFdBQUhtQixXQUFnQixhQUZScEQsRUFFUm9ELEdBQTRCLFVBQWhCcUIsRUFBZ0IsTUFGcEJ6RSxFQUVMaUM7TUFERztpQkFHR25HLEVBQUVrRTtNO1FBRUssSUFBYmlDLFdBQUhtQixXQUFnQixhQUZMcEQsRUFBRmxFLEVBRVRzSDtRQUE4QixVQUFsQnFCLEVBQWtCLElBRnJCM0ksVUFBRWtFLEVBRVJpQztNQURHO2tCQUdEakMsRUFBRWlDLEdBQUksYUFBTmpDLEVBQUVpQyxFQUFjO3FCQUViakMsRUFBRW1MOzs7O1VBR1E7V0FBYmxKO1dBQUhtQjtXQUFnQixxQkFIVnBELEVBR05vRDs7bUJBQUduQjs7UUFERyxZQUdDO29CQUdBakM7TTs7O2NBRU5pQyxhQUFIbUI7VUFBUSxXQUZDcEQsRUFFVG9EO3NCQUFHbkI7O1FBREc7bUJBT0FqQyxFQUFFc0s7Ozs7Y0FGTHJJLFdBQUhtQjtVQUFRLFdBRUZwRCxJQUZOb0Q7VUFBUSw4QkFBTG5COztRQURHLFNBR2lCO3lCQUVUakMsRUFBRWlGLEtBQUtoRDtVQUFMa0QsWUFBS21GO01BQ3ZCO1dBRHVCQTtVQUdEO1dBQWpCRSxJQUhrQkY7V0FHckJsSCxFQUhxQmtIO1dBR0Qsa0JBSE50SyxFQUFFbUYsT0FHaEIvQjtXQUhnQitCO1dBQUttRixJQUdsQkU7O1FBREcsT0FGVXJGLE9BR2dCO3dCQUVqQm5GLEVBQUVpQyxFQUFFZ0Q7TUFDckIsR0FEbUJoRCxPQUdkcUksSUFIY3JJLEtBR2pCbUIsRUFIaUJuQixLQUdMLGtCQUhHakMsRUFHZm9ELEVBQVksV0FIR3BELEVBR1pzSyxJQUhnQnJGO01BRWIsT0FGYUEsSUFHYztrQkFFeEJqRixFQUFFc0IsR0FBR0M7TUFDaEIsR0FEYUQ7V0FBR0M7VUFHYyxJQUFmc0osS0FIQ3RKLE1BR0w4SixHQUhLOUosTUFHVHFKLEtBSE10SixNQUdWZ0ssR0FIVWhLLE1BR2lCLGFBSG5CdEIsRUFHUnNMLEdBQVFEO1VBQW1DLFVBQXBCNUcsRUFBb0IsS0FIbkN6RSxFQUdKNEssS0FBUUM7O1lBSEN0SjtNQUlKLGlDQUF1QjtzQkFFeEJ2QixFQUNVc0IsR0FBR0M7VUFBUjBELE9BQUsyRixRQUFHQztNQUN0QjtXQURtQkQ7YUFBR0M7WUFHUzthQUFoQkUsS0FIT0Y7YUFHWFEsR0FIV1I7YUFHZkMsS0FIWUY7YUFHaEJVLEdBSGdCVjthQUdZLHFCQUp0QjVLLEVBSU5zTCxHQUFRRCxJQUhHcEc7O2FBQUsyRixLQUdaRTthQUhlRCxLQUdQRTs7O2NBSE9GLFlBQVI1RjtRQUlGLHNDQUVFO21CQUdKakYsRUFBRXNCLEdBQUdDO1VBQUhxSixRQUFHQztNQUNqQjtXQURjRDthQUFHQztnQkFHRkUsS0FIRUYsUUFHTlEsR0FITVIsUUFHVkMsS0FIT0YsUUFHWFUsR0FIV1Y7WUFHUSxXQUhWNUssRUFHVHNMLEdBQVFEO2dCQUhHVCxLQUdQRSxLQUhVRCxLQUdGRTs7O2NBSEVGO1FBSUwsbUNBQXdCO3dCQUVuQjdLLEVBQUVpRixLQUFLM0QsR0FBR0M7VUFBUjRELFlBQUt5RixRQUFHQztNQUMzQjtXQUR3QkQ7YUFBR0M7WUFHUTthQUFwQkUsS0FIWUY7YUFHaEJRLEdBSGdCUjthQUdwQkMsS0FIaUJGO2FBR3JCVSxHQUhxQlY7YUFHVyxrQkFIbEI1SyxFQUFFbUYsT0FHaEJtRyxHQUFRRDthQUhRbEc7YUFBS3lGLEtBR2pCRTthQUhvQkQsS0FHWkU7OztjQUhZRixZQUFSMUY7UUFJUCx3Q0FBNkI7eUJBRXZCbkYsRUFBRXNCLEdBQUdDLEdBQUcwRDtNQUMxQixHQURvQjNEO1dBQUdDO2NBR1JzSixLQUhRdEosTUFHWjhKLEdBSFk5SixNQUdoQnFKLEtBSGF0SixNQUdqQmdLLEdBSGlCaEs7VUFHVSxrQkFIWnRCLEVBR2ZzTCxHQUFRRCxHQUFtQixZQUhackwsRUFHWDRLLEtBQVFDLEtBSFc1Rjs7WUFBSDFELFVBQUcwRDtNQUlkLHdDQUE4QjtxQkFFNUJzRztNOzs7VUFFSixJQUFMdEosYUFBSG1CLGFBQVEsZ0JBRkltSSxFQUVabkk7VUFBUSxxQkFBTG5CO1VBREc7O29CQUdLc0o7TTs7O1VBRUgsSUFBTHRKLGFBQUhtQixhQUFRLGdCQUZHbUksRUFFWG5JO1VBQVE7c0JBQUxuQjs7UUFERztzQkFHT3NKLEVBQUVqSyxHQUFHQztVQUFIcUosUUFBR0M7TUFDcEI7V0FEaUJEO2FBQUdDO1lBR0U7YUFBUEUsS0FIS0Y7YUFHVFEsR0FIU1I7YUFHYkMsS0FIVUY7YUFHZFUsR0FIY1Y7YUFHSyxnQkFIUFcsRUFHWkQsR0FBUUQ7WUFBVyxhQUhMVCxLQUdWRSxLQUhhRCxLQUdMRTs7O2NBSEtGO1FBSVIsc0NBQTJCO3FCQUV6QlUsRUFBRWpLLEdBQUdDO1VBQUhxSixRQUFHQztNQUNuQjtXQURnQkQ7YUFBR0M7WUFHRzthQUFQRSxLQUhJRjthQUdSUSxHQUhRUjthQUdaQyxLQUhTRjthQUdiVSxHQUhhVjthQUdNLGdCQUhSVyxFQUdYRCxHQUFRRDtZQUFXO2dCQUhOVCxLQUdURSxLQUhZRCxLQUdKRTs7O2NBSElGO1FBSVAscUNBQTBCO2lCQUU1QnZLO007OztVQUVBLElBQUwyQixhQUFIbUIsYUFBUSx3QkFBUkEsRUFGUTlDO1VBRUE7c0JBQUwyQjs7UUFERztrQkFHRzNCO007OztjQUVOMkIsYUFBSG1CLHdCQUZTOUM7O3NCQUVOMkI7O1FBREc7bUJBR0kzQjtNOzs7Y0FFSDJCLDhCQUFKTixXQUFGeUI7VUFBYyxzQkFBZEEsRUFGUzlDLFVBRVBxQjtzQkFBSU07O1FBREQ7dUJBR1EzQjtNOzs7Y0FFUDJCLDhCQUFKTixXQUFGeUI7VUFBYyxzQkFBZEEsRUFGYTlDLGFBRVhxQjtzQkFBSU07O1FBREQ7a0JBR0czQjtNOzs7Y0FFRjJCLDhCQUFKTixXQUFGeUI7bUJBRlE5QyxTQUVOcUI7c0JBQUlNOztRQUREO3NCQUdPM0I7TTs7O2NBRU4yQiw4QkFBSk4sV0FBRnlCO21CQUZZOUMsWUFFVnFCO3NCQUFJTTs7UUFERDt1QkFHUTNCO007OztVQUVDO1dBQUwyQjs7V0FBVG1CO1dBQWMsd0JBQWRBLEVBRmE5QztVQUVDO3NCQUFMMkI7O1FBREo7c0JBR08zQjtNOzs7Y0FFSDJCLDhCQUFUbUIsc0JBRlk5Qzs7c0JBRUgyQjs7UUFESjswQkFHVzNCO007WUFFQzJCLFdBQWxCdUosY0FBQ3BJLEVBQURvSTtRQUNLLDBCQURKcEksRUFGZ0I5QyxHQUVDMkIsS0FBbEJ1SixLQUN5QyxhQUh4QmxMLEVBRUMyQjtNQURaO3lCQUlVM0I7TTtZQUVFMkIsV0FBbEJ1SixjQUFDcEksRUFBRG9JO2VBQUNwSSxNQUZlOUMsRUFFRTJCLEtBQWxCdUosS0FBcUQsWUFGckNsTCxFQUVFMkI7TUFEWjtrQkFHR3NKO007OztjQUVKdEosYUFBTDNCO1VBQWEsY0FGSmlMLEVBRVRqTDtzQkFBSzJCOztRQURDO3NCQUdPc0o7TTs7O2NBRVJ0SixhQUFMM0I7VUFBYSxjQUZBaUwsRUFFYmpMO3NCQUFLMkI7O1FBREM7c0JBR0dzSjtNQUNYOzs7OztnQkFFT3RKLFdBQUwzQjtZQUFhLGNBSEppTCxFQUdUakw7Y0FBc0IsY0FBdEJBLDhCQUFLMkI7OztVQURDLG9CQUVEO3VCQUlLc0osRUFBRUo7Ozs7Y0FHUGxKLGFBQUwzQjtVQUFhLGNBSEhpTCxFQUdWakw7WUFBc0IsYUFBdEJBLHlCQUFLMkI7VUFBMkMsWUFBaEQzQixzQkFBSzJCOztRQURXO1FBQVQseUJBRUc7O01BRUU7UUFHSztTQURWQTs7U0FBSjFCO1NBQUZEO1NBQ2dCLGNBRFYyQjtTQUNVOztxQkFEaEIzQixFQUNNb0wsT0FESm5MLEVBQ1FrTDtNQUZMLFVBRW9DO3FCQUU5Qm5LLEdBQUdDO01BQ2pCLEdBRGNEO1dBQUdDO2NBR0ZzSixLQUhFdEosTUFHTjhKLEdBSE05SixNQUdWcUosS0FIT3RKLE1BR1hnSyxHQUhXaEs7VUFHb0IsYUFBL0JnSyxHQUFRRCxJQUF1QixRQUEzQlQsS0FBUUM7O1lBSEV0SjtNQUlMLG9DQUEwQjttQkFJMUJvSyxJQUdWckssR0FESXNLO01BRE4sR0FFRXRLO1dBRElzSztjQUVZQyxHQUZaRCxTQUVNRSxHQUZORixTQUVFRyxHQUROekssTUFDQTBLLEdBREExSztVQUVLLHNCQUxLcUssSUFJVkssR0FBVUY7eUJBR0csTUFQSEgsSUFHVnJLLEdBQ2dCdUs7c0JBQWhCRyxHQUVhLE1BTkhMLElBSUpJLEdBRkZIO1FBQ00sT0FBVnRLO01BRFUsT0FBTnNLLEtBS3dCO2FBR3hCSyxLQUFLQyxFQUFFaks7VUFBRmtLLE1BQUU3QjtNQUNiO2lCQURXNkIsV0FBRTdCO1FBQ1EsR0FEUkEsS0FHRCxRQUhDQSxPQUdELElBSEQ2QixvQkFBRTdCO1FBSUosNkJBQ047dUJBR1dxQixJQUFJMUo7TUFDbEIsU0FrQlFvSyxLQUFLNUssRUFBRVE7UUFDYixTQURXUjthQUFFUTs7O2tCQUVGcUssV0FBTkMsR0FGUXRLO2NBR1Asc0JBdEJNMEosSUFxQlBZLEdBQU1ELGFBQU5DLGdCQUFNRDs7a0JBRkE3SzthQUFFUTs7Ozs7b0JBSUl1SyxXQUFOQyxhQUFOQyxLQUpReks7Z0JBS1Asc0JBeEJNMEosSUF1QlBlLEtBQU1EOzZCQU1ILFdBN0JJZCxJQXVCUGUsS0FBWUY7K0JBT0osV0E5QkRiLElBdUJEYyxLQUFNRDtzQ0FBTkMsUUFBTkM7Z0NBQU1ELFFBQU1ELE1BQVpFOzhCQUFNRCxRQUFOQyxRQUFZRjs2QkFFVCxXQXpCSWIsSUF1QkRjLEtBQU1EOytCQUdKLFdBMUJEYixJQXVCUGUsS0FBWUY7c0NBQVpFLFFBQU1EO2dDQUFOQyxRQUFZRixNQUFOQzs4QkFBTkMsUUFBTUQsUUFBTUQ7UUFXZDtZQWZRL0s7U0FlUixHQWZRQSxJQWVKa0w7U0FFSyxVQUZMQSxHQWZNMUs7U0FrQkQsY0FITDBLLEdBZk0xSztTQW1CRCxjQUhMMkssR0FDQS9CO1NBMUJhdko7U0FBR0M7U0FBRzBEO1FBQzFCO2FBRG9CM0Q7ZUFBR0M7a0JBSVRzSyxHQUpTdEssTUFJYnVLLEdBSmF2SyxNQUlqQndLLEdBSmN6SyxNQUlsQjBLLEdBSmtCMUs7Y0FLYixrQkFmS3FLLElBY1ZLLEdBQVFGO2dCQUVELGNBRlBFLEdBSndCL0csTUFBTjNELEdBSWR5SyxHQUpvQjlHO2NBT2pCLGNBSEM2RyxHQUpnQjdHLE1BQUgxRCxHQUlUc0ssR0FKWTVHOztZQUdkLGtCQUhRM0QsR0FBTTJEO1VBRWQsa0JBRlcxRCxHQUFHMEQsTUE2QkQ7TUF0QzNCLFNBdUNJNEgsU0FBU3BMLEVBQUVRO1FBQ2IsU0FEV1I7YUFBRVE7OztrQkFFRnFLLFdBQU5DLEdBRlF0SztjQUdQLHNCQTNDTTBKLElBMENQWSxHQUFNRCxPQUFOQyxNQUFNRCxnQkFBTkM7O2tCQUZNOUs7YUFBRVE7Ozs7O29CQUlJdUssV0FBTkMsYUFBTkMsS0FKUXpLO2dCQUtQLHNCQTdDTTBKLElBNENQZSxLQUFNRDs2QkFFSCxXQTlDSWQsSUE0Q0RjLEtBQU1EOzhCQUFaRSxRQUFNRCxRQUFNRDsrQkFHSixXQS9DRGIsSUE0Q1BlLEtBQVlGO2dDQUFaRSxRQUFZRixNQUFOQztnQ0FBTUQsTUFBWkUsUUFBTUQ7NkJBTUgsV0FsRElkLElBNENQZSxLQUFZRjs4QkFBTkMsUUFBTkMsUUFBWUY7K0JBT0osV0FuRERiLElBNENEYyxLQUFNRDtnQ0FBTkMsUUFBTUQsTUFBWkU7Z0NBQVlGLE1BQU5DLFFBQU5DO1FBV0Y7WUFmUWpMO1NBZVIsR0FmUUEsSUFlSmtMO1NBRUssVUFGTEEsR0FmTTFLO1NBa0JELFVBSEwwSyxHQWZNMUs7U0FtQkQsVUFITDJLLEdBQ0EvQjtTQXhEU3ZKO1NBQUdDO1NBQUcwRDtRQUN0QjthQURnQjNEO2VBQUdDO2tCQUlMc0ssR0FKS3RLLE1BSVR1SyxHQUpTdkssTUFJYndLLEdBSlV6SyxNQUlkMEssR0FKYzFLO2NBS1Qsa0JBTktxSyxJQUtWSyxHQUFRRjtnQkFHRCxjQUhDQSxHQUpZN0csTUFBSDFELEdBSUxzSyxHQUpRNUc7Y0FNYixjQUZQK0csR0FKb0IvRyxNQUFOM0QsR0FJVnlLLEdBSmdCOUc7O1lBR1Ysa0JBSEkzRCxHQUFNMkQ7VUFFVixrQkFGTzFELEdBQUcwRCxNQTJERDtNQUViLElBQU52QixJQUFNLE9BOURRekI7TUE4RFIsWUFBTnlCLElBQ21CLEtBRG5CQSxJQTlEY3pCLElBK0RlO3VCQXlDckIwSixJQUFJMUo7TUFDaEIsU0FzQlFvSyxLQUFLNUssRUFBRVE7UUFDYixTQURXUjthQUFFUTs7O2NBR0YsSUFEQXFLLFdBQU5DLEdBRlF0SyxLQUdGLGVBMUJEMEosSUF5QkxZLEdBQU1EO2NBQ0EsYUFBSlE7MEJBREZQOzRCQUNFTyxPQURJUixNQUFOQyxnQkFBTUQ7O2tCQUZBN0s7YUFBRVE7Ozs7O2dCQU9GO2lCQURNdUs7aUJBQU5DO2lCQUFOQyxLQU5Reks7aUJBT0YsZUE5QkQwSixJQTZCTGUsS0FBTUQ7Z0JBQ0EsU0FBSk07a0JBRU0sSUFBSkMsSUFBSSxXQWhDSHJCLElBNkJDYyxLQUFNRDtrQkFHSixhQUFKUTs4QkFIRVA7Z0NBR0ZPLE9BSFFSLE1BQU5DLG9CQUFNRDtnQkFNTCxRQUxMTztrQkFjTSxJQUFKRSxJQUFJLFdBNUNIdEIsSUE2QkxlLEtBQVlGO2tCQWVKLFNBQUpTLGNBZkVSLFFBQU5DO2tCQWlCSyxRQUZETztvQkFHUyxJQUFKQyxJQUFJLFdBL0NSdkIsSUE2QkNjLEtBQU1EO29CQWtCQyxhQUFKVTtnQ0FsQkhULFFBQU5DO2tDQWtCU1E7a0NBbEJHVixNQUFOQyxRQUFOQztrQ0FBTUQsUUFBTUQsTUFBWkU7a0JBaUJtQixVQWpCYkQsUUFBTkMsUUFBWUY7Z0JBQ04sSUFNRlcsSUFBSSxXQXBDSHhCLElBNkJDYyxLQUFNRDtnQkFPSixTQUFKVyxjQVBKVCxRQUFNRDtnQkFTRCxRQUZEVTtrQkFHUyxJQUFKQyxJQUFJLFdBdkNSekIsSUE2QkxlLEtBQVlGO2tCQVVDLGFBQUpZOzhCQVZUVixRQUFNRDtnQ0FVR1c7Z0NBVkdaLE1BQVpFLFFBQU1EO2dDQUFOQyxRQUFZRixNQUFOQztnQkFTYSxVQVRuQkMsUUFBTUQsUUFBTUQ7UUF3QmQ7WUE5QlEvSztTQThCUixHQTlCUUEsSUE4QkprTDtTQUVLLFVBRkxBLEdBOUJNMUs7U0FpQ0QsY0FITDBLLEdBOUJNMUs7U0FrQ0QsY0FITDJLLEdBQ0EvQjtTQTNDYXZKO1NBQUdDO1NBQUcwRDtRQUMxQjthQURvQjNEO2VBQUdDO2NBS1gsSUFERXNLLEdBSlN0SyxNQUlidUssR0FKYXZLLE1BSWpCd0ssR0FKY3pLLE1BSWxCMEssR0FKa0IxSyxNQUtSLGFBakJGcUssSUFnQlJLLEdBQVFGO2NBQ0UsU0FBSi9JO2dCQUNVLGNBRmhCaUosR0FKd0IvRyxNQUFOM0QsR0FJZHlLLEdBSmlCeEssR0FJVHNLLEdBSlk1RztjQU9qQixPQUZEbEMsR0FHQyxjQUpQaUosR0FKd0IvRyxNQUFOM0QsR0FJZHlLLEdBSm9COUc7Y0FLZCxJQUlILFVBTEM2RyxHQUpnQjdHLE1BQUgxRCxHQUlUc0ssR0FKWTVHOztZQUdkLGtCQUhRM0QsR0FBTTJEO1VBRWQsa0JBRlcxRCxHQUFHMEQsTUE4Q0Q7TUF6RDNCLFNBMERJNEgsU0FBU3BMLEVBQUVRO1FBQ2IsU0FEV1I7YUFBRVE7OztjQUdGLElBREFxSyxXQUFOQyxHQUZRdEssS0FHRixlQTlERDBKLElBNkRMWSxHQUFNRDtjQUNBLGFBQUpROzBCQURGUDsyQkFDRU8sT0FERlAsTUFBTUQsZ0JBQU5DOztrQkFGTTlLO2FBQUVROzs7OztnQkFPRjtpQkFETXVLO2lCQUFOQztpQkFBTkMsS0FOUXpLO2lCQU9GLGVBbEVEMEosSUFpRUxlLEtBQU1EO2dCQUNBLFNBQUpNO2tCQUVNLElBQUpDLElBQUksV0FwRUhyQixJQWlFQ2MsS0FBTUQ7a0JBR0osYUFBSlE7OEJBSEVQOytCQUdGTyxPQUhFUCxRQUFNRCxnQkFBTkM7Z0JBTUMsT0FMTE07a0JBTU0sSUFBSkUsSUFBSSxXQXhFSHRCLElBaUVDYyxLQUFNRDtrQkFPSixTQUFKUyxjQVBKUCxRQUFNRDtrQkFTRCxPQUZEUSxjQVBKUCxRQUFNRCxRQUFNRDtrQkFPSixJQUdDVSxJQUFJLFdBM0VSdkIsSUFpRUxlLEtBQVlGO2tCQVVDLGFBQUpVOzhCQVZUUixRQUFNRDsrQkFVR1M7Z0NBVlRSLFFBQVlGLE1BQU5DO2dDQUFNRCxNQUFaRSxRQUFNRDtnQkFDQSxJQWNGVSxJQUFJLFdBaEZIeEIsSUFpRUxlLEtBQVlGO2dCQWVKLFNBQUpXLGNBZkVWLFFBQU5DO2dCQWlCSyxPQUZEUyxjQWZFVixRQUFOQyxRQUFZRjtnQkFDTixJQWlCR1ksSUFBSSxXQW5GUnpCLElBaUVDYyxLQUFNRDtnQkFrQkMsYUFBSlk7NEJBbEJIWCxRQUFOQzs2QkFrQlNVOzhCQWxCSFgsUUFBTUQsTUFBWkU7OEJBQVlGLE1BQU5DLFFBQU5DO1FBd0JGO1lBOUJRakw7U0E4QlIsR0E5QlFBLElBOEJKa0w7U0FFSyxVQUZMQSxHQTlCTTFLO1NBaUNELFVBSEwwSyxHQTlCTTFLO1NBa0NELFVBSEwySyxHQUNBL0I7U0ExRlN2SjtTQUFHQztTQUFHMEQ7UUFDdEI7YUFEZ0IzRDtlQUFHQztjQUtQLElBREVzSyxHQUpLdEssTUFJVHVLLEdBSlN2SyxNQUlid0ssR0FKVXpLLE1BSWQwSyxHQUpjMUssTUFLSixhQU5GcUssSUFLUkssR0FBUUY7Y0FDRSxTQUFKL0k7Z0JBQ1UsY0FGaEJpSixHQUpvQi9HLE1BQU4zRCxHQUlWeUssR0FKYXhLLEdBSUxzSyxHQUpRNUc7Y0FPYixRQUZEbEMsR0FJQyxjQUxDK0ksR0FKWTdHLE1BQUgxRCxHQUlMc0ssR0FKUTVHO2NBS1YsSUFHSCxVQUpQK0csR0FKb0IvRyxNQUFOM0QsR0FJVnlLLEdBSmdCOUc7O1lBR1Ysa0JBSEkzRCxHQUFNMkQ7VUFFVixrQkFGTzFELEdBQUcwRCxNQTZGRDtNQUViLElBQU52QixJQUFNLE9BaEdNekI7TUFnR04sWUFBTnlCLElBQ21CLEtBRG5CQSxJQWhHWXpCLElBaUdpQjs2QkFFWFgsR0FBR0M7VUFBSHFKLFFBQUdDO01BQ3pCO1dBRHNCRDthQUFHQyx1QkFBSEMsdUJBQUdEO1VBSWQ7UUFEQSxPQUhjQSxVQUtrQjtpQ0FHakI1SSxFQUFFUjtVQUFGNkksTUFBRUM7TUFDNUI7V0FEMEJEO1VBTXhCLElBREtFLElBTG1CRjtVQU14QixPQU4wQkMsS0FPeEIsUUFQd0JBLFlBQUZELElBS25CRSxJQUxxQkQ7VUFNWDtRQUhmLGFBSDBCQSxtQkFPRztvQkFLdEJ0STtNQUNULFNBQVFxTCxJQUFJckw7UUFBTyxHQUFQQTtjQUVINkYsS0FGRzdGLEtBRVIzQixFQUZRMkI7VUFFa0IsVUFBMUIzQixpQixPQUZJZ04sSUFFQ3hGO1FBREMsUUFDNkI7TUFGdkMsc0IsT0FBUXdGLElBRENyTCxRQUtKO29CQUVJc0Y7TUFDVCxTQUFRZ0csT0FBT0MsTUFBTWpHO1FBQ25CLFNBRGFpRztVQUdYO3dDQUFtQnRGLElBQUk1SCxHQUFLLFVBQUxBLEVBQUo0SCxJQUFlLE9BSGpCWDtRQUtSLHFCQUxRQTtRQUtSO2NBRU1DLGNBQUhsSDtVQUFpQixVQUFqQkEsRUFBaUIsT0FQbEJrTixjQU9JaEc7UUFERixRQUNxQztNQVB0RCxrQkFEU0QsSUFVSzs7OztPQTFlWjJDOzs7T0FFQUU7T0FFQTdIO09BSUFEO09BSUErSDtPQVFBSztPQWVBTTs7T0FQQTNJO09BRUlzSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JJWENsSixFQUFFc0I7TUFDVCxJQUFJNUMsRUFBSixrQkFET3NCLEdBRVAsZ0JBREl0QixJQURHc0IsRUFBRXNCLEdBRVQsT0FESTVDLENBRUg7b0JBRU1zQixFQUFFekI7TUFDVCx3QkFET3lCLEdBQ1AsS0FET0EsVUFDUDs7WUFDQTNGO1FBQ0U7VUFBZSxzQkFGYnFFLEVBQ0pyRSxFQUNpQixXQUhSa0UsRUFFVGxFO1VBQ2lCLFNBRGpCQTs7O01BR0EsT0FKSXFFLENBSUg7SUFFUztrQkFFSEE7TUFDUCw2QkFET0EsR0FDUCxvQkFBSXVEO01BRUosZ0JBSE92RCxJQUVIc0UsSUFEQWY7TUFFSixPQURJZSxDQUVIO0lBTlMsbUJBUUU5QyxHQUFxQixpQ0FBckJBLEdBQTZCO0lBUi9CLG1CQVNFeEIsR0FBSSxpQ0FBSkEsR0FBNkI7SUFUL0IsYUFXSkEsRUFBRXNELElBQUlDO01BQ1osUUFEUUQ7ZUFBSUM7b0NBQU52RCxLQUFNdUQsV0FBSkQ7VUFHSCxJQUNDZ0IsRUFERCxrQkFIT2Y7VUFLVixnQkFMSXZELEVBQUVzRCxJQUlGZ0IsSUFKTWY7VUFLVixPQURJZTtNQUZELDRDQUtGO0lBbEJPLG9CQW9CRzlDLEVBQUU4QixJQUFJQztNQUF1QixnQ0FBN0IvQixFQUFFOEIsSUFBSUMsS0FBc0M7SUFwQi9DLFNBdUJSK0osSUFBS3JLLEVBQUV6QjtNQUNUO1NBRE95QixJQUFFekI7T0FDVCxLQURTQTtPQUNULE1BQUlvQjtPQUFKO2VBRE9LOzs7TU42YkQsZ0JNemJtQiw4QkFIckJMLENBSUk7SUE1QkUsZ0JBOEJENUMsRUFBRXVOLEtBQUtDO01BQ047bUJBQVYscUJBRFN4TixHQUFFdU4sTUFBS0M7T0FDTixvQkFBTmpLO01BQU0sUUFEQ2dLO1dBR05FLFNBQVFDLE9BSEZIOztXQUdORSxTQUhNRixTQUdFRztNQUZILElBR05DLE9BQVMsSUFBYixxQkFKUzNOLEtBR0p5TixXQUZEbEssTUFFU21LO01BQ0EsT0FBVEMsT0FDZSxnQkFMVjNOLEVBR0p5TixPQUREbkosRUFDU29KLE9BQ1RDO01BQ21ELE9BSG5EckosQ0FJSDtJQXBDUyxjQXNDSHRFLEVBQUVzRCxJQUFJQyxJQUFJWDtNQUNqQixRQURTVTtlQUFJQztvQ0FBTnZELEtBQU11RCxXQUFKRDtnQkFHSixnQkFIRXRELEVBQUVzRCxJQUFJQyxJQUFJWDtNQUVaLDhDQUN1QjtJQXpDbEIsY0EyQ0gzQixHQUFHMk0sS0FBSzFNLEdBQUcyTSxLQUFLdEs7TUFDdkIsUUFEdUJBO2VBQWJxSztvQ0FBSDNNLE1BQWdCc0MsV0FBYnFLO2lCQUFRQztzQ0FBSDNNLE1BQVFxQyxXQUFMc0s7a0JBSWIsZ0JBSkU1TSxHQUFHMk0sS0FBSzFNLEdBQUcyTSxLQUFLdEs7TUFHbEIsa0NBQytCO0lBL0MxQixnQkFpREl0QyxHQUFHMk0sS0FBSzFNLEdBQUcyTSxLQUFLdEs7TUFDOUIsUUFEOEJBO2VBQWJxSztxQ0FBSDNNLE1BQWdCc0MsV0FBYnFLO2lCQUFRQztzQ0FBSDNNLE1BQVFxQyxXQUFMc0s7a0JBSXBCLGlCQUpTNU0sR0FBRzJNLEtBQUsxTSxHQUFHMk0sS0FBS3RLO01BR3pCLHFEQUNzQztJQXJEakMsZ0JBd0RIMUQsRUFBRW9EO01BQ1QsOEJBRFNBLFdBQ1Q7OztRQUE2QjtxQkFEdEJwRCxFQUNzQixzQkFEcEJvRCxFQUNUdEg7VUFBNkIsU0FBN0JBOzs7Y0FBbUQ7SUF6RHpDLGlCQTRERmtFLEVBQUVvRDtNQUNWLDhCQURVQSxXQUNWOzs7UUFBNkI7cUJBRHJCcEQsRUFDUmxFLEVBQTZCLHNCQURuQnNILEVBQ1Z0SDtVQUE2QixTQUE3QkE7OztjQUFzRDtJQTdENUMsZ0JBK0VEbVMsSUFFUGhNO00sR0FBQUE7UUFBSyxnQ0FGRWdNLGlCQUVQaE0sRUFBSzs7Ozs7Y0FiTzsrQ0FFaUJpTTtlQVBQLGFBQVg1TixJQUFpQzs7OztxQkFJaEM7OztVQWdCNEIsa0RBRnhDMkI7Ozs7O2dCQU5BLHVCQUxpQmtNLFFBS2pCO2dCQUNBO2tCQUdPRixNQVRVRSxVQUtqQiwrQkFMNkJEO2dCQU03QjtnRUFONkJBOzs7O2NBRzdCLHVCQUhpQkMsUUFHakI7cUJBSGlCQTtZQUNYLE9BRFdBO01BVVg7SUFoRkUsYUFzRkovTSxHQUFHQztNQUNUOytCQURNRDtPQUNOLHdCQURTQztPQUNULG9CQUFJQyxLQUNBQztNQUVKLGdCQUpNSCxLQUdGcUQsSUFGQW5EO01BSUosZ0JBTFNELEtBR0xvRCxFQUZBbkQsR0FDQUM7TUFHSixPQUZJa0QsQ0FHSDtJQTVGUyxTQWtHUjJKO01BQVc7OztNTmtYUCxtQk1oWE07SUFwR0YsY0FzR0hqTztNQUNQLDZCQURPQSxHQUNQOztXQUNJckUsT0FEQTRIO1lBRWMsK0JBSFh2RCxFQUVIckUsUUFFRjtRQUVGLElBQUl1UyxLQUxBM0s7O2FBQ0E1SCxRQUlBdVM7Y0FDYywrQkFQWGxPLEVBTUhrTyxRQUVGO1VBRUYsT0FSSXZTLFFBSUF1UyxLQUtGLElBWEtsTyxFQUVIckUsTUFJQXVTLE9BSkF2Uyw0QkFXRztJQW5IRyxtQkFxSEFxRTtNQUNWLHNDQURVQSxXQUNWOztZQUNBK0I7UUFDRTswQ0FIUS9CLEVBRVYrQjtVQUNFOzs7Ozs7Ozs7Ozs7VU40Vkk7VU05VkZUO1VBRUYsU0FERlM7OztNQU9BLEdBUklULFNBUUoscUJBVFV0QixVQVNZLEtBVFpBO01BQ1YsSUFTTW1JLElBRDRCLGtCQVI5QjdHO01BUThCO01BUmxDLElBUWtDLDBCQVR4QnRCLFdBU3dCOztZQUdoQ3JFO1FBQ0U7Y0FXRWlILEVBWEYsc0JBYk01QyxFQVlSckU7VUFDRSxTQVdFaUg7Ozs7Ozs7Ozs7O2dCQURFLHNCQWJGdUYsSUFURjdHO2dCQXNCSTtzQ0FiRjZHLElBVEY3Rzs7OztnQkFrQkksc0JBVEY2RyxJQVRGN0c7Z0JBa0JJO3NDQVRGNkcsSUFURjdHOzs7O2dCQWdCSSxzQkFQRjZHLElBVEY3RztnQkFnQkk7c0NBUEY2RyxJQVRGN0c7Ozs7Z0JBb0JJLHNCQVhGNkcsSUFURjdHO2dCQW9CSTtzQ0FYRjZHLElBVEY3Rzs7Ozs7O2FBeUJJLHNCQWhCRjZHLElBVEY3RzthQXlCSTttQ0FoQkY2RyxJQVRGN0csV0F1QkVzQjthQUVFO21DQWhCRnVGLElBVEY3RyxZQXVCRXNCO2FBRUU7bUNBaEJGdUYsSUFURjdHLFdBdUJFc0I7OzthQVRFLHNCQUxGdUYsSUFURjdHO2FBY0k7bUNBTEY2RyxJQVRGN0csS0F1QkVzQjs7bUJBQXFCLHNCQWRyQnVGLElBVEY3RyxLQXVCRXNCOztVQVdGO1VBdEJBLFNBREZqSDs7O01BeUJBLE9BM0JJd00sR0E0Qkg7SUEzSk8sZUE2Skp0SSxFQUFFRztNQUNSLElBQUk4QixFQUFKLHFCQURROUI7TUFDUixTQUFJOEIsU0FESTlCO01BQ1IsSUFDcUIsb0JBRGpCOEIsR0FDaUIsS0FEakJBLFVBQ2lCOztZQUVuQm5HO1FBQXNCO1VBQWUsc0JBRGpDMkksRUFDSjNJLEVBQXFDLFdBSmpDa0UsRUFJa0Isc0JBSmhCRyxFQUlOckU7VUFBcUMsU0FBckNBOzs7TUFDQSxPQUZJMkksQ0FHSDtJQW5LTyxnQkFxS0h6RSxFQUFFRztNQUNULElBQUk4QixFQUFKLHFCQURTOUI7TUFDVCxTQUFJOEIsU0FESzlCO01BQ1QsSUFDcUIsb0JBRGpCOEIsR0FDaUIsS0FEakJBLFVBQ2lCOztZQUVuQm5HO1FBQXNCO1VBQWU7WUFEakMySSxFQUNKM0ksRUFBcUMsV0FKaENrRSxFQUlMbEUsRUFBc0Isc0JBSmZxRSxFQUlQckU7VUFBcUMsU0FBckNBOzs7TUFDQSxPQUZJMkksQ0FHSDtJQTNLTywyQkE2S1F0RSxHQUFJLGFGOUpwQnVJLGdCRThKZ0J2SSxFQUE4QjtJQTdLdEMsMkJBOEtRQSxHQUFJLGFGcEtwQnNJLGdCRW9LZ0J0SSxFQUE4QjtJQTlLdEMsU0FnTFJtTyxPQUFPdE8sRUFBRUc7TUFDWCw4QkFEV0E7TUFFRCxJQUFKc0UsRUFBSSxLQUZDdEU7TUFHTSxzQkFEWHNFLElBQ1csV0FIUnpFLEVBRUMsc0JBRkNHO01BR00sT0FEWHNFLENBR0g7SUFyTE8sMEJBdUxTdEUsR0FBSSxjRnhLckJ1SSxnQkV3S2lCdkksRUFBaUM7SUF2TDFDLDRCQXdMV0EsR0FBSSxjRjlLdkJzSSxnQkU4S21CdEksRUFBaUM7SUF4TDVDLFNBMkxKb08sVUFBVXBPLEVBQUVxTyxJQUFJMVMsRUFBRWlIO00sSUFBRmI7TUFDdEI7V0FEa0JzTSxPQUFJdE07UUFFdEIseUJBRmdCL0IsRUFBTStCLFNBQUVhLFNBQUZiO1FBRVksUUFGWkE7aUJBRXFDO0lBN0xqRCxlQWdNRi9CLEVBQUU0QyxHQUFJLGlCQUFONUMsRUFBTSxxQkFBTkEsS0FBRTRDLEVBQThCO0lBaE05QixTQW1NSjJMLGNBQWN2TyxFQUFFcU8sSUFBSTFTLEVBQUVpSDtNLElBQUZiO01BQzFCO1dBRHNCc00sT0FBSXRNO1FBRTFCLHlCQUZvQi9CLEVBQU0rQixTQUFFYSxZQUFGYjtRQUVhLFFBRmJBO2lCQUUwQztJQXJNMUQsbUJBd01FL0IsRUFBRTRDO01BQUkscUJBQU41QyxFQUFNLHFCQUFOQSxLQUFFNEMsRUFBa0M7SUF4TXRDLG9CQTJNRzVDLEVBQUVyRSxFQUFFaUg7TUFDakIsSUFBSWQsRUFBSixxQkFEYTlCO01BQ2IsUUFEZXJFLFFBQ1htRyxJQURXbkcsVUFHZixVQUhhcUUsRUFDVDhCLEVBRFduRyxFQUFFaUg7TUFFTSwwREFDTjtJQTlNUCx3QkFpTk81QyxFQUFFckUsRUFBRWlIO01BQ3JCLElBQUlkLEVBQUoscUJBRGlCOUI7TUFDakIsUUFEbUJyRSxRQUNmbUcsSUFEZW5HLFVBR25CLGNBSGlCcUUsRUFDYjhCLEVBRGVuRyxFQUFFaUg7TUFFRSxrRUFDRjtJQXBOWCxTQXVOSjRMLFdBQVd4TyxFQUFFckUsRUFBRWlIO00sSUFBRmI7TUFDbkI7Z0JBRG1CQTtVQUVuQix5QkFGaUIvQixFQUFFK0IsU0FBRWEsU0FBRmI7VUFFZSxRQUZmQTs7UUFDTCxnQkFDMEM7SUF6TjlDLGdCQTRORC9CLEVBQUU0QztNQUFJLGtCQUFONUMsRUFBTSxxQkFBTkEsV0FBRTRDLEVBQWlDO0lBNU5sQyxxQkErTkk1QyxFQUFFckUsRUFBRWlIO01BQ2xCLFNBRGdCakgsNkJBQUZxRSxNQUFFckUsVUFJZCxXQUpZcUUsRUFBRXJFLEVBQUVpSDtNQUVoQiw0REFFZ0I7SUFuT1IsU0FzT0o2TCxlQUFlek8sRUFBRXJFLEVBQUVpSDtNLElBQUZiO01BQ3ZCO2dCQUR1QkE7VUFFdkIseUJBRnFCL0IsRUFBRStCLFNBQUVhLFlBQUZiO1VBRWdCLFFBRmhCQTs7UUFDVCxTQUNtRDtJQXhPdkQsb0JBMk9HL0IsRUFBRTRDO01BQUksc0JBQU41QyxFQUFNLHFCQUFOQSxXQUFFNEMsRUFBcUM7SUEzTzFDLHlCQThPUTVDLEVBQUVyRSxFQUFFaUg7TUFDdEIsU0FEb0JqSDtrQ0FBRnFFLE1BQUVyRSxVQUlsQixlQUpnQnFFLEVBQUVyRSxFQUFFaUg7TUFFcEIsb0VBRW9CO0lBbFBaLHVCQXNQTTVDLEVBQUVyRSxFQUFFaUg7TUFDcEIsSUFBSWQsRUFBSixxQkFEZ0I5QjtNQUNoQixRQURrQnJFO2FBQ2RtRyxJQURjbkc7O1VBS0wsVUFMR3FFLEVBQ1o4QixFQURjbkcsRUFBRWlILEdBS1A7Ozs7O01BRlgsZ0VBRTREO0lBM1BwRCxrQkErUEM1QyxFQUFFNEMsR0FBSSxxQkFBTjVDLElBQUU0QyxFQUF1QjtJQS9QMUIsd0JBa1FPNUMsRUFBRXJFLEVBQUVpSDtNQUNyQixRQURtQmpIO2tDQUFGcUUsTUFBRXJFOztVQUlOLFdBSklxRSxFQUFFckUsRUFBRWlILEdBSVI7Ozs7O01BRlgsa0VBRTJEO0lBdFFuRDt5QkFnUkU1QyxHQUFJLGFGN1FkcUksVUU2UVVySSxFQUF3QjtJQWhSMUIscUJBaVJFQSxHQUFJLGFGclJkb0ksVUVxUlVwSSxFQUF3QjtJQWpSMUIsb0JBbVJHQSxHQUFJLGNGaFJmcUksVUVnUldySSxFQUEyQjtJQW5SOUIsc0JBb1JLQSxHQUFJLGNGeFJqQm9JLFVFd1JhcEksRUFBMkI7SUFwUmhDLGtCQXdSREE7TUFDVCxTQUFRbU4sSUFBSXhSO1FBQ1YsR0FEVUEsTUFDVixxQkFGT3FFO1FBSUwscUJBSktBLEVBQ0dyRSxHQUdSLEtBSFFBO1FBSUssVUFEVHdFLGlCLE9BSEFnTixnQkFJbUI7TUFKM0I7NEIsT0FBUUEsZUFNSDtJQS9SSyxpQkFpU0FuTjtNQUNWLFNBQVFtTixJQUFJeFI7UUFDVixHQURVQSxNQUNWLHFCQUZRcUU7UUFJTixxQkFKTUEsRUFDRXJFLEdBR1IsS0FIUUE7UUFJUyxhQUpUQSxFQUdKd0Usa0IsT0FIQWdOLGdCQUl1QjtNQUovQjs0QixPQUFRQSxlQU1IO0lBeFNLLGtCQTBTRHhSO01BQ1QsWUFDYztNQVNkO2lCQUNPaUg7VUFDRixHQVpEdEIsU0FZQyxxQkFYRHVEO1lBR1k7YUFBVjZKO2NBQVUsUUFBZCxxQkFIRTdKO1lBR1ksd0JBSFpBLFlBR0U2SjthQUMwQjtZQURoQixJQUVWQyxRQUFVLEtBRlZEO1lBR0osS0FORTdKLFNBS0U4SixVQU5Gck47WUFPRixTQURJcU47VUFPRCxlQVpEOUosT0FEQXZELEtBV0dzQjtVQUVGO2tCQUNNO1FBZkZqSDtNQVdULFdBVElrSixTQURBdkQsS0FnQlM7SUEzVEg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQ2JIQSxFQUFFc0IsR0FDVCxpQ0FET3RCLEVBQUVzQixHQUNRO29CQUNWdEIsRUFBRXpCLEdBQ1QsbUNBRE95QixFQUFFekIsR0FDUTtvQkFDVkc7TUFDUCxpQ0FBTyxxQkFEQUEsSUFDYzttQkFDZkEsRUFBRXNELElBQUlDO01BQ1osZ0NBQU0scUJBREF2RCxHQUFFc0QsSUFBSUMsS0FDZ0I7c0JBc0JuQnVLLElBRVBoTTtNLEdBQUFBO1FBQUssaUNBRkVnTSxpQkFFUGhNLEVBQUs7Ozs7O2NBYk87Z0RBRWlCaU07ZUFQUCxhQUFYNU4sSUFBaUM7Ozs7cUJBSWhDOzs7VUFnQjhCLGtEQUYxQzJCOzs7OztnQkFOQSx3QkFMaUJrTSxRQUtqQjtnQkFDQTtrQkFHT0YsTUFUVUUsVUFLakIsZ0NBTDZCRDtnQkFNN0I7aUVBTjZCQTs7OztjQUc3Qix3QkFIaUJDLFFBR2pCO3dDQUhpQkE7TUFVWDtvQkFPRG5PLEVBQUVHO01BQ1QsK0JBRFNBLFdBQ1Q7OztRQUE2QjtxQkFEdEJILEVBQ3NCLHVCQURwQkcsRUFDVHJFO1VBQTZCLFNBQTdCQTs7O2NBQW9EO3FCQUc1Q2tFLEVBQUVHO01BQ1YsK0JBRFVBLFdBQ1Y7OztRQUE2QjtxQkFEckJILEVBQ1JsRSxFQUE2Qix1QkFEbkJxRSxFQUNWckU7VUFBNkIsU0FBN0JBOzs7Y0FBc0Q7bUJBRWhEa0UsRUFBRUc7TUFDUixrQ0FETUgsRUFDRSxxQkFEQUcsSUFDYztvQkFDZkgsRUFBRUc7TUFDVCxtQ0FET0gsRUFDRSxxQkFEQUcsSUFDYzthQU1yQjRPO01BQVc7OztNUDRhUCxtQk8xYU07b0JBRUw1TztNQUNKLHFCQURJQTtNQUVDLGdCQUFILHVCQUZFQTs7O1NBRThCO2tDQUY5QkE7O01BR0ksaUNBQVEscUJBSFpBLElBSUQ7dUJBR21CQTtNQUF6Qiw0QkFBeUJBLEdBQUlyRTtNQUMzQjtXQUR5QjJGLEtBQUUzRixTQUFKcUU7UUFFckI7c0NBRnFCQSxFQUFJckU7U0FFekI7OztRUCtaRTtnQk85WnNELCtCQUFXLHFCQUg5Q3FFO1FBRXJCLElBRU8sSUFKa0JyRTtpQkFNRTthQUd6QmtULFlBQVU3TyxFQUFFcU8sSUFBSTFTLEVBQUVpSDtNLElBQUZiO01BQ3RCO1dBRGtCc00sT0FBSXRNO1FBRXRCLDBCQUZnQi9CLEVBQU0rQixTQUFFYSxTQUFGYjtRQUVZLFFBRlpBO2lCQUVxQztxQkFHbkQvQixFQUFFNEMsR0FBSSxtQkFBTjVDLEVBQU0sc0JBQU5BLEtBQUU0QyxFQUE4QjthQUdsQ2tNLGdCQUFjOU8sRUFBRXFPLElBQUkxUyxFQUFFaUg7TSxJQUFGYjtNQUMxQjtXQURzQnNNLE9BQUl0TTtRQUUxQiwwQkFGb0IvQixFQUFNK0IsU0FBRWEsWUFBRmI7UUFFYSxRQUZiQTtpQkFFMEM7eUJBR3hEL0IsRUFBRTRDO01BQUksdUJBQU41QyxFQUFNLHNCQUFOQSxLQUFFNEMsRUFBa0M7MEJBR25DNUMsRUFBRXJFLEVBQUVpSDtNQUNqQixJQUFJZCxFQUFKLHNCQURhOUI7TUFDYixRQURlckUsUUFDWG1HLElBRFduRyxVQUdiLFlBSFdxRSxFQUNUOEIsRUFEV25HLEVBQUVpSDtNQUVNLDREQUNKOzhCQUdGNUMsRUFBRXJFLEVBQUVpSDtNQUNyQixJQUFJZCxFQUFKLHNCQURpQjlCO01BQ2pCLFFBRG1CckUsUUFDZm1HLElBRGVuRyxVQUduQixnQkFIaUJxRSxFQUNiOEIsRUFEZW5HLEVBQUVpSDtNQUVFLG9FQUNGO2FBR2ZtTSxhQUFXL08sRUFBRXJFLEVBQUVpSDtNLElBQUZiO01BQ25CO2dCQURtQkE7VUFFbkIsMEJBRmlCL0IsRUFBRStCLFNBQUVhLFNBQUZiO1VBRWUsUUFGZkE7O1FBQ0wsZ0JBQzBDO3NCQUcvQy9CLEVBQUU0QztNQUFJLG9CQUFONUMsRUFBTSxzQkFBTkEsV0FBRTRDLEVBQWlDOzJCQUc5QjVDLEVBQUVyRSxFQUFFaUg7TUFDbEIsU0FEZ0JqSDttQ0FBRnFFLE1BQUVyRSxVQUlkLGFBSllxRSxFQUFFckUsRUFBRWlIO01BRWhCLDhEQUVnQjthQUdab00saUJBQWVoUCxFQUFFckUsRUFBRWlIO00sSUFBRmI7TUFDdkI7Z0JBRHVCQTtVQUV2QiwwQkFGcUIvQixFQUFFK0IsU0FBRWEsWUFBRmI7VUFFZ0IsUUFGaEJBOztRQUNULFNBQ21EOzBCQUdwRC9CLEVBQUU0QztNQUFJLHdCQUFONUMsRUFBTSxzQkFBTkEsV0FBRTRDLEVBQXFDOytCQUdsQzVDLEVBQUVyRSxFQUFFaUg7TUFDdEIsU0FEb0JqSDttQ0FBRnFFLE1BQUVyRSxVQUlsQixpQkFKZ0JxRSxFQUFFckUsRUFBRWlIO01BRXBCLHNFQUVvQjs2QkFHTjVDLEVBQUVyRSxFQUFFaUg7TUFDcEIsSUFBSWQsRUFBSixzQkFEZ0I5QjtNQUNoQixRQURrQnJFO2FBQ2RtRyxJQURjbkc7O1VBS0wsWUFMR3FFLEVBQ1o4QixFQURjbkcsRUFBRWlILEdBS1A7Ozs7O01BRlgsa0VBRTREO3dCQUduRDVDLEVBQUU0QyxHQUFJLHVCQUFONUMsSUFBRTRDLEVBQXVCOzhCQUduQjVDLEVBQUVyRSxFQUFFaUg7TUFDckIsUUFEbUJqSDttQ0FBRnFFLE1BQUVyRTs7VUFJTixhQUpJcUUsRUFBRXJFLEVBQUVpSCxHQUlSOzs7OztNQUZYLG9FQUUyRDsrQkFFM0M1QztNQUNsQiw4Q0FBa0IscUJBREFBLElBQ2M7K0JBQ2RBO01BQ2xCLDhDQUFrQixxQkFEQUEsSUFDYztnQ0FDYkE7TUFDbkIsNkNBQW1CLHFCQURBQSxJQUNjO2tDQUNaQTtNQUNyQiwrQ0FBcUIscUJBREFBLElBQ2M7OzJCQU9uQjhOLElBQUk5TjtNQUNwQjs7a0NBRG9CQTtPQUNwQiwyQkFEb0JBO01BQ3BCO1lBRUFyRTtRQUNFO29DQUprQnFFLEVBR3BCckUsT0FIZ0JtUztZQUllLFNBSDNCeEo7WUFJSyxnQkFMV3RFLEVBR3BCckUsV0FESXVTLE9BQ0p2UztZQUVTLE9BRlRBOzs7O01BRkEsU0FBSTJJO01BUUosZ0JBVG9CdEUsSUFFaEJrTyxXQU9ZO3lCQUlKbE87TUFDWix3Q0FBWSxxQkFEQUEsSUFDYzt5QkFDZEE7TUFDWix3Q0FBWSxxQkFEQUEsSUFDYzswQkFDYkE7TUFDYix1Q0FBYSxxQkFEQUEsSUFDYzs0QkFDWkE7TUFDZix5Q0FBZSxxQkFEQUEsSUFDYztzQkFJcEJBLEdBQUkscUNBQUpBLEdBQXFCO3VCQUVwQkEsR0FBSSxvQ0FBSkEsR0FBc0I7c0JBRXZCNEcsR0FBSSxxQ0FBSkEsR0FBcUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FDbE54QnFJLFFBQU1DLE1BQU0vTixHQUFHQztNQUNyQixHQURrQkQ7WUFHVnlLLEdBSFV6SyxNQUdoQjBLLEdBSGdCMUs7V0FBR0M7Y0FNVHNLLEdBTlN0SyxNQU1mdUssR0FOZXZLO1VBT1Ysa0JBUEM4TixNQUdWckQsR0FHSUY7c0JBSEpFLEdBS2lCLFFBUlBxRCxNQUdKdEQsR0FIYXhLO3NCQU1mdUssR0FHYSxRQVRQdUQsTUFBTS9OLEdBTU51SztRQURBLE9BTE12SztNQUVWLE9BRmFDLEVBU2U7YUFFbEMrTixLQUFLRCxNQUFNcE47TUFDYixTQUFRc047UUFBVzs7O1lBSWlDO2FBRHhDdlQ7YUFBSndUO2FBQzRDLGNBRHhDeFQ7YUFDRjt5QkFMSHFULFdBSUNHOztVQURHO1FBREQsUUFHdUQ7TUFKakUsU0FLUUMsT0FFSm5QO1FBRmEsR0FFYkE7OztZQURxQyxJQUE3QnRFLGFBQUp1RixXQUFKRCxHQUNBaEIsS0FEcUMsWUFBN0J0RTtZQUFRLGtCQVBicVQsTUFPSC9OLEdBQUlDO1FBQ0MsT0FBTGpCLENBQU07TUFLRixxQkFiSzJCO01BU007O3VCQUdHO1VBRFgsSUFBTnFJO1VBQU0sT0FBTkE7UUFESyxTQUdVO2FBRWxCb0YsS0FBS0MsSUFBSTdULEVBQUV1UztNQUNiLElBQUl1QixJQURHRCxJQUFJN1QsT0FHWCxJQUhXQSxTQUFKNlQsSUFBTXRCLE9BR2IsT0FIT3NCLElBQU10QixTQUNUdUIsR0FFZ0I7YUFLbEJDLE1BQU1sRSxJQUFJZ0U7TUFDWixTQUFRRyxNQUFNQyxHQUFHQztZQUFIQyxRQUFHQzs7UUFDZjt5QkFEZUEsT0FBSEQ7VUFDWjtZQUFxQixJQUNmRSxLQUZNRixPQUFHQztZQVFWLGNBVEN2RSxJQUFJZ0UsSUFHSlEsU0FISVIsSUFDRU0sV0FRMkMsS0FUN0NOLElBR0pRLElBRk1GO1lBU1AsY0FWQ3RFLElBQUlnRSxJQUNLTyxVQURMUCxJQUdKUTtjQVFGLEtBWE1SLElBR0pRLElBRlNEO2NBV1IsY0FaRHZFLElBQUlnRSxJQUdKUSxTQUhJUixJQUNFTSxXQVc2QyxLQVovQ04sSUFHSlEsSUFGTUY7WUFDUzthQVVtRCxNQVo5RE4sSUFHSlE7YUFTa0UsS0FYNURGO2FBVzRELEtBWHpEQzthQWVOLG9CQWhCSHZFLElBY0F5RSxNQWRJVCxJQUNLTzthQWVOLGlCQUNHLFdBakJOdkUsSUFBSWdFLElBQ0VNLFVBYU5HO1lBSUM7OztpQkFIRHRVLE9BQXFCdVM7O2lCQUtiLGNBcEJSMUMsSUFjQXlFLE1BZElULElBZUo3VDs7b0JBTVEsY0FyQlI2UCxJQUFJZ0UsSUFlaUJ0QixVQURyQitCO3NCQVFGLEdBUEV0VSxPQUFxQnVTLEtBT1AsS0F0QlZzQixJQWVKN1QsS0FBcUJ1UztzQkFPTzs7O29CQURlOztpQkFEQTs7Y0FNL0MsSUFYeUJBLE9BZGY0QixjQUFHQyxPQWNUcFU7Z0JBWUYsTUExQlFtVSxLQWNlNUIsTUFZdkIsU0FaRXZTLEtBZE1tVTtjQTRCUixNQWRFblUsS0FkU29VO2NBNEJYLFNBZHVCN0IsS0FkWjZCOztzQkE4Qlo7TUFDTCxRQWhDWVA7TUFnQ1osU0FoQ1lBLHVCQWdDWjs7WUFFQTdUO1FBQ0U7Y0FBSXlVLE1BbkNNWixJQWtDWjdUO1VBRVMsa0JBcENENlAsSUFBSWdFLEtBa0NaN1QsZ0JBQ015VTtZQUdGLElBSkp6VSxTQWxDWTZULEtBa0NaN1Q7WUFJSSxJQUFJdVMsS0FKUnZTOztzQkFJUXVTO29CQUNpQixXQXZDakIxQyxJQUFJZ0UsS0FzQ0p0QixtQkFIRmtDO2lCQU1BLElBSEVsQyxZQXRDSXNCLEtBc0NKdEIsbUJBR0Y7Y0FFRixJQUxJQSxZQUhGa0M7O1VBQUosU0FERnpVOzs7Y0FXSTt1QkFwRUZ3VCxLQXVCQU8sTUFsQ0lUOzthQ1lKb0IsVUFBVUMsS0FBS2hOLElBQUlDLElBQUlJLEVBQUU0TTtNQUMzQixRQURpQmpOO2VBQUlDO29DQUFUK00sUUFBUy9NLFdBQUpEO2dCQUdaLG9DQUhPZ04sS0FBS2hOLElBQUlDLElBQUlJLEVBQUU0TTtNQUV0QixpRUFDcUM7UUFZeENDO2FBQ0FDLFVBQVVILEtBQUtoTjtNQUNqQixRQURpQkE7bUNBQUxnTixrQkFBS2hOO2VBR1osdUJBSE9nTixLQUFLaE47TUFFWix5Q0FDeUI7YUFDNUJvTixXQUFXSixLQUFLaE4sS0FBb0Isc0JBQXpCZ04sS0FBS2hOLFFBQXNDO2FBRXREcU4sV0FBV0wsS0FBS2hOO01BQ2xCLFFBRGtCQTttQ0FBTGdOLGtCQUFLaE47U0FHYixJQUNDQyxJQURELHVCQUhRK00sS0FBS2hOO1NBR2IsNkJBSFFnTixjQUlQL00sZ0JBSllEO2tCQU1YO2tCQUNBLG9DQVBNZ04sS0FBS2hOO01BRWIsMENBTUY7YUFFRHNOLFlBQVlOLEtBQUtoTjtNQUdSLHVDQUhHZ04sTUFBS2hOLElBR3lCOzs7OztPQW5DMUMrTTs7T0FzQkFNO09BVUFDO09BakJBSjtPQUNBQztPQUlBQzs7YUM1QmlCRyxTQUFTNU4sR0FBSSxtQkFBSkEsZUFBa0I7O0tBVTNCNk47S0FDQUM7YUFPakJDLFFBQVNDLEtBQ1gsMENBRFdBLE1BQ1k7YUFDckJDLFVBQVUzUyxJQUFJNFM7TUFDbUIsU0FEbkJBLE1BQ21CLFdBRHZCNVMsSUFBSTRTO01BQ2YscUJBRFc1UyxJQUFJNFMsVUFDOEM7O0tBRTVEQztLQUNBQztLQUVBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUVBQztLQUVBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUlBQztLQUNBQztLQUNBQzthQUVBQyxzQkFDRWpTO01BRUMsWUFGREE7VUFFaUIsYUFGakJBO2lDQUNBa1MsS0FEQWxTOzs7OztNVmtjRSxrQlVqY0ZrUyxLQURBbFM7TUFNQyxZQUxEa1M7VUFLb0IsYUFMcEJBO1lBSUExUCxLQUpBMFA7Ozs7O3dCQUlBMVAsS0FFRztNQUVGLG9CQUpEQTtlQUpBMFA7ZUFTRywwQ0FBdUM7YUFFM0JDLGVBQWdCRCxNQUNsQyxPQURrQ0EsT0FDVDthQUVQRSxhQUFjRixNQUNoQyxPQURnQ0EsT0FDUDthQVN0QkcsU0FBT3JTLEdBQUksT0FBSkEsb0JBQW9COzt1Qjs7Ozs7Ozs7Ozs7Ozs7O09BQTNCcVM7Ozs7Ozs7Ozs7Ozs7OztPQXhFZTNCO09BVUFDO09BQ0FDO09BWWpCSztPQUNBQztPQUVBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUVBQztPQUVBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQzs7T0FJQUM7T0FDQUM7T0FDQUM7T0FFQUM7T0FhaUJFO09BR0FDO09BNUNqQnZCO09BRUFFOzs7O0tDbkJBdUI7S0FDQUM7S0FDQUM7S0FFQUM7S0FDQUM7S0FDQUM7S0FJQUM7S0FDQUM7S0FSQUM7YUE2REFDLFFBQU0vUyxFQUFFQyxHQUFJLGdDQUFORCxFQUFFQyxNQUFtQjthQUUzQitTLE9BQUtoVCxHQUFJLDBCQUFKQSxFQUFnQzs7Ozs7T0FsRXJDc1M7T0FDQUM7T0FDQUM7T0FDQU07T0FDQUw7T0FDQUM7T0FDQUM7T0FJQUM7T0FDQUM7O09BcURBRTtPQUVBQzs7OztvQkNoREtyUixFQUFFakM7TUFDVCxTQURPaUM7TUFFUCxRQUZPQTtRQU1hLHVCQU5iQSxFQU1hLFdBTlhqQyxNQU1XLEtBTmJpQyxVQU1hOztjQUNuQm5HO1VBQ0U7WUFBaUIsSUFEbkJBLFNBQ21CLFdBUlhrRSxFQU9SbEU7WUFDbUIsU0FEbkJBOzs7UUFHQSxPQUpJc0o7TUFKUyxrQ0FRVjsyQkFFVW1PLEdBQUdDLEdBQUdDO01BQ3BCLHVCQURjRixRQUNkLEtBRGNBLFdBQ2Q7O1lBQ0FqVDtRQUNFO1VBQWlCLElBRG5CQSxTQUNtQixlQUhGa1QsR0FBR0M7VUFHRCxTQURuQm5UOzs7TUFHQSxPQUpJOEUsR0FJRDtvQkFJSWhDO01BQ1AsSUFBSW5CLEVBREdtQixhQUNQLGFBQUluQixNQUF3QyxlQURyQ21CLElBQ0huQixFQUF3RDtzQkFFbkRxSixHQUFHRDtNQUNaLElBQUkvSixHQURLZ0s7TUFDVCxhQUFJaEs7ZUFDVyxPQUZIK0o7O2lCQUdlLGVBSGxCQyxLQUNMaEs7aUJBR0MsMEJBSklnSyxHQUFHRCxHQUlVO21CQUVoQmpJLEVBQUVLLElBQUlDO01BQ1osUUFEUUQ7ZUFBSUM7ZUFBTk4sZUFBTU0sV0FBSkQ7Z0JBR0gsZUFIQ0wsRUFBRUssSUFBSUM7TUFFUCxpQ0FDb0I7b0JBRWxCTixFQUFFSyxJQUFJQyxJQUFJSTtNQUNqQixRQURTTDtlQUFJQztlQUFOTixlQUFNTSxXQUFKRDtVQUdKLFVBSElBLE1BQUlDO1VBR1IsYUFISUQ7Z0JBR0ozSCxFQUhJMkg7WUFHNEI7Z0JBQWhDM0gsU0FIWWdJO2NBR29CLFNBQWhDaEk7Ozs7TUFEQSxrQ0FDcUQ7b0JBRW5Ed1AsR0FBR3lDLEtBQUsxQyxHQUFHMkMsS0FBS3RLO01BQ3ZCLFFBRHVCQTtlQUFicUs7ZUFBSHpDLGdCQUFnQjVILFdBQWJxSztpQkFBUUM7aUJBQUgzQyxnQkFBUTNILFdBQUxzSztrQkFJYix3QkFKRTFDLEdBQUd5QyxLQUFLMUMsR0FBRzJDLEtBQUt0SztNQUdsQixrQ0FDK0I7b0JBRTdCMUQsRUFBRW9EO01BQ1QsU0FEU0EscUJBQ1Q7OztRQUE2QjtxQkFEdEJwRCxFQUFFb0QsRUFDVHRIO1VBQTZCLFNBQTdCQTs7O2NBQW1EO3FCQUUzQ2tFLEVBQUVvRCxFQUFFekI7TUFDWixHQURVeUIsaUJBQUV6QjtjQUVWO01BRUEsU0FKUXlCLHFCQUlSOzs7UUFBNkI7cUJBSnZCcEQsRUFBRW9ELEVBSVJ0SCxPQUpVNkYsRUFJVjdGO1VBQTZCLFNBQTdCQTs7O2NBQXFFO21CQUVqRWtFLEVBQUVvRDtNQUNSLElBQUluQixFQURJbUI7TUFDUixTQUFJbkI7TUFBSixJQUVtQixpQkFGZkEsRUFFZSxXQUhiakMsRUFBRW9ELE9BR1csS0FGZm5CLFVBRWU7O1lBQ2pCbkc7UUFDRTtVQUFlLEVBRGpCQSxTQUNpQixXQUxia0UsRUFBRW9ELEVBSU50SDtVQUNpQixTQURqQkE7OztNQUdBLE9BSkkySSxDQUtIO29CQUVJekUsRUFBRW9ELEVBQUV6QjtNQUNYLE9BRFN5QixhQUNULEdBRFd6QjtNQUNYLEdBQUkrUixPQUNBQztjQUVGO01BQ0csU0FKREQ7TUFBSixJQU1zQixpQkFObEJBLEdBTWtCLFdBUGYxVCxFQUFFb0QsS0FBRXpCLE9BT1csS0FObEIrUixXQU1rQjs7WUFDbEI1WDtRQUNFO1VBQWUsRUFEakJBLFNBQ2lCLFdBVGRrRSxFQUFFb0QsRUFRTHRILE9BUk82RixFQVFQN0Y7VUFDaUIsU0FEakJBOzs7TUFHQSxPQUpJMkksQ0FNTDtxQkFFS3pFLEVBQUVvRDtNQUNWLFNBRFVBLHFCQUNWOzs7UUFBNkI7cUJBRHJCcEQsRUFDUmxFLEVBRFVzSCxFQUNWdEg7VUFBNkIsU0FBN0JBOzs7Y0FBc0Q7b0JBRS9Da0UsRUFBRW9EO01BQ1QsSUFBSW5CLEVBREttQjtNQUNULFNBQUluQjtNQUFKLElBRW1CLGlCQUZmQSxFQUVlLFdBSFpqQyxJQUFFb0QsT0FHVSxLQUZmbkIsVUFFZTs7WUFDakJuRztRQUNFO1VBQWUsRUFEakJBLFNBQ2lCLFdBTFprRSxFQUlMbEUsRUFKT3NILEVBSVB0SDtVQUNpQixTQURqQkE7OztNQUdBLE9BSkkySSxDQUtIO3FCQUVPckI7TUFDVixRQURVQSxxQkFDS3RILE1BQUVzSjtNQUNmO2dCQURhdEo7VUFDVSxhQUZmc0gsRUFDS3RILE9BQUVzSixLQUNRLElBRFZ0SixnQkFBRXNKO1FBQ0QsT0FEQ0EsSUFFTzthQUdsQnlPOzs7O1VBRUk7Ozs7bUJBQUxDOztRQURHO3FCQUtON1I7TUFGVSxHQUVWQTtRQUNpQjtTQURiSyxHQUFKTDs7U0FDaUIsK0JBRGpCQTs7ZUFBSUs7OztnQkFJTXlSLGNBQUpDO1lBQTZCLFdBQTdCQTtZQUE2Qiw4QkFBekJEOztVQURFLE9BRk4zUTtNQUZBLFVBTUs7eUJBRURwRCxFQUFFTSxFQUFFOEM7TUFDaEIsU0FEYzlDLEdBQ2QsS0FEZ0I4QyxxQkFDaEI7O1lBQ0F0SDtRQUNFO1VBQUssa0JBSEtrRSxFQUNSeUUsS0FEWXJCLEVBRWhCdEg7VUFDTyxTQURQQTs7O01BR0EsT0FKSTJJLElBSUY7MEJBRVd6RSxFQUFFb0QsRUFBRTlDO01BQ2pCLFNBRGlCQSxHQUNqQixLQURlOEM7TUFDZjtZQUNBdEg7UUFDRTtVQUFLLGtCQUhNa0UsRUFBRW9ELEVBRWZ0SCxPQURJMkk7VUFFRyxTQURQM0k7OztNQUdBLE9BSkkySSxJQUlGO3NCQUVPOEcsRUFBRW5JO01BQ1gsTUFEV0EsYUFFRXRIO01BQ1g7V0FEV0EsTUFEVDJGO1FBR00sY0FKRDhKLEVBQUVuSSxFQUVFdEg7UUFHTixRQUhNQTtpQkFJUDt1QkFFSXlQLEVBQUVuSTtNQUNaLE1BRFlBLGFBRUN0SDtNQUNYO1dBRFdBLE1BRFQyRjtRQUdNLGNBSkE4SixFQUFFbkksRUFFQ3RILFNBRXFCLFFBRnJCQTtRQUdOLFNBQ0Q7bUJBRUF3RSxFQUFFOEM7TUFDUixNQURRQSxhQUVLdEg7TUFDWDtXQURXQSxNQURUMkY7UUFHTSxzQkFKRjJCLEVBRUt0SCxPQUZQd0U7UUFLQyxRQUhNeEU7aUJBSVA7b0JBRUN3RSxFQUFFOEM7TUFDVCxNQURTQSxhQUVJdEg7TUFDWDtXQURXQSxNQURUMkY7UUFHRyxHQUpBbkIsTUFBRThDLEVBRUl0SDtRQUdOLFFBSE1BO2lCQUlQOztrQkFHQzZQLElBQUl2STtNQUNYLFNBQUk2USxPQUFPaFMsRUFBRW5HO1FBQ1gsVUFEV0EsNEJBQ1gsS0FBSW9ZO1FBQUosSUFBSUEsZUFES2pTO1VBR1MsU0FGZGlTLFlBR2lCLHNCQUxaOVE7VUFLSixjQUxBdUksSUFLSSxpQkFMQXZJLEVBRUw4UTtXQUNBNVQsT0FEQTRUO1VBRWM7V0FFaEIsS0FKRUE7V0FJZ0Isc0JBTlg5UTtXQU1XLEtBSGhCOUM7VUFHQyxjQU5BcUwsSUFNSSxpQkFOQXZJO1dBR0w5QyxPQURBNFQ7VUFLRixPQUpFNVQ7UUFNRixJQVBFNFQsZUFES2pTO1VBUXlCLFNBUDlCaVMsWUFPOEIsc0JBVHpCOVE7VUFTUyxzQkFUYnVJLElBU2lCLGlCQVRidkksRUFFTDhROztRQVNHLEdBVEhBLE1BREtqUyxTQUNMaVM7UUFTNEIsZ0JBVnJCcFksRUFVcUM7TUFWbEQsU0FZUXFZLFlBQVlsUyxFQUFFbkcsRUFBRXNZO1EsSUFBRmxTO1FBQ3BCO1VBQVEsSUFBSm1NLEVBQUksT0FEVXBNLEVBQUVDO1VBRWpCLGtCQWZFeUosSUFlRSxpQkFmRXZJLEVBY0xpTCxVQURrQitGO1lBR1osMEJBaEJEaFIsRUFjTGlMO1lBRUYsaUJBaEJPakwsRUFhV2xCO1lBR1YsSUFIVUEsSUFDaEJtTTs7VUFJSyx3QkFsQkFqTCxFQWFXbEIsZ0JBQUVrUyxFQU9sQjtNQW5CTixTQXFCSUMsUUFBUXBTLEVBQUVuRyxFQUFFc1k7UUFBSTtVQUFJLHFCQUFablMsRUFBRW5HLEVBQUVzWTs7OztZQUEyQyxJQUFMbFMsV0FBSyx3QkF0QmhEa0IsRUFzQjJDbEIsZ0JBQXRDa1M7b0JBQW9EO01BckJwRSxTQXNCUUUsV0FBV3JTLEVBQUVuRztRLElBQUFvRztRQUNuQjtVQUFRLGVBRFNELEVBQUVDLEtBRVgsc0JBekJDa0IsRUF1QlVxTDtVQUVuQixpQkF6QlNyTCxFQXVCVWxCO1VBQ1gsSUFEV0E7bUJBR0w7TUF6QmhCLFNBMkJJcVMsT0FBT3RTLEVBQUVuRztRQUFJO1VBQUksb0JBQVZtRyxFQUFFbkc7OztnQ0FBd0MsSUFBTG9HLFdBQUssT0FBTEE7b0JBQU07TUEzQnRELE1BRFdrQixhQUNYLE9Bc0NJbkI7TUF0Q0o7WUF1Q0F1UztRQUFvQztrQkFEaEN2UyxFQUNKdVMsSUFBZ0QsaUJBeENyQ3BSLEVBd0NYb1I7VUFBb0MsU0FBcENBOzs7TUF2Q0EsU0FzQ0l2UztNQUVKOzs7UUFDRTs7Z0NBMUNTbUIsRUF5Q1hsQjtXQUVVLHNCQTNDQ2tCO1VBMkNULGlCQTNDU0EsRUF5Q1hsQjtVQUNFLElBRVUsV0FIWkEsT0Faa0JwRztVQUNoQjtnQkFBSTRZLFFBRFk1WTtZQUNoQixHQURnQkEsTUFDWjRZO1lBRUQ7OEJBaENFL0ksSUFnQ0UsaUJBaENFdkksRUE4QkxzUixvQkFEY0Q7YUFNVCxpQkFuQ0FyUixFQTZCT3RILFlBQUUyWTs7Y0FJUiwwQkFqQ0RyUixFQThCTHNSO2NBR0YsaUJBakNPdFIsRUE2Qk90SDtjQUlkLE9BSEU0WSxZQURZNVksRUFDWjRZO2NBSXlDLGlCQWxDcEN0UixVQTZCU3FSO1lBQ2xCLFNBV0Z2Uzs7OztNQXhDQSxhQXNDSUQ7TUFPSjtRQUFjLHVCQTlDSG1CLFFBOENpQyxzQkE5Q2pDQTtRQThDeUIsaUJBOUN6QkE7UUE4Q0csU0FBc0IsaUJBOUN6QkEsVUE4Q1FnUjs7O01BcERqQixXQW9EK0Q7eUJBSW5EekksSUFBSXZJO01BQ2xCLFNBQUl1UixNQUFNQyxRQUFRQyxRQUFRQyxLQUFLQyxRQUFRQyxRQUFRN0csSUFBSThHO1FBQ2pEO2VBRFFMLFVBQVFDO1NBQ2hCLE1BRDZCRSxVQUFRQztTQWtCRyxzQkFsQmhCRixLQUFLQztTQWtCYixzQkFuQkEzUixFQUNSd1I7U0FFS1UsR0FGTFY7U0FFUXhUO1NBQUdtVSxHQUZVUjtTQUVQMVQ7U0FBR21VLEVBRndCUDtRQUcvQztVQUFHLGtCQUpPdEosSUFHSXZLLEdBQU1DO1lBU2xCLGlCQVh5QzhNLElBRXBCcUgsWUFBSG5VO1lBU2xCLElBQ0lvVSxLQVZXRjtZQVNmLEdBQ0lFLE9BWDBCTjtjQWE1QjttQkFabUJLO2VBWUwsc0JBZElWLEtBWWhCVztlQVZXRixHQVVYRTtlQVZjcFU7ZUFBR21VOztZQWNuQixjQWpCVXBTLEVBR0hrUyxHQUZnQ25ILElBRXBCcUgsVUFEckJOLFFBQ1NJO1VBRVQsaUJBSnlDbkgsSUFFcEJxSCxZQUFUcFU7VUFFWixJQUNJd1UsS0FIS047VUFFVCxHQUNJTSxPQUpKVjtZQU1FO2lCQUxtQk07YUFLWCxzQkFSRXBTLEVBTVJ3UzthQUhLTixHQUdMTTthQUhReFU7YUFBU29VOztVQU9uQixjQVRrQlYsS0FFTFMsR0FGMEJwSCxJQUVwQnFILFVBRFNMLFFBQ2ZJLFFBZ0IrQztNQWxCcEUsU0FvQklRLFFBQVFDLE9BQU83SCxJQUFJOEcsT0FBT3ZSO1FBQzVCLFNBRDRCQSxZQUM1Qjs7OztVQUNFOztrQkFGUXNTLFNBQ1ZsYTthQUNFLG1CQXZCY3NIO2FBdUJkLE1BRm1CNlIsU0FDckJuWjs7aUJBRHFCbVosVUFHZjVHOztnQkFDbUIsa0JBekJiMUMsSUF5QmlCLGlCQUpad0Msb0JBRVhpRztrQkFHRjt3QkFGRS9GO21CQUVlLHNCQUxKRjttQkFLSSxLQUZmRTtrQkFFRixpQkFMYUY7a0JBS2I7O2NBR0YsU0FMSUU7Y0FLSixpQkFSZUYsc0JBRVhpRztjQU1KLFNBUEZ0WTs7OztnQkFRSTtNQTdCTixTQStCUW1hLE9BQU9ELE9BQU83SCxJQUFJOEcsT0FBT3ZSO1FBQy9CLEdBRCtCQSxnQkFDVCxRQURUc1MsT0FBTzdILElBQUk4RyxPQUFPdlI7UUFDMEIsT0FEMUJBLFlBQzBCLEdBRDFCQSxNQUV6QnBDO1FBRUosT0FKVzBVLFNBRVAxVSxPQUZjNk0sSUFBSThHLFNBRWxCM1QsT0FDQUM7UUFFSixPQUxXeVUsT0FoQ0c1UyxFQWdDSDRTLFNBR1B6VSxPQURBRDtRQUdKLGFBTFcwVSxTQUdQelUsT0FEQUQsR0FGYzZNLElBQUk4RyxTQUVsQjNULE9BQ0FDLEdBSGM0TSxJQUFJOEcsT0FPckI7TUF0Q0wsSUF3Q0loVCxFQXpDY21CO01BQ2xCLEdBd0NJbkIsY0FDZ0IsVUExQ0ZtQixJQXlDZG5CO01BeENKO09BeUN5QyxHQURyQ0E7T0FDcUMsR0FEckNBLElBRUVYO09BRVksaUJBRFpDLEdBQ1ksaUJBN0NBNkI7TUE4Q2hCLE9BSEk5QixHQUVBNFUsSUFEQTNVO01BR0osU0EvQ2dCNkIsRUE0Q1o3QixHQURBRDtNQUlKLGFBSElDLEdBREFELEdBRUE0VSxJQURBM1UsR0E1Q1k2QixJQWlEZjtzQkFPTUE7TUFDVCxTQUFRa0ssSUFBSXhSO1FBQ1YsR0FEVUEsSUFESHNIO1VBSUwsTUFKS0EsRUFDR3RILE9BR1IsS0FIUUE7VUFJSyxVQURUd0UsaUIsT0FIQWdOO1FBS0QsUUFBTztNQUxkOzRCLE9BQVFBLGVBT0g7dUJBRUtsSztNQUNWLFNBQVFrSyxJQUFJeFI7UUFDVixHQURVQSxJQURGc0g7VUFJTixNQUpNQSxFQUNFdEgsT0FHUixLQUhRQTtVQUlTLGFBSlRBLEVBR0p3RSxrQixPQUhBZ047UUFLRCxRQUFPO01BTGQ7NEIsT0FBUUEsZUFPSDtzQkFhSWtIO01BQ1QsV0FBUSxxQkFBbUJ0TSxJQUFJNUgsR0FBSyxVQUFMQSxFQUFKNEgsSUFBZSxPQURqQ3NNO01BWE8sR0FFZHZTO1FBQ1k7U0FEUkssR0FBSkw7O1NBQ1ksa0JBRFpBO1NBQ1ksaUJBQU55QixJQURObkI7U0FDWSxJQUFObUI7O2VBREZwQjs7O2dCQUtNeVIsY0FBSkM7WUFBNkIsV0FBN0JBO1lBQTZCLDhCQUF6QkQ7O1VBREUsT0FGTjNRO01BSEEsVUFZSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQ3hTWCtTLE9BQ0FDLE1BQ0FDO2FBQ0FDLE9BQUs3VSxHQUFJLE9BQUpBLFNBQVk7YUFDakI4VSxPQUFLOVUsR0FBSSxPQUFKQSxTQUFZO2FBQ2pCK1UsTUFBSS9VLEdBQUkseUJBQUpBLGNBQWdDO1FBQ3BDZ1Ysc0JBQ0FDO2FBQ0FDLE9BQU9sVixHQUFJLE9BQUpBLE1BQWtCO2FBR3pCbVYsWUFBVW5WLEdBQUksNkJBQUpBLEVBQWlCO2FBSTNCb1YsZ0JBQWMxVztNQUVoQjtRQUFTLCtCQUZPQTs7OztRQUpBLFdBT007UUFJcEIyVzthQUNBQyxRQUFPelcsRUFBT0MsR0FBUSw4QkFBZkQsRUFBT0MsTUFBdUI7Ozs7T0F2QnJDNFY7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FFQUU7T0FEQUQ7T0FFQUU7T0FPQUU7T0FKQUQ7T0FXQUU7T0FDQUM7O2FuQnRCQUMsT0FBS3ZWLEdBQUksc0JBQUpBLE1BQVk7YUFDakJ3VixPQUFLeFYsR0FBSSxzQkFBSkEsTUFBWTthQUNqQnlWLE1BQUl6VjtNQUFJLHlCQUFKQSxTQUEyQix1QkFBM0JBLEVBQWdDO2FBR3BDMFYsU0FBTzFWLEdBQUksOEJBQUpBLE1BQWtCO2FBR3pCMlYsWUFBVTNWLEdBQUksaUNBQUpBLEVBQWlCO2FBSTNCNFYsZ0JBQWNsWDtNQUVoQjtRQUFTLGlDQUZPQTs7OztRQUpBLFdBT007UUFhcEJtWDthQUNBQyxRQUFPalgsRUFBT0MsR0FBUSxnQ0FBZkQsRUFBT0MsTUFBdUI7Ozs7T0FoQ3JDL0Y7T0FDQUM7T0FDQUM7T0FDQXNjO09BQ0FDO09BQ0FDO09BRUF0YztPQURBRDtPQUVBd2M7T0FPQUU7T0FKQUQ7T0FvQkFFO09BQ0FDOztRV2xDQUMsU0FDQUMsUUFDQUM7YUFDQUMsT0FBS2xXLEdBQUksT0FBSkEsU0FBWTthQUNqQm1XLE9BQUtuVyxHQUFJLE9BQUpBLFNBQVk7YUFDakJvVyxNQUFJcFcsR0FBSSx5QkFBSkEsY0FBZ0M7UUFFcENxVyxzQkFDQUM7YUFDQUMsU0FBT3ZXLEdBQUksT0FBSkEsTUFBa0I7YUFHekJ3VyxZQUFVeFcsR0FBSSwrQkFBSkEsRUFBaUI7YUFJM0J5VyxnQkFBYy9YO01BRWhCO1FBQVMsK0JBRk9BOzs7O1FBSkEsV0FPTTtRQUlwQmdZO2FBQ0FDLFFBQU85WCxFQUFPQyxHQUFRLDhCQUFmRCxFQUFPQyxNQUF1Qjs7OztPQXhCckNpWDtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBNU47T0FFQThOO09BREFEO09BRUFFO09BT0FFO09BSkFEO09BV0FFO09BQ0FDOzthVkRBQyxPQUFPQyxJQUFJQyxNQUFNdlQ7TUFDbkIsSUFBSXdULE9BQUosd0JBRFNGLElBQUlDLE1BQU12VDtNQUNuQixRQUFJd1Q7UUFDZ0IsVUFGRHhUO1FBRUMsU0FGREE7UUFFQyxxQ0FGREE7TUFPbkIsT0FOSXdULE1BTUU7YUFHSkMsV0FBV0gsSUFBSUMsTUFBTXZUO01BQ3ZCLElBQUl3VCxPQUFKLDRCQURhRixJQUFJQyxNQUFNdlQ7TUFDdkIsUUFBSXdUO1FBQ2dCLFVBRkd4VDtRQUVILFNBRkdBO1FBRUgscUNBRkdBO01BT3ZCLE9BTkl3VCxNQU1FO2FBbUVKRSxjQUFjMVk7TUFDYTs7T0FBN0I7Ozs7Ozs7O09BQ2U7TUFEQzt1QkFqRWlCNFk7Z0JBRS9COzs2QkE4RGM1WSxFQWhFTTJZLFdBQ3RCLHFCQURzQkE7aUJBRXBCLE1BREVFLFdBRDZCRDtnQkFhakMsd0JBYmlDQSwwQkFHN0JuWDtrQkFVK0Q7c0JBYmxDbVgsNkJBRzdCblg7O29CQVUrRCxxQkFibENtWDttQkFpQjFCO3FCQWpCMEJBOztvQkE0QjNCO3FCQURFRTtzQkFDRjs0QkFMSyxxQkF2QnNCRjtvQkE0QjNCLEdBREVFLFdBM0J5QkYsNkJBRzdCblg7cUJBMkJLO29CQUZILElBR0VzWCxPQURpRCxrQkFIakREO29CQU1KLEtBakM2QkYsb0JBK0J6QkcsU0EvQnlCSDtvQkFpQzdCLFlBRklHO2tCQVNOLElBQUk1WSxFQXhDMkJ5WTtrQkF3Qy9CLFlBeEMrQkEsWUF3QzNCelk7a0JBQUosWUF4QytCeVksWUF3QzNCelk7a0JBQUo7OEJBeEMrQnlZLFlBd0MzQnpZO2tCQUFKLFlBeEMrQnlZLFlBd0MzQnpZO2tCQUFKLE1BeEMrQnlZLFdBd0MvQixLQU1JMUMscUJBTko7O3dCQU9BcGE7b0JBQ0U7MEJBQUlnSSxFQUFKLGlCQUZFb1MsRUFDSnBhO3NCQUNFLFFBQUlnSSxFQUVGLGlCQUpBb1MsRUFDSnBhLFlBQ01nSSxJQVJGM0Q7c0JBUUYsU0FERnJFOzs7Z0JBT0YsS0F0RHNCNmMsYUFBV0Msb0JBRzdCblg7Z0JBbURKLFlBdERpQ21YLFlBRzdCblg7Z0JBbURKOzs7Ozs7Ozs7O2NBR0UzRzt1QkFvQkQ7YUFFQ2tlLGFBQWEzVTtNQUNmLDhCQUFtQlcsSUFBSXZELEdBQUssYUFEYjRDLEdBQ0lXLE1BQUl2RCxFQUFxQixFQUFDO2FBRTNDd1gsY0FBWTlZO01BQ2Q7Ozs7Ozs7O2tDQURjQTtPQUVDLGVBRkRBO01BRUM7dUJBRE15WSxRQUFVLHNCQUE4Qjs7Ozs7Ozs7OztjQTFCM0Q5ZDt1QkF1Q0Q7YUFFQ29lLE9BQU9OO01BQ1QsSUFBSWxWLElBREtrVjtNQUNULGtCQURTQSxvQkFDTGxWLElBQ3VEO2FBRXpEeVYsV0FBV1AsT0FBT3RELEdBQUdDO01BQ3ZCLElBQUk3UixJQURtQjZSLEtBQUhELE9BQ3BCLGtCQURhc0QsVUFBT3RELEdBQ2hCNVIsSUFDcUM7YUFFdkMwVixlQUFlUixPQUFPdEQsR0FBR0M7TUFDM0IsUUFEd0JELElBQ1IsSUFDVjVSLElBRnFCNlIsS0FBSEQsT0FHakIscUJBSFVzRCxVQUFPdEQsR0FFbEI1UjtNQUVHLFFBRU47YUFFRDJWLGdCQUFnQlQsT0FBTzljLEdBQUksc0JBQVg4YyxVQUFPOWMsRUFBaUM7YUFFeER3ZCxvQkFBb0JWLE9BQU85YztNQUM3QixZQUQ2QkEsS0FFdEIsZUFGZThjLFVBQU85YyxLQUl2QjthQUdKeWQsWUFBWVgsT0FBTzljO01BQ3JCLHNCQURjOGMsc0JBQU85YyxNQUNpQzthQUVwRDBkLGFBQWFaLFFBQVMsT0FBVEEsYUFBb0M7YUFDakRhLFdBQVdiLFFBQVMsT0FBVEEsYUFBbUM7YUFFOUNjLGVBQWVkLFFBQVMsT0FBVEEsVUFBMkI7YUFDMUNlLGFBQWFmLFFBQVMsT0FBVEEsVUFBMEI7YUFFdkNnQixTQUFTaEI7TUFDWCxJQUFJaUIsSUFET2pCO01BQ1gsZ0JBQUlpQjtNQUFKLFFBSUM7YUFNQ0MsWUFBWW5HO01BQ2Q7O2VBRGNBO01BQ2Q7O2NBR3VCOzs7O09BOU1yQjlZO09BMElBbWU7T0FHQUM7T0FsQkFQO09Ba0NBUTtPQXlCQUs7T0FHQUM7T0FDQUM7T0FFQUM7T0FDQUM7T0FFQUM7T0FXQUU7T0F6Q0FYO09BSUFDO09BUUFDO09BRUFDO09BeElBakI7T0FVQUk7O0ltQmVVOzs7Ozs7T0FDQTtPQUNTLG1CbkJsRW5CNWQ7T21CbUVpQixtQm5CbkVqQkE7Ozs7Ozs7Ozs7Ozs7SW1CZ0VVLFNBaUJWbWY7TUFDRjtlQW5CRUQ7T0FtQkYsUUFBSUU7T0FFUSxxQkFEUkM7T0FFUSxxQkFGUkE7T0FHWSx5QkFIWkEsUW5CbkZGcmY7T21Cc0ZjLHVCQUhacWYsUW5CbkZGcmY7TW1Cd0ZBLE9BekJBa2YsU0FxQkVJLFFBRkFGO01BTUYsU0FKRUU7TUFNRixPQTNCQUosU0FzQkVLLFFBSEFIO01BUUYsU0FMRUc7TUFPRixPQTdCQUwsU0F1QkVNLFlBSkFKO01BVUYsU0FORUk7TUFRRixPQS9CQU4sU0F3QkVPLFVBTEFMO01BWUYsU0FQRUs7TUFPRixTQVhFSjtNQVdGLFFBRXdCO0lBaENkLFNBa0NWSztNQUNGLE9BcENFUixtQkFvQ0YsbUJBQ3VCO0lBcENYLElBc0NWUyx5Q0FBZ0QsUUFBSztJQXRDM0MsU0F3Q1ZDLFFBQVFDLE9BQU9DLE1BQU1DLE1BQU1oQztNQUM3QjtnQkExQ0VtQjtPQTBDRixRQTFDRUE7T0EwQ0YsZUExQ0VBO09BMENGLFdBMUNFQTtPQTBDRixlQTFDRUE7T0EwQ0YsVUExQ0VBO09BMENGLGFBMUNFQTtNQTBDRixTQTFDRUE7TUEwQ0YsU0FEaUJZO01BQ2pCLFVBRDZCL0I7TUFDN0I7WUFBYXdDLE1BQUlDO1FBQ2Y7VUFBTSxvQ0FGRVgsT0F6Q1JYLElBMENXcUIsSUFBSUM7VUFDVDs7YUFFYyxJQUhMQyxNQUdLLFdBSkNWLE1BQU1oQzthQUlQLFNBSk9BO2FBSVAsVUFKT0E7YUFJUCxJQUhUd0MsTUFBSUM7O21CQVFYO21CQVNBLG1CQWpCT0QsTUFBSUM7bUJBbUJYLG1CQW5CT0QsTUFBSUM7O2FBVVg7ZUFFK0Q7cUJBdERuRXRCO2dCQXNEbUU7NEJBQWhDLGlCQWIzQlcsMEJBekNSWDtnQkFzRG1FO2dCQVp4RHdCO2dCQUFJQzs7OzttQkFBSkQsUUFBSUM7aUJBQUpKLFVBQUlDOzs7YUFxQlgsV0F0QklYLGlDQUNHVSxNQUFJQztZQW1DWkk7O1FBQ0gsSUFBSUMsVUE5RUozQjtRQThFQSxVQWJFYztRQWFGLFVBWkVDO1FBWUYsU0FYRUM7UUFXRixVQVZFQztRQVVGLFNBVEVDO1FBU0YsU0FSRUM7UUFRRixVQVBFQztRQU9GLEdBREdNLG1CQVdDLElBREszWCxFQVZOMlgsT0FXQyxPQURLM1g7UUFHTDs7aUJBQ082WDtVQUNBLFlBREFBO1lBRXVCLHNCQUZ2QkE7WUFFRSx3QkFwRExqQiw4QkFxQ0pnQjs7O1VBZ0JTLHdCQXJETGhCLFVBa0RHaUIsa0JBYlBELGFBZ0J3RDtRQUp4RCxNQWJERCxJQWtCVTtJQTlGSCxTQWdHVkcsU0FBUzdCLElBQUl0WTtNQUNmLFNBRFdzWSxVQUFJdFksTUFDZix3QkFEV3NZLHNCQUN3QjtJQWpHdkIsU0FtR1Y4QjtNLElBQ1cvZixFQXJHWGllO01Bc0dBO2VBRFdqZTtVQUVOO2lCQXZHTGllLFVBcUdXamU7V0FFTixvQkF2R0xpZTtXQXVHSyxNQXZHTEEsVUFxR1dqZTtXQUVOLG9CQXZHTGllO1VBMEdLLGlCQUZDK0IsR0FDQUMsV0FEQUQ7VUFERCxJQUdzQixJQUxoQmhnQjs7UUFDSSxTQXRHZmllO1FBc0dlLHdCQXRHZkEsdUJBNkdlO0lBNUdMLFNBOEdWaUM7TUFBb0IsU0EvR3BCakMsUUErR29CLHdCQS9HcEJBLHNCQStHZ0Q7SUE5R3RDLFNBK0dWa0MsY0FBY3hhO01BQUksU0FoSGxCc1kscUJBZ0hjdFk7TUFBSSx3QkFoSGxCc1ksc0JBZ0hxRTtJQS9HM0QsU0FnSFZtQyxZQUFZemE7TUFBSSxTQWpIaEJzWSxxQkFpSFl0WTtNQUFJLHdCQWpIaEJzWSxzQkFpSGlFO0lBaEh2RCxTQWtIVm9DLG9CQUFrQiw2QkFBOEI7SUFsSHRDLFNBbUhWQyxrQkFBZ0IsMkJBQTRCO0lBbkhsQyxTQW9IVkMsVUFBVTVhLEdBQUkscUJBQUpBLEtBQThCO0lBcEg5QixTQXFIVjZhLFFBQVE3YSxHQUFJLG1CQUFKQSxLQUE0QjtJQXJIMUIsU0F1SFY4YSxxQkFBcUJaO01BQ3ZCLGtCQWxGRW5CLHlCQWlGcUJtQixJQUNlO0lBeEgxQixTQTBIVmEsbUJBQTJCLFFBQUU7SUExSG5COzs7T0FrSFZMO09BQ0FDO09BQ0FDO09BQ0FDO09BbEJBVDtPQVdBRztPQUNBQztPQUNBQztPQTlFQTNCOztzQjs7T0FNQUU7T0F3REFtQjtPQXVCQVc7T0FHQUM7SUExSFU7Ozs7O2tCQ1pOQyxjQUFTLFVBRUcsSUFBTkMsV0FBTSxPQUFOQSxFQURHLFFBQ0k7a0JBT2JDLE9BQU8xYSxFQUFFNkIsRUFBRVc7V0FDYixHQURTeEMsRUFDc0MsTUFEdENBLEtBQ0wyYSxHQUFxQ0YsV0FBckNFO1dBQ0osR0FGYW5ZLEVBRWtDLFFBRmxDQSxLQUVUcVksR0FBcUNELGFBQXJDQztXQUNKLFNBRElBLE1BREFGLGNBQ0FFO3FCQUZLN2EsRUFBRTZCLEVBQUVXLE9BR3lDO2tCQU9wRHNZLElBQUk5YSxFQUFFNkIsRUFBRVc7V0FDVixHQURNeEMsRUFDeUMsTUFEekNBLEtBQ0YyYSxHQUFxQ0YsV0FBckNFO1dBQ0osR0FGVW5ZLEVBRXFDLFFBRnJDQSxLQUVOcVksR0FBcUNELGFBQXJDQztXQUNKLElBRElBLGNBREFGO2FBRWdCLEdBSGQzYTtlQU9nQixJQURDK2EsR0FOakIvYSxLQU1XZ2IsR0FOWGhiLEtBTUtpYixHQU5MamIsS0FPZ0IsWUFEQythO2VBQ2Qsa0JBREVFLFdBRVUsT0FGVkEsR0FBTUQsR0FFSSxPQUZFRCxHQU5mbFosRUFBRVc7ZUFTQyxHQUhZdVk7aUJBT21CLElBRFhHLElBTlJILE1BTUNJLElBTkRKLE1BTU5LLElBTk1MLE1BT21CLFlBRFhHLElBWnZCclosRUFBRVc7aUJBYVMscUJBUFJ5WSxHQUFNRCxHQU1BSSxLQUFPRDtlQURMO2FBTk47V0FVSixJQWRMUixjQUNBRTthQWF5QixHQWZuQnJZO2VBbUJZLElBREM2WSxHQWxCYjdZLEtBa0JPOFksR0FsQlA5WSxLQWtCQytZLEdBbEJEL1ksS0FtQlksWUFEWCtZO2VBQ0Ysa0JBRGNGLFdBRVIsY0FwQlRyYixFQUFFNkIsRUFrQkcwWixJQUFNRCxHQUFNRDtlQUdaLEdBSEFFO2lCQU82QixJQURUQyxJQU5wQkQsTUFNYUUsSUFOYkYsTUFNTUcsSUFOTkgsTUFPNkIsWUFEVEMsSUFOZEYsR0FBTUQ7aUJBT0oscUJBekJicmIsRUFBRTZCLEVBd0JTNlosS0FBT0Q7ZUFETDthQU5OO1dBV1gsU0ExQkVaLE1BREFGLGNBQ0FFO3FCQUZFN2EsRUFBRTZCLEVBQUVXLE9BNEI4QztrQkFJbERtWixJQUFJdGQsRUFFUjRWO1csR0FBQUE7YUFDVSxJQURDelIsRUFBWHlSLEtBQVFwUyxFQUFSb1MsS0FBS2pVLEVBQUxpVSxLQUNVLG9CQUhGNVYsRUFFQXdEO2FBQ0UsU0FBSmYsU0FETm1UO2FBR0UsUUFGSW5ULEdBTU8sSUFBTHVhLEdBQUssSUFUTGhkLEVBRUdtRSxHQU9FLE9BUEZBLE1BT0g2WSxHQVBScEgsRUFRMkIsSUFSdEJqVSxFQUFHNkIsRUFPQXdaO2FBTkUsSUFHRkosR0FBSyxJQU5MNWMsRUFFSDJCO2FBSVEsT0FKUkEsTUFJR2liLEdBSlJoSCxFQUsyQixJQURuQmdILEdBSkFwWixFQUFHVztXQURGLFlBRERuRTtrQkFZUnVkLFVBQVV2ZCxHQUFJLFlBQUpBLE1BQW9DO2tCQVMxQ3dkLGdCQUFnQnhkO1c7aUJBRVJtRSxXQUFIWCxXQUFIN0I7YUFDRiwyQkFIZ0IzQixFQUVkMkIsR0FBRzZCLEVBQUdXO1dBREgsaUJBRFduRTtrQkFLaEJ5ZCxnQkFBZ0J6ZDtXO2lCQUVSbUUsV0FBSFgsV0FBSDdCO2FBQ0UsV0FERkEsRUFBRzZCLEVBQ0QsZ0JBSFl4RCxFQUVSbUU7V0FESCxpQkFEV25FO2tCQVFoQjBkLEtBQUsvYixFQUFFNkIsRUFBRVc7V0FDZixHQURXeEM7Z0JBQUl3Qzs7Z0JBSTJDd1osR0FKM0N4WjtnQkFJcUM2WSxHQUpyQzdZO2dCQUkrQjhZLEdBSi9COVk7Z0JBSXlCK1ksR0FKekIvWTtnQkFJYXlaLEdBSmpCamM7Z0JBSVcrYSxHQUpYL2E7Z0JBSUtnYixHQUpMaGI7Z0JBSURpYixHQUpDamI7dUJBSStDZ2MsY0FBOUJDO3dCQUNNLElBRHhCaEIsR0FBTUQsR0FDa0IsS0FEWkQsR0FKVGxaLEVBQUVXO3lCQUlheVosY0FBOEJELEdBRTlCLFNBTmpCaGMsRUFBRTZCLEVBSTJCMFosSUFBTUQsR0FBTUQsSUFHaEQsT0FQT3JiLEVBQUU2QixFQUFFVzthQUdDLHVCQUhIWCxFQUFGN0I7V0FFSyx1QkFGSDZCLEVBQUVXLEVBT0M7a0JBSVYwWjtXO1dBQVU7Ozs7ZUFFTSxJQUFOcmE7ZUFBTSxPQUFOQTthQURMLGdCQUVXO2tCQUVoQnNhO1c7V0FBYzs7OztlQUVFLElBQU50YTtlQUFNLFVBQU5BO2FBREwsU0FFZTtrQkFFcEJ1YTtXO1dBQVU7Ozs7ZUFFTTthQURYLGdCQUVXO2tCQUVoQkM7VztXQUFjOzs7O2VBRUU7YUFEWCxTQUVlO2tCQUlwQkM7V0FBaUI7OzttQkFHVjlaLFdBQUhYLFdBQWEsZ0NBQWJBLEVBQUdXO2FBRFMsSUFBTitaO2FBQU0sT0FBTkE7V0FETCwwQ0FFa0M7a0JBZ0IzQ0MsT0FHQ3ZJLEVBRE90SztXQURWLEdBRUdzSzthQUNTLEdBRkZ0SztlQUV1Qix3QkFGdkJBO2VBRVUsWUFEakJzSyxFQUNpQixRQUZWdEs7YUFDTSxPQUFic0s7V0FEYSxPQUFOdEssS0FFMEM7a0JBUTlDOFMsTUFBTXBlO1c7YUFJQSxJQURDbUUsV0FBSFgsV0FBSDdCLFdBQ0ssb0JBSkEzQixFQUdGd0Q7YUFDRSxTQUFKZixZQUREZCxJQUFNd0M7YUFHSixRQUZEMUI7ZUFLbUIsZ0JBVGZ6QyxFQUdDbUUsR0FNYztlQUFjLGVBTmxDeEMsRUFBRzZCLEVBTUNrWixJQUFJMkIsS0FBTXJCO2FBTFQ7Y0FHZSxjQVBmaGQsRUFHTDJCO2NBSW9COzs7YUFBd0IsVUFBeENpYixHQUFJMEIsT0FBb0MsS0FBOUJwQixHQUpYMVosRUFBR1c7V0FEVDthQVdGMkM7a0JBRUF5WCxnQkFBVyxnQkFBbUM7a0JBRTFDQyxJQUFJeGU7Vzs7O2VBR0U7Z0JBRENtRTtnQkFBSFg7Z0JBQUg3QjtnQkFDSyxvQkFIRjNCLEVBRUF3RDtnQkFDRSxXQUFKZjtlQUFJO21CQURDK1EsYUFDTC9RLEVBREswQixFQUFOeEMsVUFBTTZSOzthQURGO2tCQUtMaUwsT0FBT3plLEVBRVg0VjtXLEdBQUFBO2FBQ1UsSUFERXpSLEVBQVp5UixLQUFTcFMsRUFBVG9TLEtBQU1qVSxFQUFOaVUsS0FDVSxvQkFIQzVWLEVBRUZ3RDthQUNDLFNBQUpmO2VBL0NSLEdBOENRZDtpQkEzQ0ksR0EyQ0V3QzttQkEzQ2tCLHdCQTJDbEJBLEdBM0NLLFdBMkNYeEMsRUEzQ1csUUEyQ0x3QztpQkE1Q0UsT0E0Q1J4QztlQTdDUSxPQTZDRndDO2FBSVIsUUFIRTFCLEdBUVMsSUFBTHVhLEdBQUssT0FYSmhkLEVBRUNtRSxHQVNHLE9BVEhBLE1BU0Y2WSxHQVRWcEgsRUFXVyxJQVhMalUsRUFBRzZCLEVBU0N3WjthQVJBLElBSUFKLEdBQUssT0FQSjVjLEVBRUwyQjthQUtTLE9BTFRBLE1BS0lpYixHQUxWaEgsRUFPVyxJQUZEZ0gsR0FMRHBaLEVBQUdXO1dBREg7a0JBY0x1YSxNQUdIalQsR0FET0g7V0FEVixHQUVHRztnQkFET0g7O2dCQUVnREUsR0FGaERGO2dCQUUwQ3FULEdBRjFDclQ7Z0JBRW9Dc1QsR0FGcEN0VDtnQkFFOEJySyxHQUY5QnFLO2dCQUVrQkksR0FEekJEO2dCQUNtQm9ULEdBRG5CcFQ7Z0JBQ2FxVCxHQURiclQ7Z0JBQ096SyxHQURQeUs7a0JBQ3VERCxNQUE5QkU7aUJBRXRCLFNBRm9ERixVQUVyQyxJQUZ5Qm9ULEdBRDNDblQ7aUJBSXVCO2dDQUhWcVQsR0FGTnhUO2tCQUtnQjs7a0JBQ0ksV0FKUnVULEdBR0ZFO2lCQUNQLGtCQUpIL2QsR0FHR3VKLE1BSEd1VTtlQU9WLFNBUHNCcFQsVUFPUCxJQVBMb1QsR0FGTnhUO2VBVWdCOzhCQVJvQnNULEdBRDNDblQ7Z0JBU3VCOztnQkFDSSxXQURWdVQsS0FSZ0NMO2VBU3ZDLGtCQURBclUsS0FSMkJySixJQUFNMmQ7YUFEN0IsT0FBZG5UO1dBRGMsT0FBUEgsS0FZRDtrQkFFSDJULE1BQU1uZSxHQUlld0s7V0FIM0IsR0FEWXhLO2dCQUlld0s7ZUFDakI7Z0JBRFl1VCxHQUpWL2Q7Z0JBSUlnZSxHQUpKaGU7Z0JBSUZFLEdBSkVGO2dCQUtGLFdBRE1nZSxHQUFXeFQ7Z0JBQ2pCOztpQkFFRixlQUFxQixXQUhQdVQsR0FFSkY7aUJBQ0gsb0JBSEwzZDtlQUNBLElBR08rZCxhQUNhLFdBTFJGLEdBSUxFO2VBQ0osa0JBTEgvZCxTQUFNOGQ7YUFEQTtXQURBLFFBTzJCO2tCQUVyQ0ksS0FHSHpULEdBQ3dCSDtXQUgzQixHQUVHRztnQkFDd0JIO2VBQ2pCO2dCQURZdVQsR0FEbkJwVDtnQkFDYXFULEdBRGJyVDtnQkFDT3pLLEdBRFB5SztnQkFFTyxXQURNcVQsR0FBV3hUO2dCQUNqQjs7aUJBRUYsZUFBcUIsVUFIUHVULEdBRUpGO2lCQUNMLGlCQUhIM2QsU0FBTThkO2VBQ04sSUFHT0MsYUFDVyxVQUxORixHQUlMRTtlQUNGLG1CQUxML2Q7YUFETyxPQUFkeUs7V0FEYSxRQU93QjtrQkFJbEMwVCxVQUFVdGYsRUFBRWlVO2VBQUY5TCxNQUFFbU07V0FDbEI7Z0JBRGdCbk07O2dCQUdIN0QsRUFIRzZEO2dCQUdOeEUsRUFITXdFOztnQkFBRXFYLE9BR1I3YixFQUFHVyxFQUhLZ1E7Z0JBQUZuTTtnQkFBRW1NOzthQUVQLE9BRk9BLElBRzRCO2tCQWE1QzlMLFFBQVF2SCxHQUFHQztXQUNrQixtQkFEbEJBLE1BQ0QsZUFERkQsTUFYUTBlLFFBQUd0UTtXQUNuQjtnQkFEZ0JzUTtrQkFBR3RRO2lCQU1UO2tCQURzQnVRLEtBTGJ2UTtrQkFLU3lQLEdBTFR6UDtrQkFLSzBQLEdBTEwxUDtrQkFLTHdRLEtBTEVGO2tCQUtOWCxHQUxNVztrQkFLVlYsR0FMVVU7a0JBTU4sb0JBREpWLEdBQWtCRjtpQkFDZCxTQUFKbmM7bUJBRytCO21DQUpUa2MsR0FBSWM7b0JBSWIsZUFKVFosR0FBSWE7b0JBTEVGO29CQUFHdFE7O2lCQVFaLE9BRkR6TTtlQUZNO2FBREMsT0FITXlNLFFBWTRCO2tCQUUvQzFHLE1BQU0xSCxHQUFHQyxJQUNYLHFCQURRRCxHQUFHQyxPQUNNO2tCQUVYOGUsT0FBTy9lLEdBQUdDO2VBQUh5VSxRQUFHSDtXQUNoQjtnQkFEYUc7a0JBQUdIO2lCQU9KO2tCQURvQ3NKLEdBTmhDdEo7a0JBTTBCdUosR0FOMUJ2SjtrQkFNb0JwVSxHQU5wQm9VO2tCQU1Nd0osR0FOVHJKO2tCQU1Hc0osR0FOSHRKO2tCQU1IeFUsR0FOR3dVO2tCQU9ELG9CQURJc0osR0FBMEJGO2lCQUM5QixTQUFKbmM7bUJBRUYsZ0JBSEl6QixHQUEwQkM7bUJBRzlCLGFBVE91VSxLQU1TcUosR0FOTnhKLEtBTWdDc0o7bUJBSXZDO3lCQUhEbGM7bUJBTUYscUJBUFVxYyxHQUFNRCxNQUEwQkY7bUJBTzFDLGFBYk9uSixLQU1IeFU7bUJBRE47aUJBRVEsU0FJTixVQUxJQSxHQUFNOGQsUUFBb0I3ZDtpQkFLOUIsYUFYT3VVLEtBTVNxSjtpQkFPaEI7ZUFSRjthQUZBLFNBVTZEO2tCQUUzRGhjLEtBQUtuRDtXOzs7bUJBRUV5RSxhQUFIWCxhQUFIN0I7ZUFBWSxLQUZSakMsRUFFSmlDO2VBQXNCLFdBRmxCakMsRUFFRDhEOzJCQUFHVzs7YUFERjtrQkFHTDJiLEtBQUtwZ0IsRUFBRUcsRUFBRThFO2VBQUZxRCxNQUFFbkQ7V0FDZjtnQkFEYW1EO2VBR2U7Z0JBQWY3RCxFQUhBNkQ7Z0JBR0h4RSxFQUhHd0U7Z0JBR05yRyxFQUhNcUc7Z0JBR2Usa0JBSGpCdEksRUFHRDhELEVBQXVCLEtBSHRCOUQsRUFHSmlDLEVBSFFrRDtnQkFBRm1ELElBR0E3RDtnQkFIRVU7O2FBRUosT0FGSUEsT0FHa0M7a0JBRTNDa2IsUUFBUTlVO1c7OztlQUVLO2dCQUFOOUc7Z0JBQUhYO2dCQUFIN0I7Z0JBQVksZ0JBRkxzSixFQUVKekg7ZUFBUztpQkFBTyxpQkFGWnlILEVBRVB0SjtpQkFBbUIscUJBQWJ3QztpQkFBYTs7O2VBRGY7O2tCQUdMNmIsT0FBTy9VO1c7OztlQUVNO2dCQUFOOUc7Z0JBQUhYO2dCQUFIN0I7Z0JBQVksZ0JBRk5zSixFQUVIekg7ZUFBUzs7O2lCQUFPLGdCQUZieUgsRUFFTnRKO2lCQUFtQix1QkFBYndDO2lCQUFhO2VBRGY7O2tCQUdMa0QsT0FBTzRELEVBRVgySztXLEdBQUFBO2FBRVc7Y0FGQ3pSLEVBQVp5UjtjQUFTcFMsRUFBVG9TO2NBQU1qVSxFQUFOaVU7Y0FFVyxXQUpBM0ssRUFFTHRKO2NBR0ssY0FMQXNKLEVBRUZ6SDtjQUlFLFdBTkF5SCxFQUVDOUc7YUFJRCxHQURMOGIsSUFHRixHQU5FdGUsTUFFQXFJLE9BRk03RixNQUlOK1osV0FKTnRJLEVBTWtDLFlBSjVCNUwsSUFGR3hHLEVBSUgwYTthQUdDLGNBTERsVSxJQUVBa1U7V0FMRztrQkFVTGdDLFVBQVVqVjtXO2FBSUc7Y0FGTjlHO2NBQUhYO2NBQUg3QjtjQUVZLGdCQUpIc0osRUFFVHRKO2NBRVk7O2NBQ04sY0FMR3NKLEVBRU56SDtjQUlTLGtCQU5IeUgsRUFFSDlHO2NBSU07O2dCQURYOGIsSUFHZ0IsZ0JBSlhFLEdBRUFFLElBRUgsZUFKREQsR0FGQzVjLEVBSUQ4YzthQUZVLFNBS0ssS0FMWEgsR0FGSDNjLEVBSUc2YzthQUdILGlCQUxERCxHQUVBRTtXQUxFO2tCQVVMQztXQUFXO2FBRWdCLElBQXZCcGMsV0FBSHhDLFdBQTBCLGNBQXZCd0M7YUFBTSxpQkFBVHhDO1dBREksUUFDZ0M7a0JBRXJDNmU7Ozs7ZUFFZ0M7Z0JBQXpCcmM7Z0JBQUhYO2dCQUFIN0I7Z0JBQStCLFVBQTVCNkIsRUFBNEIsb0JBQXpCVzs7d0JBQU54Qzs7YUFESTtrQkFHVDhlLFNBQVM1Z0IsR0FDWCxzQkFEV0EsRUFDTTtrQkFNWDZnQixLQUFLMWdCO1c7OztlQUdDO2dCQURDbUU7Z0JBQUhYO2dCQUFIN0I7Z0JBQ0ssb0JBSEQzQixFQUVEd0Q7ZUFDRSxTQUFKZixTQURFZTtlQUNFLElBRUgsYUFGRGYsRUFESzBCLEVBQU54QyxVQUFNNlI7O2FBREY7a0JBZUxtTixXQVRrQmpoQjtXOzs7bUJBWVh3ZSxlQUFIMEMsZUFBSDVXO2VBQ0EsY0FiaUJ0SyxFQVlka2hCO2tDQUFINVc7Ozt5QkFUTTdGLFdBQUhYLFdBQUg3QjtxQkFDQSxjQUppQmpDLEVBR2Q4RCxtQkFBSDdCOytCQUFNd0M7O21CQURUOzJCQVVTK1o7O2FBRFQ7a0JBZ0JFMkMsZUFUc0JuaEI7Vzs7O21CQVlmd2UsZUFBSDBDLGVBQUg1VztlQUNBLGNBYnFCdEssRUFZbEJraEI7a0NBQUg1Vzs7O3lCQVRNN0YsV0FBSFgsV0FBSDdCO3FCQUNBLGNBSnFCakMsRUFHbEI4RCxtQkFBSDdCOytCQUFNd0M7O21CQURUOzJCQVVTK1o7O2FBRFQ7a0JBZ0JFNEMsVUFUaUJwaEI7Vzs7O21CQVlWd2UsZUFBSDBDLGVBQUg1VztlQUNBLGNBYmdCdEssRUFZYmtoQjtrQ0FBRzFDOzs7eUJBVEEvWixXQUFIWCxXQUFIN0I7cUJBQ0EsY0FKZ0JqQyxFQUdiOEQsbUJBQUdXOytCQUFOeEM7O21CQURIOzJCQVVHcUk7O2FBREg7a0JBZ0JFK1csY0FUcUJyaEI7Vzs7O21CQVlkd2UsZUFBSDBDLGVBQUg1VztlQUNBLGNBYm9CdEssRUFZakJraEI7a0NBQUcxQzs7O3lCQVRBL1osV0FBSFgsV0FBSDdCO3FCQUNBLGNBSm9CakMsRUFHakI4RCxtQkFBR1c7K0JBQU54Qzs7bUJBREg7MkJBVUdxSTs7YUFESDtrQkFPRWdYLFNBQVNoaEI7Vzs7O2VBR0g7Z0JBRENtRTtnQkFBSFg7Z0JBQUg3QjtnQkFDSyxvQkFIRzNCLEVBRUx3RDtlQUNFLFNBQUpmLFlBREVlO2VBQ0UsSUFFSCxhQUZEZixFQURLMEIsRUFBTnhDLFVBQU02Ujs7YUFERjtrQkFlTHhNLElBQUl0SCxFQUVSa1c7VyxHQUFBQTthQUVVO2NBRkN6UixFQUFYeVI7Y0FBUXBTLEVBQVJvUztjQUFLalUsRUFBTGlVO2NBRVUsUUFKRmxXLEVBRUhpQztjQUdLLGVBTEZqQyxFQUVBOEQ7Y0FJRSxRQU5GOUQsRUFFR3lFO2FBSUQsR0FKTHhDLE1BWElxSSxPQVdEeEcsTUFYR29kLE9BV0F6YyxNQVhFK1osV0FXYnRJO2FBUEYsU0FKVzVMOzs7Y0FJa0I7NEJBSmxCQTtlQUlNLHFDQUpKNFc7YWZ3Q1g7d0JleENhMUM7OztnQkFLZ0I7OEJBTGhCQTtpQkFLRSxnQ0FMSjBDO29DQU1SLEtBTk01VyxJQUFFNFcsSUFBRTFDO2FBT0YsYUFQRmxVLElBT0UsSUFQQTRXLElBQUUxQztXQVVKO2tCQThCVCtDLFFBQVF0ZjtXQUNWLEdBRFVBOzs7Ozs7Ozs7O3VCQVFZOzZDQVJaQTt3QkFwQlY7a0NBQVlSLEVBQUVROzJCQUNaLFVBRFVSOztxQ0FFQSxZQUZFUTs7eUNBR0R3ZixJQUhDeGYsS0FHUHlmLEdBSE96ZixvQkFHUHlmLFFBQU1EOzs7a0NBSEN4Zjs7O3VDQUlLMGYsWUFBTnBWLFdBQU5xVixLQUpPM2Y7cURBSVAyZixVQUFNclYsUUFBTW9WOzs7a0NBSkwxZjs7Ozs7eUNBTVc0ZixZQUFOdlYsV0FBTkksYUFBTm9WLEtBTk83Zjt1REFNUDZmLFVBQU1wVixVQUFNSixXQUFNdVY7MkJBSXJCLE9BVlFwZ0IsVUFXTSxVQURWc2dCLEdBVk05ZixHQVdJOzhCQUFKcUk7NkJBSU87OEJBRFJFLElBSENGOzhCQUdSNkYsSUFIUTdGOzhCQUlPLGFBZlQ3SSxJQVVKc2dCLGdCQUlLdlg7OEJBQ1E7OzZCQUNmLGlCQUxFa0QsS0FHRnlDLElBQ0l4QyxPQUFPcVU7MkJBRkwsNEJBR2tCO3VCQUUxQixXQUFLLE9BbkJRMVg7eUJBNEJFMlg7cUJBQWMsV0FBZEEsR0FBYyxTQUFRLFNBQVEsU0FBUTttQkFENUIseUJBQVEsU0FBUTtpQkFEcEIseUJBQVE7ZUFEWjthQURYO1dBREYsT0E1Uk43YSxLQWtTa0Q7a0JBRWxEOGEsUUFBUXBtQixFQUFFcW1CO1dBQ1osMEJBQW1CaGlCLEVBQUVHLEdBQUssV0FBTEEsRUFBRkgsRUFBYyxFQURyQmdpQixFQUFGcm1CLEVBQzRCO2tCQUVwQ3NtQixPQUFPdG1CLEdBQUksZUFBSkEsRUF2U1BzTCxNQXVTMEI7a0JBRXRCaWIsWUFBYXRmO1dBQU8sR0FBUEE7YUFFOEIsSUFBbkMvRyxLQUZLK0csS0FFUm1ULEVBRlFuVCxLQUVYekMsRUFGV3lDLEtBRThCLGVBQXRDbVQsRUFBR2xhO2FBQXNCLFVBQTVCc0UsaUIsT0FGRitoQjtXQUNHLFFBQzJEO2tCQUVsRUMsT0FBT3ZmO1dBQWlCLG1CQUFqQkE7V0FBaUIsc0IsT0FKcEJzZix1QkFJcUM7a0JBRXpDRSxZQUFZQyxJQUFJcmlCO2VBQ0ZtSSxJQURFbkksRUFDQTRDO1dBQUk7Z0JBQU51RjtlQUdFLElBREw3RCxFQUZHNkQsT0FFQXhFLEVBRkF3RSxPQUVOckcsRUFGTXFHLE9BR0Usb0JBREZ4RSxFQUhGMGU7ZUFJSSxTQUVSL2dCO2lCQUFPLFFBQVBBLEdBQ0ssV0FKQ3FDLEVBQUhXLEVBRksxQixHQUFGdUYsSUFFTnJHLEVBRlFjO3FCQUFGdUYsSUFFSDdEOztlQUNLLFlBREZYLEVBQUhXLEVBRksxQjs7O21DLE9BUFpzZix3QkFnQnNCOztpQkF6VDFCamI7aUJBRUF5WDtpQkFFSUM7aUJBbkhBbEI7aUJBWUpDO2lCQTZHSWtCO2lCQWVBQztpQkFnQkFPO2lCQVdBQztpQkE2Qko3VztpQkFHQUc7aUJBR0lxWDtpQkFlQWhkO2lCQXFKQW1FO2lCQWpKQThZO2lCQUtBQztpQkFJQUM7aUJBSUEzWTtpQkFXQTZZO2lCQVdBSztpQkFRSkU7aUJBdk5JNUM7aUJBS0FDO2lCQUtBQztpQkFLQUM7aUJBZkFIO2lCQUtBQztpQkFnREFNO2lCQXlLQXNDO2lCQStFQU07aUJBL0RBTDtpQkFrQkFFO2lCQWtCQUM7aUJBa0JBQztpQkF3REpFO2lCQXFCQWdCO2lCQUZBRDtpQkFUQUo7aUJBR0FFOztJRDdiTTs7OztrQkVkTjNGLGNBQVMsY0FFSEMsb0JBREcsUUFDSTtrQkFFYkMsT0FBTzFhLEVBQUUzQixFQUFFa1YsRUFBRS9RO1dBQ04sY0FEQXhDLEdBQ2tCLFVBRFp3QyxHQUNZLEtBQUxxWSxNQUFsQkYsY0FBa0JFO3FCQURiN2EsRUFBRTNCLEVBQUVrVixFQUFFL1EsT0FFNEM7a0JBRXpEb1osVUFBVXZkLEVBQUVrVixHQUFJLFlBQU5sVixFQUFFa1YsTUFBdUM7a0JBRW5EdUgsSUFBSTlhLEVBQUUzQixFQUFFa1YsRUFBRS9RO1dBQ1osR0FETXhDLE1BQ21DeWEsRUFEbkN6YSxLQUNGMmEsR0FBcUNGLFdBQXJDRTtXQUNKLEdBRlluWSxNQUU2Qm9ZLElBRjdCcFksS0FFUnFZLEdBQXFDRCxhQUFyQ0M7V0FDSixJQURJQSxjQURBRjthQUVnQixHQUhkM2E7ZUFPZ0IsSUFETythLEdBTnZCL2EsS0FNaUJ3Z0IsR0FOakJ4Z0IsS0FNV2diLEdBTlhoYixLQU1LaWIsR0FOTGpiLEtBT2dCLFlBRE8rYTtlQUNwQixrQkFERUUsV0FFYSxPQUZiQSxHQUFNRCxHQUFNd0YsR0FFQyxPQUZLekYsR0FOckIxYyxFQUFFa1YsRUFBRS9RO2VBU0QsR0FIa0J1WTtpQkFPb0I7a0JBRFhHLElBTlRIO2tCQU1FMEYsSUFORjFGO2tCQU1MSSxJQU5LSjtrQkFNWkssSUFOWUw7a0JBT29CLFlBRFhHLElBWjlCN2MsRUFBRWtWLEVBQUUvUTtpQkFhTyxxQkFQUnlZLEdBQU1ELEdBQU13RixHQU1OcEYsS0FBT0QsSUFBT3NGO2VBRFo7YUFOTjtXQVVKLElBZEw5RixjQUNBRTthQWF5QixHQWZqQnJZO2VBbUJVLElBRE82WSxHQWxCakI3WSxLQWtCV2tlLEdBbEJYbGUsS0FrQks4WSxHQWxCTDlZLEtBa0JEK1ksR0FsQkMvWSxLQW1CVSxZQURYK1k7ZUFDRixrQkFEb0JGLFdBRWQsY0FwQlRyYixFQUFFM0IsRUFBRWtWLEVBa0JDZ0ksSUFBTUQsR0FBTW9GLEdBQU1yRjtlQUdsQixHQUhBRTtpQkFPbUM7a0JBRFJDLElBTjNCRDtrQkFNb0JvRixJQU5wQnBGO2tCQU1hRSxJQU5iRjtrQkFNTUcsSUFOTkg7a0JBT21DLFlBRFJDLElBTnJCRixHQUFNb0YsR0FBTXJGO2lCQU9WLHFCQXpCYnJiLEVBQUUzQixFQUFFa1YsRUF3Qk9tSSxLQUFPRCxJQUFPa0Y7ZUFEWjthQU5OO1dBV1gsU0ExQkU5RixNQURBRixjQUNBRTtxQkFGRTdhLEVBQUUzQixFQUFFa1YsRUFBRS9RLE9BNEJpRDthQUUzRDJDO2tCQUVBeVgsZ0JBQVcsZ0JBQW1DO2tCQUUxQ2pCLElBQUl0ZCxFQUFFdWlCLEtBR1ZWO1csR0FBQUE7YUFDVSxJQURRekYsRUFBbEJ5RixLQUFlMWQsRUFBZjBkLEtBQVkzTSxFQUFaMk0sS0FBU3JlLEVBQVRxZSxLQUFNbGdCLEVBQU5rZ0IsS0FDVSxvQkFKRjdoQixFQUdDd0Q7YUFDQyxTQUFKZixTQURNeVMsTUFIRnFOLEtBR1ZWLEtBQU1sZ0IsRUFIRTNCLEVBQUV1aUIsS0FHS3BlLEVBQUdpWTthQUlYLFFBSEQzWixHQU9PLElBQUx1YSxHQUFLLElBWExoZCxFQUFFdWlCLEtBR0twZSxHQVFGLE9BUkVBLE1BUVA2WSxHQVJSNkUsRUFTMkIsSUFUckJsZ0IsRUFBRzZCLEVBQUcwUixFQVFKOEg7YUFQRSxJQUlGSixHQUFLLElBUkw1YyxFQUFFdWlCLEtBR0o1Z0I7YUFLTyxPQUxQQSxNQUtFaWIsR0FMUmlGLEVBTTJCLElBRG5CakYsR0FMQ3BaLEVBQUcwUixFQUFHL1E7V0FEYixZQUZNbkUsRUFBRXVpQjtrQkFjTjdCLEtBQUsxZ0I7Vzs7O2VBSUM7Z0JBREttRTtnQkFBSCtRO2dCQUFIMVI7Z0JBQUg3QjtnQkFDSSxvQkFKRDNCLEVBR0F3RDtlQUNDLFNBQUpmLFNBRE15UztlQUNGLElBRUgsYUFGRHpTLEVBRFMwQixFQUFUeEMsVUFBUzZSOzthQURiO2tCQWVFbU4sV0FUcUJqaEI7Vzs7OztnQkFZVndlO2dCQUFIOUk7Z0JBQUh3TDtnQkFBSDVXO2VBQ0QsY0Fib0J0SyxFQVloQmtoQjsrQkFBR3hMLFVBQU5wTDs7O3lCQVRTN0YsV0FBSCtRLFdBQUgxUixXQUFIN0I7cUJBQ0QsY0FKb0JqQyxFQUdoQjhELGdCQUFHMFIsUUFBTnZUOytCQUFTd0M7O21CQURiOzJCQVVhK1o7O2FBRGI7a0JBZ0JFMkMsZUFUeUJuaEI7Vzs7OztnQkFZZHdlO2dCQUFIOUk7Z0JBQUh3TDtnQkFBSDVXO2VBQ0QsY0Fid0J0SyxFQVlwQmtoQjsrQkFBR3hMLFVBQU5wTDs7O3lCQVRTN0YsV0FBSCtRLFdBQUgxUixXQUFIN0I7cUJBQ0QsY0FKd0JqQyxFQUdwQjhELGdCQUFHMFIsUUFBTnZUOytCQUFTd0M7O21CQURiOzJCQVVhK1o7O2FBRGI7a0JBZ0JFNEMsVUFUb0JwaEI7Vzs7OztnQkFZVHdlO2dCQUFIOUk7Z0JBQUh3TDtnQkFBSDVXO2VBQ0QsY0FibUJ0SyxFQVlma2hCOytCQUFHeEwsVUFBRzhJOzs7eUJBVEEvWixXQUFIK1EsV0FBSDFSLFdBQUg3QjtxQkFDRCxjQUptQmpDLEVBR2Y4RCxnQkFBRzBSLFFBQUcvUTsrQkFBVHhDOzttQkFESjsyQkFVSXFJOzthQURKO2tCQWdCRStXLGNBVHdCcmhCO1c7Ozs7Z0JBWWJ3ZTtnQkFBSDlJO2dCQUFId0w7Z0JBQUg1VztlQUNELGNBYnVCdEssRUFZbkJraEI7K0JBQUd4TCxVQUFHOEk7Ozt5QkFUQS9aLFdBQUgrUSxXQUFIMVIsV0FBSDdCO3FCQUNELGNBSnVCakMsRUFHbkI4RCxnQkFBRzBSLFFBQUcvUTsrQkFBVHhDOzttQkFESjsyQkFVSXFJOzthQURKO2tCQU9FZ1gsU0FBU2hoQjtXOzs7ZUFJSDtnQkFES21FO2dCQUFIK1E7Z0JBQUgxUjtnQkFBSDdCO2dCQUNJLG9CQUpHM0IsRUFHSndEO2VBQ0MsU0FBSmYsWUFETXlTO2VBQ0YsSUFFSCxhQUZEelMsRUFEUzBCLEVBQVR4QyxVQUFTNlI7O2FBRGI7a0JBTUVnTCxJQUFJeGU7Vzs7O2VBSUU7Z0JBREVtRTtnQkFBSFg7Z0JBQUg3QjtnQkFDSSxvQkFKRjNCLEVBR0N3RDtnQkFDQyxXQUFKZjtlQUFJO21CQURFK1EsYUFDTi9RLEVBRE0wQixFQUFOeEMsVUFBTTZSOzthQURWO2tCQUtFZ1A7VztXQUFjOzs7O21CQUVBdE4sYUFBSDFSOzJCQUFHMFI7YUFEVCxnQkFFZ0I7a0JBRXJCdU47VztXQUFrQjs7OzttQkFFSnZOLGFBQUgxUjs4QkFBRzBSO2FBRFQsU0FFbUI7a0JBRXhCd047VztXQUFjOzs7O2VBRU07YUFEZixnQkFFZ0I7a0JBRXJCQztXO1dBQWtCOzs7O2VBRUU7YUFEZixTQUVvQjtrQkFFekJDO1dBQXFCOzs7bUJBR1Z6ZSxXQUFIK1EsV0FBSDFSO2VBQWdCLG9DQUFoQkEsRUFBRzBSLEVBQUcvUTthQURNLElBQU4rWjthQUFNLE9BQU5BO1dBRE4sMENBRTRDO3VCQUtwRHRJLEVBRE90SztXQURWLEdBRUdzSzthQUVDLEdBSE10SztlQUdPLHdCQUhQQSxPQUdPO2VBQ0YsV0FIWnNLLEVBRU01VixFQUFHa1YsRUFDRyxtQkFKTDVKO2FBQ00sT0FBYnNLO1dBRGEsT0FBTnRLLEtBSTRCO2tCQUVoQ21ULE9BQU96ZSxFQUdYNmhCO1csR0FBQUE7YUFDVSxJQURNMWQsRUFBaEIwZCxLQUFhM00sRUFBYjJNLEtBQVVyZSxFQUFWcWUsS0FBT2xnQixFQUFQa2dCLEtBQ1Usb0JBSkM3aEIsRUFHRHdEO2FBQ0EsU0FBSmYsU0FDVSxLQUZUZCxFQUFTd0M7YUFHVCxRQUZEMUIsR0FLTyxJQUFMdWEsR0FBSyxPQVRGaGQsRUFHS21FLEdBTUgsT0FOR0EsTUFNUjZZLEdBTlI2RSxFQU1rRCxJQU4zQ2xnQixFQUFHNkIsRUFBRzBSLEVBTUw4SDthQUxFLElBR0ZKLEdBQUssT0FQRjVjLEVBR0oyQjthQUlNLE9BSk5BLE1BSUNpYixHQUpSaUYsRUFJa0QsSUFBMUNqRixHQUpFcFosRUFBRzBSLEVBQUcvUTtXQURkO2tCQVNFMGUsT0FBTzdpQixFQUFFTixFQU1ibWlCO1csR0FBQUE7YUFDVSxJQURRekYsRUFBbEJ5RixLQUFlMWQsRUFBZjBkLEtBQVkzTSxFQUFaMk0sS0FBU3JlLEVBQVRxZSxLQUFNbGdCLEVBQU5rZ0IsS0FDVSxvQkFQQzdoQixFQU1Gd0Q7YUFDQyxTQUFKZjtlQUVJLHFCQVRHL0MsS0FNRHdWO2VBR0Y7aUJBR0YsSUFER3FOLGNBQ0gsT0FOSXJOLE1BS0RxTixLQUxYVixLQUFNbGdCLEVBTkszQixFQVdBdWlCLEtBTElwZSxFQUFHaVk7ZUFJSixZQUpSemEsRUFBU3dDO2FBT0osUUFOTDFCLEdBVU8sSUFBTHVhLEdBQUssT0FqQkZoZCxFQUFFTixFQU1FeUUsR0FXRixPQVhFQSxNQVdQNlksR0FYUjZFLEVBWTJCLElBWnJCbGdCLEVBQUc2QixFQUFHMFIsRUFXSjhIO2FBVkUsSUFPRkosR0FBSyxPQWRGNWMsRUFBRU4sRUFNUGlDO2FBUU8sT0FSUEEsTUFRRWliLEdBUlJpRixFQVMyQixJQURuQmpGLEdBUkNwWixFQUFHMFIsRUFBRy9RO1dBSkQsdUJBRkR6RTtXQUVDLFlBRUcsSUFBUm9qQixrQkFBUSxZQUpOOWlCLEVBSUY4aUI7V0FERztrQkFpQlJqZ0IsS0FBS25EO1c7OzttQkFFTXlFLGFBQUgrUSxhQUFIMVIsYUFBSDdCO2VBQ0osS0FIT2pDLEVBRUhpQztlQUNNLFdBSEhqQyxFQUVBOEQsRUFBRzBSOzJCQUFHL1E7O2FBRE47a0JBSUw2QyxJQUFJdEg7VzthQUlHO2NBRE8wYztjQUFIalk7Y0FBSCtRO2NBQUgxUjtjQUFIN0I7Y0FDSyxRQUpIakMsRUFHRmlDO2NBRUssZUFMSGpDLEVBR0l3VjtjQUdELFFBTkh4VixFQUdPeUU7YUFHSixVQUZMNkYsSUFER3hHLEVBRUg0UixJQUNBOEksSUFIWTlCO1dBRGhCO2tCQU9FMkcsS0FBS3JqQjtXO2FBSUU7Y0FETzBjO2NBQUhqWTtjQUFIK1E7Y0FBSDFSO2NBQUg3QjtjQUNLLFNBSkZqQyxFQUdIaUM7Y0FFSyxlQUxGakMsRUFHQThELEVBQUcwUjtjQUdELFNBTkZ4VixFQUdNeUU7YUFHSixVQUZMNkYsSUFER3hHLEVBRUg0UixJQUNBOEksSUFIWTlCO1dBRGhCO2tCQU9FMEQsS0FBS3BnQixFQUFFbWlCLEVBQUVsZDtlQUFGcWUsTUFBRW5lO1dBQ2Y7Z0JBRGFtZTtlQUlBO2dCQURJN2UsRUFISjZlO2dCQUdDOU4sRUFIRDhOO2dCQUdGeGYsRUFIRXdmO2dCQUdMcmhCLEVBSEtxaEI7Z0JBSUEsa0JBSkZ0akIsRUFHQThELEVBQUcwUixFQUNNLEtBSlR4VixFQUdIaUMsRUFIT2tEO2dCQUFGbWUsSUFHSTdlO2dCQUhGVTs7YUFFSixPQUZJQSxPQUlxQjtrQkFFOUJrYixRQUFROVU7Vzs7O2VBRVM7Z0JBQU45RztnQkFBSCtRO2dCQUFIMVI7Z0JBQUg3QjtnQkFBZSxnQkFGVHNKLEVBRUh6SCxFQUFHMFI7ZUFBUztpQkFBUyxpQkFGbEJqSyxFQUVOdEo7aUJBQXdCLHFCQUFmd0M7aUJBQWU7OztlQURyQjs7a0JBR0w2YixPQUFPL1U7Vzs7O2VBRVU7Z0JBQU45RztnQkFBSCtRO2dCQUFIMVI7Z0JBQUg3QjtnQkFBZSxnQkFGVnNKLEVBRUZ6SCxFQUFHMFI7ZUFBUzs7O2lCQUFTLGdCQUZuQmpLLEVBRUx0SjtpQkFBd0IsdUJBQWZ3QztpQkFBZTtlQURyQjs7a0JBV0w4ZSxnQkFBZ0JyWCxFQUFFNUw7VztpQkFFUG1FLFdBQUgrUSxXQUFIMVIsV0FBSDdCO2FBQ0YsMkJBSGdCaUssRUFBRTVMLEVBRWhCMkIsR0FBRzZCLEVBQUcwUixFQUFHL1E7V0FETixpQkFEV3lILEVBQUU1TDtrQkFLbEJrakIsZ0JBQWdCdFgsRUFBRTVMO1c7aUJBRVBtRSxXQUFIK1EsV0FBSDFSLFdBQUg3QjthQUNJLFdBREpBLEVBQUc2QixFQUFHMFIsRUFDRixnQkFIVXRKLEVBQUU1TCxFQUVQbUU7V0FETixpQkFEV3lILEVBQUU1TDtrQkFRbEIwZCxLQUFLL2IsRUFBRTZCLEVBQUUwUixFQUFFL1E7V0FDakIsR0FEV3hDO2dCQUFNd0M7O2dCQUlxRHdaLEdBSnJEeFo7Z0JBSStDNlksR0FKL0M3WTtnQkFJeUNrZSxHQUp6Q2xlO2dCQUltQzhZLEdBSm5DOVk7Z0JBSTZCK1ksR0FKN0IvWTtnQkFJaUJ5WixHQUp2QmpjO2dCQUlpQithLEdBSmpCL2E7Z0JBSVd3Z0IsR0FKWHhnQjtnQkFJS2diLEdBSkxoYjtnQkFJRGliLEdBSkNqYjt1QkFJMkRnYyxjQUFwQ0M7d0JBQ0csSUFEM0JoQixHQUFNRCxHQUFNd0YsR0FDZSxLQURUekYsR0FKZmxaLEVBQUUwUixFQUFFL1E7eUJBSWlCeVosY0FBb0NEOzBCQUUxQyxTQU5qQmhjLEVBQUU2QixFQUFFMFIsRUFJK0JnSSxJQUFNRCxHQUFNb0YsR0FBTXJGOzBCQUc1RCxPQVBPcmIsRUFBRTZCLEVBQUUwUixFQUFFL1E7YUFHRCx1QkFISFgsRUFBRTBSLEVBQUp2VDtXQUVLLHVCQUZINkIsRUFBRTBSLEVBQUUvUSxFQU9DO2tCQU1oQmdhLE9BR0N2SSxFQURPdEs7V0FEVixHQUVHc0s7YUFFQyxHQUhNdEs7ZUFHTyx3QkFIUEEsT0FHTztlQUNELFlBSGJzSyxFQUVNNVYsRUFBR2tWLEVBQ0ksbUJBSk41SjthQUNNLE9BQWJzSztXQURhLE9BQU50SyxLQUk2QjtrQkFFckM2WCxlQUFlMVgsR0FBR2pJLEVBQUUwUixFQUFFM0o7V0FDeEIsR0FEc0IySixHQUVWLElBQUxFLElBRmVGLEtBRVYsWUFGS3pKLEdBQUdqSSxFQUViNFIsSUFGaUI3SixJQUdkLGNBSE9FLEdBQU9GLEdBR0Y7a0JBRWhCNlMsTUFBTXBlO1c7YUFJQTtjQURLbUU7Y0FBSCtRO2NBQUgxUjtjQUFIN0I7Y0FDSSxvQkFKQTNCLEVBR0R3RDthQUNDLFNBQUpmLFlBREFkLEtBQU11VCxHQUFHL1E7YUFHUixRQUZEMUI7ZUFLbUIsZ0JBVGZ6QyxFQUdLbUUsR0FNVTtlQUFjLGVBTmpDeEMsRUFBRzZCLEVBQUcwUixFQU1Id0gsSUFBSTJCLEtBQU1yQjthQUxUO2NBR2UsY0FQZmhkLEVBR0oyQjtjQUltQjs7O2FBQXdCLFVBQXhDaWIsR0FBSTBCLE9BQW9DLEtBQTlCcEIsR0FKVjFaLEVBQUcwUixFQUFHL1E7V0FEYjtrQkFTRWtRLE1BQU0zVSxFQUFFb0IsR0FBR0M7V0FDakIsR0FEY0Q7aUJBR3FCNEssR0FIckI1SyxNQUdlK2QsR0FIZi9kLE1BR1NzaUIsR0FIVHRpQixNQUdHZ2UsR0FISGhlLE1BR0hFLEdBSEdGO2FBR3dDLFVBSHJDQyxPQUdrQjJLO2VBQ1o7NEJBRE5vVCxHQUhBL2Q7Z0JBSU07OztnQkFDbUMsV0FMOUNyQixFQUdpQm1mLEdBQ1pGO2dCQUNxQixnQkFMMUJqZixFQUdLb2YsTUFBTXNFLElBQ1ZDO2VBQ00sNEJBTFAzakIsRUFHRHNCLEdBQ0ZDLElBRFE2ZDs7aUJBSEEvZDs7YUFPTTtjQURTZ2UsS0FOZmhlO2NBTVN1aUIsS0FOVHZpQjtjQU1HNmQsR0FOSDdkO2NBTUh3SixLQU5HeEo7Y0FPTSxjQURINmQsR0FOTjlkO2NBT1M7OztjQUNtQyxXQVI5Q3BCLEVBT0tzZixLQURlRDtjQUVNLGdCQVIxQnJmLEVBTVFrZixHQUNQMkUsUUFEYUQ7YUFFUCw0QkFSUDVqQixFQU9INEssS0FES0MsTUFBTXFVO1dBSWhCLDRCQUFZO2tCQUVWRixNQUFNaGYsRUFBRW9CLEdBQUdDO1dBQ2pCLEdBRGNEO2dCQUFHQzs7Z0JBR3VEeUssR0FIdkR6SztnQkFHaUQ0ZCxHQUhqRDVkO2dCQUcyQ3NpQixHQUgzQ3RpQjtnQkFHcUM2ZCxHQUhyQzdkO2dCQUcrQkUsR0FIL0JGO2dCQUdrQjJLLEdBSHJCNUs7Z0JBR2UrZCxHQUhmL2Q7Z0JBR1NzaUIsR0FIVHRpQjtnQkFHR2dlLEdBSEhoZTtnQkFHSEUsR0FIR0Y7a0JBRzBEMEssTUFBckNFO2lCQUVWOzhCQUZSb1QsR0FIQS9kO2tCQUtROzs7a0JBQ1gsUUFORnJCLEVBR0RzQixHQUVBdUo7a0JBQ3lCLFFBTnhCN0ssRUFHaUJtZixHQUVWRTtpQkFDaUIsR0FEckJ1RTttQkFJSSxJQUFORSxLQUpFRjttQkFJd0Isc0JBSDdCM2hCLEVBSE9tZCxHQU1zQixXQVQzQnBmLEVBR0tvZixHQUFNc0UsR0FNVkksTUFIbUJyZjtpQkFFaEIsWUFGTnhDLEVBSE9tZCxHQUFNc0UsR0FHU2pmO2VBS1A7OEJBUjZCeWEsR0FIeEM5ZDtnQkFXVzs7O2dCQUNYLFVBWkZwQixFQVdENEssS0FScUNySjtnQkFTWixVQVp4QnZCLEVBV09zZixLQVIrQ0w7ZUFTOUIsR0FEckI0RTtpQkFJSSxJQUFORSxLQUpFRjtpQkFJd0Isc0JBSDdCdlosSUFUNEM0VSxHQVlmLFdBZjNCbGYsRUFHMENrZixHQVl6QzZFLEtBWitDSixJQVM1Qm5GO2VBRWhCLFlBRk5sVSxJQVQ0QzRVLEdBQU15RSxHQVM1Qm5GO2lCQVZ0QnJlLEVBRklpQjs7Z0JBRUpqQixFQUZPa0I7V0FFWSxPQUFuQmxCLENBYTJDO2tCQUUvQ3dILE9BQU80RCxFQUVYNFc7VyxHQUFBQTthQUVXO2NBRkkxZCxFQUFmMGQ7Y0FBWTNNLEVBQVoyTTtjQUFTcmUsRUFBVHFlO2NBQU1sZ0IsRUFBTmtnQjtjQUVXLFdBSkE1VyxFQUVMdEo7Y0FHTSxlQUxEc0osRUFFRnpILEVBQUcwUjtjQUlELFdBTkFqSyxFQUVJOUc7YUFJSixHQURMdWY7ZUFFUSxHQUxSL2hCLE1BRUFxSSxPQUZTN0YsTUFJVCtaLFdBSk4yRCxFQUs0QyxZQUh0QzdYLElBRkd4RyxFQUFHMFIsRUFJTmdKO2FBRUMsY0FKRGxVLElBRUFrVTtXQUxHO2tCQVNMZ0MsVUFBVWpWO1c7YUFJRztjQUZGOUc7Y0FBSCtRO2NBQUgxUjtjQUFIN0I7Y0FFVyxnQkFKSHNKLEVBRVJ0SjtjQUVXOztjQUNMLGVBTEVzSixFQUVMekgsRUFBRzBSO2NBSUssa0JBTkhqSyxFQUVDOUc7Y0FJRTs7Z0JBRFh1ZixLQUdrQixnQkFKYnZELEdBRUFFLElBRUgsZUFKREQsR0FGRTVjLEVBQUcwUixFQUlMb0w7YUFGVSxTQUtLLEtBTFhILEdBRkYzYyxFQUFHMFIsRUFJRG1MO2FBR0gsaUJBTERELEdBRUFFO1dBTEU7a0JBWUxuQixVQUFVMEMsRUFBRS9OO2VBQUZrUCxNQUFFN087V0FDbEI7Z0JBRGdCNk87O2dCQUdDN2UsRUFIRDZlO2dCQUdGOU4sRUFIRThOO2dCQUdMeGYsRUFIS3dmOztnQkFBRTNELE9BR1A3YixFQUFHMFIsRUFBRy9RLEVBSENnUTtnQkFBRjZPO2dCQUFFN087O2FBRVAsT0FGT0EsSUFHbUM7a0JBRW5EOUwsUUFBUWdELElBQUl1WSxHQUFHQztXQVlpQixtQkFaakJBLE1BWUYsZUFaREQsTUFDTXBFLFFBQUd0UTtXQUNuQjtnQkFEZ0JzUTtrQkFBR3RRO2lCQU1UO2tCQUQ4QnVRLEtBTHJCdlE7a0JBS2lCeVAsR0FMakJ6UDtrQkFLYW1VLEdBTGJuVTtrQkFLUzBQLEdBTFQxUDtrQkFLRHdRLEtBTEZGO2tCQUtGWCxHQUxFVztrQkFLTjRELEdBTE01RDtrQkFLVlYsR0FMVVU7a0JBTU4sb0JBREpWLEdBQXNCRjtpQkFDbEIsU0FBSm5jO21CQUVJLElBQUorSixJQUFJLFdBVEpuQixJQU1JK1gsR0FBc0JDO21CQUd0QixTQUFKN1c7cUJBRTBCO3FDQUxJbVMsR0FBSWM7c0JBSzFCLGVBTEFaLEdBQUlhO3NCQUxGRjtzQkFBR3RROzttQkFTRixPQURYMUM7aUJBRFcsT0FEWC9KO2VBRk07YUFEQyxPQUhNeU0sUUFXNkI7a0JBRWxEMUcsTUFBTTZDLElBQUl1WSxHQUFHQztXQVNpQixtQkFUakJBLE1BU0YsZUFUREQsTUFDTXBFLFFBQUd0UTtXQUNqQjtnQkFEY3NRO2tCQUFHdFE7aUJBTWY7a0JBRHNDdVEsS0FMdkJ2UTtrQkFLbUJ5UCxHQUxuQnpQO2tCQUtlbVUsR0FMZm5VO2tCQUtXMFAsR0FMWDFQO2tCQUtDd1EsS0FMSkY7a0JBS0FYLEdBTEFXO2tCQUtKNEQsR0FMSTVEO2tCQUtSVixHQUxRVTtrQkFNWiw2QkFESVYsR0FBc0JGO2lCQUMxQjttQkFBeUIsb0JBUHZCdlQsSUFNTStYLEdBQXNCQzttQkFDTDtxQkFDRztxQ0FGTTFFLEdBQUljO3NCQUU1QixlQUZFWixHQUFJYTtzQkFMSkY7c0JBQUd0UTs7bUJBTVU7OztpQkFGZjs7YUFEQyxPQUhJQSxPQVE2QjtrQkFFNUNxUjtXQUFXO2FBRWlCLElBQXZCcGMsV0FBSHhDLFdBQTBCLGNBQXZCd0M7YUFBTSxpQkFBVHhDO1dBREcsUUFDaUM7a0JBRXRDbWlCOzs7O2VBRXlDO2dCQUE5QjNmO2dCQUFIK1E7Z0JBQUgxUjtnQkFBSDdCO2dCQUF1QyxhQUFwQzZCLEVBQUcwUixHQUFpQyxvQkFBOUIvUTs7d0JBQVR4Qzs7YUFERztrQkFHVG9pQixTQUFTbGtCLEdBQ1gsc0JBRFdBLEVBQ007a0JBTWYraEIsUUFBUXBtQixFQUFFcW1CO1dBQ1o7NkJBQW1CQTtzQkFBTCxxQ0FBUWpXLEVBQUVwSSxFQUFMcWUsRUFBcUI7b0JBRDVCQTtvQkFBRnJtQixFQUNrQztrQkFFMUNzbUIsT0FBT3RtQixHQUFJLGVBQUpBLEVBcFhQc0wsTUFvWDBCO2tCQUV0QmliLFlBQWF0ZjtXQUFPLEdBQVBBO2FBRWtDLElBQXZDL0csS0FGSytHLEtBRVBtVCxFQUZPblQsS0FFVGUsRUFGU2YsS0FFWG1KLEVBRlduSixLQUVrQyxlQUF6Q21ULEVBQUVsYTthQUEwQixhQUFoQ2tRLEVBQUVwSSxrQixPQUZKdWU7V0FDRyxRQUMrRDtrQkFFdEVDLE9BQU9IO1dBQ0ksbUJBREpBO1dBQ0ksc0IsT0FMUEUsdUJBS3dCO2tCQUU1QkUsWUFBWUMsSUFBSUw7ZUFDRm1CLElBREVuQixFQUNBcGY7V0FBSTtnQkFBTnVnQjtlQUdFO2dCQURDN2UsRUFGSDZlO2dCQUVBOU4sRUFGQThOO2dCQUVIeGYsRUFGR3dmO2dCQUVOcmhCLEVBRk1xaEI7Z0JBR0Usb0JBREx4ZixFQUhDMGU7ZUFJSSxTQUVSL2dCO2lCQUFPLFFBQVBBLEdBQ0ssV0FKRnFDLEVBQUcwUixFQUFHL1EsRUFGRDFCLEdBQUZ1Z0IsSUFFTnJoQixFQUZRYztxQkFBRnVnQixJQUVHN2U7O2VBQ0QsWUFETFgsRUFBRzBSLEVBQUcvUSxFQUZEMUI7OzttQyxPQVJac2Ysd0JBaUJzQjs7aUJBdlkxQmpiO2lCQUVBeVg7aUJBd0dJQztpQkF0R0FsQjtpQkF5SkF1RjtpQkE3TEp0RjtpQkFrTElrQjtpQkE4SEFwSztpQkFZQXFLO2lCQTZDSnJXO2lCQWNBRztpQkF0S0kzRjtpQkF1QkFpZDtpQkFNQUM7aUJBSUFDO2lCQTJGQTNZO2lCQVVBNlk7aUJBMkNBSztpQkFRSndEO2lCQXpQSXZCO2lCQUtBQztpQkFLQUM7aUJBS0FDO2lCQWZBSDtpQkFLQUM7aUJBK0lBckU7aUJBblBBc0M7aUJBZ0ZBTTtpQkEvREFMO2lCQWtCQUU7aUJBa0JBQztpQkFrQkFDO2lCQTZGQS9aO2lCQVNBK2I7aUJBMkxKZjtpQkFHQUM7aUJBWkFMO2lCQUdBRTs7SUY5WU07YUdyRVZ6RixjQUFZLGNBQW9CO2FBRWhDMkgsTUFBTW5rQixHQUFJLDBCQUFxQjthQUUvQm9rQixPQUFLcGtCLEdBQUksVUFBSkEsVUFBNkI7YUFFbENxa0IsS0FBS2xrQixFQUFFSCxHQUFJLFVBQU5HLEVBQUVILE1BQUksT0FBSkEsYUFBSSxRQUFtQzthQUU5Q3NrQixJQUFJdGtCO01BQ04sU0FETUE7TUFDTjtZQUNNbUMsV0FBSkMsV0FGSXBDLE9BRUFtQyxHQUZBbkMsMkJBRUpvQztNQUNVLFdBQVc7YUFFckJtaUIsSUFBSXZrQjtNQUNOLFNBRE1BLEtBQ04sU0FDVyxJQUFUb0MsV0FBUyxPQUFUQSxHQUNVLFdBQVc7YUFFckJzYyxTQUFTMWUsR0FBSSxhQUFKQSxRQUFjO2FBRXZCd2tCLFNBQU94a0IsR0FBSSxPQUFKQSxJQUFTO2FBRWhCeWtCLE9BQUs1a0IsRUFBRUcsR0FBSSxjQUFOSCxFQUFFRyxLQUFtQjthQUUxQmlnQixLQUFLcGdCLEVBQUVrSSxJQUFJL0gsR0FBSSxtQkFBVkgsRUFBRWtJLElBQUkvSCxLQUE0QjthQUl2QzBrQixTQUFPMWtCLEdBQUksY0FBSkEsS0FBbUI7YUFFMUIraEIsUUFBUTRDLEVBQUVocEIsR0FBSSxxQkFBY3dFLEdBQUssWUFBTEEsRUFBcEJ3a0IsRUFBaUMsRUFBL0JocEIsRUFBa0M7YUFFNUNpcEIsU0FBT2hlLEdBQ0QsSUFBSjVHLEVBQUksVUFDUixRQURJQSxFQURLNEcsR0FFVCxPQURJNUcsQ0FFSDs7Ozs7T0FuQ0N3YztPQU1BNkg7T0FFQUM7T0FLQUM7T0FYQUo7T0FFQUM7T0FjQTFGO09BRUE4RjtPQUVBQztPQUVBeEU7T0FJQXlFO09BRUEzQztPQUVBNkM7OzthQ3ZCQUMsZ0JBQVksZ0JBSWY7YUFFR0MsUUFBTUgsR0FDUixtQ0FFYTthQUVYbEgsSUFBSXRkLEVBQUV3a0I7TUFDUixZQURNeGtCLEtBQ04sS0FEUXdrQjtNQUNSO2dCQURRQSw4QkFDSkksS0FESUosT0FDSkk7Z0JBRElKLGdCQUNKSSxLQURJSixPQUNKSSxPQVlZO2FBS2RDLEtBQUtMO01BQ1AsU0FET0EsS0FDUCxTQUVzQixJQUFiTSxnQkFBYSxPQUFiQSxRQURBLGFBQ29CO2FBSzNCQyxLQUFLUDtNQUNQLFNBRE9BO01BQ1A7O3FCQURPQSx1Q0FJTCxRQUpLQTtNQUVFLGFBT0E7YUFLUFEsT0FZRVI7TUFBSyxhQUFMQSxVQVhlVSxPQUFLTixLQVdwQko7TUFWRjtXQURzQkk7Y0FHYkUsUUFIYUYsUUFHSjFkLEtBSEkwZCxRQUloQjlmLE9BREdnZ0I7YUFIUUksZUFJWHBnQixTQUpLbWdCLFdBSUxuZ0I7Y0FKV29nQixLQUlYcGdCLElBSmdCOGYsS0FHSjFkOztRQURULFdBRlFnZTtRQUVSLE9BRkVELE1BVzJEO2FBRXRFRSxXQUFTWCxHQUNYLGFBRFdBLFFBQ0M7YUFFVlksU0FBT1osR0FDVCxPQURTQSxJQUNEO2FBRU5hLE9BUUUzbEIsRUFBRThrQjtNLElBUFNJLEtBT1RKO01BTko7V0FEYUk7Y0FHSkUsUUFISUYsUUFHSzFkLEtBSEwwZDtVQUlYLFdBR0FsbEIsRUFKT29sQjtjQUhJRixLQUdLMWQ7O1FBRFQsU0FLYzthQUV2Qm9lLE9BUUU1bEIsRUFBRW9MLE9BQUswWjtVQVBJN2YsS0FPVG1HLE9BUGM4WixLQU9USjtNQU5UO1dBRGtCSTtVQUlMO1dBREpFLFFBSFNGO1dBR0ExZCxLQUhBMGQ7V0FJTCxrQkFHWGxsQixFQVBXaUYsS0FHSm1nQjtXQUhJbmdCO1dBQUtpZ0IsS0FHQTFkOztRQURULE9BRkl2QyxLQU9vQjthQUVqQzRnQixTQUFTQyxHQUFHQztNQUNkLGFBRFdEO01BQ1g7UUFDRSxTQUZZQztRQUVaO2tCQUZZQTs7OztrQkFBSEQ7Ozs7OztrQkFBR0M7O2tCQUFIRDtrQkFTUCxRQVRPQTtrQkFBR0MsUUFBSEQsTUFBR0MsUUFBSEQsTUFBR0MsUUFBSEQsTUFJUCxRQUpPQTtpQkFZQzthQUlWRSxTQUFPbEI7TUFDVCxTQUFReFgsSUFBSXZLO1FBQU8sR0FBUEE7Y0FFT3pDLEVBRlB5QyxLQUVVeUUsS0FGVnpFO1VBRWtDLFVBQTNCekMsaUIsT0FGWGdOLElBRWM5RjtRQURYLFFBQzRDO01BRnZELFNBRFNzZDtNQUNULHNCLE9BQVF4WCxlQUlHO2FBRVQyWSxVQUFRbkIsRUFBRWhwQixHQUFJLHFCQUFjd0UsR0FBSyxXQUFMQSxFQUFwQndrQixFQUFpQyxFQUEvQmhwQixFQUFrQzthQUU1Q29xQixTQUFPbmYsR0FDRCxJQUFKK2QsRUFBSSxZQUNSLFVBRElBLEVBREsvZCxHQUVULE9BREkrZCxDQUVIOzs7OztPQXZIQ0U7T0FXQXBIOztPQTBCQXlIOztPQVJBRjs7T0F2QkFGO09BNkNBSztPQWNBRztPQUdBQztPQUdBQztPQVVBQztPQVVBQztPQWdCQUc7T0FPQUM7T0FFQUM7OzthQzdIQUMsdUJBQXNDLGVBQWU7YUFHckRDLGlCQUFrQkM7TUFDcEIsSUFBSUMsUUFEZ0JEO01BR3BCLFNBTkVGO01BTUY7UUFDZSxJQUFUM04sT0FBUyxXQUhYOE47UUFNRixTQUhJOU47UUFHSixpQkFQa0I2TjtRQVVsQixPQU5JN047WUFLRHBFO21DQUVILHlCQURvRCxNQURqREEsQ0FDd0QsRUFDM0QsTUFGR0EsRUFFSTthQUlQbVMscUJBQXNCRjtNQUN4QixJQUFJQyxRQURvQkQ7TUFHeEIsU0FyQkVGO01BbUJGLElBRUkzTixPQUFTLFdBRlQ4TjtNQUtKLFNBSEk5TjtNQUdKLGlCQU53QjZOO01BTXhCLE9BSEk3TixNQUlFO2FBT0pnTyxNQUFPQztNQUNULElBQ0l2USxFQURKLGFBRFN1UTtNQUNULE9BQ0l2USxVQUZLdVEsT0FFTHZRLFVBRkt1USxJQUtKLGlCQUxJQSxJQUtnQjthQ0d2QkMsVURBV0Q7TUFDYixJQUNJdlEsRUFESixhQURhdVE7TUFDYixPQUNJdlEsVUFGU3VRLE9BRVR2USxVQUZTdVEsSUFLUixxQkFMUUEsSUFLZ0I7OzttQkExQzNCTCxpQkFlQUcscUJBY0FDLE1DUUFFOzthQUVBQyxTQUFVM21CLEdBQ1osSUFBSU0sRUFBSixzQkFFQyxPQUhXTixFQUdYLE9BRkdNLENBRWdCO2FBR2xCc21CLFNBQVU5aUI7TUFDWixJQUFJb1MsRUFBSixhQURZcFM7TUFDWixHQUFJb1MsMkNBRFFwUztNQUUwRCxzQ0FGMURBLEVBTVQ7YUFHRCtpQixPQUFRNWtCLEdBQWMsb0JBQWRBLGNBQWtEOzs7OztPQWpCMUR5a0I7T0FFQUM7T0FNQUM7T0FTQUM7T0FmQUY7T0FNQUM7T0FTQUM7Ozs7O2FDN0NBQztNQUFRLDZCQUVEQSw0QkFEQyxRQUNlO2FBQ3ZCakU7TUFBTyw2QkFFQUEsMEJBREMsUUFDYTthQUVyQmtFLFVBQVVwbEI7TUFDSCxhQURHQSxZQUNaLHFCQURZQSxPQUNILGlCQUFxRDthQUd4RHFsQixTQUFpREYsTUFBTXRSO00sSUFBQUU7TUFBSztrQkFBTEE7U0FBSyxPQUFMQTs7WUFPOUMsSUFESmlPLEdBTmtEak8sT0FNdERnTyxHQU5zRGhPLE9BTzlDLGVBUHdDb1IsTUFNaERwRDtZQUNRO2tCQVA4Q2hPLElBTWxEaU87O2NBQ0k7b0JBQ0FzRCxhQUFIN2pCLDBCQUFHNmpCLElBRkp0RDtjQUlEOztZQWlCRTtlQTNCaURqTzthQTJCakQsa0JBQUwxVjthQUFLLGlCQUFMQSxrQkYvQ0xvbUIsaUJFK0NLcG1CO2FBM0JzRDBWOzs7Ozs7dUJBYzFELElBRHNCd1IsWUFDdEIsc0JBRHNCQSxJQWJvQ3hSO2NBWWpDO1lBSWIsK0JBaEJ3Q29SO1lBZ0J4QyxZQUVBLElBQUxLLGVBQUssVUFBTEEsSUFsQm1EelI7WUFpQmhEOzs7WUFLVixJQURNL1QsRUFyQm9EK1Q7WUFzQjFELEdBRE0vVCxhQUNpQixVQURqQkE7WUFDNEIsU0FENUJBO1lBQ04sSUFFTThDLEVBQUosc0JBSEk5QztZQUdKLE9BSElBO1lBR0osVUFBSThDLEVBeEJvRGlSOztRQUtuQyxPQUxtQ0EsSUEyQnBCO2FBR25DMFIsVUFBNkNqbkI7TUFFcEQ7aUJBRm9EQTtRQUVwRDtTQUNZOztTQURaO2tCQUVrQixJQUFUaUQsVUFBUyxVQUFUQTs7WUFFTyxJQUNWb1MsRUFEVSxTQU5vQ3JWO1lBTXBDLFVBQ1ZxVjthQUNVOztjQUZBLFNBQ1ZBLE1BQW9CLElBQWQwUixJQUFOMVIsS0FBb0IsT0FBcEJBLEVBQW9CLFVBQWQwUjtjQUVEOztZQUVFOzsrQkFBTGxuQjthQUFLLGtCQUFMQSxrQkY3RExvbUIsaUJFNkRLcG1CO1lBQWU7Ozs7cUJBQ0csSUFBTm1uQixZQUFNLE9BQU5BO1lBQ0EsSUFBSjdtQixFQUFJLG1CQWJnQ0g7WUFhaEMsYUFBSkc7WUFBSSxPQUFKQTs7WUFFWixJQURNcUI7WUFDTixHQURNQSxhQUNpQixVQURqQkE7WUFDNEIsYUFENUJBO3NCQWQwQ3hCO3dCQWlCM0Msc0JBSEN3QixhQUdtQzthQUcxQzBsQjtNQUFPLFVBRUcsSUFBTGxuQixXQUFLLGlCQUFMQSxHQURHLFFBQ2E7YUFHakJtbkIsVUFBeUNubkI7TUFDL0M7aUJBRCtDQTtRQUMvQzs7a0JBQ2tCLElBQU5xVixVQUFNLE9BRjZCclYsYUFFN0IsT0FBTnFWLEVBQU07Ozt3QkFDZSxPQUhjclYsYUFHZDs7O1lBRTdCLElBRE13QjtZQUNOLEdBRE1BLGFBQ2lCLFVBRGpCQTtZQUM0QixhQUQ1QkE7c0JBSnFDeEI7MENBSXJDd0I7O1FBSFYsVUFRVSxVQVRxQ3hCO1FBU3JDO1FBQ0ksU0FDYTthQUd6Qm9uQjtNQUFPLFVBRU0sSUFBUjFFLGNBQVEsaUJBQVJBLE1BREcsUUFDbUI7YUFFdkIyRSxVQUFVL2xCLEVBQUV0QjtNQUNsQixPQURnQnNCO1FBR1Isb0JBSFV0QjtRQUdWO1VBRUYsSUFER2lEO1VBQ0gsVUFMWWpEO1VBS1o7V0FDaUIsa0JBTlBzQixVQUFFdEI7V0FNSzs7O3VCQUZkaUQsRUFFRXFrQixPQUZGcmtCLEVBRU1vUyxHQUFHdEo7UUFDTixZQVBNL0w7TUFDSCxZQURHQSxPQU9PO2FBVXZCdW5CLE1BQU1qbUI7TTtRQUVJOztTQVJPLGdCQU1YQSxFQUVEaVU7U0FSWTs7O2lCQVFaQSxTQVJLaFM7UUFBTyxTQUFWOFI7UUFBVSxPQUFkaVM7TUFPSzthQUdSamdCLEtBQUtySDtNQUNELGlCQURDQTtNQUNELFVBQ00sSUFBTGlELFdBQUssS0FGTGpELEdBRUssT0FBTGlEO01BQ0csZUFBYTthQUdyQnVrQixRQUFNeG5CLEdBQ0YsaUJBREVBLEdBQ0YseUJBRUksUUFBRTthQUdWeW5CLE9BQUs1bkIsRUFBRTZuQjtNQUVQO1FBQU0saUJBRkNBO1FBRUQsY0FDQ3prQixXQUFLLEtBSEx5a0IsTUFHc0IsV0FIeEI3bkIsRUFHRW9EO1FBQ0csU0FFSDthQUtQMGtCLEtBQUs5bkIsR0FBSSx1QkFBSkEsS0FBeUQ7YUFFOUQrbkIsVUFBUTlsQjtNQUNWO01BQXdCLG1DQUFxQjNCLEVBQUUyQixHQUFLLFVBQVAzQixFQUFFMkIsRUFBaUIsRUFEdERBLFNBQ2lFO2FBR3pFK2xCLFlBQVU3bkI7TUFDWixJQUFJMm1CO01BQUo7O2lCQVFFLElBQUkvakIsRUFSRitqQjtpQkFRRixPQUFJL2pCLElBQUosc0JBVFU1QzsyQkFDUjJtQixjQVVxQixnQkFYYjNtQixFQVNONEM7MkJBR0ssRUFBQzthQUdWa2xCLFNBQVM5bkI7TUFDWCxJQUFJMm1CO01BQUo7O2lCQUVFLElBQUkvakIsRUFGRitqQjtpQkFFRixPQUFJL2pCLElBQUoscUJBSFM1QzsyQkFDUDJtQixjQUlxQixlQUxkM21CLEVBR0w0QzsyQkFHSyxFQUFDO2FBR1ZtbEIsV0FBVzdqQjtNQUV5QixxQkFGekJBLEdBRXlCLCtCQUFxQzthQUt6RThqQixLQUFLcnNCLEVBQUVxRSxHQUEwQyxjQUExQ0EsR0FBa0MsdUJBQXBDckUsVUFBb0Q7YUFDekRzc0IsTUFBTXRzQixFQUFFcUUsR0FBc0Msa0JBQXhDckUsRUFBd0MsS0FBdENxRSxLQUE4QzthQUN0RGtvQixNQUFNdnNCLEdBQUksa0JBQUpBLE1BQThDO2FBRXBEd3NCLEtBQUt0b0IsRUFBRUc7TUFDVDs7Ozs7O21CQUF1RCxjQUQ5Q0EsR0FDaUMsZUFBSyxXQUR4Q0gsV0FDc0QsS0FBSTthQUUvRHVvQixNQUFNdm9CLEVBQUVHO01BQUk7Ozs7OzttQkFBaUQsY0FBckRBLEdBQStDLHFCQUFqREgsVUFBNkQsS0FBSTthQUN2RXdvQixNQUFNeG9CO01BQUksc0NBQTJDLHFCQUEvQ0EsWUFBK0Q7UUFFckV5b0I7YUFDQUMsTUFBTTFvQjtNQUFJLHNDQUF5Qyx1QkFBN0NBLEtBQW1ELEtBQUc7YUFJeEQyb0IsS0FBZ0Qzb0IsRUFBRUc7TUFDeEQ7TUFDQSxVQUFVLE1BRjhDQTtNQUd4RDtNQUNBLFVBSnNESCxFQUkxQyxLQUo0Q0c7TUFLeEQ7NkJBQ2dCO2FBQ2R5b0IsVUFBd0Q1b0I7TUFBeEQ7T0FFVTs7T0FGVjs7Y0FHVXdWLFdBQUhwUztVQUNMO1VBQ0EsV0FMc0RwRCxFQUdqRG9EO1VBR0w7VUFDQSxVQVBzRHBELEVBRzlDd1Y7VUFJUjs7Y0FFUW1PLFlBQUpEO1VBQ0o7VUFDQSxVQVhzRDFqQixFQVNsRDBqQjtVQUdKO1VBQ0EsVUFic0QxakIsRUFTOUMyakI7VUFJUjtnQkFFUztnQkFDRDtpQkFDRyxpQ0FBc0I7Ozs7OztPQTVFbkNtRTtPQUVBQztPQUlBQztPQWVBQztPQVNBQztPQXpDQU47T0FaQXBnQjtPQU1BbWdCO09BbERBTjtPQW1CQUU7T0FoRkFUO09BcUdBWTtPQWdFQVM7T0FDQUM7T0FDQUM7T0FFQUM7T0FHQUM7T0FDQUM7T0FFQUM7T0FDQUM7T0FJSUM7O2FDNUxKRSxTQUFPcG5CO01BQ1Y7Z0JBRFVBO09BRVYsd0JBREk4STtPQUVKLG9CQURJRTtNQUNKLFVBQUl0SyxJQURBc0ssSUFDQXRLLEVBQ3NEO2FBRXZEMm9CLFNBQVNubkIsR0FBSSxrQkFBSkEsWUFBMEM7YUFDbkRvbkIsU0FBU3BuQixHQUFJLFdBQUpBLFlBQW1DO2FBRTVDcW5CLE1BQUlybkIsRUFBRThCLElBQUlDO01BQ1osUUFEUUQ7ZUFBSUM7ZUFBTi9CLE9BQU0rQixXQUFKRCxZQUdILFdBSEM5QixLQUFFOEIsSUFBSUM7TUFFUCxrQ0FDaUM7YUFHcEN1bEIsT0FBS0MsSUFBSXRiLE9BQU9PLElBQUlOLE9BQU9uSztNQUM3QixRQUQ2QkE7ZUFBbEJrSztlQUFKc2IsU0FBc0J4bEIsV0FBbEJrSztpQkFBV0M7c0NBQUpNLE9BQVd6SyxXQUFQbUs7a0JBS3BCLGdCQUxLcWIsT0FBSXRiLE9BQU9PLElBQUlOLE9BQU9uSztNQUd4QixtQ0FFK0M7YUFHbER5bEIsTUFBSXhuQixFQUFFOEI7TUFDUixRQURRQSxVQUFGOUIsUUFBRThCLFlBR0gsc0JBSEM5QixLQUFFOEI7TUFFUCxrQ0FDaUM7YUFHaEMybEIsU0FBT3puQixHQUFJLE9BQUpBLElBQWM7YUFFckIwbkIsUUFBTTFuQixHQUFJLGlCQUFlO2FBRXpCMm5CLE1BQU0zbkI7TUFDUixnQkFEUUEsS0FDUiw0QkFEUUEsTUFDUixRQUNpQzthQUUvQjRuQixPQUFPNW5CLEVBQUU2bkI7TUFDWCxRQURTN25CLEtBQ1QsV0FBSStCOztXQUNBbUwsY0FGS2xOLE9BQUU2bkI7VUFHMkIsaUJBRGxDM2E7UUFFSix1QkFGSUE7YUFGS2xOLE9BQUU2bkI7VUFFUDNhOztVQUtHO1FBQXlDLElBRTVDNGEsV0FGNEMsa0JBTDVDNWE7UUFVSixLQVpTbE4sT0FTTDhuQixhQVRLOW5CO1FBWVQsT0FISThuQjtRQUdKLE9BVkk1YTtRQVVKLFNBRW9CO2FBRWxCNmEsU0FBUy9uQixFQUFFb0I7TUFDYixJQUFJdU8sSUFETzNQO01BQ1gsR0FEV0EsUUFDUDJQLElBQ29CLE9BRmIzUDtNQUV1QixzQkFGdkJBLEtBQ1AyUCxJQURTdk87TUFFcUIsT0FEOUJ1TztNQUM4QixRQUViO2FBRWxCcVksZ0JBQWdCaG9CLEVBQ2xCMkg7TSxRQUFBQTtRQUNPLFNBRFBBO1VBR08sVUFIUEE7WUFXTyxXQVhQQTtjQXFCTyxhQXJCUEE7Y0FzQkUsSUFBSWdJLElBdkJZM1A7Y0F1QmhCLEdBdkJnQkEsUUF1QloyUCxhQUN1QixPQXhCWDNQO2NBd0JxQixzQkF4QnJCQSxLQXVCWjJQLFVBdEJOaEk7Y0F1QnVDO2dCQXhCckIzSCxLQXVCWjJQLG1CQXRCTmhJO2NBdUJ1QyxzQkF4QnJCM0gsS0F1QloyUCxtQkF0Qk5oSTtjQXVCdUMsc0JBeEJyQjNILEtBdUJaMlAsa0JBdEJOaEk7Y0F1QnVDLE9BRGpDZ0k7Y0FDaUM7WUFYckMsSUFBSXNZLE1BYllqb0I7WUFhaEIsR0FiZ0JBLFFBYVppb0IsZUFDdUIsT0FkWGpvQjtZQWNxQixzQkFkckJBLEtBYVppb0IsWUFaTnRnQjtZQWF1QyxzQkFkckIzSCxLQWFaaW9CLHFCQVpOdGdCO1lBYXVDLHNCQWRyQjNILEtBYVppb0Isb0JBWk50Z0I7WUFhdUMsT0FEakNzZ0I7WUFDaUM7VUFUckMsSUFBSUMsTUFMWWxvQjtVQUtoQixHQUxnQkEsUUFLWmtvQixlQUN1QixPQU5YbG9CO1VBTXFCLHNCQU5yQkEsS0FLWmtvQixZQUpOdmdCO1VBS3VDLHNCQU5yQjNILEtBS1prb0Isb0JBSk52Z0I7VUFLdUMsT0FEakN1Z0I7VUFDaUM7UUFIckMsZ0JBSGdCbG9CLEVBQ2xCMkg7TUFBZ0IsNEJBaUNDO2FBRWZ3Z0IsbUJBQW1Cbm9CLEVBQ3JCMkg7TSxRQUFBQTtRQUNPLFdBRFBBO1VBT08sYUFQUEE7VUFRRTtlQVJGQTtXQVFFLFdBQUl5Z0I7V0FBSixXQUFJQTtXQUFKLElBVG1CcG9CO1VBU25CLEdBVG1CQSxRQVlmMlAsYUFDdUIsT0FiUjNQO1VBYWtCLHNCQWJsQkEsS0FZZjJQLElBRkF0QjtVQUdpQyxzQkFibEJyTyxLQVlmMlAsWUFGQXRCO1VBR2lDLHNCQWJsQnJPLEtBWWYyUCxZQURBdkI7VUFFaUMsc0JBYmxCcE8sS0FZZjJQLFlBREF2QjtVQUVpQyxPQURqQ3VCO1VBQ2lDO1FBVnJDLElBQUlzWSxNQUhlam9CO1FBR25CLEdBSG1CQSxRQUdmaW9CLGVBQ3VCLE9BSlJqb0I7UUFJa0Isc0JBSmxCQSxLQUdmaW9CLE1BRk50Z0I7UUFHdUMsc0JBSmxCM0gsS0FHZmlvQixjQUZOdGdCO1FBR3VDLE9BRGpDc2dCO1FBQ2lDO01BSHZCLDRCQWtCQzthQUVmSSxtQkFBbUJyb0IsRUFDckIySDtNLFFBQUFBO1FBQ08sV0FEUEE7VUFPTyxhQVBQQTtVQVFFO2VBUkZBO1dBUUUsV0FBSXlnQjtXQUFKLFdBQUlBO1dBQUosSUFUbUJwb0I7VUFTbkIsR0FUbUJBLFFBWWYyUCxhQUN1QixPQWJSM1A7VUFha0Isc0JBYmxCQSxLQVlmMlAsSUFGQXRCO1VBR2lDLHNCQWJsQnJPLEtBWWYyUCxZQUZBdEI7VUFHaUMsc0JBYmxCck8sS0FZZjJQLFlBREF2QjtVQUVpQyxzQkFibEJwTyxLQVlmMlAsWUFEQXZCO1VBRWlDLE9BRGpDdUI7VUFDaUM7UUFWckMsSUFBSXNZLE1BSGVqb0I7UUFHbkIsR0FIbUJBLFFBR2Zpb0IsZUFDdUIsT0FKUmpvQjtRQUlrQixzQkFKbEJBLEtBR2Zpb0IsTUFGTnRnQjtRQUd1QyxzQkFKbEIzSCxLQUdmaW9CLGNBRk50Z0I7UUFHdUMsT0FEakNzZ0I7UUFDaUM7TUFIdkIsNkJBa0JDO2FBRWhCSyxjQUFjdG9CLEVBQUV4QixFQUFFK3BCLE9BQU94bUI7TUFDM0IsU0FEb0J3bUI7TUFDcEI7Ozs7YUFEMkJ4bUI7NkNBQVR2RCxLQUFTdUQsV0FBUHdtQjtNQUVmO01BREwsSUFFSUMsYUFIWXhvQixPQUFXK0I7TUFFeUIsR0FGcEMvQixPQUdad29CLGFBQzRCLE9BSmhCeG9CLEVBQVcrQjtNQUszQixPQUxrQnZELEVBQUUrcEIsT0FBSnZvQixVQUFXK0I7TUFLM0IsT0FGSXltQjtNQUVKLFFBQzBCO2FBRXhCQyxhQUFhem9CLEVBQUV4QixFQUFFK3BCLE9BQU94bUI7TUFDVixxQkFERC9CLEVBQ0MscUJBREN4QixHQUFFK3BCLE9BQU94bUIsSUFDMkI7YUFFbkQybUIsV0FBVzFvQixFQUFFeEI7TUFDZiw4QkFEZUEsR0FDZixhQURhd0IsT0FDVCtCO01BQUosR0FEYS9CLE9BRVR3b0IsYUFDNEIsT0FIbkJ4b0IsRUFDVCtCO01BR0osT0FKZXZELElBQUZ3QixVQUNUK0I7TUFHSixPQUZJeW1CO01BRUosUUFDMEI7YUFFeEJHLFVBQVUzb0IsRUFBRXhCLEdBQWlCLGtCQUFuQndCLEVBQW1CLHFCQUFqQnhCLEdBQTJDO2FBRXZEb3FCLFdBQVc1b0IsRUFBRTZvQixJQUNmLG9CQURhN29CLEVBQUU2b0IsY0FDdUI7YUFXcENDLFlBQVk5b0IsRUFBRTBDLEdBQUdLO01BQ25CLFNBRG1CQSxjQUNuQixrQ0FEbUJBO01BRWpCO01BQWdDLEdBRnBCL0MsZUFBSytDLFdBR2lCLE9BSHRCL0MsRUFBSytDO01BQ25CLElBVDJCaEIsSUFRUmdCO01BUG5CO3FCQUQyQmhCO1FBQzNCO1VBQ1UsSUFBSmpDLEVBQUksTUFNTTRDLEdBQUYxQyxVQVJhK0I7VUFFakIsT0FNSS9CLE9BTlJGO1VBQUksU0FBSkE7VUFBSSxJQUdILE1BTG9CaUMsTUFFckJqQyxNQUZxQmlDOztRQWtIM0IsWUF0R3dCO2FBRXRCZ25CLGNBQWNwbkIsR0FBRzNCLEdBQ25CLGNBRGdCMkIsR0FBRzNCLFlBQ1k7YUE0QzdCZ3BCLGVBQWVocEIsRUFBRTNCLEVBQUVHO01BQ3JCLGdDQURxQkEsR0FFUDBxQixZQUFTQztNQUNyQjtXQURxQkEsTUFqQkZGO1VBbUJYLElBZUpHLFFBZkksZ0JBSlc1cUIsRUFFRTJxQjtVQUViLFVBZUpDO1lBZG9CLFVBSFpGO2NBSVAsU0FOVWxwQixFQW1CWG9wQjtjQWJDLFFBSmdCRCxZQUFURCxZQUFTQzs7WUFPaEIsSUF4QlFuUSxNQWlCUW1RO1lBaEJ2QixHQURxQkYsU0FBTmpRO1lBd0JSLElBMUNjc1EsUUFvQmYsZ0JBYWU5cUIsRUFmTndhO1lBRVQsVUFwQmVzUTs7Ozs7O2VBNEJsQixRQVZZdFEsY0FSZiw0QkF1QnFCeGEsR0F2QkxpckI7ZUFDZDtvQkFEZ0JELFNBQUZDO3NCQWtCVEMsS0FsQldGOzttQkFFVjswQ0FxQmFockIsRUF2QkxpckI7b0JBRVI7Ozs7Z0NBQzBDLFFBSGxDQTttQkFFUixJQWdCREMsS0FsQlNEOzs2QkFtQmIsTUFJa0JqckIsRUFmTndhLE1BVVIwUSxPQVZRMVEsV0FVUjBROzs7WXRCMFJEO2NzQi9SSCxRQUxZMVEsY0FLWjtjQWhDUyxVQVNTc1E7Ozs7Y0F1QmxCLElBdEJILDBCQWdDcUI5cUIsR0FoQ0wrTCxNQUFFcFE7Y0FDaEI7bUJBRGtCMFMsT0FBRjFTO2dCQUViLG1CQThCZ0JxRSxFQWhDSHJFLE9BREdtdkI7a0JBR0ssUUFGUm52QixVQUVRLElBRlZvUSxnQkFBRXBRO2dCQUdiLG1CQTZCZ0JxRSxFQWhDSHJFO2tCQUtYLFFBTFdBO2dCQUlkLFNBSllvUTtrQkFJUyxRQUpQcFEsVUFJTyxJQUpUb1EsZ0JBQUVwUTs7O3FCQXdCZixNQVFrQnFFLEVBaENIb3JCLFNBaUJINVEsb0JBakJHN2U7O1lBeUNYLElBQ1cydkIsa0JBQVBDO1lBQ0osV0FYVS9wQixFQVdHLFdBWEQzQixFQVVSMHJCO1lBREosSUFQT2IsWUFBU0MsSUFRTFc7O1VBR0MsVUFYTFo7WUFZUCxTQWRVbHBCO1lBZVYsU0FmVUEsRUFtQlhvcEI7WUFKQyxRQWJnQkQsWUFBVEQsWUFBU0M7O29CQWlCakJDO1lBREMsU0FoQmdCRCxZQUFURCxTQWlCUkUsUUFqQmlCRDtVQWtCaEIsU0FwQlVucEIsRUFtQlhvcEI7VUFmSSxJQWdCSCxLQWxCZ0JELFlBQVRELFNBaUJSRSxRQWpCaUJEOztRQXFCckIsZ0JBckJZRDtRQXFCWixZQUF3QixTQXZCVGxwQixFQUVIa3BCLGVBc0JIO2FBRVRpQixTQUFTbnFCLEVBQUUrQjtNQUNYLFFBRFdBLFVBQUYvQixPQUFFK0IsTUFJVCxPQUpTQSxJQUlUO01BRkEsdUNBRWlCO2FBSW5CcW9CLFNBQU9wcUI7TUFDVCxTQUFRMkwsSUFBSXhSO1FBQ1YsR0FGTzZGLFFBQ0c3RjtRQUdSLHFCQUpLNkYsS0FDRzdGLEdBR1IsS0FIUUE7UUFJSyxVQURUd0UsaUIsT0FIQWdOLGdCQUltQjtNQUozQjs0QixPQUFRQSxlQU1IO2FBRUgwZSxVQUFRcnFCO01BQ1YsU0FBUTJMLElBQUl4UjtRQUNWLEdBRlE2RixRQUNFN0Y7UUFHUixxQkFKTTZGLEtBQ0U3RixHQUdSLEtBSFFBO1FBSVMsYUFKVEEsRUFHSndFLGtCLE9BSEFnTixnQkFJdUI7TUFKL0I7NEIsT0FBUUEsZUFNSDthQUVIMmUsVUFBUXRxQixFQUFFNEY7TUFBZSwyQixPQTNOekJtaUIsU0EyTlEvbkIsU0FBRTRGLElBQStCO2FBRXpDMmtCLFNBQU9wd0IsR0FDRCxJQUFKNkYsRUFBSSxhQUNSLFVBRElBLEVBREs3RixHQUVULE9BREk2RixDQUVIOzs7O09BclJDa25CO09BTUFDO09BQ0FDO09BRUFDO09BTUFDO09BUUFFO09BTUFDO09BRUFDO09BRUFDO09Bb0JBSTtPQU1DQztPQXlEQUs7T0FyQkFGO09BcURETztPQU9BQztPQWxCQUw7T0FRQUc7T0EyRUFPO09BL0RBSjtPQVlBRTtPQU1BQztPQXVFQW9CO09BUUFDO09BU0FDO09BU0FDO09BRUFDOzthMUJsUkFDLHVCQUFxQixpQkFBb0I7YUFHekNDLGdCQUFnQjVzQixTQUFTdUQ7TUFDM0IsWUFEMkJBLFlBQzNCLFdBRDJCQTtNQUl6QjtlQUpnQnZEO2VBRWQ2c0I7ZUFFRixZQUEwQixlQUpWN3NCLFNBRWQ2c0IsV0FBd0JDLE1BRXVDO2FBRWpFQyxnQkFBZ0Ivc0IsVUFDbEIsaUJBRGtCQSxTQUNNO2FBR3RCZ3RCLGFBQWFodEI7TUFDQyxrQ0FDaEIxRDtNQUNFOztVQUZFMndCLFdBQ0ozd0IsRUFFSSxZQUEwQixnQkFKZjBELFNBRWYxRDtRQUNFLFNBREZBOztRQUlBLDRCQUxJMndCLFlBSzRCO2FBRzlCQyxlQUFlbHRCLFNBQVN1RDtNQUMxQixZQUQwQkEsWUFDMUIsV0FEMEJBO01BR2IsOEJBSEl2RCxTQUViNnNCLFdBQXdCQyxTQUM4QjthQWF4REssZUFBZUM7TUFBVSxHQUFWQSxTQUVELElBQVRDLE1BRlVELFdBRUQsWUFBVEMsT0FERyxRQUNnQzthQVN4Q0MsK0JBR0FodEIsSUFBSWl0QjtNQUFPLFVBQVhqdEI7T0FBVyxPQUFYQTtnQkFFQSxhQUZJaXRCO2dCQUlKLGFBSklBO2dCQStCSixjQS9CSUE7aUJBcUNKLGNBckNJQTs7T0FBTyxPQUFYanRCO2dCQU1BLElBRGU4c0IsUUFMZjlzQixPQU0wQiw0QkFEWDhzQixTQUxYRzs7VUFRSixJQURvQkMsVUFQcEJsdEIsT0FRK0IsNEJBRFhrdEIsV0FQaEJEOztjQVNnQkUsVUFUcEJudEIsT0FTYWxDLE1BVGJrQztVQVU4QixhQURqQmxDLE1BQ2lCLGVBRFZxdkIsYUFUaEJGOztjQVdrQkcsVUFYdEJwdEIsT0FXZS9CLFFBWGYrQjtVQWFpQixhQUZGL0IsUUFFRSxlQUZLbXZCLGFBWGxCSDs7Y0Fjc0JJLFVBZDFCcnRCLE9BY21CNUIsUUFkbkI0QjtVQWdCcUIsYUFGRjVCLFFBRUUsZUFGS2l2QixhQWR0Qko7O2NBaUJrQkssVUFqQnRCdHRCLE9BaUJlekIsUUFqQmZ5QjtVQW1CaUIsYUFGRnpCLFFBRUUsZUFGSyt1QixhQWpCbEJMOztjQW9Cb0JNLFNBcEJ4QnZ0QixPQW9CZXd0QixVQXBCZnh0QjtVQVQ0QixHQTZCSnV0QixTQTNCWCxTQTJCV0Esb0JBM0JuQkU7VUE2QmMsOEJBRkpELGdCQXBCWFA7O1VBd0JKLElBRGFTLFVBdkJiMXRCLE9Bd0J3Qiw0QkFEWDB0QixXQXZCVFQ7O2NBeUJ5Qm51QixNQXpCN0JrQixPQXlCb0IydEIsVUF6QnBCM3RCO3dCQXlCb0IydEIsVUFBUzd1QixNQXpCekJtdUI7O2NBMkIyQmp1QixRQTNCL0JnQixPQTJCc0I0dEIsVUEzQnRCNXRCO3dCQTJCc0I0dEIsVUFBUzV1QixRQTNCM0JpdUI7O2NBZ0M4QnZ0QixTQWhDbENNLE9BZ0N1QkwsVUFoQ3ZCSzt3QkFnQ3VCTCxVQUFXRCxTQWhDOUJ1dEI7aUJBbUNKLElBRHlCcHRCLFFBbEN6QkcsT0FtQ0EsY0FEeUJILFFBbENyQm90QixNQXFDaUM7UUEwR3JDWTthQStCQUMsY0FBY0M7TUFBK0IsOEJBQS9CQSxXQUF1RDthQUdyRUMsa0JBQWtCOW9CLElBQUkrb0I7TUFDeEI7Z0NBRG9CL29CO09BQ3BCLFFBRG9CQSxTQUFJK29CO09BQ3hCLEtBQUlycUIsTUFDQXNxQjtNQURKO1FBR2dCO3FCQUhadHFCLFlBQ0FzcUI7U0FFWSwwQkFBVm5mO1FBRUosS0FOa0I3SixTQUtkaXBCLFVBSkZ2cUI7UUFLRixTQURJdXFCO1FBRFU7OztNQVBZLFdBVzNCO2FBR0NDLGdCQUFnQmxwQixJQUFJakM7TUFDdEIsa0JBRGtCaUM7TUFFbEIsZUFGa0JBLGNBQUlqQztNQUV0QixTQUZrQmlDO01BRWxCLFFBQ3NCO2FBR3BCbXBCLGtCQUFrQm5wQixJQUFJN0U7TUFDeEIsSUFBSWl1QixRQUFKLHNCQUR3Qmp1QjtNQUV4QixrQkFGb0I2RSxJQUNoQm9wQjtNQUVKLE9BSHdCanVCLElBQUo2RSxjQUNoQm9wQjtNQUVKLFNBSG9CcHBCLFNBQ2hCb3BCO01BRUosUUFDNEI7YUFHMUJDLGdCQUFnQnJwQixLQUNsQixrQkFEa0JBLGdCQUNrQjthQUtsQ3NwQixjQUFjMXdCO01BQVEsT0FBUkE7Z0JBR0w7O2VBRFM7O2VBQXdCOztnQkFBd0I7OztlQUR2QztnQkFBaUMsV0FFaEQ7YUFHWjJ3QixjQUFjL3ZCO01BQVEsT0FBUkE7Z0JBR29DOzs7ZUFGakI7OztlQUF1Qzs7O2VBQ3ZDOzs7Z0JBQXVDOzs7Z0JBQ3ZDOzs7Z0JBQ0E7Z0JBQXVDLFVBQUc7YUF5RTNFZ3dCLGFBQWF4cEIsSUFBSXlwQjtNQUFRLE9BQVJBO2VBQ1IsdUJBREl6cEI7ZUFFSjtnQkFDQSx1QkFISUEsUUFHbUI7YUFHaEMwcEIsb0JBQW9CMXBCLElBQUkycEI7TUFDMUIsT0FEMEJBLFNBQ1QsZ0JBREszcEIsUUFBSTJwQixRQUNjO2FBSXRDQyxlQUFlNXBCLElBQUk0bkI7TUFBVSxHQUFWQTtRQUVMLElBQVRDLE1BRmNEO1FBRWlCLHlCQUZyQjVuQixJQUVxQixxQkFBL0I2bkI7TUFERyxRQUNpRDthQUt6RGdDLGVBQ0E3cEIsSUFBSXhIO01BQU8sVUFBUEE7T0FDVTs7UUFESCxTQUFQQTtjQUVnQmlFLEVBRmhCakUsT0FFU2l4QixNQUZUanhCO1VBR0osYUFIQXdILElBRWF5cEI7VUFFUyx5QkFKdEJ6cEIsSUFJc0IscUJBRkZ2RDtRQUlwQixJQURZcXRCLFFBTFJ0eEI7UUFNSixhQU5Bd0gsSUFLWThwQjtRQUNaLHVCQU5BOXBCLFFBT3VCO2FBR3ZCK3BCLGlCQUNFL3BCLElBQUl0SDtNQUFRLFVBQVJBOzJCQU1OLGtCQU5Fc0g7VUFFWXZELEVBRlIvRDtNQUdOLGdCQUhFc0g7TUFJb0IseUJBSnBCQSxJQUlvQixxQkFGUnZELEdBSVk7YUFLMUJ1dEIsa0JBQWtCaHFCLElBQUlwSDtNQUFRLE9BQVJBOztlQUNILHVCQUREb0g7O2VBRUMsdUJBRkRBOzs7Z0JBR1UsdUJBSFZBO2dCQUkrQixTQUFFO2FBWW5EaXFCLGtCQUFrQmpxQixJQUFJMnBCLFNBQVMvd0IsTUFBTUosSUFBSUUsS0FBS3FGO01BQ2hELGdCQURvQmlDO01BRXBCLG9CQUZvQkEsSUFBSTJwQjtNQUd4QixrQkFIb0IzcEIsSUFBYXBIO01BSWpDLGVBSm9Cb0gsSUFBbUJ4SDtNQUt2QyxpQkFMb0J3SCxJQUF1QnRIO01BTTNDLGdCQU5vQnNILElBQTRCakM7TUFPNUIsdUJBUEFpQyxJQU9BLGNBUGFwSCxPQU9RO2FBS3ZDc3hCLGtCQUFrQmxxQixJQUFJeEc7TUFBUSxPQUFSQTs7Ozs7OztnQkFHdEIsdUJBSGtCd0c7Ozs7Ozs7Z0JBTWxCLHVCQU5rQkE7Z0JBU2xCLFNBQUU7YUFhRm1xQix5QkFBeUJuMEI7TUFBaUIsVUFBakJBO09BQWlCLE9BQWpCQTtnQkFDRDtnQkFDQTtnQkFFQTtnQkFDQTtnQkFDQTtnQkFFQTtpQkFDQTs7T0FUa0IsT0FBakJBO2dCQUdELElBQWpCMEQsSUFIa0IxRCxrQkFHRCxPQUFqQjBEO2dCQUlpQixJQUFaMHdCLE1BUGFwMEIsa0JBT0QsT0FBWm8wQjtpQkFHSSxJQUFMcnNCLEVBVmMvSCxrQkFVSCwyQkFBWCtILElBQTRCO2FBSXZDc3NCLHlCQUVFQztNQUFrQixTQUFsQkE7b0NBQ21CNXdCO2tCQURuQjR3QixrQkFFbUJGO2tCQUFZO2FBS2pDRyxvQkFBb0J2cUIsSUFBSXJHO01BQU0sY0FBTkEsSUFDakIsa0JBRGFxRyxZQUVmLGdCQUZlQSxJQUFJckcsSUFFSTthQUc1QjZ3QixzQkFBc0J4cUIsSUFBSXRHO01BQzVCLCtCQUQ0QkEsYUFDNUI7OztRQUNFOzhCQUZzQnNHLElBRUUsZ0JBRkV0RyxJQUM1QjVDO1VBQ0UsU0FERkE7OztjQUVJO2FBTUUyekIsYUFFSnpxQixJQUFJcEc7TSxJQUFBRTtNQUFTO2lCQUFUQTtRQXlCWTs7UUF6QkgsT0FBVEE7O2VBQ0k5QyxLQURKOEM7V0FDaUIsa0JBRHJCa0c7ZUFBSWxHLFFBQ0k5Qzs7O2VBQ0VDLE9BRk42QztXQUVpQixrQkFGckJrRztlQUFJbEcsUUFFTTdDOzs7ZUFDSEMsT0FISDRDO1dBR2lCLGtCQUhyQmtHO2VBQUlsRyxRQUdHNUM7OztlQUNFQyxPQUpMMkM7V0FJaUIsa0JBSnJCa0c7ZUFBSWxHLFFBSUszQzs7O2VBQ0lDLE9BTFQwQztXQUtpQixrQkFMckJrRztlQUFJbEcsUUFLUzFDOzs7ZUFDSkMsT0FOTHlDO1dBTWlCLGtCQU5yQmtHO2VBQUlsRyxRQU1LekM7OztlQUNBQyxPQVBMd0M7V0FPaUIsa0JBUHJCa0c7ZUFBSWxHLFFBT0t4Qzs7O2VBQ0RDLE9BUkp1QztXQVFpQixrQkFSckJrRztlQUFJbEcsUUFRSXZDOzs7ZUFVa0JDLE9BbEJ0QnNDLFdBa0JXNHdCLFVBbEJYNXdCO1dBbUJKLGtCQW5CQWtHO1dBbUI0QixhQW5CNUJBLElBa0JlMHFCO1dBRWYsa0JBcEJBMXFCO2VBQUlsRyxRQWtCc0J0Qzs7O2VBR0tFLE9BckIzQm9DLFdBcUJhNndCLFlBckJiN3dCO1dBc0JKLGtCQXRCQWtHO1dBc0I0QixhQXRCNUJBLElBcUJpQjJxQjtXQUVqQixrQkF2QkEzcUI7ZUFBSWxHLFFBcUIyQnBDOzs7ZUFadEJFLE9BVExrQztXQVNpQixrQkFUckJrRztlQUFJbEcsUUFTS2xDOzs7ZUFDQUMsUUFWTGlDO1dBVWlCLGtCQVZyQmtHO2VBQUlsRyxRQVVLakM7OztlQUNGQyxRQVhIZ0M7V0FXaUIsa0JBWHJCa0c7ZUFBSWxHLFFBV0doQzs7O2VBQ0dDLFFBWk4rQjtXQVlpQixrQkFackJrRztlQUFJbEcsUUFZTS9COzs7ZUFFUUMsUUFkZDhCO1dBZUosa0JBZkFrRztlQUFJbEcsUUFjYzlCO29CQVdBO2FBSWQ0eUI7Z0JBSWEsSUFBTHR2QixXQUFTLCtCQUFUQSxPQURHLFFBQzJCO2FBOEcxQ3V2QixjQUFjQztNQUNOLDBCQXpHTi9DLElBd0dZK0MsTUF4R1JuQjs7TUFBWTtpQkFBaEI1QjtlQWxRRnNCLGdCQStQV3JwQjs7UUFHTyxPQUFoQituQjs7ZUEwQksvd0IsS0ExQkwrd0I7V0EyQkEsZ0JBOUJTL25CO1dBOEJnQixvQkE5QmhCQSxJQUdMMnBCO1dBNEJKLGdCQS9CUzNwQjtlQUdUK25CLElBMEJLL3dCLEtBMUJEMnlCOzs7ZUE2Qk0xeUIsT0E3QlY4d0I7V0E4QkEsZ0JBakNTL25CO1dBaUNnQixvQkFqQ2hCQSxJQUdMMnBCO1dBK0JKLGdCQWxDUzNwQjtlQUdUK25CLElBNkJVOXdCLE9BN0JOMHlCOzs7ZUFDU3p5QixPQURiNndCLE9BQ1F2dkIsSUFEUnV2QjtXQUVBLGdCQUxTL25CO1dBS2dCLG9CQUxoQkEsSUFHTDJwQjtXQUdKLGVBTlMzcEIsSUFJRHhIO1dBRWdCLGdCQU5md0g7ZUFHVCtuQixJQUNhN3dCLE9BRFR5eUI7OztlQUtjeHlCLE9BTGxCNHdCLE9BS2F0dkIsTUFMYnN2QjtXQU1BLGdCQVRTL25CO1dBU2dCLG9CQVRoQkEsSUFHTDJwQjtXQU9KLGVBVlMzcEIsSUFRSXZIO1dBRVcsZ0JBVmZ1SDtlQUdUK25CLElBS2tCNXdCLE9BTGR3eUI7OztlQVVtQnZ5QixPQVZ2QjJ3QixPQVVpQnJ2QixLQVZqQnF2QixPQVVZcHZCLE1BVlpvdkIsT0FVS252QixNQVZMbXZCO1dBeEhKLGdCQXFIYS9uQjtXQXBIYixvQkFvSGFBLElBR0wycEI7V0F0SFIsa0JBbUhhM3BCLElBYUpwSDtXQS9IVCxlQWtIYW9ILElBYUdySDtXQTlIaEIsaUJBaUhhcUgsSUFhUXRIO1dBN0hELGdCQWdIUHNILElBaEhPLGNBNkhYcEg7ZUFWTG12QixJQVV1QjN3QixPQVZuQnV5Qjs7O2VBYXFCdHlCLE9BYnpCMHdCLE9BYW1CbHZCLE9BYm5Ca3ZCLE9BYWNqdkIsTUFiZGl2QixPQWFPaHZCLFFBYlBndkI7V0FjQSxrQkFqQlMvbkIsSUFHTDJwQixTQWFHNXdCLFFBQU9ELE1BQUtEO2VBYm5Ca3ZCLElBYXlCMXdCLE9BYnJCc3lCOzs7ZUFnQnlCcnlCLE9BaEI3Qnl3QixPQWdCdUIvdUIsT0FoQnZCK3VCLE9BZ0JrQjl1QixNQWhCbEI4dUIsT0FnQlc3dUIsUUFoQlg2dUI7V0FpQkEsa0JBcEJTL25CLElBR0wycEIsU0FnQk96d0IsUUFBT0QsTUFBS0Q7ZUFoQnZCK3VCLElBZ0I2Qnp3QixPQWhCekJxeUI7OztlQW1CcUJweUIsT0FuQnpCd3dCLE9BbUJtQjV1QixPQW5CbkI0dUIsT0FtQmMzdUIsTUFuQmQydUIsT0FtQk8xdUIsUUFuQlAwdUI7V0FvQkEsa0JBdkJTL25CLElBR0wycEIsU0FtQkd0d0IsUUFBT0QsTUFBS0Q7ZUFuQm5CNHVCLElBbUJ5Qnh3QixPQW5CckJveUI7OztlQXNCcUJueUIsT0F0QnpCdXdCLE9Bc0JtQnp1QixPQXRCbkJ5dUIsT0FzQmN4dUIsTUF0QmR3dUIsT0FzQk92dUIsTUF0QlB1dUI7V0F2RkosZ0JBb0ZhL25CO1dBbkZiLG9CQW1GYUEsSUFHTDJwQjtXQXJGUixrQkFrRmEzcEIsSUF5QkZ4RztXQTFHWCxlQWlGYXdHLElBeUJLekc7V0F6R2xCLGlCQWdGYXlHLElBeUJVMUc7V0F4R0gsZ0JBK0VQMEcsSUEvRU8sY0F3R1R4RztlQXRCUHV1QixJQXNCeUJ2d0IsT0F0QnJCbXlCOzs7ZUFnQ09qeUIsT0FoQ1hxd0IsT0FnQ010dUIsTUFoQ05zdUI7V0FpQ0EsZ0JBcENTL25CO1dBb0NnQixvQkFwQ2hCQSxJQUdMMnBCO1dBa0NKLGVBckNTM3BCLElBbUNIdkc7V0FFa0IsZ0JBckNmdUc7ZUFHVCtuQixJQWdDV3J3QixPQWhDUGl5Qjs7O2VBbURFL3hCLE9BbkRObXdCO1dBb0RBLGtCQXZEUy9uQjtlQUdUK25CLElBbURNbndCOzs7ZUFJZUMsUUF2RHJCa3dCLE9BdURnQnJ1QixJQXZEaEJxdUI7V0F3REEsc0JBM0RTL25CLElBMERPdEc7ZUF2RGhCcXVCLElBdURxQmx3Qjs7O2VBR0ZDLFFBMURuQml3QixPQTBEY2dELE1BMURkaEQ7V0EyREEsb0JBOURTL25CLElBNkRLK3FCO2VBMURkaEQsSUEwRG1CandCOzs7ZUFJU0MsUUE5RDVCZ3dCLE9BOERxQm51QixNQTlEckJtdUIsT0E4RFlILFFBOURaRztXQStEQSxnQkFsRVMvbkI7V0FrRWdCLG9CQWxFaEJBLElBR0wycEI7V0FnRUosZUFuRVMzcEIsSUFpRUc0bkI7V0FFZ0IsZ0JBbkVuQjVuQjtXQW9FVCxhQXBFU0EsSUFpRVlwRztXQUdHLGdCQXBFZm9HO1dBb0V3QyxnQkFwRXhDQTtlQUdUK25CLElBOEQ0Qmh3QixRQTlEeEI0eEI7OztlQW1FMEIzeEIsUUFuRTlCK3ZCLE9BbUV1Qmp1QixRQW5FdkJpdUIsT0FtRWNDLFVBbkVkRDtXQW9FQSxnQkF2RVMvbkI7V0F1RWdCLG9CQXZFaEJBLElBR0wycEI7V0FxRUosZUF4RVMzcEIsSUFzRUtnb0I7V0FFYyxnQkF4RW5CaG9CO1dBeUVULGFBekVTQSxJQXNFY2xHO1dBR0MsZ0JBekVma0c7V0F5RXdDLGdCQXpFeENBO2VBR1QrbkIsSUFtRThCL3ZCLFFBbkUxQjJ4Qjs7O2VBb0NFM3ZCLFFBcENOK3RCO1dBcUNBLGdCQXhDUy9uQjtXQXdDZ0Isb0JBeENoQkEsSUFHTDJwQjtXQXNDSixnQkF6Q1MzcEI7ZUFHVCtuQixJQW9DTS90QixRQXBDRjJ2Qjs7O2VBdUNFMXZCLFFBdkNOOHRCO1dBd0NBLGdCQTNDUy9uQjtXQTJDZ0Isb0JBM0NoQkEsSUFHTDJwQjtXQXlDSixnQkE1Q1MzcEI7ZUFHVCtuQixJQXVDTTl0QixRQXZDRjB2Qjs7O2VBeUZ3Qnp2QixRQXpGNUI2dEIsT0F5RmdCNXRCLFdBekZoQjR0QjtXQTBGQSxzQkE3RlMvbkIsSUE2RmlCLHlCQURWN0Y7ZUF6RmhCNHRCLElBeUY0Qjd0Qjs7O2VBR0FFLFFBNUY1QjJ0QixPQTRGZ0IxdEIsV0E1RmhCMHRCO1dBNkZBLHNCQWhHUy9uQjtXQWlHVCxzQkFqR1NBLElBaUdpQix5QkFGVjNGO2VBNUZoQjB0QixJQTRGNEIzdEI7OztlQTVDckJFLFFBaERQeXRCO1dBaURBLGdCQXBEUy9uQjtXQW9EZ0Isb0JBcERoQkEsSUFHTDJwQjtXQWtESixnQkFyRFMzcEI7ZUFHVCtuQixJQWdET3p0QixRQWhESHF2Qjs7O2VBeUVnQ3B2QixRQXpFcEN3dEIsT0F5RTBCdnRCLFNBekUxQnV0QixPQXlFZXR0QixVQXpFZnN0QjtXQTBFQSxnQkE3RVMvbkI7V0E2RWdCLG9CQTdFaEJBLElBR0wycEI7V0EyRUosZUE5RVMzcEIsSUE0RU12RjtXQTlTbkI7WUE0Q0k2RjtzQkFBV04sSUFBSWxKO2VBQVUsSUFHekJpSCxFQUh5QixZQUFWakg7ZUFBVSxjQUd6QmlIO3lCQUZPLGdCQURJaUMsUUFDSixnQkFESUE7K0JBR1hqQzsyQkFETyxnQkFGSWlDLFFBRUosZ0JBRklBOzBCQUdKLGdCQUhJQSxJQUdYakMsRUFBNkI7V0FFakMsZ0JBaUxhaUM7V0FsT2I7WUFtREs7NEJBMlB5QnhGO2dCQTFQckIsZ0JBOEtJd0YsUUE5S3FCLGFBMFBKeEY7O1lBN1M1Qjs7d0JBQUl5d0IsU0FBU2x0QjtpQkFDaUM7NEJBRGpDQTtrQkFDZSxXQURmQTtrQkFFWCx5QkFGV0E7aUJBRVg7a0JBQ1E7OzZCQUE2Qjs7OztpQkFIdkMsV0FHZ0U7c0JBSDVEa3RCO1lBQUo7V0FJRyxnQkFBa0IsZ0JBNk5WanJCO1dBbE9iLElBUWtCbEo7O1dBQ2hCO2dCQURnQkE7ZUFFWCx5QkFBbUIsWUFGUkE7aUJBR1QsUUFIU0E7ZUFLVixzQkFMVUEsR0FLVjs7OENBQ00sV0FvTkRrSjs7OzJDQW5OSSxRQVBDbEo7O2VJK01aO2lCSnZNRyxJQUNZMlMsSUFUSDNTO2lCQVViLHlCQUFtQixZQURIMlM7bUJBZ0JqQixXQWlNU3pKLElBak5ReUo7bUJBZ0JqQixRQWhCaUJBLFlBVEgzUzs7aUJBUVQsSUFHQyxvQkFGVzJTLEtBRVg7Ozs7O3VCQUVKLFdBNk1PekosU0E3TVAsV0E2TU9BOzs7OztxQkEzTVkseUJBQW9CLFlBTnhCeUo7dUJBT2YsV0EwTU96SixJQWpOUXlKO3VCQU9mLFFBUGVBLFlBVEgzUzs7Ozs7O21CQWtCRCx5QkFBb0IsWUFUaEIyUztxQkFVZixXQXVNT3pKLElBak5ReUo7cUJBV2YsV0FzTU96SixJQWpOUXlKO3FCQVdmLFFBWGVBLFlBVEgzUzs7bUJBdUJaLE1BZGUyUyxZQWNmLElBZGVBLFlBbUJGeWhCO21CQUNqQjtnQ0FEaUJBO3lCQUNDLG9CQUFvQixZQURyQkE7d0JBT2YsUUFQZUE7cUJBRWYsV0E0TFNsckIsSUE5TElvbUI7cUJBR2IsV0EyTFNwbUI7cUJBMUxULFdBMExTQSxJQTlMTWtyQjtxQkFJZixHQUplQSxXQUtDLFFBTERBLFlBNUJEcDBCOzthQURiLGdCQUFrQixnQkEyTlZrSjthQTVRWGtwQixnQkE0UVdscEI7aUJBR1QrbkIsSUF5RW9DeHRCLFFBekVoQ292Qjs7O2VBNkV1Qmp2QixRQTdFM0JxdEIsT0E2RWtCcHRCLFFBN0VsQm90QjtXQThFQSxnQkFqRlMvbkI7V0FpRmdCLG9CQWpGaEJBLElBR0wycEI7V0E5T29CLE9BMlROaHZCOzs7O1dBRWxCLGdCQWxGU3FGO2VBR1QrbkIsSUE2RTJCcnRCLFFBN0V2Qml2Qjs7O2VBaUZXL3VCLFFBakZmbXRCO1dBa0ZBLGdCQXJGUy9uQjtXQXFGZ0Isb0JBckZoQkEsSUFHTDJwQjtXQW1GSixzQkF0RlMzcEI7ZUFHVCtuQixJQWlGZW50QixRQWpGWCt1Qjs7O1dBc0Z3QjtZQURSOXVCLFFBckZwQmt0QjtZQXFGZWp0QixJQXJGZml0QjtZQXNGNEIsdUNBRGJqdEIsSUFBS0Q7WUFDUTtZQXRGNUJrdEI7WUFBSTRCOzs7V0EyQ1U7WUFESTV1QixRQTFDbEJndEI7WUEwQ1E5c0IsTUExQ1I4c0I7WUEyQ2MseUJBRE45c0I7O1dBQ007aUJBQWQrcUI7YUFDRTsrQkEvQ09obUI7ZUErQ2tCLG9CQS9DbEJBLElBR0wycEI7ZUE2Q0YsZ0JBaERPM3BCO2VBZ0RQLFNBRkZnbUI7OztXQUFjLElBM0NkK0IsSUEwQ2tCaHRCLFFBMUNkNHVCO29CQTJHVzthQVdiMEI7O09BdUJZOztPQXZCWjtnQkFNWSxJQUFScjBCLGNBQWdCLGVBQWhCQTtnQkFPVSxJQUFSQyxnQkFBa0IsZUFBbEJBO2dCQU5LLElBQVJDLGdCQUFlLGVBQWZBO2dCQUNVLElBQVJDLGdCQUFpQixlQUFqQkE7Z0JBRVksSUFBUkMsZ0JBQXFCLGVBQXJCQTtnQkFESSxJQUFSQyxnQkFBaUIsZUFBakJBO2dCQUVRLElBQVJDLGdCQUFpQixlQUFqQkE7Z0JBQ08sSUFBUkMsZ0JBQWdCLGVBQWhCQTtvQkFPV0MsZ0JBQUpDLFlBQ0ksVUFESkEsR0FDSSxLQURBRDs7Y0FFUUUsZ0JBQUxVLGFBQUxUO1VBQ1UsVUFETFMsSUFBTFQsSUFDVSxLQURBRDtpQkFOVixJQUFSRSxnQkFBaUIsZ0JBQWpCQTtpQkFEUSxJQUFSQyxpQkFBaUIsZ0JBQWpCQTtpQkFFTSxJQUFSQyxpQkFBZSxnQkFBZkE7aUJBQ1csSUFBUkMsaUJBQWtCLGdCQUFsQkE7aUJBQ2dCLElBQVJDLGlCQUEwQixnQkFBMUJBLFVBS1U7YUFFeEJzekI7O1FBU0o7OEJBR2EsUUFBSTtTQUhqQixxQkFFYSxRQUFJO1NBRmpCLHFCQUNhLFFBQUk7UUFEakIsMEJBQWEsUUFBSTs7T0FUYjs7VUFjSjs7V0FBcUIsb0JBRGJ0MEI7V0FDYTs7OztnQ0FFRyxXQUZoQnkwQixNQUVnQixRQUFlO1VBRmxCLDBCQUNHLFdBRHBCQyxNQUNvQixRQUFlLE9BRDNCRixHQUFJRDs7VUFLaEI7O1dBQXFCLHNCQURYdDBCO1dBQ1c7Ozs7Z0NBRUcsV0FGaEI0MEIsUUFFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsUUFDb0IsUUFBZTs7a0JBRDNCRjtrQkFBSUQ7O1VBS2hCOztXQUFxQixzQkFEZHowQjtXQUNjOzs7O2dDQUVHLFdBRmhCKzBCLFFBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFFBQ29CLFFBQWU7O2tCQUQzQkY7a0JBQUlEOztVQUtoQjs7V0FBcUIsc0JBRFo1MEI7V0FDWTs7OztnQ0FFRyxXQUZoQmsxQixRQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxRQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFVaEI7O1dBQXFCLHNCQURSLzBCO1dBQ1E7Ozs7Z0NBRUcsV0FGaEJxMUIsUUFFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsUUFDb0IsUUFBZTs7a0JBRDNCRjtrQkFBSUQ7O1VBTGhCOztXQUFxQixzQkFEWmwxQjtXQUNZOzs7O2dDQUVHLFdBRmhCdzFCLFFBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFFBQ29CLFFBQWU7O2tCQUQzQkY7a0JBQUlEOztVQVVoQjs7V0FBcUIsc0JBRFpyMUI7V0FDWTs7OztnQ0FFRyxXQUZoQjIxQixRQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxRQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFLaEI7O1dBQXFCLHNCQURieDFCO1dBQ2E7Ozs7Z0NBRUcsV0FGaEI4MUIsUUFFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsUUFDb0IsUUFBZTs7a0JBRDNCRjtrQkFBSUQ7O1VBaUNoQjs7V0FBcUIsc0JBREQzMUI7V0FDQzs7OztnQ0FFRyxXQUZoQmkyQixRQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxRQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFLSztXQURNNzFCO1dBQUxVO1dBQUxUO1dBQ0ksc0JBRE1EO1dBQ047Ozs7V0FDWixTQUFNLEtBRkVDLEtBQUtTO1dBR0Qsc0JBRGpCWDtXQUNpQjs7OztnQ0FJRyxXQUpSdTJCLE1BSThCLFdBTjlCTCxRQU04QixRQUFlO1dBSnhDLHFCQUdHLFdBTFpDLFFBS2tDLFdBSGxDSyxNQUdrQyxRQUFlO1dBSHhDLHFCQUVHLFdBRmhCQyxNQUVzQyxXQUp0Q0wsUUFJc0MsUUFBZTtVQUZ4Qzs7b0JBQ0csV0FIcEJDLFFBRzBDLFdBRDFDSyxNQUMwQyxRQUFlOzs7OztVQTlCN0Q7O1dBQXFCLHVCQURadjJCO1dBQ1k7Ozs7Z0NBRUcsV0FGaEIwMkIsUUFFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsUUFDb0IsUUFBZTs7a0JBRDNCRjtrQkFBSUQ7O1VBTGhCOztXQUFxQix1QkFEWnYyQjtXQUNZOzs7O2dDQUVHLFdBRmhCNjJCLFNBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFNBQ29CLFFBQWU7O2tCQUQzQkY7a0JBQUlEOztVQVVoQjs7V0FBcUIsdUJBRGQxMkI7V0FDYzs7OztnQ0FFRyxXQUZoQmczQixTQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxTQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFLaEI7O1dBQXFCLHVCQURYNzJCO1dBQ1c7Ozs7Z0NBSUcsV0FKUmkzQixTQUlRLFFBQWU7V0FKbEIscUJBR0csV0FIWkMsU0FHWSxRQUFlO1dBSGxCLHFCQUVHLFdBRmhCQyxTQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxTQUNvQixRQUFlOzs7OztVQUt2Qzs7V0FBcUIsdUJBREhuM0I7V0FDRzs7OztnQ0FJRyxXQUpSbzNCLFNBSVEsUUFBZTtXQUpsQixxQkFHRyxXQUhaQyxTQUdZLFFBQWU7V0FIbEIscUJBRUcsV0FGaEJDLFNBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFNBQ29CLFFBQWU7Ozt3QkFnQnVCO2FBaUI5RHhCLE1BV0VwMkIsSUFBSWlQO01BQU8sVUFBWGpQO2lCQUFJaVA7UUE4Q3dCOztlQTlDeEJBOzs7Ozs7OztrQkErQ2E7O09BL0NOLE9BQVhqUDs7O29CQUFJaVA7Ozs7b0JBQzBCLElBQVQ0b0IsTUFEakI1b0IsU0FDa0MscUJBQWpCNG9COzs7Ozs7Ozs7Ozs7bUJBRHJCNzNCO29CQUFJaVA7Ozs7b0JBRThCLElBQVQ2b0IsUUFGckI3b0IsU0FFd0MscUJBQW5CNm9COzs7Ozs7Ozs7Ozs7bUJBRnpCOTNCO29CQUFJaVA7Ozs7b0JBSXdCLElBQVQ4b0IsUUFKZjlvQixTQUkrQixxQkFBaEI4b0I7Ozs7Ozs7Ozs7OzttQkFKbkIvM0I7b0JBQUlpUDs7OztvQkFLNEIsSUFBVCtvQixRQUxuQi9vQixTQUtxQyxxQkFBbEIrb0I7Ozs7Ozs7Ozs7OzttQkFMdkJoNEI7b0JBQUlpUDs7OztvQkFPb0MsSUFBVGdwQixRQVAzQmhwQixTQU9pRCxxQkFBdEJncEI7Ozs7Ozs7Ozs7OzttQkFQL0JqNEI7b0JBQUlpUDs7OztvQkFNNEIsSUFBVGlwQixRQU5uQmpwQixTQU1xQyxxQkFBbEJpcEI7Ozs7Ozs7Ozs7OzttQkFOdkJsNEI7b0JBQUlpUDs7OztvQkFRNEIsSUFBVGtwQixRQVJuQmxwQixTQVFxQyxxQkFBbEJrcEI7Ozs7Ozs7Ozs7OzttQkFSdkJuNEI7b0JBQUlpUDs7OztvQkFHMEIsSUFBVG1wQixRQUhqQm5wQixTQUdrQyxxQkFBakJtcEI7Ozs7Ozs7Ozs7OzttQkFIckJwNEI7b0JBQUlpUDs7Ozs7Y0FnQ3dCLElBRGtCb3BCLFFBL0IxQ3BwQixTQStCcUN4TyxJQS9CckN3TyxTQWdDd0IsZ0JBRGtCb3BCO2NBQ2pDLHFCQUQ0QjUzQjs7Ozs7Ozs7OzttQkEvQnpDVDtvQkFBSWlQOzs7Ozs7Y0FzQ0c7ZUFEb0JxcEIsUUFyQ3ZCcnBCO2VBcUNpQnNwQixLQXJDakJ0cEI7ZUFxQ1d1cEIsS0FyQ1h2cEI7ZUFzQ0csU0FBTSxXQURFdXBCO2VBRUUsc0JBRGYxNEI7ZUFDZTs7Y0FDUixXQURKNDRCO2NBRUksV0FGR0Q7Y0FHZSxlQUxORixLQUtNLFdBTEFEOzs7Ozs7Ozs7O21CQXJDM0J0NEI7b0JBQUlpUDtZQVU0QixJQUFUMHBCLFFBVm5CMXBCLFNBVXFDLHNCQUFsQjBwQjtVQUNSOzttQkFYZjM0QjtvQkFBSWlQOzs7OztxQkFjNEIsSUFBVDJwQixTQWRuQjNwQixTQWNxQyxzQkFBbEIycEI7Ozs7O21CQWR2QjU0QjtvQkFBSWlQOzs7Ozs7cUJBa0J3QixJQUFUNHBCLFNBbEJmNXBCLFNBa0IrQixzQkFBaEI0cEI7Ozs7O21CQWxCbkI3NEI7b0JBQUlpUDs7Ozs7OztxQkFzQjhCLElBQVQ2cEIsU0F0QnJCN3BCLFNBc0J3QyxzQkFBbkI2cEI7Ozs7O21CQXRCekI5NEI7b0JBQUlpUDs7Ozs7Ozs7cUJBMkJOLElBRDJDOHBCLFNBMUJyQzlwQixTQTJCWSxzQkFEeUI4cEI7OztNSWhUdkM7ZUprU2E7ZUFJQTtlQUlGO2VBSUc7ZUFLUTtlQUtKO2VBVUU7Z0JBSUwsOEJBQVk7YUFrRy9CQyx1QkFFRW40QixJQUFJb0I7TUFBUyxjQUFicEIsaUJBQUlvQixZQUFKcEIsT0FBSW9CLGVBR3lCO2FBckMvQmczQixnQkFHQTMxQixNQUFNckI7TUFBUyxHQUFmcUI7UUFFcUIsSUFBVDQxQixRQUZaNTFCLFNBRTRCLDJCQUFoQjQxQixRQUZOajNCO01BQ1MsT0FEVEEsS0FFbUQ7YUE3RHpEazNCLGFBRUFsM0I7TSxJQUFBRTtNQUFTO2lCQUFUQTtRQW9EOEI7O1FBcERyQixPQUFUQTtpQkEyQjhCLElBQXpCOUMsS0EzQkw4QyxXQTJCc0MsdUJBQWpDOUM7aUJBQ3lCLElBQXBCQyxPQTVCVjZDLFdBNEJzQyx1QkFBNUI3Qzs7ZUEzQkdDLE9BRGI0QyxXQUNRdEIsSUFEUnNCO1dBRXNDLDhCQUQ5QnRCLE9BQzhCLGFBRHpCdEI7O2VBRUtDLE9BSGxCMkMsV0FHYXJCLE1BSGJxQjtXQUlzQyw4QkFEekJyQixTQUN5QixhQURwQnRCOztXQUlKO1lBREtDLE9BTm5CMEM7WUFNYXBCLEtBTmJvQjtZQU1RbkIsTUFOUm1CO1lBT2MscUJBREsxQztZQUVMLGlDQUZEc0IsUUFDVHE0QjtXQUNVLDhCQUZOcDRCLE1BRUpxNEI7O1dBR1U7WUFETzM1QixPQVZyQnlDO1lBVWVqQixPQVZmaUI7WUFVVWhCLE1BVlZnQjtZQVdjLHVCQURPekM7WUFFUCxtQ0FGQ3dCLFVBQ1hxNEI7V0FDVSw4QkFGSnA0QixNQUVOcTRCOztXQUdVO1lBRFc3NUIsT0FkekJ3QztZQWNtQmQsT0FkbkJjO1lBY2NiLE1BZGRhO1lBZWMsdUJBRFd4QztZQUVYLG1DQUZLMEIsVUFDZm80QjtXQUNVLDhCQUZBbjRCLE1BRVZvNEI7O1dBR1U7WUFETzk1QixPQWxCckJ1QztZQWtCZVgsT0FsQmZXO1lBa0JVVixNQWxCVlU7WUFtQmMsdUJBRE92QztZQUVQLG1DQUZDNEIsVUFDWG00QjtXQUNVLDhCQUZKbDRCLE1BRU5tNEI7O1dBR1U7WUFETy81QixPQXRCckJzQztZQXNCZVIsT0F0QmZRO1lBc0JVUCxNQXRCVk87WUF1QmMsdUJBRE90QztZQUVQLG1DQUZDOEIsVUFDWGs0QjtXQUNVLDhCQUZKajRCLE1BRU5rNEI7O2VBS08vNUIsT0E3QlhvQyxXQTZCTUwsTUE3Qk5LO1dBNkJrRSw4QkFBNURMLFNBQTRELGFBQXZEL0I7a0JBV21CLFlBeEM5Qm9DO2tCQXlDOEIsWUF6QzlCQTtrQkEwQzhCLFlBMUM5QkE7O2VBbUNtQmxDLE9BbkNuQmtDLFdBbUNlckMsR0FuQ2ZxQztXQW9DbUIsVUFESnJDLEdBQ0ksYUFEQUc7O2VBRUVDLFFBckNyQmlDLFdBcUNpQiszQixLQXJDakIvM0I7V0FzQ3lCLFVBRFIrM0IsVUFDUSxhQURKaDZCO2tCQVBTLElBQXhCQyxRQTlCTmdDLFdBOEJ1Qyx3QkFBakNoQztrQkFDd0IsSUFBeEJDLFFBL0JOK0IsV0ErQnVDLHdCQUFqQy9CO2tCQWlCd0IsWUFoRDlCK0I7O1dBa0RrRDtZQUR0QjlCLFFBakQ1QjhCO1lBaURnQk8sV0FqRGhCUDtZQWtEa0Qsa0JBRHRCOUI7V0F4RFYsU0F3REZxQztvQ0F2REUwdEIsa0JBSWxCK0ksYUFKa0IvSTs7O3FCQXVERjF0QjthQXRERSt3QjtrQkFHbEIwRixhQUhrQjFGO2tCSTFSZG56QjtrQkpnVTBCLElBQXZCK0IsUUFqQ1BGLFdBaUN3Qyx3QkFBakNFO2tCQVd1QixJQUFUQyxRQTVDckJILFdBNEN3Qyx1QkFBbkJHO2tCQUNTLElBQVRDLFFBN0NyQkosV0E2Q3FDLHVCQUFoQkk7a0JBQ1MsSUFBZkUsUUE5Q2ZOLFdBOENzQyx1QkFBdkJNOztlQUNLRSxRQS9DcEJSLFdBK0NlZ0IsSUEvQ2ZoQjtXQW1FVyxVQXBCSWdCO1lBb0JKLE9BcEJJQTt5QkEvQ2ZoQixRQStDb0JRO3lCQS9DcEJSLFFBK0NvQlE7cUJBaUNpQyx3QkFqQ2pDQTswQkEvQ3BCUixRQStDb0JROztZQW9CVCxPQXBCSVE7eUJBL0NmaEIsUUErQ29CUTt5QkEvQ3BCUixRQStDb0JRO3lCQS9DcEJSLFFBK0NvQlE7eUJBL0NwQlIsUUErQ29CUTt5QkEvQ3BCUixRQStDb0JRO3lCQS9DcEJSLFFBK0NvQlE7eUJBL0NwQlIsUUErQ29CUTt5QkEvQ3BCUixRQStDb0JRO3lCQS9DcEJSLFFBK0NvQlE7O2VBZ0NlLElBQVZ5M0IsUUFoQ1ZqM0I7ZUFnQ3VDLG9CQUE3QmkzQixRQUE2QixhQWhDbEN6M0I7MEJBL0NwQlIsUUErQ29CUTswQkEvQ3BCUixRQStDb0JROztlQWZGQyxRQWhDbEJULFdBZ0NRbUIsTUFoQ1JuQjtXQWdDb0QsdUJBQTVDbUIsTUFBNEMsYUFBbENWLFVBb0J3QjthQTBDMUMwMkIseUJBRUV2NEIsS0FBS2tCO01BQVMsY0FBZGxCLDZCQUFLa0IscUJBRzBCOzs7O2FBV2pDbzRCLGFBR0F4NUIsSUFBSW9PO01BQVMsVUFBYnBPO09BQ2lCLFlBRGJvTzs7UUFBUyxTQUFicE87Y0FFb0J5NUIsRUFGcEJ6NUIsT0FFYWl4QixNQUZianhCLG9CQUVhaXhCLE1BQU93SSxHQUZoQnJyQjs7Y0FHc0I1UCxLQUh0QjRQLFNBR1FrakIsUUFIWnR4QixvQkFHWXN4QixTQUFjOXlCO1FBQ3JCLG9CQUFtQjthQUt4Qms3QixhQUdBMTVCLElBQUlFLEtBQUtrQjtNQUFxQix1QkFBOUJwQixJQUFTb0I7TUFBcUIsVUFBMUJsQjs7Y0FDa0MxQixjQUFMeUIsaUNBQUt6Qjs7O2NBSVFDLGVBQVowQixpQ0FBWTFCO1FBRWY7TUFQRCxJQUdXQyxnQkFBTDRCLGVBQXRCeU4sRUFIVjdOO2dCQUdnQ0ksU0FBdEJ5TixHQUEyQnJQLE9BSVM7YUFNOUNpN0IsWUFNRnBLLElBQUludUI7TUFBZSx5QkFBbkJtdUIsSUFBSW51QjtNQUFlLGdDQUNpQixJQUF2Qnd4QixjQUF1QixPQUF2QkE7TUFDVixtQkFBbUI7YUFrTHhCaUgsdUJBS0V2M0IsSUFBSWl0QixJQUFJbnVCO01BQ3VCLDBCQUQzQm11QixJQUFJbnVCLE9BQ3VCO29CQUQvQmtCLElBQ2Vzd0IsT0FBTXR4QixRQUN3QjthQXZML0NzNEIsZ0JBTUVySyxJQTRJTW51QjtNQTVJTyxVQUFibXVCO09BbUgyQixZQXlCckJudUI7O09BNUlPLE9BQWJtdUI7O29CQTRJTW51QjtZQTFJMkI7YUFEWjA0QixXQTJJZjE0QjthQTNJSDI0QixTQURIeEs7YUFFaUMsc0JBRDlCd0ssU0FBa0JEO2FBQ1k7O3lCQUFoQmxILE9BQU10eEI7OztvQkEwSWpCRjtZQXZJMkI7YUFEUDQ0QixhQXdJcEI1NEI7YUF4SUU2NEIsV0FKUjFLO2FBS2lDLHdCQUR6QjBLLFdBQWtCRDthQUNPOzt5QkFBaEIxSCxPQUFNNEc7OztVQUduQjtXQURPZ0IsV0FQWDNLO1dBT012dkIsSUFQTnV2QjtXQVFJLGtCQURFdnZCLElBcUlBb0I7V0FwSUY7OztZQUVKOzthQUFtQyx3QkFIeEI4NEIsV0FFdUJDO2FBQ0M7OzhCQUFoQkMsT0FBTWpCO1VBRUc7O1VBR3hCO1dBRFlrQixXQWRoQjlLO1dBY1d0dkIsTUFkWHN2QjtXQWVJLGtCQURPdHZCLE1BOEhMbUI7V0E3SEY7OztZQUVKOzthQUFtQyx3QkFIbkJpNUIsV0FFa0JDO2FBQ0M7OzhCQUFoQkMsT0FBTW5CO1VBRUc7O1VBR3hCO1dBRGlCb0IsV0FyQnJCakw7V0FxQmVydkIsS0FyQmZxdkI7V0FxQlVwdkIsTUFyQlZvdkI7V0FxQkdudkIsTUFyQkhtdkI7V0FzQkksa0JBRE1wdkIsTUFBS0QsS0F1SFRrQjtXQXRIRjs7OztZQUVKOzthQUFtQyx3QkFIZG81QixXQUVnQkM7YUFDRjs7eUJBSGhDcjZCLGdCQUdnQnM2QixPQUFNcEI7VUFFTTs7VUFHM0I7V0FEbUJxQixXQTVCdkJwTDtXQTRCaUJsdkIsT0E1QmpCa3ZCO1dBNEJZanZCLE1BNUJaaXZCO1dBNEJLaHZCLFFBNUJMZ3ZCO1dBNkJJLGtCQURRanZCLE1BQUtELE9BZ0hYZTtXQS9HRjs7OztZQUVKOzthQUFtQyx3QkFIWnU1QixXQUVnQkM7YUFDSjs7eUJBSDlCcjZCLGtCQUdjczZCLE9BQU10QjtVQUVNOztVQUczQjtXQUR1QnVCLFdBbkMzQnZMO1dBbUNxQi91QixPQW5DckIrdUI7V0FtQ2dCOXVCLE1BbkNoQjh1QjtXQW1DUzd1QixRQW5DVDZ1QjtXQW9DSSxrQkFEWTl1QixNQUFLRCxPQXlHZlk7V0F4R0Y7Ozs7WUFFSjs7YUFBbUMsd0JBSFIwNUIsV0FFZ0JDO2FBQ1I7O3lCQUgxQnI2QixrQkFHVXU2QixPQUFNRDtVQUVNOztVQUczQjtXQURtQkUsV0ExQ3ZCM0w7V0EwQ2lCNXVCLE9BMUNqQjR1QjtXQTBDWTN1QixNQTFDWjJ1QjtXQTBDSzF1QixRQTFDTDB1QjtXQTJDSSxrQkFEUTN1QixNQUFLRCxPQWtHWFM7V0FqR0Y7Ozs7WUFFSjs7YUFBbUMsd0JBSFo4NUIsV0FFZ0JDO2FBQ0o7O3lCQUg5QnQ2QixrQkFHY3c2QixPQUFNRDtVQUVNOztVQUczQjtXQURtQkUsV0FqRHZCL0w7V0FpRGlCenVCLE9BakRqQnl1QjtXQWlEWXh1QixNQWpEWnd1QjtXQWlES3Z1QixNQWpETHV1QjtXQWtESSxrQkFEUXh1QixNQUFLRCxPQTJGWE07V0ExRkY7Ozs7WUFFSjs7YUFBbUMsd0JBSFprNkIsV0FFZ0JDO2FBQ0o7O3lCQUg5QnY2QixnQkFHY3k2QixPQUFNRDtVQUVNOztVQUczQjtXQURLRSxXQXhEVG5NO1dBd0RJdHVCLE1BeERKc3VCO1dBeURJLGtCQURBdHVCLE1Bb0ZFRztXQW5GRjs7O1lBRUo7O2FBQW1DLHdCQUgxQnM2QixXQUV1QkM7YUFDRzs7OEJBQWhCRSxPQUFNRDtVQUVHOztVQUdLO1dBRDdCRSxXQS9ESnZNO1dBZ0VpQyx3QkFEN0J1TSxXQTZFRTE2QjtXQTVFMkI7O3dCQUFoQjQ2QixRQUFNRDs7VUFJVTtXQURkRSxZQW5FbkIxTTtXQW1FY3J1QixJQW5FZHF1QjtXQW9FaUMseUJBRGQwTSxZQXlFYjc2QjtXQXhFMkI7O3dCQURuQkYsSUFDR2k3QixRQUFNRDs7VUFHVTtXQURoQkUsWUF0RWpCN007V0FzRVlwdUIsSUF0RVpvdUI7V0F1RWlDLHlCQURoQjZNLFlBc0VYaDdCO1dBckUyQjs7d0JBRHJCRCxJQUNLbTdCLFFBQU1EOztvQkFxRWpCajdCOzthQWpFbUJtN0IsYUFpRW5CbjdCO2FBakVPOHdCLFVBaUVQOXdCO2FBbEV3Qm83QixZQTFFOUJqTjthQTBFbUI0QyxZQTFFbkI1QzthQTBFVUgsUUExRVZHO1lBNEVDLG9CQUZrQjRDLGdCQUNORDs7WUFFb0I7c0NBSEhzSyxZQUNMRDthQUVROzswQkFIdkJuTixRQUNHOEMsVUFFSXdLLFFBQU1EOzs7b0JBK0RqQnI3QjtZQTNEd0M7YUFETnU3QixjQTREbEN2N0I7YUE1RFN3N0IsV0E0RFR4N0I7YUE3RDBCeTdCLFlBL0VoQ3ROO2FBK0VxQnVOLFlBL0VyQnZOO2FBK0VZQyxVQS9FWkQ7YUFpRjhDLGtCQUQvQnFOO1lBQ2Qsb0JBQVUsVUFGVUU7O1lBRXlCO2FBRzlDLHlCQUxnQ0QsWUFLUCxVQUplRjthQUl4Qzs7MEJBTFluTixVQUNHb04sV0FHRUksUUFBTUQ7OztvQkF5RGpCMzdCO1lBbkQyQjthQURWNjdCLGNBb0RqQjc3QjthQXBERjg3QixZQXhGSjNOO2FBeUZpQyx5QkFEN0IyTixZQUFtQkQ7YUFDVTs7MEJBQWhCRyxRQUFNRDs7O29CQW1EakIvN0I7WUFoRDJCO2FBRFZpOEIsY0FpRGpCajhCO2FBakRGazhCLFlBM0ZKL047YUE0RmlDLHlCQUQ3QitOLFlBQW1CRDthQUNVOzswQkFBaEJHLFFBQU1EOzs7VUFLVTtXQURIRSxZQWhHOUJsTztXQWdHYy94QixlQWhHZCt4QjtXQWlHaUMseUJBREhrTyxZQTRDeEJyOEI7V0EzQzJCOzt3QkFEbkI1RCxlQUNHbWdDLFFBQU1EOztjQUVPRSxZQW5HOUJyTyxPQW1HY3VDLGVBbkdkdkM7VUE0SDRCLFNBekJkdUM7WUEyQm1CO3NCQTNCbkJBO2FBMEJRRjthQUFOOXhCO2FBQ2lCLHlCQURqQkEsS0FlVnNCO2FBZDJCOzthQUNBLHlCQTVCSHc4QixZQTJCUGorQjthQUNVOztnQ0FEaEJJLEtBREs2eEIsUUFFTGtNLE1BQU1EO1VBR1U7b0JBL0JuQi9MO1dBOEJRaU07V0FBTkM7V0FDaUIseUJBRGpCQSxPQVdWNThCO1dBVjJCOztXQUNBLHlCQWhDSHc4QixZQStCUEs7V0FDVTs7OEJBRGhCQyxPQURLSCxRQUVMSyxRQUFNRDs7b0JBU2pCLzhCO1lBcEMyQjthQURSaTlCLGNBcUNuQmo5QjthQXJDRGs5QixZQXZHTC9PO2FBd0dpQyx5QkFENUIrTyxZQUFvQkQ7YUFDUTs7MEJBQWhCRyxRQUFNRDs7O29CQW9DakJuOUI7WUFqQzJCO2FBRHNCcTlCLGNBa0NqRHI5QjthQWxDNEJzOUIsWUExR2xDblA7YUEwR3dCdnRCLFNBMUd4QnV0QjthQTBHYXR0QixVQTFHYnN0QjthQTJHaUMseUJBRENtUCxZQUFxQkQ7YUFDdEI7OzBCQURwQng4QixVQUFXRCxTQUNQNDhCLFFBQU1EOzs7b0JBaUNqQnY5QjtZQTlCMkI7YUFEVXk5QixjQStCckN6OUI7YUEvQm1CMDlCLFlBN0d6QnZQO2FBNkdnQnB0QixRQTdHaEJvdEI7YUE4R2lDLHlCQURSdVAsWUFBa0JEO2FBQ1Y7OzBCQURqQjE4QixRQUNDNjhCLFFBQU1EOzs7Y0FFTHZnQyxLQWhIbEIrd0IsT0FnSGFqdEIsSUFoSGJpdEI7VUE0SWUsVUE1QkZqdEI7V0E0QkUsT0E1QkZBO29CQTZCdUIsOEJBN0J2QkEsSUFBSzlELEtBNEJaNEM7b0JBRThCLDhCQTlCdkJrQixJQUFLOUQsS0E0Qlo0Qzs7Y0FzQlUsVUF0QlZBO2dCQXlCTjsrQkF6Qk1BO2lCQXlCNkIseUJBckRqQjVDLEtBb0RBeWdDO2lCQUNpQjs7Z0NBQWhCRSxRQUFNRDtjQUVwQjtxQkFkK0IsOEJBekN2QjU4QixJQUFLOUQsS0E0Qlo0Qzs7V0FBUyxPQTVCRmtCO29CQStCdUIsOEJBL0J2QkEsSUFBSzlELEtBNEJaNEM7b0JBSThCLDhCQWhDdkJrQixJQUFLOUQsS0E0Qlo0QztvQkFLOEIsOEJBakN2QmtCLElBQUs5RCxLQTRCWjRDO29CQU04Qiw4QkFsQ3ZCa0IsSUFBSzlELEtBNEJaNEM7b0JBTzhCLDhCQW5DdkJrQixJQUFLOUQsS0E0Qlo0QztvQkFROEIsOEJBcEN2QmtCLElBQUs5RCxLQTRCWjRDO29CQVM4Qiw4QkFyQ3ZCa0IsSUFBSzlELEtBNEJaNEM7b0JBVThCLDhCQXRDdkJrQixJQUFLOUQsS0E0Qlo0Qzs7a0JBY3FCZytCLFlBMUNkOThCLE9BMENLbXRCLFVBMUNMbnRCO3FCQTBEZnUzQjswQkFoQm9CcEssVUFBUzJQLGFBMUNUNWdDLEtBNEJaNEM7O2NBa0JOO2VBRjZCaStCLFlBNUNoQi84QjtlQTRDT290QixVQTVDUHB0QjtlQThDYixzQ0FGNkIrOEIsWUE1Q1g3Z0MsS0E0Qlo0QztlQWtCTjs7OzsrQkFGb0JzdUIsVUFDSCtQLGFBQTJCRCxRQUFNRDtxQkFOZCw4QkF2Q3ZCajlCLElBQUs5RCxLQTRCWjRDO3FCQVk4Qiw4QkF4Q3ZCa0IsSUFBSzlELEtBNEJaNEM7O01BdkJILG1CQUFtQjthQStEeEJrK0IsaUNBSUFwTixVQUFVM0MsSUFBSW5oQjtNQUFTLFVBQXZCOGpCO09BMEU2Qiw0QkExRW5CM0MsSUFBSW5oQjs7T0FBUyxPQUF2QjhqQjs7b0JBQWM5akI7WUFHWjthQUY4QjByQixXQURsQjFyQjthQUNOc3hCLGVBRFJ4TjthQUdFOytDQUZNd04sZUFERW5RLElBQ3NCdUs7YUFFOUI7O3lCQURpQjZGLGtCQUFpQi9NOzs7b0JBRnRCeGtCO1lBT1o7YUFGa0M0ckIsYUFMdEI1ckI7YUFLSnd4QixpQkFMVjFOO2FBT0U7O2dCQUZRME4saUJBTEFyUSxJQUswQnlLO2FBRWxDOzt5QkFEaUI2RixrQkFBaUJ2Tjs7O29CQU50QmxrQjtZQVdaO2FBRjRCK3JCLGFBVGhCL3JCO2FBU1AweEIsaUJBVFA1TjthQVdFOztnQkFGSzROLGlCQVRHdlEsSUFTb0I0SzthQUU1Qjs7eUJBRGlCNEYsa0JBQWlCM0Y7OztvQkFWdEJoc0I7WUFlWjthQUZnQ2tzQixhQWJwQmxzQjthQWFMNHhCLGlCQWJUOU47YUFlRTs7Z0JBRk84TixpQkFiQ3pRLElBYXdCK0s7YUFFaEM7O3lCQURpQjJGLGtCQUFpQjFGOzs7b0JBZHRCbnNCO1lBbUJaO2FBRndDcXNCLGFBakI1QnJzQjthQWlCRDh4QixpQkFqQmJoTzthQW1CRTs7Z0JBRldnTyxpQkFqQkgzUSxJQWlCZ0NrTDthQUV4Qzs7eUJBRGlCMEYsa0JBQWlCekY7OztvQkFsQnRCdHNCO1lBdUJaO2FBRmdDd3NCLGFBckJwQnhzQjthQXFCTGd5QixpQkFyQlRsTzthQXVCRTs7Z0JBRk9rTyxpQkFyQkM3USxJQXFCd0JxTDthQUVoQzs7eUJBRGlCeUYsbUJBQWlCeEY7OztvQkF0QnRCenNCO1lBMkJaO2FBRmdDMnNCLGFBekJwQjNzQjthQXlCTGt5QixrQkF6QlRwTzthQTJCRTs7Z0JBRk9vTyxrQkF6QkMvUSxJQXlCd0J3TDthQUVoQzs7eUJBRGlCd0YsbUJBQWlCdEY7OztvQkExQnRCN3NCO1lBK0JaO2FBRjhCK3NCLGFBN0JsQi9zQjthQTZCTm95QixrQkE3QlJ0TzthQStCRTs7Z0JBRk1zTyxrQkE3QkVqUixJQTZCc0I0TDthQUU5Qjs7eUJBRGlCc0YsbUJBQWlCcEY7OztvQkE5QnRCanRCOzthQW1EY210QixhQW5EZG50QjthQW1EQ3N5QixXQW5ERHR5QjthQWtEYXV5QixrQkFsRDNCek87YUFrRGUwTyxhQWxEZjFPO1lBb0RHLG9CQUZZME8saUJBQ0FGOztZQUdiOzs7Z0JBSnlCQyxrQkFsRGpCcFIsSUFtRGtCZ007YUFHMUI7O3lCQUhhbUYsV0FFSUcsbUJBQWlCcEY7OztvQkFyRHRCcnRCO1lBMkRtQzthQUZOdXRCLGFBekQ3QnZ0QjthQXlEZ0IweUIsYUF6RGhCMXlCO2FBeURHMnlCLFdBekRIM3lCO2FBd0Q2QjR5QixrQkF4RDNDOU87YUF3RDhCK08sYUF4RDlCL087YUF3RGlCZ1AsYUF4RGpCaFA7YUEyRGlELGtCQUZoQzZPO1lBRWQsb0JBQVUsVUFISUc7O1lBR2dDLFlBRUEsVUFKbkJKO1lBSTNCLG9CQUFVLFVBTGlCRzs7WUFHbUI7YUFJaEMsa0JBQU0sS0FOTkYsWUFBYUQ7YUFPWCxzQkFEZjNPO2FBQ2U7O1lBQ1IsV0FESjBGO1lBRUksV0FGR0Q7WUFMbUM7YUFTL0M7O2dCQUFpQyxVQVpRb0osbUJBeERqQ3pSLElBeURpQ29NO2FBV3pDOztZQUc4Qjt1QkFkZm9GLFdBQWFELGFBY0UsS0FKYks7b0JBQWlCdEY7OztvQkFuRXRCenRCO1lBbUNaO2FBRmdDbXVCLGFBakNwQm51QjthQWlDTGd6QixrQkFqQ1RsUDthQW1DRTs7Z0JBRk9rUCxrQkFqQ0M3UixJQWlDd0JnTjthQUVoQzs7MEJBRGlCOEUsbUJBQWlCckY7OztvQkFsQ3RCNXRCO1lBdUNaO2FBRmdDdXVCLGNBckNwQnZ1QjthQXFDTGt6QixrQkFyQ1RwUDthQXVDRTs7Z0JBRk9vUCxrQkFyQ0MvUixJQXFDd0JvTjthQUVoQzs7MEJBRGlCNEUsbUJBQWlCcEY7OztvQkF0Q3RCL3RCO1lBMkNaO2FBRmtDNnVCLGNBekN0Qjd1QjthQXlDSm96QixrQkF6Q1Z0UDthQTJDRTs7Z0JBRlFzUCxrQkF6Q0FqUyxJQXlDMEIwTjthQUVsQzs7MEJBRGlCd0UsbUJBQWlCbkY7OztvQkExQ3RCbHVCO1lBK0NaO2FBRmtEaXZCLGNBN0N0Q2p2QjthQTZDSXN6QixrQkE3Q2xCeFA7YUErQ0U7O2dCQUZnQndQLGtCQTdDUm5TLElBNkMwQzhOO2FBRWxEOzswQkFEaUJzRSxtQkFBaUJqRjs7O01BNkIvQixtQkFBbUI7YUEwQnhCa0YsT0FRRXJTLElBQUludUIsT0FDUSxtQkFEWm11QixJQUNZLFVBQVcsS0FEbkJudUIsUUFDZ0M7YUFNdEN5Z0MsWUFBWTVRLE1BQU01QixNQUFNbnVCO01BQzFCO2lDQUQwQkE7T0FDMUIsYUFEb0JtdUIsTUFBTjRCO09BR1osWUFIa0I1QjtNQUdsQixjQUZFbnBCLFdBRHNCaEY7TUFDMUIsSUFjRSxXQWZZb3dCLGNBZUY7YUFmRUE7ZUFpQkQsT0FqQmFwd0IsTUFlcEIwRyxNQWRGMUI7ZUFpQlMsT0FsQmFoRixNQWVwQjBHLGNBZEYxQjs7U0FrQlcsT0FsQlhBO1dBa0J1QiwwQkFuQkRoRjs7O3NCQW1Ca0IsZ0JBbkJsQkE7Ozt1QkFtQm1DLGdCQW5CbkNBOzs7OzthQW9CdEIsZUFMRTBHLE1BS2MsZ0JBcEJNMUc7YUFxQnRCLE9BckJzQkEsTUFlcEIwRyxlQWRGMUI7Ozs7U0l6eEJFO1dKOHlCUyxPQXJCWEE7c0JBcUJzQixnQkF0QkFoRjtjQXNCa0IsMkJBdEJsQkE7Ozt5QkFzQm1DLGdCQXRCbkNBOzs7OztnQkF1QnRCLGVBUkUwRyxNQVFjLGdCQXZCTTFHO2dCQXdCdEIsT0F4QnNCQSxNQWVwQjBHLGVBZEYxQjs7Ozs7O3lCQXlCQSxPQTFCc0JoRixNQWVwQjBHLGNBZEYxQjtNQTJCRiw0QkFiSTBCLElBYXNCO2FBRzFCazZCLGtCQUFrQjVoQyxLQUFLZ0I7TUFDZDtrQkFEU2hCO09BQ1QsMEJBRGNnQjtPQUduQixrQkFIbUJBO01BR25CLFNBQ0pxRTs7Ozs7Ozs7OztjQUtTLEdBUFBXLE9BREE3RjtzQkFDQTZGO2lCQU9xQzs7MkNBVGhCaEY7OzRCQVNpQyxnQkFUakNBOzttQkFVYixJQUFONmdDLE1BQU0sS0FUUjFoQzttQkFVRixlQURJMGhDLFFBQ1ksZ0JBWE83Z0M7bUJBWXZCLE9BWnVCQSxNQVVuQjZnQyxPQVRGMWhDLFNBQ0E2RjttQkFVRiw0QkFGSTY3Qjs7Ozs7Ozs7Ozs7O1VBTndCLEdBRjFCNzdCLE9BREE3RjtZQUlRLElBQU4rVixNQUFNLEtBSlIvVjtZQUtGLGVBREkrVixRQURKN1E7WUFHQSxPQVB1QnJFLE1BS25Ca1YsT0FKRi9WLFNBQ0E2RjtZQUtGLDRCQUZJa1E7O01JNXpCQTtVSnl6QkZsUSxNQURBN0Y7U0FjUSxJQUFOdUgsSUFBTSxLQWRSdkg7U0FlRixPQWhCdUJhLE1BZW5CMEcsSUFkRnZILFNBQ0E2RjtTQWNGLDRCQURJMEI7TUFJSixPQW5CdUIxRyxHQW1CcEI7YUFHSDhnQyxzQkFBc0I5Z0M7TUFDZDt1QkFEY0E7T0FDZCx3QkFBTjB3QjtPQUVNLFNBRE5udEI7TUFFSixpQkFISW10QixRQUVBaHFCLE1BREFuRDtNQUVKLDRCQURJbUQsSUFFc0I7YUFrRHhCcTZCLFlBQVk3aEMsTUFBTTZEO01BOUNBLE9BOENON0Q7Ozs7Ozs7Ozs7Ozs7O2tDQUFNNkQsRUFBd0M7YUFDMURpK0IsY0FBYzloQyxNQUFNNkQ7TUEvQkQsT0ErQkw3RDs7Ozs7Ozs7Ozs7Ozs7a0NBQU02RCxFQUEyQzthQUMvRGsrQixrQkFBa0IvaEMsTUFBTTZEO01BeEJMLE9Bd0JEN0Q7Ozs7Ozs7Ozs7Ozs7O2tDQUFNNkQsRUFBK0M7YUFDdkVtK0IsY0FBY2hpQyxNQUFNNkQ7TUF6Q0QsT0F5Q0w3RDs7Ozs7Ozs7Ozs7Ozs7b0NBQU02RCxFQUEyQzthQUkvRG8rQixjQUFjcmhDLE1BQU1YLE9BQUt5QztNQUMzQixTQURnQjlCO1FBR2QsU0FIY0E7Ozs7c0JBR1ZzaEM7Ozs7UUk5NEJBLGtCSjg0QkFBO1FBS0osSUFBSXBoQyxJQUFKLGdDQVJ5QjRCLEVBQUx6QyxPQUdoQmlpQztRQUtKLGFBUmN0aEMsTUFVcUIsa0JBRi9CRTtNQTNCTixVQW1CZ0JGOzs7UUFsQkgsYUFrQlNYLFFBakJULG1CQWlCR1csT0FoQko7UUFDVixnQkFESXdHO1FBRUosa0JBRklBLElBZ0JVeEc7UUFiZCxnQkFISXdHO1FBSUosa0JBSklBLElBSWtCLHFCQU5sQnRIO1FBT0osZ0JBTElzSCxJQURBKzZCO1FBRE8sU0FPWCxnQkFMSS82QjtVQThCQW9xQiw2QkFkcUI5dUI7Z0JBQVg5QjtRQWdCWjttQ0FGRTR3QjtTQVNJLG9DQXZCaUI5dUI7UUF1QmpCLHdCQXZCaUJBOztRQWdCdkIsSUFDaUJ4RTtRQUNmO2FBRGVBLE1BRGI0SDs7O1lBR007bUNBTFIwckIsTUFHZXR6QjthQUVQOzs7MkJBRUMsUUFKTUE7WUFFUDtzQkFMUnN6QixNQVc0QixJQVg1QkE7TUFDcUIsT0FEckJBLEtBY2U7YUFXbkI0USxnQkFBZ0JwaEM7TUFDUixJQUFOb0csSUFBTTtNQUNWLGFBRElBLElBRGNwRztNQUVsQix1QkFESW9HLElBRWU7YUF1TGpCaTdCLDJCQUtFL3pCLEVBQUVnMEIsRUFBRWg0QixJQUFJNmtCLElBQUl2dkIsSUFBSW9PLE1BQUttbkIsTUFBTW4xQjtNQUFTLFVBQXhCSjtrQkFBSW9POzsyQkFFZHRMO29CQUNRLElBQU41QixJQUFNLFdBSFdxMEIsTUFBTW4xQixNQUV6QjBDO29CQUNRLG1CQUhWNEwsRUFBRWcwQixLQUFFaDRCLElBR0F4SixLQUhJcXVCLElBSXdDOzJCQU05Q3hoQixFQUFFakw7b0JBQ00sSUFBTjVCLElBQU0sa0JBRFI2TSxFQUM0QixXQVhUd25CLE1BQU1uMUIsTUFVdkIwQztvQkFDTSxtQkFYVjRMLEVBQUVnMEIsS0FBRWg0QixJQVdBeEosS0FYSXF1QixJQVl3QztRQU5sRCxJQUQwQnhoQixFQUxSSztRQU1sQixnQkFBSXRMO1VBQ1EsSUFBTjVCLElBQU0sa0JBRmM2TSxFQUVNLFdBUFR3bkIsTUFBTW4xQixNQU16QjBDO1VBQ1EsbUJBUFY0TCxFQUFFZzBCLEtBQUVoNEIsSUFPQXhKLEtBUElxdUIsSUFRd0M7O1FBUlosU0FBeEJ2dkI7O29CQUFJb087OzZCQWNkdEw7c0JBQ1EsSUFBTjVCLElBQU0sc0JBQW9CLFdBZlRxMEIsTUFBTW4xQixNQWN6QjBDO3NCQUNRLG1CQWZWNEwsRUFBRWcwQixLQUFFaDRCLElBZUF4SixLQWZJcXVCLElBZ0J3Qzs2QkFNOUN4aEIsRUFBRWpMO3NCQUNNO3VCQUFONUI7d0JBQU07b0NBQW9CLGtCQUQ1QjZNLEVBQ2lELFdBdkI5QnduQixNQUFNbjFCLE1Bc0J2QjBDO3NCQUNNLG1CQXZCVjRMLEVBQUVnMEIsS0FBRWg0QixJQXVCQXhKLEtBdkJJcXVCLElBd0J3QztjQVBacVQsSUFqQnBCeDBCOzBCQWtCZHRMO1lBQ1E7YUFBTjVCO2NBQU07MEJBQW9CLGtCQUZNMGhDLElBRWUsV0FuQjlCck4sTUFBTW4xQixNQWtCekIwQztZQUNRLG1CQW5CVjRMLEVBQUVnMEIsS0FBRWg0QixJQW1CQXhKLEtBbkJJcXVCLElBb0J3QztpQkFwQnBDdnZCO2tCQUFJb087OzJCQTBCZHFyQixFQUFFMzJCO29CQUNNLElBQU41QixJQUFNLGlCQURSdTRCLEVBQzRCLFdBM0JUbEUsTUFBTW4xQixNQTBCdkIwQztvQkFDTSxtQkEzQlY0TCxFQUFFZzBCLEtBQUVoNEIsSUEyQkF4SixLQTNCSXF1QixJQTRCd0M7MkJBTTlDa0ssRUFBRTFyQixFQUFFakw7b0JBQ0k7cUJBQU41QjtzQkFBTTs2QkFEUnU0QixFQUM0QixrQkFEMUIxckIsRUFDK0MsV0FuQzlCd25CLE1BQU1uMUIsTUFrQ3JCMEM7b0JBQ0ksbUJBbkNWNEwsRUFBRWcwQixLQUFFaDRCLElBbUNBeEosS0FuQ0lxdUIsSUFvQ3dDO1lBUGpCc1QsSUE3QmZ6MEI7d0JBOEJkcXJCLEVBQUUzMkI7VUFDTTtXQUFONUI7WUFBTTttQkFEUnU0QixFQUM0QixrQkFGQ29KLElBRW9CLFdBL0I5QnROLE1BQU1uMUIsTUE4QnZCMEM7VUFDTSxtQkEvQlY0TCxFQUFFZzBCLEtBQUVoNEIsSUErQkF4SixLQS9CSXF1QixJQWdDd0MsRUFJQTthQTdEbER1VCxhQUlFcDBCLEVBQUVnMEIsRUFBRWg0QixJQUFJNmtCLElBQUl2dkIsSUFBSXUxQjtNQUFTLFVBQWJ2MUI7T0FFZCxnQkFBSThDO1NBQ2tDLElBQWhDaWdDLFdBSEFyNEIsSUFHZ0MsV0FIcEI2cUIsTUFFZHp5QjtTQUNrQyxtQkFIcEM0TCxFQUFFZzBCLEVBR0VLLFFBSEl4VCxJQUltQjs7UUFKRixTQUFidnZCO2NBS01xdkIsTUFMTnJ2QixPQUtEaXhCLE1BTENqeEI7MEJBTVY4QztZQUNrQyxJQUFoQ2lnQyxXQVBBcjRCLElBT2dDLFlBRnpCdW1CLE1BQU81QixNQUUwQyxXQVA1Q2tHLE1BTWR6eUI7WUFDa0MsbUJBUHBDNEwsRUFBRWcwQixFQU9FSyxRQVBJeFQsSUFRbUI7UUFFN0IsSUFEWStCLFFBVEV0eEI7UUFVZCxnQkFBSXk1QixFQUFFMzJCO1VBQ2dDLElBQWhDaWdDLFdBWEFyNEIsSUFXZ0MsWUFGMUI0bUIsUUFDUm1JLEVBQ3NELFdBWHhDbEUsTUFVWnp5QjtVQUNnQyxtQkFYcEM0TCxFQUFFZzBCLEVBV0VLLFFBWEl4VCxJQVltQjthQXZLekJ5VCxzQkFHSnQwQixFQXlOSWcwQixFQXpOQWg0QixJQUFJNmtCO1VBQVI1Z0IsTUFBSWhFLFVBQUlpb0I7TUFBTztpQkFBUEE7UUF1RlIsa0JBdkZBamtCLElBeU5JK3pCLEVBek5BLzNCOztRQUFXLE9BQVBpb0I7O1dBRVIsSUFES3AwQixLQURHbzBCO1dBRVIsZ0JBQUlydEI7YUFDRixJQUFJdzlCLFdBSEZwNEIsTUFFQXBGLEdBQ0YsbUJBSEZvSixJQXlOSSt6QixFQXRORUssUUFGRHZrQyxLQUd5Qjs7V0FFOUIsSUFEVUMsT0FMRm0wQjtXQU1SLGdCQUFJcnRCO2FBL0JJOzBCQStCSkE7Y0EvQkksd0JBQU5yRTtjQUVNLFNBRE51RDthQUVKLGlCQUhJdkQsTUFFQTBHLE1BREFuRDthQURNLElBZ0NGcytCLFdBUEZwNEIsTUF0Qk4scUJBREkvQztvQkFvQkUrNkIsWUFHSmgwQixJQXlOSSt6QixFQWxORUssUUFGSXRrQyxPQUdvQjs7ZUFDakJDLE9BVExrMEIsU0FTQTV5QixJQVRBNHlCO2tCQW9KUmtRO29CQXBKQW4wQixJQXlOSSt6QixFQXpOQS8zQixNQVNTak0sT0FBTHNCLGFBQzJCa0IsS0FBTyxPQUFQQSxHQUFVOztlQUMzQnZDLE9BWFZpMEIsU0FXSzN5QixNQVhMMnlCO2tCQW9KUmtRLGFBcEpBbjBCLElBeU5JK3pCLEVBek5BLzNCLE1BV2NoTSxPQUFMc0IsTUFsSWIraEM7O2VBb0l1QnBqQyxPQWJmZzBCLFNBYVMxeUIsS0FiVDB5QixTQWFJenlCLE1BYkp5eUIsU0FhSHh5QixNQWJHd3lCO2tCQXdLUjZQO29CQXhLQTl6QixJQXlOSSt6QixFQXpOQS8zQixNQWFtQi9MLE9BQVh1QixNQUFLRCxLQTdFakIraEMsWUE2RUs3aEM7OztZQUVvQnZCLE9BZmpCK3pCO1lBZVd2eUIsT0FmWHV5QjtZQWVNdHlCLE1BZk5zeUI7WUFlRHJ5QixRQWZDcXlCO2tCQXdLUjZQO29CQXhLQTl6QixJQXlOSSt6QixFQXpOQS8zQixNQWVxQjlMLE9BQVh5QixNQUFLRCxPQTlFbkI2aEMsY0E4RU8zaEM7OztZQUVzQnpCLE9BakJyQjh6QjtZQWlCZXB5QixPQWpCZm95QjtZQWlCVW55QixNQWpCVm15QjtZQWlCR2x5QixRQWpCSGt5QjtrQkF3S1I2UDtvQkF4S0E5ekIsSUF5TkkrekIsRUF6TkEvM0IsTUFpQnlCN0wsT0FBWDJCLE1BQUtELE9BL0V2QjJoQyxrQkErRVd6aEM7OztZQUVjM0IsT0FuQmpCNnpCO1lBbUJXanlCLE9BbkJYaXlCO1lBbUJNaHlCLE1BbkJOZ3lCO1lBbUJEL3hCLFFBbkJDK3hCO2tCQXdLUjZQO29CQXhLQTl6QixJQXlOSSt6QixFQXpOQS8zQixNQW1CcUI1TCxPQUFYNkIsTUFBS0QsT0FoRm5CeWhDLGNBZ0ZPdmhDOztlQUVrQjdCLE9BckJqQjR6QixTQXFCVzl4QixPQXJCWDh4QixTQXFCTTd4QixNQXJCTjZ4QixTQXFCRDV4QixNQXJCQzR4QjtXQXlOd0IsVUFwTWxCN3hCO3VCQUFLRDs7Z0NBc01mZ0M7eUJBQ1EsSUFBTjVCLElBQU0sY0F2TUxGLE1BdndDUG12Qix3QkE2OENJcnRCO3lCQUNRLG1CQTVOWjZMLElBeU5JK3pCLEtBek5BLzNCLE1BNE5FekosS0F2TW1CbEMsT0F3TXlCO2dDQU05QytPLEVBQUVqTDt5QkFDTSxJQUFONUIsSUFBTSxjQS9NTEYsTUE4TUgrTSxFQUFFakw7eUJBQ00sbUJBcE9aNkwsSUF5TkkrekIsS0F6TkEvM0IsTUFvT0V6SixLQS9NbUJsQyxPQWdOeUI7YUFObEQsSUFEMEIrTyxFQXpNUGpOO2FBME1uQixnQkFBSWdDO2VBQ1EsSUFBTjVCLElBQU0sY0EzTUxGLE1BeU1tQitNLEVBQ3RCakw7ZUFDUSxtQkFoT1o2TCxJQXlOSSt6QixLQXpOQS8zQixNQWdPRXpKLEtBM01tQmxDLE9BNE15Qjs7YUFSbEIsU0FwTWxCK0I7O3lCQUFLRDs7a0NBa05mZ0M7MkJBQ1E7OENBbk5MOUIsTUF2d0NQbXZCLHdCQXk5Q0lydEI7NEJBRVMsNEJBRFA1QjsyQkFDTyxtQkF6T2J5TixJQXlOSSt6QixLQXpOQS8zQixNQXlPRWluQixPQXBObUI1eUIsT0FxTjBCO2tDQU0vQytPLEVBQUVqTDsyQkFDTSxJQUFONUIsSUFBTSxzQkFBb0IsY0E1TnpCRixNQTJOSCtNLEVBQUVqTDsyQkFDTSxtQkFqUFo2TCxJQXlOSSt6QixLQXpOQS8zQixNQWlQRXpKLEtBNU5tQmxDLE9BNk55QjttQkFQWjRqQyxJQXRObkI5aEM7K0JBdU5mZ0M7aUJBQ1EsSUFBTjVCLElBQU0sc0JBQW9CLGNBeE56QkYsTUFzTitCNGhDLElBQ2xDOS9CO2lCQUNRLG1CQTdPWjZMLElBeU5JK3pCLEtBek5BLzNCLE1BNk9FekosS0F4Tm1CbEMsT0F5TnlCO3NCQXpOcEMrQjt1QkFBS0Q7O2dDQStOZjI0QixFQUFFMzJCO3lCQUNNOzRDQWhPTDlCLE1BdndDUG12Qix3QkFzK0NNcnRCOzBCQUVPLHVCQUZUMjJCLEVBQ0V2NEI7eUJBQ08sbUJBdFBieU4sSUF5TkkrekIsS0F6TkEvM0IsTUFzUEVpbkIsT0FqT21CNXlCLE9Ba08wQjtnQ0FNL0N5NkIsRUFBRTFyQixFQUFFakw7eUJBQ0ksSUFBTjVCLElBQU0saUJBRFJ1NEIsRUFDNEIsY0F6T3pCejRCLE1Bd09EK00sRUFBRWpMO3lCQUNJLG1CQTlQWjZMLElBeU5JK3pCLEtBek5BLzNCLE1BOFBFekosS0F6T21CbEMsT0EwT3lCO2lCQVBqQjZqQyxJQW5PZC9oQzs2QkFvT2YyNEIsRUFBRTMyQjtlQUNNLElBQU41QixJQUFNLGlCQURSdTRCLEVBQzRCLGNBck96Qno0QixNQW1PMEI2aEMsSUFDM0IvL0I7ZUFDTSxtQkExUFo2TCxJQXlOSSt6QixLQXpOQS8zQixNQTBQRXpKLEtBck9tQmxDLE9Bc095Qjs7ZUFwT3ZDRSxPQXZCSDB6QixTQXVCRjN4QixNQXZCRTJ4QjtrQkFvSlJrUSxhQXBKQW4wQixJQXlOSSt6QixFQXpOQS8zQixNQXVCT3pMLE9BQUwrQixNS3B2Q05pRDs7V0x1d0NBLFVBMUNRMHVCLFNBMENSLFNBMUNJam9CLG1CQUFJaW9COzs7OztZQTRDUTF4QixJQTVDUjB4QjtZQUFKcVEsZUE0Q1kvaEM7WUE1Q1p5SjtZQUFJaW9COzs7OztZQThDTXp4QixJQTlDTnl4QjtZQUFKc1EsZUE4Q1UvaEM7WUE5Q1Z3SjtZQUFJaW9COzs7V0FrREM7WUFEaUJ4ekIsT0FqRGxCd3pCO1lBaURPVixVQWpEUFU7WUFrREMsbUJBRE1WO1dBQ04sZ0JBQ0poeEI7YUFDSCxtQkFwREZ5TixJQXlOSSt6QixLQXpOQS8zQixNQWtEQTFMLElBRHNCRyxPQUl3Qjs7ZUFDMUJDLFFBdERoQnV6QixTQXNEU3h4QixNQXREVHd4Qjs7YUF1RFIsSUFBYXJEO2FBQ1g7c0JBeERGNWdCLElBeU5JK3pCLEVBek5BLzNCLE1Bd0RGLFdBQVksT0FERDRrQixJQURJbnVCLE9BQU8vQixTQUVjOztXQTlCdEMsSUFETUMsUUF6QkVzekI7V0EwQlIsZ0JBQUlwd0IsRUFBRU07YUFBSztzQkExQlg2TDtzQkF5TkkrekI7eUJBek5BLzNCLGVBMEI0QyszQixHQUFLLGtCQUFqRGxnQyxFQUE0Q2tnQyxFQUExQzUvQixFQUFvRDtzQkFEcER4RCxRQUMyRDs7V0FFakUsSUFETUMsUUEzQkVxekI7V0E0QlIsZ0JBQUlwd0IsR0FBSyxtQkE1QlRtTSxJQXlOSSt6QixLQXpOQS8zQixNQTRCQW5JLEdBREVqRCxRQUM0Qzs7O1lBNUIxQ203QjtZQTJFUS80QixXQTNFUml4QjtZQUFKdVEsZUEyRVl4aEM7WUEzRVpnSjtZQUFJaW9COzs7Ozs7Y0E2RXFDcHpCLFFBN0VyQ296Qjs7O2NBQVJ3UTt3QkFBSTE0QixJQUFKZ0UsRUE2RTZDbFE7MEJBN0U3Q21RLElBOEVPMDBCLElBQUlDO21CQUNULG1CQS9FRjUwQixFQThFTzIwQixPQTlFSDM0QixPQThFTzQ0QixPQURrQzlrQyxLQUV5Qjt3QkEvRXRFbVE7c0JBQUloRSxNQUFKZ0UsSUE2RTZDblA7Y0E3RTdDbVA7Y0FBSWhFO2NBQUlpb0I7OztZQWlGcUNweEIsUUFqRnJDb3hCOzs7WUFBUjJRO3NCQUFJNzRCLElBQUpnRSxFQWlGNkNsUTt3QkFqRjdDbVEsSUFrRk8wMEIsSUFBSUM7aUJBQ1QsbUJBbkZGNTBCLEVBa0ZPMjBCLE9BbEZIMzRCLE9Ba0ZPNDRCLE9BRGtDOWtDLEtBRXlCO3NCQW5GdEVtUTtvQkFBSWhFLE1BQUpnRSxJQWlGNkNuTjtZQWpGN0NtTjtZQUFJaEU7WUFBSWlvQjs7a0JBd0NSOztlQWtCcUJueEIsUUExRGJteEIsU0EyREptUSxXQTNEQXA0QjtrQ0E0REssbUJBNURUZ0UsSUF5TkkrekIsRUE5SkFLLFFBRGlCdGhDLFFBRWdCOztXQUtyQyxJQUpxQkMsUUE3RGJreEI7V0FpRVIsZ0JBQUkzdUI7YUFDa0MsSUFBaEM4K0IsV0FsRUZwNEIsTUFrRWtDLHdCQURsQzFHO2FBQ2tDLG1CQWxFdEMwSyxJQXlOSSt6QixFQXZKRUssUUFMZXJoQyxRQU1TOztXQUU5QixJQURlRSxRQXBFUGd4QjtXQXFFUixnQkFBSXJ0QjthQUNGLElBQUl3OUIsV0F0RUZwNEIsTUFxRUFwRjthQUNGLG1CQXRFRm9KLElBeU5JK3pCLEVBbkpFSyxRQUZTbmhDLFFBR2U7O2VBQ1ZFLFFBeEVaOHdCLFNBd0VPdHdCLElBeEVQc3dCOzs7b0JBMkZSNFEsK0JBM0ZBNzBCLElBeU5JK3pCLEVBek5BLzNCLE1Bd0VXckksSUFBS1I7O29CQW1CcEIwaEMsd0JBM0ZBNzBCLElBeU5JK3pCLEVBek5BLzNCLE1Bd0VXckksSUFBS1I7O1dBMUNXO1lBRGJDLFFBN0JWNndCO1lBNkJPcHdCLEVBN0JQb3dCO1lBNkJBbndCLE1BN0JBbXdCO1lBOEJ1QixnQkFEaEJwd0I7V0FDZ0I7O29CQWtPL0JpaEMsd0JBaFFBOTBCLElBeU5JK3pCLEVBek5BLzNCLE1BNkJjNUksUUFBVlU7O29CQW1PUmdoQyxpQkFoUUE5MEIsSUF5TkkrekIsRUF6TkEvM0IsTUE2QmM1SSxRQUFWVSxhQTBERDthQUlQK2dDLDZCQUlBOTBCLEVBQUVnMEIsRUFBRWg0QixJQUFJcEksSUFBSWl0QjtNQUFPLFVBQVhqdEI7T0FBVyxPQUFYQTs7VUFDMkI7O21CQTZDbkNvaEMsMkJBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCO3dDQThDWm1VLG9CQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjs7VUFFdUI7O21CQTRDbkNtVSwyQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7d0NBOENabVUsb0JBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCO2dCQWF1Qjs7VUFHQTs7bUJBOEJuQ21VLDJCQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjt3Q0E4Q1ptVSxvQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7O09BQU8sT0FBWGp0Qjs7VUFHMkI7O21CQTJDbkNvaEMsMkJBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCO3dDQThDWm1VLG9CQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjs7VUFJdUI7O21CQTBDbkNtVSwyQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7d0NBOENabVUsb0JBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCOztVQUt1Qjs7bUJBeUNuQ21VLDJCQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjt3Q0E4Q1ptVSxvQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7O1VBTXVCOzttQkF3Q25DbVUsMkJBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCO3dDQThDWm1VLG9CQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjs7VUFPdUI7O21CQXVDbkNtVSwyQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7d0NBOENabVUsb0JBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCOztVQVF1Qjs7bUJBc0NuQ21VLDJCQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjt3Q0E4Q1ptVSxvQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7O1VBU3VCOzttQkFxQ25DbVUsMkJBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCO3dDQThDWm1VLG9CQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjs7VUFVdUI7O21CQW9DbkNtVSw0QkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7d0NBOENabVUsb0JBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCOztVQVd1Qjs7bUJBbUNuQ21VLDRCQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjt3Q0E4Q1ptVSxvQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7O1VBWXVCLElBQVZudUIsTUFaakJrQjtVQVkyQjs7bUJBUW5DcWhDLDZCQXBCQWoxQixFQUFFZzBCLEVBQUVoNEIsSUFZcUJ0SixNQVpibXVCOzttQkFvQlpvVSxxQkFwQkFqMUIsRUFBRWcwQixFQUFFaDRCLElBWXFCdEosTUFaYm11Qjs7VUFjdUI7O21CQWdDbkNtVSw0QkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0I7d0NBOENabVUsb0JBOUNBaDFCLEVBQUVnMEIsRUFBRWg0QixJQUFRNmtCOztVQWV1Qjs7bUJBK0JuQ21VLDRCQTlDQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBUTZrQjt3Q0E4Q1ptVSxvQkE5Q0FoMUIsRUFBRWcwQixFQUFFaDRCLElBQVE2a0IsTUFnQm1EO2FBSS9Eb1UsMEJBSUFqMUIsRUFBRWcwQixFQUFFaDRCLElBQUl0SixNQUFNbXVCO01BQU8sVUFBYm51QjtRQWVtQjs7aUJBTzNCc2lDLDJCQXRCQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBVTZrQjtzQ0FzQmRtVSxvQkF0QkFoMUIsRUFBRWcwQixFQUFFaDRCLElBQVU2a0I7O09BQU8sT0FBYm51Qjs7VUFDbUIsSUFBbkI1QyxLQURBNEM7VUFDbUIsdUJBQVMsdUJBRHBDc04sRUFBRWcwQixFQUFFaDRCLElBQ0lsTSxLQURNK3dCLElBQ3NEOztVQUN6QyxJQUFqQjl3QixPQUZGMkM7VUFFbUIsdUJBQVMsdUJBRnBDc04sRUFBRWcwQixFQUFFaDRCLElBRU1qTSxPQUZJOHdCLElBRXNEOztVQUN6QyxJQUFwQjd3QixPQUhDMEM7VUFHbUIsdUJBQVMsdUJBSHBDc04sRUFBRWcwQixFQUFFaDRCLElBR0doTSxPQUhPNndCLElBR3NEOztVQUN6QyxJQUFsQjV3QixPQUpEeUM7VUFJbUIsdUJBQVMsdUJBSnBDc04sRUFBRWcwQixFQUFFaDRCLElBSUsvTCxPQUpLNHdCLElBSXNEOztVQUN6QyxJQUFkM3dCLE9BTEx3QztVQUttQix1QkFBUyx1QkFMcENzTixFQUFFZzBCLEVBQUVoNEIsSUFLUzlMLE9BTEMyd0IsSUFLc0Q7O1VBQ3pDLElBQWxCMXdCLE9BTkR1QztVQU1tQix1QkFBUyx1QkFOcENzTixFQUFFZzBCLEVBQUVoNEIsSUFNSzdMLE9BTkswd0IsSUFNc0Q7O1VBQ3pDLElBQWxCendCLE9BUERzQztVQU9tQix1QkFBUyx1QkFQcENzTixFQUFFZzBCLEVBQUVoNEIsSUFPSzVMLE9BUEt5d0IsSUFPc0Q7O1VBQ3pDLElBQW5CeHdCLE9BUkFxQztVQVFtQix1QkFBUyx1QkFScENzTixFQUFFZzBCLEVBQUVoNEIsSUFRSTNMLE9BUk13d0IsSUFRc0Q7O1VBTXpDLElBQVR2d0IsT0FkVm9DO1VBY21CLHVCQUFTLHVCQWRwQ3NOLEVBQUVnMEIsRUFBRWg0QixJQWNjMUwsT0FkSnV3QixJQWNzRDs7VUFHM0Q7V0FEa0Jyd0IsT0FoQm5Ca0M7V0FnQmN4QixJQWhCZHdCO1dBZ0JTakMsSUFoQlRpQztXQWlCQyxTQUFNLEtBREVqQyxLQUFLUztVQUNiO1lBQ3dCLHVCQWxCakM4TyxFQUFFZzBCLEVBQUVoNEIsSUFrQjZCLGFBRDdCekwsR0FEdUJDLFFBaEJicXdCLElBa0I2Qzs7VUFUaEMsSUFBbEJud0IsT0FURGdDO1VBU21CO1lBQVcsdUJBVHRDc04sRUFBRWcwQixFQUFFaDRCLElBU0t0TCxPQVRLbXdCLElBU3dEOztVQUMzQyxJQUFsQmx3QixRQVZEK0I7VUFVbUIsdUJBQVMsdUJBVnBDc04sRUFBRWcwQixFQUFFaDRCLElBVUtyTCxRQVZLa3dCLElBVXNEOztVQUN6QyxJQUFwQmp3QixRQVhDOEI7VUFXbUIsdUJBQVMsdUJBWHBDc04sRUFBRWcwQixFQUFFaDRCLElBV0dwTCxRQVhPaXdCLElBV3NEO2lCQUN6QztpQkFDQSw4QkFLZ0M7YUFJM0RtVSx5QkFHQWgxQixFQUFFZzBCLEVBQUVoNEIsSUFBSTZrQjtNQUNWLFlBRE03a0I7TUFDTjs7ZUFwSk1zNEIsd0JBbUpKdDBCLEVBQUVnMEIsT0FBTW5UO29DQW5KSnlULGlCQW1KSnQwQixFQUFFZzBCLE9BQU1uVCxLQUM4RDthQStHdEVrVSxzQkFJRS8wQixFQUFFZzBCLEVBQUVoNEIsSUFBSWxNLEtBQUtpRSxNQUFNRDtNQUFLLEdBQVhDO1FBR2YsSUFEWTQxQixRQUZHNTFCO1FBR2YsZ0JBQUlLO1VBQzZCLG1CQUovQjRMLEVBQUVnMEIsRUFBRWg0QixJQUFJbE0sS0FFRTY1QixRQUVxQixXQUpaNzFCLEVBR2pCTSxHQUNrQztNQUh2QixZQURUNEgsSUFBZWxJO01BQ047O2VBeFFYd2dDLHdCQXVRRnQwQixFQUFFZzBCLE9BQU1sa0M7b0NBdlFOd2tDLGlCQXVRRnQwQixFQUFFZzBCLE9BQU1sa0MsTUFJNEI7YUEzUWxDbWtDLFlBR0pqMEIsRUF5TklnMEIsRUF6TkFoNEIsSUFBSTZrQjtNLHVCQUhKeVQsZ0JBR0p0MEIsRUF5TklnMEIsRUF6TkFoNEIsSUFBSTZrQjthQTJGUnVVLG1CQUlBcDFCLEVBQUVnMEIsRUFBRWg0QixJQUFJcEksSUFBSWl0QjtNLHVCQUpaaVUsdUJBSUE5MEIsRUFBRWcwQixFQUFFaDRCLElBQUlwSSxJQUFJaXRCO2FBb0JacVUsZ0JBSUFsMUIsRUFBRWcwQixFQUFFaDRCLElBQUl0SixNQUFNbXVCO00sdUJBSmRvVSxvQkFJQWoxQixFQUFFZzBCLEVBQUVoNEIsSUFBSXRKLE1BQU1tdUI7YUF5SWRzVSxZQUlFbjFCLEVBQUVnMEIsRUFBRWg0QixJQUFJbE0sS0FBS2lFLE1BQU1EO00sdUJBSnJCaWhDLGdCQUlFLzBCLEVBQUVnMEIsRUFBRWg0QixJQUFJbE0sS0FBS2lFLE1BQU1EO2FBaUZyQnVoQyx3QkFJRXIxQixFQUFFZzBCLEVBQUVuVCxJQUFJdnZCLElBQUlFO01BQVEsVUFBWkY7a0JBQUlFOztZQUVKLHNCQUZSd08sRUFBRWcwQixFQUFFblQsS0FFSSxzQjtVQUlPLHNCQU5mN2dCLEVBQUVnMEIsRUFBRW5ULEtBTUksb0I7VUFBQSxzQjtRQUZBLHNCQUpSN2dCLEVBQUVnMEIsRUFBRW5UO1FBSUksc0I7O1FBSlksU0FBWnZ2QjtvQkFBSUU7O2NBUUosc0JBUlJ3TyxFQUFFZzBCLEVBQUVuVDtjQVFJLHNCO1lBSU8sc0JBWmY3Z0IsRUFBRWcwQixFQUFFblQsS0FZSSxvQjtZQUFBLHNCO1VBRkEsc0JBVlI3Z0IsRUFBRWcwQixFQUFFblQ7VUFVSSxzQjtrQkFWSXJ2Qjs7WUFjRyxzQkFkZndPLEVBQUVnMEIsRUFBRW5ULEtBY0ksb0I7WUFBQSxzQjtVQUljOzZCQWxCdEI3Z0IsRUFBRWcwQixFQUFFblQ7V0FrQlcsb0I7V0FBUCxvQjtVQUFBLHNCO1FBRk8sc0JBaEJmN2dCLEVBQUVnMEIsRUFBRW5ULEtBZ0JJLG9CO1FBQUEsc0IsYUFFc0M7YUEvRjVDMFUsdUJBRUZ2MUIsRUFBRWcwQixFQUFFblQ7VUFBSjVnQixNQUFJaWtCO01BQU87aUJBQVBBO1FBc0VGLGtCQXRFRmprQixJQUFFK3pCOztRQUFTLE9BQVA5UDs7V0FFRixTQUZFQSxTQUVJLGtCQUZSamtCLElBQUUrekIsRUFDR2xrQztXQUNHLHNCOztXQUVOLFdBSkVvMEIsU0FJSSxrQkFKUmprQixJQUFFK3pCLEVBR1Fqa0M7V0FDRixzQjs7b0JBSkptMEI7O2FBTUYsV0FORUEsU0FNSSxrQkFOUmprQixJQUFFK3pCLEVBS2tCaGtDO2FBQ1osc0I7OztlQUVOLFdBUkVrMEIsU0FRSSxrQkFSUmprQixJQUFFK3pCLEVBT3FCL2pDO2VBQ2Ysc0I7YUFFTjtxQkFWRWkwQjtjQVVXLGtCQVZmamtCLElBQUUrekIsRUFTcUI5akM7Y0FDZixvQjthQUFBLHNCOztvQkFWSmcwQjs7YUFZRixXQVpFQSxTQVlJLGtCQVpSamtCLElBQUUrekIsRUFXdUI3akM7YUFDakIsc0I7OztlQUVOLFdBZEUrekIsU0FjSSxrQkFkUmprQixJQUFFK3pCLEVBYTBCNWpDO2VBQ3BCLHNCO2FBRU47cUJBaEJFOHpCO2NBZ0JXLGtCQWhCZmprQixJQUFFK3pCLEVBZTBCM2pDO2NBQ3BCLG9CO2FBQUEsc0I7O2VBQ1dDLE9BakJmNHpCLFNBaUJTMXlCLEtBakJUMHlCLFNBaUJJNXlCLElBakJKNHlCO2tCQXVFTm1SLHdCQXZFRXAxQixJQUFFK3pCLEVBaUJpQjFqQyxPQUFYZ0IsSUFBS0U7O2VBRVFoQixPQW5CakIwekIsU0FtQld2eUIsT0FuQlh1eUIsU0FtQk0zeUIsTUFuQk4yeUI7a0JBdUVObVIsd0JBdkVFcDFCLElBQUUrekIsRUFtQm1CeGpDLE9BQVhlLE1BQUtJOztlQUVVakIsT0FyQnJCd3pCLFNBcUJlcHlCLE9BckJmb3lCLFNBcUJVenlCLE1BckJWeXlCO2tCQXVFTm1SLHdCQXZFRXAxQixJQUFFK3pCLEVBcUJ1QnRqQyxPQUFYZSxNQUFLSzs7ZUFFRW5CLFFBdkJqQnV6QixTQXVCV2p5QixPQXZCWGl5QixTQXVCTXR5QixNQXZCTnN5QjtrQkF1RU5tUix3QkF2RUVwMUIsSUFBRSt6QixFQXVCbUJyakMsUUFBWGlCLE1BQUtLOztlQUVNckIsUUF6QmpCc3pCLFNBeUJXOXhCLE9BekJYOHhCLFNBeUJNbnlCLE1BekJObXlCO2tCQXVFTm1SLHdCQXZFRXAxQixJQUFFK3pCLEVBeUJtQnBqQyxRQUFYbUIsTUFBS0s7O29CQXpCWDh4Qjs7YUE0QkYsWUE1QkVBLFNBNEJJLGtCQTVCUmprQixJQUFFK3pCLEVBMkJnQm5qQzthQUNWLHNCOzs7ZUFFTixZQTlCRXF6QixTQThCSSxrQkE5QlJqa0IsSUFBRSt6QixFQTZCbUJsakM7ZUFDYixzQjthQUVOO3NCQWhDRW96QjtjQWdDVyxrQkFoQ2Zqa0IsSUFBRSt6QixFQStCbUJsaEM7Y0FDYixvQjthQUFBLHNCO2tCQVlOLFVBNUNFb3hCO2tCQThDRixVQTlDRUE7a0JBZ0RGLFVBaERFQTs7V0FrREYsWUFsREVBLFNBa0RJLGtCQWxEUmprQixJQUFFK3pCLEVBaURnQmpoQztXQUNWLHNCOztlQUNnQkMsUUFuRHBCa3hCLFNBbURheHhCLE1BbkRid3hCOzthQW9ERixJQUFhckQ7YUFFVCxvQkF0RE41Z0IsSUFBRSt6QixFQXNESSxXQUFZLE9BRkhuVCxJQURFbnVCLE9BQU9NLFNBR2tCOztXQXBCeEM7b0JBbENFa3hCO1lBa0NXLGtCQWxDZmprQixJQUFFK3pCLEVBaUNJOWdDO1lBQ0Usb0I7V0FBQSxzQjs7V0FFTixZQXBDRWd4QixTQW9DSSxrQkFwQ1Jqa0IsSUFBRSt6QixFQW1DSTVnQztXQUNFLHNCO2tCQTRCTixVQWhFRTh3Qjs7Ozs7Y0FpRXlDN3dCLFFBakV6QzZ3Qjs7O2NBQUp3UTswQkFpRTZDNWtDOzBCQWpFN0NtUSxJQWtFb0IwMEIsS0FBTyxvQkFsRTNCMzBCLEVBa0VvQjIwQixJQUR5QjdrQyxLQUNLLFFBbEVsRG1ROzBCQWlFNkM1TTtjQWpFN0M0TTtjQUFJaWtCOzs7WUFtRXlDMXdCLFFBbkV6QzB3Qjs7O1lBQUoyUTt3QkFtRTZDL2tDO3dCQW5FN0NtUSxJQW9Fb0IwMEIsS0FBTyxvQkFwRTNCMzBCLEVBb0VvQjIwQixJQUR5QjdrQyxLQUNLLFFBcEVsRG1RO3dCQW1FNkN6TTtZQW5FN0N5TTtZQUFJaWtCOztrQkEwQ0Y7O1dBY0EsWUF4REVBLFNBd0RJLGtCQXhEUmprQixJQUFFK3pCLEVBdURtQnRnQztXQUNiLHNCOztXQUVOLFlBMURFd3dCLFNBMERJLGtCQTFEUmprQixJQUFFK3pCLEVBeURtQnJnQztXQUNiLHNCOztXQUVOLFlBNURFdXdCLFNBNERJLGtCQTVEUmprQixJQUFFK3pCLEVBMkRhbmdDO1dBQ1Asc0I7O2VBQ1kyaEMsUUE3RGhCdFIsU0E2RFd0d0IsSUE3RFhzd0I7a0JBbkxOa1I7NkJBaVA0QmhoQyxTQUFPLGtCQTlEakM2TCxJQThEMEI3TCxFQUFVO29CQTlEbEM0L0I7O29CQTZEYXBnQztvQkFBSzRoQzs7ZUF4QkZDLFFBckNkdlIsU0FxQ0lud0IsTUFyQ0ptd0I7OztvQkE4Rk53UiwrQkE5RkV6MUIsSUFBRSt6QixFQXFDZ0J5QixRQUFWMWhDOztvQkF5RFYyaEMsd0JBOUZFejFCLElBQUUrekIsRUFxQ2dCeUIsUUFBVjFoQyxRQWlDSDthQXdCUDJoQyw2QkFFRTExQixFQUFFZzBCLEVBQUVuVDtNQUZOO1FBTUksbUJBQU0sd0JBSlI3Z0IsRUFBRWcwQixFQUFFblQsSUFHUTlzQjtRQUNKLHNCO01BRk47O2VBcEdBd2hDLHlCQWtHRnYxQixFQUFFZzBCLEVBQUVuVDtvQ0FsR0YwVSxrQkFrR0Z2MUIsRUFBRWcwQixFQUFFblQsS0FJc0M7YUF0R3hDeVUsYUFFRnQxQixFQUFFZzBCLEVBQUVuVDtNLHVCQUZGMFUsaUJBRUZ2MUIsRUFBRWcwQixFQUFFblQ7YUE4Rk44VSxtQkFFRTMxQixFQUFFZzBCLEVBQUVuVDtNLHVCQUZONlUsdUJBRUUxMUIsRUFBRWcwQixFQUFFblQ7YUFZRitVLFdBQVc1QixFQUFFaDRCO00sSUFBQUM7TUFBTTtpQkFBTkE7UUFlVzs7UUFmTCxPQUFOQTs7V0FFVDtZQURlaEosV0FETmdKO1lBQ0dvRCxFQURIcEQ7WUFFVCwyQkFEZWhKO1dBRXZCLFdBSGUrZ0MsRUFDSzMwQjtXQUVwQixxQkFIZTIwQixFQUVYLy9COztvQkFGYWdJOzthQUtqQixJQURvQ0M7YUFDcEMsV0FMZTgzQjthQUtDLGNBTERBO2FBS2YsSUFMaUIvM0IsTUFJbUJDOztlQUVBcTRCO1dBQ3BDLFdBUGVQO1dBT0MsY0FQREE7ZUFBRS8zQixNQU1tQnM0Qjs7O2VBTXRCemdDLEVBWkdtSSxTQVlONDVCLElBWk01NUI7V0FZVyxXQVpiKzNCLEVBWUo2QjtXQUFpQixrQkFBZC9oQyxFQVpDa2dDO2lCQWFhLElBQWxCOEIsSUFiTzc1QixTQWFXLFdBYmIrM0IsRUFhTDhCLEtBQWtCLHFCQWJiOUI7O2VBY0srQixJQWRIOTVCLFNBY0ErNUIsSUFkQS81QjtXQWNXLFdBZGIrM0IsRUFjRWdDO1dBQVcsbUJBQVJEOzs7bUJBZEg5NUI7V0FTVyxXQVRiKzNCO1dBU2EscUJBVGJBOztpQkFBRS8zQjtXQVdXLFdBWGIrM0I7V0FXYSwyQkFYYkEsS0FlZTthQUsxQmlDLFdBQVd4Z0MsRUFBRXVHO00sSUFBQUM7TUFBTTtpQkFBTkE7UUFlVzs7UUFmTCxPQUFOQTs7V0FFVDtZQURlaEosV0FETmdKO1lBQ0dvRCxFQURIcEQ7WUFFVCwyQkFEZWhKO1dBRXZCLFdBSGV3QyxFQUNLNEo7V0FFcEIsa0JBSGU1SixFQUVYeEI7O29CQUZhZ0k7O2FBS2pCLElBRG9DQzthQUNwQyxXQUxlekc7YUFLQyxXQUxEQTthQUtmLElBTGlCd0csTUFJbUJDOztlQUVBcTRCO1dBQ3BDLFdBUGU5K0I7V0FPQyxXQVBEQTtlQUFFd0csTUFNbUJzNEI7OztlQU10QnpnQyxFQVpHbUksU0FZTjQ1QixJQVpNNTVCO1dBWVcsV0FaYnhHLEVBWUpvZ0M7V0FBaUIsa0JBQWQvaEMsRUFaQzJCO2lCQWFhLFVBYlh3Rzs7ZUFjRzg1QixJQWRIOTVCLFNBY0E2NUIsSUFkQTc1QjtXQWNXLFdBZGJ4RyxFQWNFcWdDO1dBQVcsbUJBQVJDOzs7bUJBZEg5NUI7V0FTVyxXQVRieEc7V0FTYSxrQkFUYkE7O2lCQUFFd0csc0JBV1csV0FYYnhHLE9BV2EsZ0JBWGJBLEtBZWU7YUFNMUJ5Z0MsV0FBV3pnQyxFQUFFdUc7TSxJQUFBQztNQUFNO2lCQUFOQTtRQWVXOztRQWZMLE9BQU5BOztXQUVUO1lBRGVoSixXQUROZ0o7WUFDR29ELEVBREhwRDtZQUVULDJCQURlaEo7V0FFdkIsV0FIZXdDLEVBQ0s0SjtXQUVwQixrQkFIZTVKLEVBRVh4Qjs7b0JBRmFnSTs7YUFLakIsSUFEb0NDO2FBQ3BDLFdBTGV6RzthQUtDLFdBTERBO2FBS2YsSUFMaUJ3RyxNQUltQkM7O2VBRUFxNEI7V0FDcEMsV0FQZTkrQjtXQU9DLFdBUERBO2VBQUV3RyxNQU1tQnM0Qjs7O2VBTXRCemdDLEVBWkdtSSxTQVlONDVCLElBWk01NUI7V0FZVyxXQVpieEcsRUFZSm9nQztXQUFxRCxrQkFaakRwZ0MsRUFZaUQsV0FBbEQzQjtpQkFDYyxVQWJYbUk7O2VBY0c4NUIsSUFkSDk1QixTQWNBNjVCLElBZEE3NUI7V0FjVyxXQWRieEcsRUFjRXFnQztXQUFXLG1CQUFSQzs7O21CQWRIOTVCO1dBU1csV0FUYnhHO1dBU2Esa0JBVGJBOztpQkFBRXdHLHNCQVdXLFdBWGJ4RyxPQVdhLGdCQVhiQSxLQWVlO2FBTTlCMGdDO01BQ1EsSUFEa0J0VixhQUNsQjtlQUNON2dCLFFBQUtoRTtRQUFNLFdBRFhsRCxJQUNLa0QsS0FBbUMseUJBRHhDbEQsS0FDNkQ7TUFEdkQsbUJBQ05rSCxNQUZ3QjZnQjthQVMxQnVWLG1CQUFtQjVqQztNQUNsQixxQkFEa0JBO01BRW5CLElBQUlnRixJQUFKLHNCQUZtQmhGO01BRW5CLFNBQ0k2akM7UUFBaUIseUNBSEY3akMsSUFHbUQ7TUFEdEUsU0FFUThqQyxhQUFhMW1DO1EsSUFBQW9HO1FBQ25CO2FBRG1CQSxRQUZqQndCLFdBRWlCeEI7VUFFWCwwQkFOU3hELElBSUV3RDtVQUVYLHNDQUZXQTtVQUVYLElBQ1UsSUFIQ0E7bUJBSVQ7TUFOWixTQU9JdWdDLFlBQVkzbUMsRUFBRXVTO1EsSUFBQTZoQjtRQUNoQjthQURnQkEsUUFQZHhzQixXQU9jd3NCO1VBRVIsMEJBWFN4eEIsSUFTRHd4QixLQUVSO3dDQUZRQTtVQUVSLElBQ1UsSUFIRkE7bUJBSU47TUFYWixTQVlJd1MsVUFBVTVtQyxFQUFFdVM7USxJQUFBNmhCO1FBQ2Q7YUFEY0EsUUFaWnhzQixXQVlZd3NCO1VBRU47aUNBaEJTeHhCLElBY0h3eEI7V0FFTjtVSXI1Q04sYUpzNUNzQixRQUhWQTtVQUlMLE9BSktBLElBSUo7TUFDQzs7T0FDRixpQkFEUHlTO09BRVcsZUFyQklqa0MsSUFtQmZpa0MsT0FDQUMsT0FEQUQ7T0FHUyxvQkFGVEM7T0FHTyxlQURQRTtNQUNPLEdBRFBBLFdBQ0FDO1dBQ0FDOzs7U0FFeUQ7a0NBQXZDLE1BMUJIdGtDLElBc0Jmb2tDLE9BQ0FDLE9BREFEO1VBRUFFOzs7O29CQUdrQjtNQVJULElBU1RDLFFBQVUsYUFMVkY7TUFLVSxHQUFWRSxZQTFCQXYvQixJQTJCbUI7TUFBYyx3QkFSakNtL0I7Ozs7OztnQkFTQUssU0FNWTs7Z0JBTlpBOzs7Ozs7Ozs7OztNSW42Q0Esa0JKbTZDQUE7TUFPSixVQWJJRixPQU1BRSxTQU9jO2FBT2xCQyxxQkFHQTNsQyxJQUFJdXZCO01BQU8sVUFBWHZ2QjtPQUNzQixZQURsQnV2Qjs7UUFBTyxTQUFYdnZCLFlBRWdCeTVCLEVBRmhCejVCLE9BRWEyQyxFQUZiM0Msb0JBRWEyQyxFQUFHODJCLEdBRlpsSztRQUdrQixJQUFWemtCLElBSFo5SztRQUdzQixhQUFWOEssS0FIUnlrQixLQUdzRDthQWUxRHFXLHFCQUlBNWxDLElBQUlFLEtBQ3VCcXZCO01BYmYsVUFZUnJ2QjtpQ0FDdUJxdkI7O09BWFIsTUFVZnJ2QixvQkFWVTZOLEdBV2F3aEI7VUFBTmx2QjtnQkFEckJMO09BR3NCLFlBRkRLLE9BQU1rdkI7O2lCQUQzQnZ2QixZQUlnQnk1QixFQUpoQno1QixPQUlhMkMsRUFKYjNDLG9CQUlhMkMsRUFBRzgyQixHQUhLcDVCLE9BQU1rdkI7UUFJTCxJQUFWemtCLElBTFo5SztRQUtzQixhQUFWOEssS0FKU3pLLE9BQU1rdkIsS0FJc0M7YUFPakVzVyxrQkFBbUJDLGdCQUFnQjVrQztNQWlCckMsR0FqQnFCNGtDO09Ba0JKLFNBbEJJQSxtQkFpQmpCRSxrQkFDS0Q7O1dBRExDO01BaUJKLFNBQUlDLHVCQUF1QnBYLFFBQVE0VjtRQUNqQyx5Q0FuQ21DdmpDLElBa0NWMnRCLFFBQVE0VixJQUdoQjtNQUhuQixTQVFJeUIseUJBQXlCQztRQUMzQiw4QkFEMkJBLHFDQUVDO01BVjlCLFNBb0JJQyx1QkFBdUJ2WCxRQUFRdHBCLEVBQUU1QztRQUNuQyx5Q0F2RG1DekIsSUFzRFYydEIsUUFBUXRwQixFQUFFNUMsRUFHbEI7TUF2Qm5CLFNBNEJJMGpDLG1CQUFtQnhYLFFBQVF5WCxTQUFTanJCO1FBQ3RDLHlDQS9EbUNuYSxJQThEZDJ0QixRQUFReVgsU0FBU2pyQixLQUdYO01BL0I3QixTQTZ2QklrckIsWUFHQUMsVUFBVTNYLFFBQVFVO1FBQU8sSUFHekI5aUIsS0FIVW9pQixVQUFWMlg7UUFBeUIsYUFHekIvNUI7b0JBSGtCOGlCO3VCQUdsQjlpQjswQkFEK0IsZ0JBcHlCRXZMLElBa3lCakNzbEMsV0FBa0JqWDswQkFHZSxNQXJ5QkFydUIsSUFreUJqQ3NsQyxVQUdBLzVCLE1BSGtCOGlCLEtBR21EO01BbndCekUsU0FtQ1FrWCxNQUtKRCxVQWtkUUw7USxJQWxkRXRYLFFBQVYyWDtRQUNGO2FBRFkzWCxZQWtkRnNYLGVBamRnQixZQUR4QkssVUFBVTNYO1VBRUosMEJBNUUyQjN0QixJQTBFdkIydEI7VUFFSjtZQVlhLElBR1g2WCxVQWpCRTdYO1lBa0JaLEdBRFU2WCxjQWljQVAsUUFoY2dCLHlCQWdjaEJBO1lBcGNXO2FBS2Ysd0JBN0Y2QmpsQyxJQTJGekJ3bEM7YUFFSjs7Z0JBQ0ssWUFwQkM3WCxRQWlCRjZYLGtCQWljQVA7Z0JBN2JELFlBckJHdFgsUUFpQkY2WCxVQWljQVA7YUE5Y01wTTttQkFpdEJkd00sWUFydEJBQyxVQUFVM1gsUUFJSWtMOztZQUdaLElBMmNGNk0sVUFsZFUvWDtZQW1kWixHQURFK1gsY0FBUVQ7OztjQUdGLElBdUNKNWdDLEVBdkNJLGdCQS9oQjJCckUsSUE0aEJqQzBsQztjQUdNLFNBdUNKcmhDOzs7Ozs7Ozs7OEJBaENBLFlBVkZxaEMsa0JBQVFUOzs7OztxQkFZaUI7b0NBWnpCUyxrQkFBUVQ7c0JBWWlCO3VDQUFYOUw7Ozt5QkE4Qlo5MEI7Ozs7OzhCQXJDQSxZQUxGcWhDLGtCQUFRVDs7Ozs7cUJBT2lCO29DQVB6QlMsa0JBQVFUO3NCQU9pQjt1Q0FBWDNMOzs7Ozt5QkFtQ1pqMUI7Z0JBaEJ1QjsrQkExQnpCcWhDLGtCQUFRVDtpQkEwQmlCO2tDQUFYeEw7Ozt5QkFnQlpwMUI7Ozs7cUJBeEJ1QjtvQ0FsQnpCcWhDLGtCQUFRVDtzQkFrQmlCOzBDQUFYckw7Ozs7cUJBa0JILElBcENYOEwscUJBQVFUO2dDQW9DNEIsZ0JBaGtCSGpsQyxJQTRoQmpDMGxDO3VCQXFDeUI7c0NBckN6QkEsa0JBQVFUO3dCQXFDaUI7eUNBQVhqTDs7Ozs7Ozs7c0JBR1c7cUNBeEN6QjBMLFVBQVFUO3VCQXdDaUI7eUNBQVg3Szs7OztxQkF6Qlc7b0NBZnpCc0wsa0JBQVFUO3NCQWVpQjswQ0FBWHpLOzs7O3FCQWNXO3FDQTdCekJrTCxrQkFBUVQ7c0JBNkJpQjt1Q0FBWHJLOzs7Ozs4QkFSWixpQkFyQkY4SyxrQkFBUVQ7Ozs7OzhCQWdDTixpQkFoQ0ZTLGtCQUFRVDs7OztxQkF1QmlCO3FDQXZCekJTLGtCQUFRVDtzQkF1QmlCO3VDQUFYbEs7Ozs7cUJBV1c7cUNBbEN6QjJLLGtCQUFRVDtzQkFrQ2lCO3VDQUFYL0o7Ozs7OztjSXBoRVo7ZUo2aEV1Qjs4QkEzQ3pCd0ssa0JBQVFUO2dCQTJDaUI7a0NBRHZCNWdDLEdBQ1kyMEI7WUF0ZlosSUFBWUQ7bUJBOHNCZHNNLFlBcnRCQUMsVUFBVTNYLFFBT0lvTDtVQUxSLElBUUosVUFWUXBMO21CQUo4QztNQXBDNUQsU0ErTUlvWTtRQTZvQm1CQyxRQUFRclksUUEzTkpzWCxRQS9hQ2dCLEtBQUszNkIsS0FBSzQ2QixNQUFNOWtDLElBQUl0QyxJQUFJRSxLQUFLbW5DLFFBMG9CUDlFO1FBeG9CaEQ7Ozs7Ozs7aUJBS0lxRixnQkFBaUIsd0JBUEtULElBT21CO1FBTDdDLFNBTUlVLGdCQUFnQix3QkFSV3I3QixJQVFZO1FBTjNDLFNBT0lzN0IsaUJBQWlCLHlCQVRlVixLQVNVO1FBUDlDLFNBUUlXLGVBQWlCLHVCQVZxQnpsQyxHQVVFO1FBUjVDLFNBU0kwbEMsZUFBaUIsdUJBWHlCaG9DLEdBV0Y7UUFUNUMsU0FVSWlvQyxnQkFBaUIsd0JBWjZCL25DLElBWUw7UUFWN0MsU0FXSWdvQyxtQkFBaUIsdUJBYmtDYixPQWFQO1FBWGhELFNBYUljO1VBWUssbUJBQVk7NkRBVWRub0M7O1dBUnFCOztxQkFRckJBOztnQkFOQSxJQURvQmlFLEVBT3BCakU7Z0JBTkEsT0FsUUxnbUM7OEJBaVF5Qi9oQzt5QkFFZixrQkEwbUJTaWpDLFFBQVFyWTtjQXRtQkssT0FDM0I3dUI7O3FCQXhRTGdtQzs7dUJBc1FVLGtCQXVtQlNrQixRQUFRclk7cUJBcm1CdEI3dUIsSUFBOEI7UUFuQ3JDLFNBc0NJcW9DLFdBQVc5RixLQUF3QnZpQztVQUNyQyxVQURxQ0E7V0FFckIsT0FGcUJBOztZQUNyQyxTQURxQ0E7O2dCQU1uQyxJQURvQnF2QixNQUxlcnZCO2dCQU1uQyxPQWpSRmdtQzs4QkFnUnNCM1c7eUJBRWYsa0JBMmxCWTZYLFFBQVFyWSxRQWxtQmQwVDtjQUd3QixPQUhBdmlDOztxQkEzUXJDZ21DOzt1QkFxUk8sa0JBd2xCWWtCLFFBQVFyWSxRQWxtQmQwVDtxQkFBd0J2aUMsSUFVWTtRQWhEbkQsU0FzRElzb0MsV0FBVy9pQyxFQUFxQnZGO1VBQXdCLFVBQXhCQTtXQUNsQjs7WUFEMEMsU0FBeEJBOzs7Z0JBT2hDLElBRG1CcXZCLE1BTmFydkI7Z0JBT2hDLE9BbFNGZ21DOzRCQWlTcUIzVzt5QkFFZCxrQkEwa0JZNlgsUUFBUXJZLFFBbGxCZHRwQjtzQkFFbUIsSUFBVmdqQyxRQUZZdm9DLE9BRUYsVUFBVnVvQzs7Z0JBRXBCLElBRG9CQyxRQUhZeG9DO2dCQUloQyxPQS9SRmdtQzs0QkE4UnNCd0M7eUJBRWYsa0JBNmtCWXRCLFFBQVFyWSxRQWxsQmR0cEI7WUFTTSx5QkF5a0JBMmhDLFFBQVFyWSxRQWxsQmR0cEIsVUFTK0M7UUEvRDlELFNBaUVJa2pDLFlBQVlsakMsR0FBaUIsa0JBQWpCQSxFQUFpQixXQUFZO1FBakU3QyxTQWtFSW1qQyxnQkFBZ0JuakMsR0FBaUIsa0JBQWpCQSxFQUFpQixlQUFnQjtRQWxFckQsVUF3b0JnRGc5Qjs7Ozs7WUE3YXZCOzJCQTZhSTFULFFBM05Kc1g7YUFsTkE7YUE5SXJCd0Msa0JBOElVN047Ozs7WUFnQkU7MENBNlphak0sUUEzTkpzWDthQWpNQSxjQURuQnlDLGdCQWtNbUJ6QzthQWpNQTthQUNELGNBMlpLdFgsUUE3WnZCK1o7YUFFa0I7YUFDTix1QkFESkU7WUFFVDthQUNtQzsyQ0FGbEM1VzswQkFFRTZXLFVBSk16Tjs7NkJBT2EsZ0JBTHJCcEosVUFGUW9KO1lBREUsSUE5SlpxTjs7a0NBRUYsTUF5akIyQjlaLFFBM05Kc1g7O1lBeFVBOzRCQW1pQkl0WCxRQTNOSnNYO2FBeFVBO2FBQ3BCLHlCQURTbEs7YUF4QlYwTTs7OztZQTJEcUI7NEJBZ2dCSTlaLFFBM05Kc1g7YUFyU0E7O1lBRXBCO2FBQ0Qsa0JBRkU2Qyx1QkFFRUMsVUFITS9MOzs2QkFDUjhMLFVBRFE5TDtZQUFXLElBM0RyQnlMOzs7WUFzQ1E7OEJBcWhCb0NwRyxLQXJoQnBCO2FBQ0gsZUFvaEJJMVQsUUEzTkpzWDthQXpUQTtZQUNwQjthQUNpQzs7MEJBQTlCK0MsVUFGTTVMOzthQU1SOzRDQVBBcjhCLE1BQ1FxOEI7Y0FNUjs7eUJBRG1CajhCLE1BQU1vOEI7WUFObkIsSUF0Q1JrTDs7O1lBaVdKLEdBME42QjlaLFlBM05Kc1gsUUFDQyx5QkFEREE7WUFHVjs7K0JBQ0Y1Z0MsR0FDWCx1QkFGRXZELFNBQ1N1RCxFQUNlO2FBRmI7dUJBSUQrSixJQUFFL0o7Z0JBQ2QsTUFEY0EsSUFBRitKO3NCQUNaaFIsRUFEWWdSO2tCQUVWO29DQU5BdE4sU0FNeUIsWUFEM0IxRDtvQkFDRSxTQURGQTt1QkFEY2lILE1BQ2RqSDs7Z0JBSEEsUUFLSTthQVBTO3VCQVVTdXdCO2dCQUN0Qix5Q0FqckJpQzN0QixJQWdyQlgydEIsUUFHMEI7YUFibkM7K0JBdUJZQSxRQUFRc1g7Z0IsSUFBUlM7Z0JBQ3pCO3FCQUR5QkEsY0FBUVQsUUFDUCx5QkFET0E7a0JBRTNCLElBTUo1Z0MsRUFOSSxnQkEvckIyQnJFLElBNnJCUjBsQztrQkFFbkIsVUFNSnJoQztvQkFGQTtrQ0FOdUJxaEM7OzRCQVF2QnJoQyxTQVJ1QnFoQztrQkFFbkIsU0FGbUJBO2tCQVN2Qjs7MkJBR0EwQywyQ0FaK0JuRCxRQVEvQjVnQzs7MkJBSUErakMsb0NBWitCbkQsUUFRL0I1Z0MsSUFDaUQ7YUFoQ3RDOytCQW1DZXNwQixRQW9CU3NYLFFBcEJPNWdDO29CQUFoQnFoQyxrQkFBZ0J0M0I7Z0JBQzVDO3FCQUQ0QnMzQixjQW9CU1QsUUFuQlgseUJBbUJXQTtrQkFsQi9CLElBRnNDNTJCLElBRXRDLGdCQTNzQjJCck8sSUF5c0JMMGxDO2tCQUV0QixTQUZzQ3IzQjs7OztvQ0FJMUMsU0FKMENELEtBSTFDLE9BSjBCczNCOzs7NkJBQWdCcjNCOzs7O3VCQU8xQyxJQWEyQm0zQixVQXBCREU7dUJBcUI1QixHQUQ2QkYsY0FBUVAsUUFDWCx5QkFEV0E7dUJBYm5DLElBNEJBMzJCLElBYkksZ0JBL3RCMkJ0TyxJQTZ0Qkp3bEM7dUJBRXZCLFVBYUpsM0I7eUJBUEEsSUFSMkJrM0IsdUJBQVFQOzBCQVFMLHlCQVJLQTt5QkFTdkIsSUFDUjEyQixJQURRLGdCQXR1Qm1Cdk8sSUE2dEJKd2xDO3lCQVNmLFVBQ1JqM0I7K0NBR0ssb0JBYmtCaTNCO3lCQVd2QixVQS9Cc0NwM0IsSUE4QnRDRzt5QkFEUSxTQVRlaTNCO3lCQVd2Qjs7a0NBM0NKMkMsc0NBZ0NtQ2xEOztrQ0FoQ25Da0QsK0JBZ0NtQ2xEO2lDQWVuQzMyQjt5QkFYQSxTQXhCMENGLEtBeUIxQyxvQkFMMkJvM0I7dUJBZ0IzQixVQXBDMENwM0IsSUFtQzFDRTt1QkE1QkEsU0FhMkJrM0I7dUJBZ0IzQjs7Z0NBaERBMkMsc0NBZ0NtQ2xEOztnQ0FoQ25Da0QsK0JBZ0NtQ2xEOztrQkluckVuQzs2QkorcEUwQzcyQjtxQkFTMUMsU0FUMENDO3FCQVMxQyxTQVQwQnEzQjtxQkFTMUI7OzhCQXJCQXlDLHNDQWdDbUNsRDs7OEJBaENuQ2tELCtCQWdDbUNsRDtrQkFSbkMsVUFaMEM3MkIsSUFZMUIsb0JBWlVzM0I7a0JBZ0IxQixTQWhCMEN0M0I7a0JBRXRDLElBY0osVUFoQjBCczNCLHNDQUFnQnQzQjsyQkFpQlE7YUFwRHZDO3VCQW1DZXVmLFFBb0JTc1gsUUFwQk81Z0M7Z0I7eUJBQTFDK2pDLDhCQUEwQnphLFFBb0JTc1gsUUFwQk81Z0M7WUFuQy9CLEdBd05jc3BCLFlBM05Kc1gsUUE4RUcseUJBOUVIQTtZQUdWLGFBNEVQLGdCQWx2QjJCamxDLElBODNCTjJ0QjtZQTVJckI7YUFDSyxjQTJJZ0JBLGdCQTlJekJtWSxvQkFBU3dDOztpQkFBVHhDLFVBOEl5Qm5ZLFFBOUloQjJhO1lBeERYLEdBd0RFeEMsY0E3RXFCYixRQXFCRyx5QkFyQkhBO1lBR1Y7YUFrQjZDLGtCQXhyQnpCamxDLElBZ3ZCL0I4bEM7YUF4RHdELG1DQXdEeERBLGtCQTdFcUJiLFFBc0JuQjVnQzthQTZEUywyQkFoRlh2RDthQWdGVyxXQU5Gd25DLFFBT2MsYUFEdkJ2YTthQTFRcUIsZUF5UXJCd2EsU0FsRnFCdEQ7YUF2TEE7WUFDcEI7YUFDb0M7NENBSHpCdUQ7MEJBR1JDLFVBRk1qTDs7NkJBS2MsZ0JBTlpnTCxXQUNGaEw7WUEwTEMsSUFuV1hpSzs7O1lBb0lxQjs0QkF1Ykk5WixRQTNOSnNYO2FBNU5BO2FBcElyQndDLGtCQW9JVTdKOzs7O1lBaElaOzt1QkFBZ0IvRTtnQkFDWCwyQkFEV0EsMkJBR2M7YUFPUCxlQTZpQklsTCxRQTNOSnNYO2FBbFZBO2FBQ1g7OztlQUxQO3lDQUlPMEQ7OztlQUtQOztpQkFyVUw3RDttQkF1VXlDLFlBUDdCNkQ7bUJBaFNkO3FCQTYwQjZCaGI7Ozs7c0JBM2lCZixZQUZBZ2I7WUFWWixJQUpFbEI7OztZQTBJcUI7NEJBaWJJOVosUUEzTkpzWDthQXROQTthQUNwQix5QkFEUzJEO2FBMUlWbkI7Ozs7WUE0QlE7OEJBK2hCb0NwRyxLQS9oQnBCO2FBQ0gsZUE4aEJJMVQsUUEzTkpzWDthQW5VQTtZQUNwQjthQUM0Qjs7MEJBQXpCOEQsV0FGTUQ7O2FBTVI7NENBUEFELE1BQ1FDO2NBTVI7O3lCQURtQkcsT0FBTUQ7WUFObkIsSUE1QlJ2Qjs7O1lBdUlxQjs0QkFvYkk5WixRQTNOSnNYO2FBek5BO2FBdklyQndDLGtCQXVJVXlCOzs7O1lBYUU7NENBdWFhdmIsUUEzTkpzWDthQTNNRCxlQXNhS3RYLFFBdmF2QndiO2FBQ2tCO2FBQ0MsZUFGbkJBLGtCQTRNbUJsRTthQTFNQTthQUNQLHlCQUZKbUU7WUFHVDthQUNpQzs0Q0FGaENuWTswQkFFRXFZLFdBSE1EOzs2QkFNVyxpQkFMbkJwWSxZQURRb1k7WUFGRSxJQXBKWjVCOzs7O1lBMEhROzhCQWljb0NwRyxLQWpjcEI7YUFDSCxlQWdjSTFULFFBM05Kc1g7YUFyT0E7WUFDcEI7YUFDMEI7OzBCQUF2QnNFLFVBRk0vTzs7YUFNUjs0Q0FQQWo3QixNQUNRaTdCO2NBTVI7O3lCQURtQjk2QixNQUFNazdCO1lBTm5CLElBMUhSNk07Ozs7WUFpSnFCOzJCQTBhSTlaLFFBM05Kc1g7YUEvTUE7YUFqSnJCd0Msa0JBMmpCNENwRyxLQTFhbENySDs7Ozs7O1lBL0VTLEdBeWZNck0sWUEzTkpzWDs7O2NBOVJrQywyQkFyWXhCamxDLElBODNCTjJ0QixTQTNDUixLQUFQNmI7Y0FBTzs7Ozs7Ozs7Ozs7Ozs7Y0E3Y0ksbUJBd2ZJN2IsUUEzTkpzWCxTQTdSQTtjQWtkQSxVQXNDdUI1RDs7Ozs7OzhCQXZmMUNwZ0M7Ozs7eUJBdWYwQ29nQyxTQXZmMUNwZ0M7O2NBQ0Q7ZUFDRCxrQkFGRUEscUJBRUV3b0MsVUFITTlOOzsrQkFDUjE2QixRQURRMDZCO2NBQVcsSUFuRXJCOEw7Ozs7Ozs7O3dCQWdMRixrQ0FuZmlDem5DLElBODNCZGdtQyxRQUEyQjNFOzs7Ozs7Ozs7WUExZ0I1Qzs7YUFEeUQ7YUFBL0M7K0JBMmdCTzJFLFFBQVFyWSxRQTNnQmtCLHNCQTJnQkMwVDthQXpnQnZCLGVBeWdCSTFULFFBM05Kc1g7YUE5U0E7WUFDcEI7YUFDaUM7MkJBSmhDdGxDLFFBSWdDOzBCQUE5QmdxQyxVQUZNak47O2FBTThCOztjQUF0Qyw4QkFBcUIsb0JBTmJBO2NBTVI7Ozt5QkFSQS84QixRQU9tQlUsTUFBTXVwQyxPQUFPeE07WUFObEMsSUFqREFxSzs7Ozs7Ozs7OztZQWdIQTs7YUFENkM7YUE0Y1pzQzthQUFLQztZQUM1Qzt1QkFEdUNEO3dCQUFLQzswQkFBTTNJOzs7Ozs7aUNBNWMxQ3ZoQzs7Ozs7MkJBNGMwQ3VoQzs7O2lDQTVjMUN2aEM7Ozs7Ozs7OzBCQTRjMEN1aEM7Ozs7OztpQ0E1YzFDdmhDOzs7OzsyQkE0YzBDdWhDOzs7aUNBNWMxQ3ZoQzs7Ozs7OzttQkFvZUosR0FyNEJBZ2xDLHVCQTYyQndDa0Y7dUJBNWNwQ2xxQyxNQXNlQyxrQkExQmNrbUMsUUFBUXJZLFFBQW1CMFQ7O3dCQUFOMkk7MEJBQU0zSTs7Ozs7O2lDQTVjMUN2aEM7Ozs7OzJCQTRjMEN1aEM7OztpQ0E1YzFDdmhDOzs7Ozs7O21CQXdlSixHQXo0QkFnbEMsdUJBNjJCbUNpRjt1QkE1Yy9CanFDLE1BMGVDLGtCQTlCY2ttQyxRQUFRclksUUFBbUIwVDs7aUJBbUI5QyxHQWg0QkF5RCx1QkE2MkJ3Q2tGO3FCQTVjcENscUMsTUFrZUMsa0JBdEJja21DLFFBQVFyWTtjQTFjSixtQkEwY0lBLFFBM05Kc1gsU0EvT0E7Y0FDcEI7Z0JBeEh1Qjs7OztpQ0FHRixrQkE4akJMZSxRQUFRclk7O2lCQS9qQkgsMEJBQVJrQjtnQkFGVTtpQkF5SEs7NkJBQXpCb2IsVUFGTS9POztlQU0wQjs7Z0JBQWxDLDhCQUFxQixnQkFOYkE7Z0JBTVI7OzsyQkFSQXA3QixNQU9tQkQsTUFBTUQsT0FBTzA3QjtjQUxiLElBakhyQm1NOzs7O1FJenhEQTtvQkpvMUU0Q3BHOzs7Ozs7O2dCQTllM0I7c0NBaFpjcmhDLElBODNCTjJ0QjtpQkE5ZXZCO2lCQURtRDtpQkFBckQ7O29CQStlaUJxWSxRQUFRclksZ0JBL2VjO2lCQUVsQixjQTZlSUEsZ0JBM05Kc1g7aUJBbFJBO2dCQUNwQjtpQkFDbUM7NkJBTGxDL2xDLE1BS2tDOzhCQUFoQ2dyQyxRQUZNclI7O2lCQU04Qjs7a0JBQXRDLDZCQUFxQixvQkFOYkE7a0JBTVI7Ozs2QkFUQTM1QixNQVFtQkgsTUFBTUksT0FBTzQ1QjtnQkFOakI7Ozs7Z0JBWWM7c0NBNVpBLzRCLElBODNCTjJ0QjtpQkFsZVQ7aUJBQWQ7aUJBREY7O29CQW1laUJxWSxRQUFRclksZ0JBbmVjO2lCQUVsQixjQWllSUEsZ0JBM05Kc1g7aUJBdFFBO2dCQUNwQjtpQkFDdUM7K0JBTHRDNWxDLFFBS3NDOzhCQUFwQzhxQyxVQUZNblI7O2lCQU04Qjs7a0JBQXRDLDZCQUFxQixvQkFOYkE7a0JBTVI7Ozs2QkFUQTM1QixRQVFtQkosTUFBTUssT0FBTzY1QjtnQkFOSDs2QkF6Ri9Cc087O3FCQTJqQjRDcEc7YUF0ZDNCO21DQXhhY3JoQyxJQTgzQk4ydEI7Y0F0ZHZCO2NBRG1EO2NBQXJEOztpQkF1ZGlCcVksUUFBUXJZLGdCQXZkYztjQUVsQixjQXFkSUEsZ0JBM05Kc1g7Y0ExUEE7YUFDcEI7Y0FDbUM7NEJBTGxDemxDLFFBS2tDOzJCQUFoQzRxQyxVQUZNOVE7O2NBTThCOztlQUF0Qyw2QkFBcUIsb0JBTmJBO2VBTVI7OzswQkFUQTk1QixRQVFtQkosTUFBTUssT0FBT2c2QjthQU5qQixJQXJHakJnTzs7Ozs7O2FBcUxGLGtDQXhmaUN6bkMsSUE4M0JOMnRCLGdCQUFtQjBUO1FBcFlRLE9BemV0RHlEO1VBK2UwQixhQTFReEJzQixhQTBRd0IsWUE1UUZIO1VBOFF4QixHQTlRd0JvRSxPQThReEIsa0JBNFhtQnJFLFFBQVFyWSxRQUFtQjBUO1VBOVhwQixJQUVrQixTQTVRZmdGLGFBNFFlLFlBOVFmLzZCO1VBZ1I3QixHQWhSNkJzSixPQWdSN0Isa0JBMFhtQm94QixRQUFRclksUUFBbUIwVDtVQTlYcEIsSUFJa0IsU0E3UTFDaUYsY0E2UTBDLGFBaFJWSjtVQWtSbEMsR0FsUmtDb0UsUUFrUmxDLGtCQXdYbUJ0RSxRQUFRclksUUFBbUIwVDtVQTlYcEIsSUFNa0IsU0E5UTFDbUYsWUE4UTBDLFVBQ3pCLGlCQW5SeUIxbkM7VUFtUmdCLFFBQzVELGtCQXNYbUJrbkMsUUFBUXJZLFFBQW1CMFQ7VUE5WHBCO1dBUXdCLFNBaFJyQm9GO1dBZ1JxQixVQUMvQixpQkFyUjZCem5DO1VBcVJtQjtZQUNuRSxTQXRSd0NvQyxPQTBvQk1pZ0M7WUFwWDlDLGtCQW9YbUIyRSxRQUFRclk7VUE5WEQsSUE1UUY0YyxPQUFnQm5wQyxJQUFoQjZrQyxLQUFnQjdrQztVQXdSdEIsR0F4Uk1tcEMsT0F3Uk4sa0JBa1hDdkUsUUFBUXJZO1FBbFhrQyxhQXJSaEM0WSxZQXFSZ0MsV0F4UnJCbmxDO1FBOFJ4QyxHQTlSd0NvcEM7VUE4UnhDOztrQkE0VzhDbko7OztnQ0E3MkI5Q3lEO3lCQXFnQkksa0JBd1dla0IsUUFBUXJZLFFBQW1CMFQ7UUF4V0UsT0FuTjlDb0csVUFxTk07TUF0ZlosU0FxTElnRDtRQUdBekUsUUFBUXJZLFFBQVFzWCxRQUFReUYsTUFBTXpFLEtBQUszNkIsS0FBSzQ2QixNQUFNOWtDLElBb0I5Q3RDLElBcEJzRG9PO1FBQ3hELEdBRFV5Z0IsWUFBUXNYLFFBQ1EseUJBRFJBO1FBQ3dDLFNBQ3REMEYsV0FBOEJ4RTtVQUVqQjttQkFKZkg7bUJBQVFyWTttQkFBUXNYO21CQUFjZ0I7bUJBQUszNkI7bUJBQUs0NkI7bUJBQU05a0M7bUJBb0I5Q3RDO21CQXBCc0RvTzttQkFFdEJpNUI7bUJBRWpCLGdCQTlOa0JubUMsSUEwTnpCMnRCLFNBSW9CO1FBSDRCLFVBbUJ4RDd1QjtVQVJjLFVBWndDb08seUNBYy9CO21CQWRDdzlCO3NCQUE4Qng5QiwwQkFpQjFCO1lBRkUsSUFBTG5LLEVBZjZCbUs7WUFleEIsdUJBQUxuSztvQkFmNkJtSywwQkFrQjNCO1VBRkUsSUFBTHJCLElBaEI4QnFCO1VBZ0J6Qix1QkFBTHJCO1FBSWpCLGtCQUFQL00sSUFBcUI7TUE1TXpCLFNBb0lJOHJDO1FBaUJBNUUsUUFkUXJZLFFBY1FzWCxRQUFReUYsTUFBTXpFLEtBQUszNkIsS0FBSzQ2QixNQUFNOWtDLElBQUl0QztRQWJwRCxHQURVNnVCLFlBY1FzWCxRQWJRLHlCQWFSQTtRQVpaLElBSUo1RCxLQUpJLGdCQTNLNkJyaEMsSUF5S3pCMnRCO1FBRUosVUFJSjBUO1VBRkEsSUFVUXFFLFVBZEEvWDtVQWVWLEdBRFUrWCxjQUFRVCxRQUNRLHlCQURSQTtVQVZoQjtXQVd3RDtxQkFDeEN5RixNQUFNL2M7Y0FDRjtvQ0FERUEsUUFGTnNYO2VBR0k7Ozt1QkFIcEJlO3VCQUdJK0U7dUJBSFk5Rjt1QkFFQXlGO3VCQUZjekU7dUJBQUszNkI7dUJBQUs0NkI7dUJBQU05a0M7dUJBQUl0QzswQkFHckNFLE1BRWE7V0FDdEIsdUJBN0w2QmdCLElBdUx6QjBsQztVQU1KLFNBRUo4RDt1Q0FEYyxjQVBVa0IsTUFBaEJoRjs7b0JBUVI4RDs7OztnQkFXQTt5QkFuQkF4RDt5QkFBUU47eUJBQVFUO3lCQUFReUY7eUJBQU16RTt5QkFBSzM2Qjt5QkFBSzQ2Qjt5QkFBTTlrQzt5QkFBSXRDOzs7O2dCQVF6QixHQTlLekJnbUM7a0JBdUxBO3dCQWpCUVk7bUJBaUJSLFFBakJ3QmdGLGlCQVF4QmxCO2tCQWNBLHFCQXRCd0J3Qjs7O1VBc0J4QixPQTVMQWxHO21CQWdNRTtxQkExQkZrQjtxQkFBUU47cUJBQVFUO3FCQUFReUY7cUJBQU16RTtxQkFBSzM2QjtxQkFBSzQ2QjtxQkFBTTlrQztxQkFBSXRDOzttQkE2QmhELHVCQTdCTTRtQztRQVBSO2lCQU9BTTtpQkFkUXJZO2lCQWNRc1g7aUJBQWNnQjtpQkFBSzM2QjtpQkFBSzQ2QjtpQkFBTTlrQztpQkFBSXRDOzs7aUJBUmxEdWlDLEtBRXVCO01BL0kzQixTQStESW9FLFlBaUNBTyxRQW5CaUJyWSxRQW1CRHNYLFFBQW1DN2pDO1FBOUJyRDtpQkFHSTZwQyxTQUFTdGQsUUFBUWtYO1VBRW5CLFNBRm1CQSxRQUVuQixjQXhGQUM7VUF5RkU7WUFFYyx5QkE1R2lCOWtDLElBdUd0QjJ0QjtZQUdULGtDQTFHK0IzdEIsSUF1R3RCMnRCO1VBS2tCO2tCQUNoQjtZQUVJK1g7UUFDakI7YUFEaUJBLGNBbUJEVCxRQWxCVSx5QkFrQlZBO1VBakJKLDBCQWpIcUJqbEMsSUErR2hCMGxDLFdBRUw7Ozs7Y0FLSCxTQVBRQSxVQVZNUTtjQWlCZCxjQVBRUjs7O2NBTVIsU0FOUUEsVUFUZnA2QjtjQWVPLGNBTlFvNkI7OztjQUtSLFNBTFFBLFVBVmZPO2NBZU8sY0FMUVA7OztjQUlSLFNBSlFBLFVBWE1nRjtjQWVkLGNBSlFoRjs7O2NBR1IsU0FIUUEsVUFYZmp1QjtjQWNPLGNBSFFpdUI7OztVQUVMO1dBT1YsS0FuQnFCUTtXQW1CckIsS0FsQkE1NkI7V0FrQkEsS0FuQkEyNkI7V0FtQkEsS0FwQnFCeUU7V0FvQnJCLEtBcEJBanpCO1VBK0JKLEdBcEJtQml1QixjQW1CRFQsUUFDUSx5QkFEUkE7VUFqQko7V0FrQjRDOzs7OztnQkFsSHhESDs7a0JBeUhPLGtCQVJQa0IsUUFuQmlCTjtXQTRCYix3QkEzSTZCMWxDLElBK0doQjBsQztVQTRCYjs7Y0FFaUI7c0NBOUJKQSxVQW1CRFQ7ZUFXSzs7O3VCQVhyQmU7dUJBV0krRTt1QkFYWTlGOzs7Ozt1QkFBbUM3akM7MEJBRWpEMnVCLE1BU1c1Qjs7O21CQUliO3FCQWZBNlg7cUJBbkJpQk47cUJBbUJEVDs7Ozs7cUJBQW1DN2pDO3dCQUVqRDJ1QjtVQWdCRixPQWhCRUE7O2FBa0JBLE9BcklGK1U7Y0FzSUksdUJBeENhWTthQXdDcUM7c0JBckJ0RE0sUUFuQmlCTixVQW1CRFQsNEJBQW1DN2pDOzthQStCakQ7c0JBL0JGNGtDLFFBbkJpQk4sVUFtQkRULDRCQUFtQzdqQzs7YUE0QmpEO3NCQTVCRjRrQyxRQW5CaUJOLFVBbUJEVCw0QkFBbUM3akMsV0FObkM7TUExRnBCLFNBaWpCSXVrQyxVQUNBMEYsWUFBWTFkLFFBQVFzWDtRQUN0QjthQURjdFgsWUFBUXNYO1VBR2QsNEJBdmxCMkJqbEMsSUFvbEJyQjJ0QjtVQUdOO1lBRU0sSUFBTjJkLElBQU0sYUF6bEJxQnRyQyxJQW9sQnJCMnRCO1lBS0EsR0FMUXNYLFdBS2RxRztZQUFNO2FBRUksY0EzbEJpQnRyQyxJQW9sQnJCMnRCLFNBS04yZCxNQUxNM2Q7YUFRYSxjQUhuQjJkLFlBTGNyRzthQVFLO2FBQ0QsY0FUWnRYLFFBS04yZDthQUlrQjs2QkFBVjFELFFBRlIyRDtZQUVrQixHQVR4QkY7aUJBV01JLGdCQURBRDs7Y0FuQkMsVUFrQk81RDs7O2VBbEJQLFVBa0JPQTs7a0JBakJ5QixJQUF2QmxYLE1BaUJGa1g7a0JBakJ5QjtvQkFDNUIsbUJBREtsWDs7Ozs7Ozs7OztrQkFtQlYrYSxnQkFEQUQ7WUFMTSxnQkFNTkMsYUFIUTFTOztVQVFaOzs7O1lBRXFCO3lCQWxCWHBMLFFBQVFzWDthQWtCRzt3QkFsQnZCb0csZUFtQklodkM7WUFHSixjQUZJcXZDLFdBRlE3UztxQkFJbUM7TUF4a0JuRCxTQTJrQkkrTSxpQkFDQWpZLFFBQVFzWDtRQUNWOztnQkFERXRYLFlBQVFzWDtnQ0FHa0IsZ0JBam5CT2psQyxJQThtQmpDMnRCO1VBR29EO1VBQ2xDO2tDQUpsQkEsZ0JBQVFzWDtXQUtBLHdCQW5uQnlCamxDLElBa25CM0IyckM7V0FDRTtVSXprRU47VUp3a0VnQjtXQUdTLHNCQUhyQkEsVUFKRTFHO1dBT21COztXQUNMLHVCQURkNEcsVUFQQTVHO1dBU0ksd0JBdm5CcUJqbEMsSUFzbkJ2QjhyQztXQUNFOzs7WUFFTTtxQkF6bkJlOXJDLElBOG1CakMydEIsaUJBUVVtZSxZQVJWbmU7YUFXa0IsUUFBSmxzQixFQUpLMHNCO2FBSUQsS0FIUjJkO2FBUFJ2RDthQUFVd0Q7Ozs7Ozs7Y0Fhc0I7cUNBTnhCRCxVQVJGN0c7ZUFjMEI7O2VBQ1IsdUJBRForRyxVQWROL0c7Y0FnQkssMEJBOW5Cb0JqbEMsSUE2bkJuQmlzQztjQURvQjtlQUdoQjtzQkEvbkJlanNDLElBOG1CakMydEIsaUJBZWNzZSxZQWZkdGU7ZUFpQmtCLFFBQUovakIsSUFWS3VrQixNQU9NM0M7ZUFHUCxLQUZKeWdCO2VBZFoxRDtlQUFVd0Q7Ozs7Ozs7O2NBQVZ4RCxTQURGNWEsUUFDWW9lO1FBd0JTLGdCQXhCbkJ4RCxTQURNdEQsU0F5QmE7c0JBeEJUOEcsaUJBd0JGbFQsVUFDdUM7TUF0bUJyRCxTQXltQklnTixpQkFDQWxZLFFBQVFzWDtRQUNWO1VBRW9CO2tDQUhsQnRYLFFBQVFzWDtXQUlBLHdCQWhwQnlCamxDLElBK29CM0IyckM7V0FDRTtVSXRtRU47WUp3bUV3QjttQ0FIcEJBLFVBSEUxRzthQU1rQjs7YUFDTix1QkFEWjRHLFVBTkE1RztZQVFELDBCQXBwQjBCamxDLElBbXBCekI4ckM7WUFEa0I7YUFHZCxRQXJwQnFCOXJDLElBNG9CakMydEIsaUJBT1FtZSxZQVBSbmU7d0JBT1FtZSxxQkFFQXJxQyxFQUhXOEo7OztVQUhEOzs7Ozs7VUFhSzs7V0FEUGpQO1dBQVZpc0M7V0FDaUIsY0FEakJBLFNBZkV0RDtXQWdCZTt3QkFEUDNvQyxlQUNKdThCO1FBR1csa0JBbkJ2QmxMLFFBQVFzWCxTQW1CZTsyQkFBWGxNLFlBQ3VDO01BOW5CdkQsU0F3dEJJK0ssYUFBYW5XLFFBQVFzWDtRLElBQVJTO1FBQ2Y7YUFEZUEsY0FBUVQsUUFDRyx5QkFESEE7VUFFcEIsMEJBNXZCZ0NqbEMsSUEwdkJwQjBsQztZQUVhLGNBRmJBO1VBRXFELE9BRnJEQSxVQUU0RDtNQTF0QjdFLFNBOHRCSW9GLGVBQWVuZCxRQUFRc1gsUUFBUXo3QjtZQUFoQms4QixrQkFBZ0JqOEI7UUFDakM7YUFEaUJpOEIsY0FBUVQsUUFDQyx5QkFEREE7VUFFbkIsc0JBbHdCNkJqbEMsSUFnd0JsQjBsQyxXQUVYLFNBQ0pyaEM7VUFESSxnQ0FGV3FoQyxVQUFnQmo4QjtVQUUzQixJQUYyQkMsMEJBRy9CckY7VUFDQSx1QkFKK0JxRjtrQkFNN0I7MkNBdHdCK0IxSixJQWd3QkYwSjtVQUUzQixJQVFGLFVBVmFnOEIsc0NBQWdCajhCO21CQVdkO01BenVCckIsU0E2dUJJbWlDLGNBQWNqZSxRQUFRc1g7UUFDeEIsR0FEZ0J0WCxZQUFRc1gsUUFDRSx5QkFERkE7UUFFbEIsMEJBanhCNkJqbEMsSUErd0JuQjJ0QjtRQUVWO29DQUNVLGVBSEFBLFFBQVFzWDs7O1dBSWYsSUFKT3RYLHFCQUFRc1gsUUFLUSx5QkFMUkE7V0FNaEIsc0JBcnhCMkJqbEMsSUErd0JuQjJ0QixpQkFNUixTQUlKdHBCO1dBSkk7bUJBS0osbUJBWFlzcEIsMEJBVVp0cEI7V0FKSTtZQUVjLHVCQVJOc3BCLGdCQUFRc1g7WUFRRjs7cUJBQWRzRCxXQUFVeGxDO1FBS1gsNkJBQVk7TUExdkJyQixTQXV3Qkk0a0MscUJBQXFCaGEsUUFBUXNYLFFBQVE1Z0M7USxJQUFoQnFoQztRQUN2QjthQUR1QkEsY0FBUVQ7V0FFN0Isa0NBM3lCaUNqbEMsSUF5eUJJcUUsRUFBUjRnQztVQUt6QiwwQkE5eUI2QmpsQyxJQXl5QlowbEM7VUFLakI7WUFFSixJQVBxQkEsdUJBQVFUO2FBT0MseUJBUERBO1lBUTFCLG1CQWp6QjhCamxDLElBeXlCWjBsQyx1QkFBZ0JyaEMsU0FBaEJxaEM7WUFTUCw0QkFsekJtQjFsQyxJQXl5QlowbEM7WUFTUDs7Ozs7O3FCQWVJO21EQXhCR0Esa0JBQVFUO3NCQXdCWCxVQUFWeUM7c0JBeEJhaEM7Ozs7cUJBZ0NqQjs4QkFoQ2lCQTs7O2lCQVlqQixJQVppQkEsdUJBQVFUO2tCQVlLLHlCQVpMQTtpQkFhYiw0QkF0ekJpQmpsQyxJQXl5QlowbEM7aUJBYUw7bUJBS0k7bURBbEJDQSxrQkFBUVQ7b0JBa0JULFVBQVZrRTtvQkFsQld6RDs7O21CQWVEOzswQ0FmQ0Esa0JBQVFUO29CQWVULFVBQVZpSDtvQkFmV3hHOztpQkFhTCxJQU9MLFVBcEJVQTs7OztnQkE0Qkg7Z0RBNUJHQSxrQkFBUVQ7aUJBNEJYLFVBQVZrSDtpQkE1QmF6Rzs7O3NCQW1DakIsbUJBbkNpQkE7WUFTUCxJQTRCVixVQXJDaUJBOztVQUtqQixJQWtDQyxVQXZDZ0JBO21CQXVDNEI7TUE5eUJyRCxTQTgzQkl3QixrQkFDRWxCLFFBQVFyWSxRQUFRMFQsS0FBS2lMO1FBQ1YsSUFBVEMsT0FBUyxNQWw2Qm9CdnNDLElBaTZCL0JnbUMsUUFBUXJZLFVBQVJxWTtRQUNXO3dDQWw2Qm9CaG1DLElBaTZCL0JnbUMsUUFBcUJzRyxPQUFMakwsS0FDZGtMLE9BSTRCO01BcDRCcEMsU0EyekJJN0MsaUJBQWlCMUQsUUFBUXJZLFFBQVFzWSxLQUFLMzZCLEtBQUs0NkIsTUFBTTdFO1lBQWhCZ0osWUFBS3oxQixZQUFLMDFCO1FBQzdDO21CQURtQ0Q7b0JBQUt6MUI7cUJBQUswMUI7MkJBQU1qSjs7Ozs7d0JBS2dCO3lCQUhyQzt5QkFBcUM7eUJBS3JDO3lCQUVBO3lCQUpBOzs7eUJBTHFCQTs7OztxQkFBTmlKO3dCQUFNako7Ozs7Ozs7b0JBQVh6c0I7cUJBQUswMUI7eUJBQU1qSjs7Ozs7OztVSW56RS9DOzJCSm16RStDQTs7O3NCQVc1QixHQXYxQnJCeUQ7dUJBdzFCcUIsR0F4MUJyQkE7dUJBczFCcUIsR0F0MUJyQkE7Ozs7Z0JBMDFCQSxHQTExQkFBLHVCQTQwQnNDbHdCO2dCQWdCakMseUJBaEJZb3hCLFFBQVFyWSxRQUF3QjBUOzttQkFBaEJnSjtxQkFBVUM7WUF1QjNDLEdBbjJCQXhGLHVCQTQwQjJDd0Y7WUF5QnRDLHlCQXpCWXRFLFFBQVFyWSxRQUF3QjBUO21CQUFOaUo7WUEyQjNDLEdBdjJCQXhGLHVCQTQwQmlDdUY7WUE2QjVCLHlCQTdCWXJFLFFBQVFyWSxRQUF3QjBUO1VBa0JqRCxHQTkxQkF5RCx1QkE0MEIyQ3dGO1VBcUJ0Qyx5QkFyQll0RSxRQUFRclksbUJBOEJTO01BejFCdEMscUNBbENxQzN0QixLQXc2QlA7YUFPNUJ3c0MsdUJBQXVCeHNDLElBQUlFO01BQ1gsOEJBRE9GLEtBQ1A7O1FBQ04sd0JBREFxdUIsSUFEaUJudUIsT0FBSkY7Ozs7VUFNakIseUJBTnFCRTtVQU1yQix5Q0FOaUJGO21CQU1NO2FBSTdCeXNDLHdCQUF3QnpzQztNQUNSO09BRDJCMHdCO09BQU5yQztPQUNyQiwwQkFEUXJ1QjtPQUNSOztRQUNOLHdCQURBMHhCLE1BQ2dCLGFBRldyRCxNQUFicnVCOzs7O2dCQUl4QixrQ0FKd0JBLElBQW1CMHdCOzs7OztPQTEyRjNDMUM7T0FUQUY7T0FiQUw7T0FHQUM7T0FNQUc7T0F3Q0FPO09BaTRDSXFUO09BK1FBcUI7T0E4R0FNO09Bb0JBSztPQXFCQUM7T0EzNEJBakw7T0EwL0JKa007T0ErNkJBNkg7T0FVQUM7T0E3bkZBN2M7T0E4S0FhO09BY0FFO09BbytCQTJRO09BNXpCQW5RO09BK3dDQXlTO09BandDSWpTO09BdUlKMEM7T0E4ZkFxTTs7YTJCL3ZDQWdNLFNBQVNsL0IsRUFBRWcwQjtVQUFXblQ7YTNCdTdDbEJvVDt3QjJCdDdDV0QsRUFBRWg0QixLQUFPLFdBQVRnNEIsRUFBRWg0QixLQUFPLGtCQURmZ0UsRUFDTWcwQixFQUE4QjtlQURsQ0E7O2VBQVduVDthQUV0QnNlLFNBQVNuL0IsRUFBRXZLO1VBQVdvckI7YTNCcTdDbEJvVDt3QjJCcDdDV3grQixFQUFFdUcsS0FBTyxXQUFUdkcsRUFBRXVHLEtBQU8sa0JBRGZnRSxFQUNNdkssRUFBOEI7ZUFEbENBOztlQUFXb3JCO2FBRXRCdWUsVUFBVXAvQixFQUFFNUk7TSxJQUFZeXBCLG9CM0Jrc0RwQnlVLGEyQmxzRE10MUIsRUFBRTVJLEdBQVl5cEI7YUFHeEJ3ZSxRQUFRam9DLEdBQUd5cEIsS0FBTSwrQixVQUFUenBCLEdBQUd5cEIsSUFBNEI7YUFDdkN5ZSxRQUFRN3BDLEVBQUVvckIsS0FBTSwrQixVQUFScHJCLEVBQUVvckIsSUFBMkI7YUFDckMwZSxTQUFTbm9DLEdBQUd5cEI7TUFBTSxnQyxVQUFUenBCLEdBQUd5cEIsSUFBNkI7YUFDekMyZSxPQUFPM2UsS0FBTSxldEIrUWJ0cUIsT3NCL1FPc3FCLElBQXdCO2FBQy9CNGUsUUFBUTVlLEtBQU0sZXRCK1FkcnFCLE9zQi9RUXFxQixJQUF3QjthQUVoQzZlLFNBQVMxL0I7TSxJQUFXNmdCO2VBQ2xCNWdCLFVBQU1qRTtRQUNFLElBQU5sRCxJQUFNO1FBQ1YsV0FESUEsSUFESWtEO1FBR04sa0JBSk9nRSxFQUlQLFNBRkVsSCxLQUVtQjthM0JzNkNuQm03QixZMkJ6NkNGaDBCLFFBRGtCNGdCO2FBT3BCOGUsUUFBUTllLEtBQU0seUJBQWM1c0IsR0FBSyxPQUFMQSxDQUFNLEVBQTFCNHNCLElBQStCOzs7O09BYnZDd2U7T0FHQUc7T0FDQUM7T0FTQUU7T0FaQUw7T0FDQUM7T0FUQUw7T0FJQUU7T0FTQU07T0FYQVA7T0FXQU87Ozs7OzthQzRCSUUsT0FBT3hyQyxFQUFFMkI7TSxJQUFBcUk7TUFDZjtXQURlQTtvQ0FHUnloQyxZQUFKQztVQUFxQixjQUFyQkEsR0FIVTFyQyxVQUdOeXJDO2NBSFF6aEM7O1FBRVAsZ0JBRWM7YUFHcEIyaEMsUUFBTTlyQztNQUNBO2lCQURBQTtPQUNBLDBCQURBQTtPQUdVLFdBSFZBLEVBQ0pyRSxVQUNBNEgsT0FEQTVIO01BRUosZ0JBSFFxRSxJQUNKckUsUUFFNEM7YUFHOUNvd0MsYUFBYUMsT0FBT2wrQixJQUFJbStCLE9BQU9ucUM7TUFDakMsR0FEaUNBO1FBR2tCLElBQTlDaVUsRUFINEJqVSxLQUcvQnlhLEVBSCtCemEsS0FHa0IsU0FIcENrcUMsT0FHYnp2QjtRQUFRO3NDQUFxQnBjLEVBQUVDLEdBQVMsV0FBWEQsRUFBVyxJQUhwQjJOLElBR1cxTixHQUFnQixPQUE1QzJWO2lCQUhxQmsyQjtNQUVsQixlQUNtRTthQVl6RUMsbUJBQWlCLG1CQUE4QjthQUUvQ0MsU0FBU0M7TUFDWDtRQUNhLGtCQUZGQSxVQUVFOzs7Ozs7NEJBSlhGOztRQVFXLGtCQU5GRSxVQU1FLFdBRFRDOzs7Ozs7OzRCQVBGSDs7TUFZUyxjQVZBRSxTQVVBLFlBTFBDLE1BS29CO2FBR3RCQyxRQUFRem5DLElBQUl1bkMsU0FBU0c7TUFDdkIsbUJBRFUxbkMsVUFBYTBuQztNQUVJLGtCQUZiSDtNQUVKOzs7a0JBMUJtQkk7a0JBQU5DO2tCQUFMQztpREFBV0Y7O21CQUUzQixVQUZxQkM7cUJBSWpCLE1BSmlCQSxRQUlhLHVDQUR4QjNxQztxQkFDd0IsMEJBb0IxQitDLFVBeEJRNm5DLFNBQVdGO21CQU12QiwwQkFrQkkzbkMsVUF4QlE2bkMsSUFBV0Y7O29CQTBCaUI7YUFHNUNHLGFBQWFQLFNBQVNHO01BQ2hCLElBQUovcUMsRUFBSSxjQUNSLFFBRElBLEVBRFc0cUMsU0FBU0csUUFFeEIsZ0JBREkvcUMsRUFFYTthQUdmb3JDLE1BQU1SLFNBQVNHO01BQ0osc0JBRExILFNBQVNHO01BQ0oscUNBQThCO1FBR3pDM2hCO2FBRUFpaUIscUJBQW1CMXNDO01BQ3JCO1FBQVMsMkJBRFlBOzs7O21CQUVVO2FBRTdCMnNDLG9CQUFrQjNzQztNQUNwQjtRQUFTLCtCQURXQTs7OztRQUhwQixXQUtzQjthQUVwQjRzQyxzQkFBb0I1c0M7TUFDdEI7UUFBUyxpQ0FEYUE7Ozs7UUFIdEIsV0FLc0I7YUFFcEI2c0M7TUFBa0NDLGFBQWFyaUIsUUFBUXNpQixLQUFLZCxTQUFTZSxRQUFRWjtNQUMvRSxJQUFJYSxRQUQ2Q3hpQjtNQUNqRCxTQUNJeWlCLGNBQWNDO1FBS1I7OztVQU5ORixVQURxREY7WUFRRCxpQkFSQ0EsUUFDckRFOztRQVFGLE9BUGdCRTs7Ozs7YUFXVixtQkFORjlyQyxRQUNBK3JDOzs7ZUFRaUI1SixTQWRMMkosU0FjQXB5QixJQWRBb3lCLFNBY0xFLElBZEtGO1dBZVYsbUJBVkY5ckMsUUFDQStyQyxTQVFZcnlCLElBQUxzeUIsSUFBVTdKOztpQkFEZixJQURNM2pDLEVBWklzdEMsU0FhVixtQkFSRjlyQyxRQUNBK3JDLFNBTVF2dEM7a0JBTU4sSUFETW1JLElBakJJbWxDLFNBa0JWLG1CQWJGOXJDLFFBQ0ErckMsU0FXUXBsQztRQUdaLFFBZkkzRyxFQVB3RDRxQyxZQUFpQkc7UUF1QjFFLGdCQXJCYWU7Y0FxQmMsV0FyQmRBLDBCQXVCUCxTQWxCTDlyQztRQWlCTSx3QkFqQk5BLEdBa0J3QjtNQXhCOUI7O1dBRGlEb3BCLGFBQVFzaUI7VUE2QnZEO3FCQTdCK0N0aUIsV0E4QnpDNXFCLG1CQTlCaURrdEM7MENBOEJqRGx0Qzt1QkFDdUIsZ0JBRHZCQTtlQUN3QztpQkFFcEM7OzhCQUhKQSxFQTlCc0Rvc0M7a0JBZ0NwRHFCO2tCQUFRQzs7OztpQkFHVjttQkFDcUI7a0NBTnJCMXRDO29CQU1xQjs7OEJBQU5rYjtvQkFDYixZQURJeXlCLFFBcENnRHZCOzs7MERBOEJ0RHBzQzs7cUJBRUV5dEMsWUFBUUM7ZUFRWjs7MEJBVkUxdEMsRUFFVTZ0Qzs0QkFRUkM7cUJBQ0YsR0FUVUQ7MkJBV0gzeUIsSUFYRzJ5QiwyQkFGVjd0QyxFQWFPa2I7cUJBREcsUUFDZ0Q7MEJBSHhENHlCO2dCQUFKLGdCQVZFOXRDLEVBRVUwdEM7Z0JBUVo7MEJBVkUxdEMsRUFFVTZ0Qzs0QkFZUkc7cUJBQ0YsR0FiVUgsWUFpQkgzeUIsSUFqQkcyeUIsaUJBaUJIM3lCO3FCQUZILElBL0NxQzBQLHNCQUFRc2lCO3VCQStDRCxTQS9DUHRpQjt1QkErQ08sd0JBL0NDc2lCO3FCQWdEeEMsaUJBbEJUbHRDLEdBbUJpQjswQkFMZmd1QztnQkFKSixrQkFWRWh1QyxFQUVVMHRDO2dCQVFaOzBCQVJZRzs0QkFtQlJLO3FCQUNGLE9BcEJVTCxVQWhDK0JqakIsZUFzRDNCOzBCQUhac2pCO2dCQVhKLDBCQVJZUjtnQkFRWjswQkFWRTF0QyxFQVVFOHRDLE9BSUFFLFFBT0FFOzRCQUtJRTtxQkFBZTs4QkFDWCxJQUFMdnVDLFdBQUssa0JBQUxBOzt3QkFFSDs7eUJBQVU7eUJBQ0UsMkJBRFJxYjt3QkFDUTswQkFFQSxJQUFML1MsYUFBSyxXQUpUa21DLElBSUlsbUMsS0FFUDt3QkFIVSxpQkEvQlpuSSxFQTZCTWtiOzhCQU1HLElBQUw1VyxXQUFLOzhCQUNFLElBQUwrWixhQUFLOzt3QkFFVCxpQkFBVTt3QkFDVixXQUZLaXdCLElBQ0RuekI7d0JBQ0o7O3dCQVlBLElBRFNvekIsYUFDSjs7d0JBR0w7O3lCQUFVO3lCQUNFLDRCQURSbHpCO3dCQUNROzBCQUVBLElBQUxsYixhQUFLLFdBSlZxdUMsSUFJS3J1QyxHQUVQO3dCQUhVLGlCQXhEWkgsRUFzRE1xYjs7d0JBT0o7O3lCQUFVO3lCQUNFLDRCQURScXpCO3dCQUNROzBCQUVBLElBQUxDLGVBQUssU0FBTEEsSUFFUDt3QkFIVSxpQkEvRFozdUMsRUE2RE0wdUM7O3dCQU9KOzt5QkFBVTt5QkFDRSw4QkFEUkc7d0JBQ1E7MEJBRUEsSUFBTEM7MEJBQUssV0FKUkYsSUFJR0U7MEJBRVA7d0JBSFUsaUJBdEVaOXVDLEVBb0VNNnVDOzt3QkFPSjs7eUJBQVU7eUJBQ0UsOEJBRFJHO3dCQUNROzBCQUVBLElBQUxDLGVBQUssU0FBTEEsSUFFUDt3QkFIVSxpQkE3RVpqdkMsRUEyRU1ndkM7O3dCQU9KLElBRElFLGVBQ0osY0F4RElkLGFBdURBYzs7d0JBdkNNLElBREVDLGFBQU52UCxjQUNJO3dCQUNQLE9BREN3UCxNQURFeFA7MEJBR0osV0FIVXVQLElBQ1JDLE9BRUY7d0JBRzRCOzs7Z0NBL0NoQ3B2QztnQ0EwQ01vdkM7Z0NBSzBCLGVBQ0Usa0NBUDFCeFA7O3dCQTJDTixJQURHeVA7d0JBR2E7NkJBcEh1QnprQixjQUFRc2lCOzRCQW1IN0MsU0FuSHFDdGlCOzRCQW1IckMsV0FGQ3lrQixJQUVDLGlCQW5IMkNuQzs0QkFvSDdDOzs7OzRCQUVHb0M7K0JBdEhxQnJDOzs7O3dCQXlIaEIscUJBQ0csa0JBSlJxQyxJQUdEQzt3QkFFSjt3QkFGVTt5QkFHRyxhQTVIa0NyQyxVQUFSdGlCO3lCQTZIM0I7OzRCQTdIbUNzaUI7NEJBQVJ0aUI7NkJBQVFzaUIscUJBQVJ0aUI7d0JBOEhoQzs7NkNBRkg2a0IsVUFGQUQsVUFHQUU7d0JBQ0csU0FBbUM7MEJBdEV0Q3RCO2dCQWhCUiw0QkFWRXB1QyxFQVVFOHRDLE9BSUFFLFFBT0FFO2VBNkVKLGFBaEdJVDtlQVFKOzs7OztZeEI2VkEsY3dCcFFHLFdBakk4RE4sUUE4Qi9EbnRDOzs7K0JBb0dVLElBQUxnaUIsU0FBVyx1QkFBWEE7Z0NBQ00sSUFBTC9OLFNBQVcsb0JBQVhBOztVQUVaOztRQXhJRixTQXlJSTthQUVGMDdCO01BQThCL2tCLFFBQVFzaUIsS0FBS2QsU0FBU2UsUUFBUVo7TUFDOUQ7aUJBRGdDM2hCLFFBQVFzaUIsS0FBS2QsU0FBU2UsUUFBUVosT0FDYTthQUV6RXFELG1CQUFxQnBDLElBQWlCTixLQUFLZCxTQUFTZSxRQUFRWjtNQUM5RCxHQUR1QmlCLElBQVEsUUFBUkEsaUJBQVFxQyxhQUFSQyxVQXpKckJsbEI7TUEwSkY7aUJBRHVCa2xCLGFBQWlCNUMsTUFBS2QsU0FBU2UsUUFBUVosT0FDb0I7YUFHaEZ3RCxXQUFhdkMsSUFBaUJOLEtBQUtkLFNBQVNlLFFBQVFaO01BQ3RELEdBRGVpQixJQUFRLFFBQVJBLGlCQUFRcUMsYUFBUkMsVUE3SmJsbEI7TUE4SkY7a0JBRGVrbEIsV0FBaUI1QyxRQUFLZCxVQUFTZSxRQUFRWixPQUNnQjthQUdwRXpJLE1BQU1oaUMsRUFBRWpDLEVBQUVpaUM7TUFDWjtRQUNFLDBCQUZNaGdDLEVBQUVqQyxFQUFFaWlDOzs7O1VBSUMsSUFBUGtPLGFBQU8seUJBQVBBLE9BQU87O1VBQ0MsSUFBUEMsYUFBTyx3QkFBUEEsT0FBTztrQkFBdUI7YUFHbkNDLGNBQWNwdUMsRUFBRWpDLEVBQUVpaUM7TUFDcEI7UUFDRSxrQ0FGY2hnQyxFQUFFakMsRUFBRWlpQzs7OztVQUlQLElBQVBrTyxhQUFPLHlCQUFQQSxPQUFPOztVQUNDLElBQVBDLGFBQU8sd0JBQVBBLE9BQU87a0JBQXVCO2FBRW5DRSxhQUFhcnVDLEVBQUVqQyxFQUFFaWlDO01BQ25CO1FBSUU7U0FISW9MO1NBQ0FULFFBSFMzcUM7U0FJVGd1QyxhQXBMSmxsQjtTQXFMQSxtQ0FESWtsQixVQUZBNUMsS0FDQVQsS0FIVzVzQyxFQUFFaWlDOzs7OztVQU9OLElBQVBrTyxhQUFPLHlCQUFQQSxPQUFPOztVQUNDLElBQVBDLGFBQU8sd0JBQVBBLE9BQU87a0JBQXVCO2FBR25DRyxZQUFZcHdDO01BQ2QsSUFBSXVELElBQUosc0JBRGN2RDtNQUNkLFNBQ1Fxd0MsS0FBSy91QztRLElBQUE4STtRQUNYO2FBRkU3RyxPQUNTNkcsV0FEVDdHO1VBR00sMEJBSkl2RCxFQUVEb0s7WUFFYyxRQUZkQTtVQUdOLE9BSE1BLElBR0w7TUFKUjtRQU1NLElBQ0pBLElBREksUUFQUXBLOzs7O1VBVVY7WUFBWSxJQUNWc0IsRUFEVSxRQVZGdEI7Ozt5Q0FDVnVEO1lBVU87c0JBQUxqQztRQUhDO2tCQUFMOEksWUFLSzthQUdMa21DLFlBQVlDO1VBQWdCL0QsYUFBTkMsY0FBTCtEO29CQUFLL0Q7ZUFFVixJQUZBOEQsSUFFQSxzQkFGS0M7ZUFHaUIsSUFIdEJELElBR3NCLHNCQUhqQkMsT0FHaUIsWUFITmhFO2FBTTVCaUUsb0JBQW9CendDO01BQ3RCLElBQUkwd0M7TUFBSjt3QkFDZ0U5dEM7aUJBQXJELFNBQXFEQSxPQUQ1RDh0QyxTQUN3QyxzQkFBeUIsT0FBTDl0QyxDQUFPO2VBRmpENUMsRUFFbUQ7YUF5QnZFMndDLE1BQVFuRCxJQUFlcEI7TUFDekIsR0FEVW9CLElBQU0sUUFBTkEsYUFBTXFDLGFBQU5lLE12QjNQUjl2QztNdUI0UGM7MEJBRFNzckM7T0FFZixnQkFuQ1JrRSxjQWtDRU87T0FFTSxVQUROdHRDLElBRk1xdEM7TUFJRDt3QkEzQlNFO2lCQUNsQixTQURrQkEsT0FDbEIsS0FEa0JBO2lCQUNsQix3QkFEa0JBOztxQkFPZDs0QkFQY0E7c0JBT0QscUJBRFdkO3NCQUVYLGdCQUFhLE1BUmhCM3JDLFFBT04wc0M7cUJBRVE7Ozt3Q0FBTyxJQURmQyxTQUN3QixvQkFISmhCO21CQUtYO29CQURIbE8sSUFWSWdQO29CQVdELG1CQURIaFA7b0JBQ0c7MEJBWEh6OUIsUUFZTjZzQyxlQURBRDttQkFBUyxPQUVUNXhCO3FCQUlXO29DQUpYQTtzQkFLVyxhQUFXLG9CQVJoQnlpQixPQUNObVA7c0JBUVc7NkJBVExuUCxJQUNObVAsT0FPVyxzQkFSTG5QLE9BQ05tUDtxQkFTVSx3QkFGUmpGLE9BRWlCLElBSGpCbUYsT0FFQWxGO21CQUpRLHdDQUxKbks7aUJBTFYsT0FMY2dQO2VBd0JkRCxVQUdnQzthQVNsQ08sU0FBU0MsS0FBS3ZqQyxJQUFJd2pDO01BQ1gsbUJBRFdBLE1BRVY7ZUFFTkU7UUFDUyxJQVpIeHhDLEVBWUcsU0FIVDZFO1FBR1MsR0FMRndzQztVQU5YLElBQUk5dEMsSUFBSixzQkFEVXZEO1VBQ1YsT0FBSXVEO3FCQUNVLGdCQUZKdkQsRUFDTnVEO3FCQUVGLE1BSFF2RCxJQUNOdUQ7Ozs7O1V4QmdLRSx1QndCaktJdkQ7VUFDVixJQVlNeXhDOztrQkFiSXp4QztRQWNSLGNBREl5eEMsS0FIRkY7UUFJRixlQUxFMXNDLElBTWM7TUFOUjs7VUFVSSxJQUFKakMsRUFBSSxtQkFYVnNCO1VBV1UsR0FBSnRCLE1BWk1rTCxJQWFNLGNBQWMsU0FYaENqSixJQVVNakM7Ozs7O1VBS1AsT0FmQ2lDLE9BZTBCO1VBQzlCLHNCQWpCSVg7VUFrQlUsbUJBaEJWcXRDO21CQWdCMkI7O0lBRWxCLFNBQVhHLGUsT0FyQkFOO0lBcUJXO0lBRUMsU0FBWk8sZ0IsT0F2QkFQO0lBdUJZLFNBRVpRLFVBQVU5akMsSUFBSXdqQyxLQUFLTztNQUNaLElBQUwxdUMsR0FBSyxhQURPbXVDO01BRWhCLGdCQUFnQnR4QyxHQUFLLDBCQURqQm1ELFNBQ1luRCxFQUZKOE4sSUFFZ0MsRUFGdkIrakM7TUFFckIsaUJBREkxdUMsR0FFUTtJQUxFO0lBT0EsU0FBWjJ1QyxxQixPQUxBRjtJQUtZO0lBRUMsU0FBYkcsc0IsT0FQQUg7SUFPYTs7O09BeEhiOU47T0FRQW9NO09BWkFIO09BSkFIO09BSEFEO09BMEJBUTs7O09BcExBdkQ7T0FOQUQ7T0FzUEFnRTtPQTVPQS9sQjtPQThRQThtQjtPQUVBQztPQU9BRztPQUVBQztJQUFhO1EzQjdYYkM7YUFJQUMsTUFBTTl4QyxFQUFFeEU7TUFDVixJQUFJa0UsRUFESU0sRUFBRXhFO01BRUgsZ0JBREhrRTtlQUdJLGFBSEpBO2lCQUlGLHlCQUpFQTtpQkFLSSxhQUxKQSxXQU1GLGdCQU5FQTtlQUVGLHlCQUZFQSxFQVFDO2FBRUNxeUMsYUFBYS94QyxFQUFFeEU7TUFDckIsR0FEbUJ3RSxnQkFBRXhFO01BRWEsc0JBRmZ3RSxFQUFFeEUsV0FFQyxXQUZId0UsRUFBRXhFO01BRUMsMENBQWtDO2FBRXREdzJDLE9BQU9oeUM7TUFDVCxVQURTQTtNQUNUO1FBSW9DLHNCQUwzQkEsS0FLZSxXQUxmQTtRQUtlOztlQUhqQjtlQUNBO2dCQUNlLGVBSmJBLEtBSWEsc0NBQ2dDO2FBRXBEaXlDLFlBaUJZanlDO01BaEJkLFNBQVFreUM7UTtRQUFPOztnQkFDTGx3QyxjQUFOQztpQkFDYSxvQkFEYkEsR0FlVWpDO3FCQWJJLElBQUxILFVBQUssT0FBTEE7d0JBRkhtQzs7VUFLSixHQVVRaEM7OzsyQkFQb0JteUMsZ0JBQU5DLGNBQU5qQjs7cUIwQmZwQjVGLFExQm5CQTV3QztxQkFrQ29CdzJDO3FCQUFNaUI7cUJBQU1EOzs7YUFPcEJueUM7OzthQUxxQnF5QzthQUFOQzthQUFOQzs7cUIwQmpCckJoSCxRMUJuQkE1d0M7cUJBb0NxQjQzQztxQkFBTUQ7cUJBQU1EOzs7YUFLckJyeUM7OzthQUhpQ3d5QzthQUFOQzthQUFOQzs7cUIwQm5CakNuSCxRMUJuQkE1d0M7cUJBc0NpQyszQztxQkFBTUQ7cUJBQU1EOzs7VUFJckMsc0JBREl4eUM7WUFJRixJQUFJMnlDLFlBSkYzeUMsUUFNWSxXQUZWMnlDLFlBRVUsT0FOWjN5QztVQUVELE9BRkNBLEtBTXNCO01BdEJwQyxZQTNCRTZ4QyxZQWtEWTthQUVaZSxNQUFNQyxJQUFJOTNCO01BQ1o7UUFDRSxvQkFGTTgzQixJQUFJOTNCLEtBSVY7WUFERy9hOztRQUNnQyxxQkFEaENBO1FBQ0g7UUFDQSxjSWtPQW9DO1FKbE9BLE1BRkdwQyxFQUdJO2FBRVA4eUMsUUFBTUQsSUFBSTkzQjtNQUNaO1FBQ0Usb0JBRk04M0IsSUFBSTkzQjtZQUdQL2E7O1FBQ0gsY0kwTkFtQztRSnpObUMscUJBRmhDbkM7UUFFSDt1QkFDTTthQW9DTit5QyxzQkFBc0JDO00sVUFDZixtQ0FEZUEsSUFFRjthQUVwQkMsc0JBQXNCamlDLElBQUlrQjtNQUM1QixTQUFJZ2hDLEtBQUtDO1FBQ1AsT0FET0E7dUJBRGVuaUM7OztrQ0FLaUQ7TUFKekUsU0FENEJrQjtRQWN4QjtjQWR3QkE7U0FjeEIsS0Fkd0JBO1NBY3hCLEtBZHdCQTtTQWN4QixLQWR3QkE7O1NBZWhCLFVBZmdCQTtRQWNuQjtNQUxMLEdBVHdCQTtNQVljO01BQS9CLHlDQUt1QzthQWNoRGtoQyxvQkFBb0JDLFFBQVFDO01BQ0ksSUFiRUMsVUFhRixzQkFESkQ7TUFYOUIsR0FEb0NDO1FBTWhDLE1BTmdDQSxhQU1oQyxLQURHendDLHFCQUNIOzs7VUFDRTtZQUFNLGdDQURSdEgsRUFDZ0MsaUJBRjdCc0gsRUFDSHRIO1lBQ1EsVUFFVSxJQUFQNEMsYUFBTyxtQkFHQWkxQyxjQUhQajFDO1lBRkgsU0FEUjVDOzs7UUFIQTtxQkFTa0I2M0MsYUFDaUQ7YUFHckVHLGdCQUFnQkg7TUFDVSwyQkFEVkEsUUFDVSxvQ0FBc0I7YUFlaERJLHdCQUF3Qkg7TUFDTixJQWRFQyxVQWNGLHNCQURNRDtNQVoxQixHQURzQkM7UUFLVixJQURMendDLEVBSmV5d0MsYUFLVixzQkFETHp3QyxxQkFDSzs7Y0FDUnRIO1VBQ0U7WUFBTSxnQ0FEUkEsRUFDZ0MsaUJBSDdCc0gsRUFFSHRIO1lBQ1EsVUFFVSxJQUFQNEMsYUFBTyxtQkFKZGlELFFBSU9qRDtZQUZILFNBRFI1Qzs7O1FBS0EsZ0JBTkk2RjtNQUZMLGlFQVdzRDthQUV2RHF5Qyx3QkFFaUI3b0M7TUFGUyxhQUVUQSwwQkFBZTthQUVoQzhvQyx5QkFDZTlvQyxPQURZLGFBQ1pBLG1CQUNZO2FBUzNCK29DLHdCQUVlL29DO01BRlcsYUFFWEEsc0RBTWQ7YUFFRGdwQyxnQkFBZ0JQO01BT1osZ0NBUFlBO01BT1o7UUFHRiwyQkFES0M7UUFJbUI7Ozs7WUFFSDtvQ0FOaEJBO2FBQ2E7O1lBS0c7eUJBTmhCQTtNQURHLFFBVUM7YUFzQlhPO01BQTJDLG1FQUFzQjthQUtqRUMsaUJBQWlCQyxJQUNuQixpQkFEbUJBLEdBdE9qQm5DLGFBdU9GLFFBQTJCO2FBSXpCb0MsU0FDRWowQyxHQUNKLDBCQURJQSxTQUNzQzthQUV4Q2swQyxZQUFZbDBDLEdBQ0gsSUFBUGtTLEtBQU8sU0FER2xTLEdBQ0gsT0FBUGtTLE9BQzhCO2FBRWhDaWlDLGNBQWNuMEMsR0FDTCxJQUFQa1MsS0FBTyxTQURLbFMsR0FDTCxPQUFQa1MsT0FDaUM7UUFHbkNraUM7YUFFQUMsK0JBQStCTDtNQUFLLG1DQUFMQSxJQUFLLFFBQXFDO0lBRS9CLG9CO0lBQUEsb0I7SUFBQTtNO0lBQUEsb0I7SUFBQTs7O09BNUYxQ047T0FJQUM7T0FXQUM7T0FyRUFYO0lBa0owQyxvQjtJQUFBLG9CO0lBQUEsb0I7SUFBQTs7O09BbE8xQ2hCO09BMEJBVztPQVFBRTtPQWlGQVU7T0FvRkFNO3NCOztPQUtBQzs7T0E3RkFYO09Bb0JBSzs7T0E2RkFZO09BakVBUjs7Ozs7O09Bc0RBSztPQUlBQztJQVMwQzthNEI3TTFDRyxXQUFXN3hDO01BQ2Isb0NBQUkrWTtNQUNKLG1CQUZhL1k7TUFDYixTQUFJK1k7TUFFSixtQkFIYS9ZO01BQ2IsU0FBSStZO01BR0osbUJBSmEvWTtNQUtiLFFBTGFBO01BQ2I7T0FJQSxLQUpJK1k7T0FLbUI7WUFMbkJBO01BTUosbUJBUGEvWSxRQU1UekI7TUFMSixTQUFJd2E7TUFPSixtQkFSYS9ZLFFBTVR6QjtNQUxKLFNBQUl3YTtNQVFKLG1CQVRhL1ksUUFNVHpCO01BSUosUUFWYXlCO01BQ2I7T0FTQSxLQVRJK1k7T0FVbUI7WUFWbkJBO01BV0osbUJBWmEvWSxRQVdUeEI7TUFWSixTQUFJdWE7TUFZSixtQkFiYS9ZLFFBV1R4QjtNQVZKLFNBQUl1YTtNQWFKLG1CQWRhL1ksUUFXVHhCO01BVkosU0FBSXVhO01BY0osbUJBZmEvWSxRQVdUeEI7TUFWSixTQUFJdWE7TUFlSixtQkFoQmEvWSxRQVdUeEI7TUFWSixTQUFJdWE7TUFnQkosbUJBakJhL1ksUUFXVHhCO01BT0osUUFsQmF3QjtNQUNiLFNBQUkrWTtNQWtCSixtQkFuQmEvWTtNQUNiLFNBQUkrWTtNQW1CSixtQkFwQmEvWTtNQUNiLFNBQUkrWTtNQW1CSiwwQkFwQmEvWSxhQXFCK0I7YUFHMUM4eEM7TUFDa0I7Ozs7O2NBQWZHLEtBQVNGLEtBQUxDLFFBQzRDO2FBbUJuREUsYUFBYWoxQyxHQUVmLFlBQ1c7YUFHVGsxQyxhQUFhOXhDLEdBQUksaUJBQVU7d0I7Ozs7OztPQW5EM0J3eEM7T0F3QkFDOzJCOzs7T0FxQkFJO09BTUFDOzthQzFGQUMsT0FBT3oyQztNQUNULHVCQURTQSxNQUNULHNCQURTQSxLQUM4QjthQUVyQzAyQyxNQUFNenpDLEdBQVcsbUNBQVhBLEdBQXFDO2FBRTNDMHpDLFVBQVUzMkMsSUFBSStFLElBQUlDO01BQ3BCLFFBRGdCRDtlQUFJQztxQ0FBUmhGLE9BQVFnRixXQUFKRDtnQkFHWCxnQkFITy9FLElBQUkrRSxJQUFJQztNQUVmLHdDQUN5QjthQUU1QjR4QyxTQUFTM3pDLEVBQUU4QixJQUFJQztNQUFnQixzQ0FBdEIvQixHQUFFOEIsSUFBSUMsSUFBa0Q7YUFFakUrdEMsS0FBSzhEO01BQ0UsSUFBTGx4QyxHQUFLLFlBREZreEM7TUFDRTtRQUNILElBQ0YvL0IsRUFERSxzQkFERm5SO1lBR1UrUCw4QkFBSyxzQkFIZi9QLElBR2UsTUFBTCtQO01BREwsc0JBRkwvUDtNQUVLLE9BQUxtUixDQUNtQzthQUVyQ2dnQyxTQUFPM3hDLEtBQUs0eEMsUUFDZCxxQkFEUzV4QyxLQUFLNHhDLE9BQ1c7YUFFdkJDLFFBQU03eEMsTUFBTywyQkFBUEEsUUFBa0M7YUFFeEM4eEMsU0FBU2wwQyxHQUNYLGVBRFdBLDJCQUNpRTthQUUxRW0wQyxPQUFPcGdDO01BQ1QsZ0NBRFNBLEdBQ3FCO01BQTJCLGlDQUV6RDFaO01BQ0U7WUFBSXdFLEVBQUosZ0JBSk9rVixFQUdUMVo7UUFFZ0Msc0JBSDVCMGMsT0FDSjFjLFVBRWdDLFNBRDFCd0U7UUFFNEIsc0JBSjlCa1ksUUFDSjFjLG1CQUdrQyxTQUY1QndFO1FBQUosU0FERnhFOztRQUtBLDRCQU5JMGMsUUFNeUI7YUFFM0JxOUIsU0FBUzExQztNQUNYLGdDQURXQSxHQUNtQjtNQUE2QixTQUN2RDIxQyxNQUFNL3lDO1FBQ1IsU0FEUUE7Ozs7Ozs7UUFLRCxnREFBMEM7TUFOUSxpQ0FVM0RqSDtNQUNFO29CQURGQSxNQUZpQyxXQUFNLGdCQVQ1QnFFLEVBU0YrQjtRQUdQO1VBRkVzVyxPQUNKMWMsRUFDcUIsS0FIUixNQUFNLGdCQVRScUUsRUFTRitCO1FBR1AsU0FERnBHOztRQUdBLDRCQUpJMGMsUUFJeUI7Ozs7OztPQWxEM0IyOEI7T0FHQUM7T0FFQUM7T0FLQUM7T0FFQTdEO09BTUErRDtPQUdBRTtPQUtBRTtPQVVBQzs7YUM1QkVFLGlCQUFzQixpQ0FBMEI7YUFDaERDLE9BQU9DLElBQUlDO01BQ2IsT0FEYUEsU0FBSkQsYUFDVCxTQURhQyxPQUNiLFFBQ2tCO2FBR2hCQyxVQUFVaDJDLEVBQUVpMkM7TUFDZCxpQkFEY0EsMkJBT2QsRUFESUMsa0JBRUpuMEM7TUFDRTt5QkFUVS9CLEtBUVorQjtRQUNFLFNBREZBOztRQUNFLElBRUYsaUJBQ2tCLGlCQUxkRCxPQUlKO1FBQ2tCO2NBQWxCbkc7VUFDRTs7ZUFERkE7YUFDRSxXQURGQSxFQUxJbUc7YUFRb0IsbUJBVHBCbzBDLE9BUUVucUM7WUFIRmpILFVBVitCLFdBVS9CQSxRQVZ1QyxxQkFBMUIzRTtZQVlmO2tCQUZFMkU7YUFQVzthQUQwQzthQUExQjthQUFuQjthQWFHLHVCQWhCSDlFLEtBYU5rTztZQUdKLGlCQWhCVWxPLEtBYU5rTztZQUFKLFNBREZ2Uzs7O1FBTUE7aUJBQVU7YUFHUnc2QyxPQUFLRjtNQUNNLElBQVQ1OUIsT0FBUyxhQUNiLFVBRElBLE9BREc0OUIsTUFFUCxPQURJNTlCLE1BRUU7YUFHSis5QixzQkFBeUIsc0NBQWdCO2FBRXpDQyxPQUFLcjJDLEdBQ00sSUFBVHFZLE9BQVMsYUFDYixPQURJQSxPQURHclksR0FFUCxPQURJcVksTUFFRTthQUlKaStCLEtBQUt0MkM7TUFDUCxRQURPQTtNQUNQO1lBRE9BO09BQ1Asd0JBRE9BO09BQ1AsTUFET0E7T0FHTTt5QkFITkE7O1NBRUh1MkM7OztPQUNTLFNBQVRDO09BQVMsS0FITngyQztNQU1QLGlCQU5PQSx1QkFLSHkyQztNQUNKLE9BRElBLFFBRUk7YUFRTkMsTUFBSTEyQyxFQUFFMjJDO01BQ1IsbUJBRFFBOzs7VUFKQSxXQUlGMzJDLEdBSkUsV0FBSnNFLEVBSUlxeUM7VUFKQSxrQkFJQUEsdUJBSkpyeUMsSUFDQVg7VUFDK0MsT0FEL0NBO01BS0Msa0NBQ2M7YUFZakJpekMsTUFBTTUyQyxFQUFFMjJDO01BQ1Ysa0JBRFVBLGdCQUVMO01BVkw7UUFBc0IsWUFRZDMyQyxHQVBpQyxTQU9qQ0EsY0FQaUMsRUFEckM2MkMsS0FDQUMsR0FBcUMsV0FDckN4eUMsRUFNTXF5QztRQVArQixvQkFDckNyeUMsSUFDQVgsb0JBS01nekM7O1FBRkwsT0FIRGh6QyxFQVFpQjthQWFuQm96QyxNQUFNLzJDLEVBQUUyMkM7TUFDVixrQkFEVUEsbUJBRUw7TUFYTDtRQUFzQjtxQ0FTZDMyQztTQVJnQyxrREFRaENBO1NBUGlDLGtEQU9qQ0E7U0FQaUMsZ0JBRnJDNjJDLEdBRXFDLGNBRHJDQyxHQUNBRTtTQUFxQyx5QkFDckMxeUMsRUFNTXF5QztRQVArQjs7MkJBQ3JDcnlDLEVBQ0FYO1lBRnFDLDhCakNqRXpDbEosVWlDd0VVazhDOztRQUZMLE9BSERoekMsRUFRaUI7SUFLaEIsU0FGSHN6QyxVQUVPajNDLEVBQUUyMkMsT0FBNEIsYUFBOUIzMkMsRUFBRTIyQyxNQUFnRTthQVl6RU8sUUFBTWwzQyxFQUFFMjJDO01BTGdCLFlBS2xCMzJDLEdBSmtCLFFBSWxCQTtjQUxKZ2Ysa0JBQ0FGLG1CQUlNNjNCLEtBQTJCO2FBRW5DUSxLQUFLbjNDLEdBQUssbUJBQUxBLFdBQXVCO1FBTTlCbzNDO2FBZ0JBQyxjQUFVLFlBaEJWRCxVQWdCNEI7YUFDNUJFLE1BQUlYLE9BQVEsYUFqQlpTLFVBaUJJVCxNQUErQjthQUNuQ1ksUUFBTVosT0FBUSxhQWxCZFMsVUFrQk1ULE1BQWlDO2FBQ3ZDYSxZQUFVYixPQUFRLGlCQW5CbEJTLFVBbUJVVCxNQUFxQzthQUMvQ2MsUUFBTWQsT0FBUSxhQXBCZFMsVUFvQk1ULE1BQWlDO2FBQ3ZDZSxRQUFNQyxPQUFRLGVBckJkUCxVQXFCTU8sTUFBaUM7YUFDdkNDLGNBQVUsWUF0QlZSLFVBc0I0QjthQUU1QlMsWUFBVTVCLE1BQU8saUJBeEJqQm1CLFVBd0JVbkIsS0FBbUM7YUFDN0M2QixPQUFLN0IsTUFBTyxpQkF6QlptQixhQXlCS25CLE1BQXlDO2FBQzlDOEIsaUJBQXlCLDJDQUFlO2FBSXhDQyxpQkFBZSxjQTlCZlosVUE4QmlDO2FBQ2pDYSxVQUFVajRDLEdBQUksY0EvQmRvM0MsVUErQlVwM0MsRUFBMEI7Ozs7T0F4SGxDbTJDO09BTUFDO09BRUFDO09BT0FDO09BZUFJO09BZUFFO09Bc0JBSztPQU5BRjtPQW9CQUc7T0FFQUM7OztPQStCRlc7T0FEQUQ7T0FFQUU7T0FWQVY7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUU7O09BUUFJO09BQ0FDOzthQzlKQUMsT0FBSy8zQyxHQUFJLDBCQUFKQSxFQUFnQzthQUNyQ2c0QyxXQUFXM3JDLEdBQUdDLEdBQUd0TSxHQUFJLGlCQUFWcU0sR0FBR0MsS0FBR3RNLEVBQStCO2FBQ2hEaTRDLFlBQVluQyxLQUFLOTFDLEdBQUksd0JBQVQ4MUMsS0FBSzkxQyxFQUFtQzthQXdCcERrNEMsa0JBQWtCOTdCO01BQ3BCLFNBRG9CQSxxQkFDcEIsY0FEb0JBLHlCQUVDO2FBRW5CKzdCLHVCQUF1Qi83QixHQUN6QixTQUR5QkEsU0FDekIsUUFBa0M7O01BTTVCLDRDQURGZzhCOzs7O01BRUY7UUFBSTs7Ozs7VUFGRkE7SUFHSjttQ0FISUE7S0FHSixjQUpFQztJQUlGLFNBSUVFLGlCQUFlLDBCQUFrQjtJQUpuQyxTQUtFQyxxQkFBbUIsT0FIbkJGLGFBRzhCO0lBTGhDLElBT0VHLHlCO0lBUEYsU0FnQkVDLFNBQVNyTCxJQUFzQnNMO01BQ2pDLEdBRFd0TCxJQUFTLFFBQVRBLGNBQVNxQyxhQUFUa0osT0FkVE47VUFTa0J0NEM7TUFDcEI7Y0FJaUMyNEMsZ0JBTGIzNEM7O1dBR2YsUUFIZUE7V0FLVDQ0QztTQUVlOzRCQVh4Qkg7VUFXd0Isa0JBWHhCQSxxQlQ5Q0EzeUIsaUJTOENBMnlCO1VBV0UzQyxLQUFzQjs7YUFBdEJBO1FBQzhDLDJCQVI5QjkxQyxLQU9oQjgxQyxLQVBnQjkxQyxHQVFrRDtJQW5CdEUsU0FxQkU2NEMsUUFBTXo4QjtNQUNSO2NBRFFBLGdCQUNSLEtBQ0loWixZQURKOztZQUVBNUg7UUFDRTsyQkFKTTRnQixLQUdSNWdCO1VBQ0UsU0FERkE7OztjQUVJO0lBMUJKLFNBNEJFczlDLFFBQU0xOEI7TUFDUixJQUFJaFosSUFESWdaO01BQ1IsUUFEUUE7VUFDSmhaLFFBRU8sSUFISGdaO1NBS0gsU0FFc0Msc0JBQXBCLElBUGZBLFNBT21DO01BSHpDLGVBSk1BLEVBUUw7SUFwQ0gsU0FzQ0UyOEI7TUFBa0I7O1NBRVp4TTtTQUFLaHFCO1NBQU1yYjtTQVdYM0osVUFYQWd2QyxJQUFLaHFCLEtBQU1yYjtjQVdYM0o7aUJBWFcySjs7OzthQUdMOHhDO2FBQUtsMkI7YUFBTW0yQjthQUNYOTBDLEtBREE2MEMsTUFBS2wyQixPQUFNbTJCO3FCQUlDLFVBSFo5MEMscUJBRFc4MEM7WUFHSjtpQkFLYjE3QztNQVpHLFFBY047SUFyREwsU0F1REUyN0MsT0FBSy9sQztNQUFJLFNBQUpBLFFBQUksS0FBSkEsUUFBb0IsV0FqQnpCNGxDLGdCQWlCSzVsQztNQUFvQixVQUFwQkEsdUJBQXNEO0lBdkQ3RCxTQXlERWdtQyxTQUFPLzhCLEdBQUksT0FBSkEsSUFBVTtJQXpEbkIsU0EyREVnOUIsU0FBT0MsU0FBU2o5QjtNQUNsQjthQURrQkE7T0FDbEIsTUFBSWs5QjtPQUFKLE1BQ0lDO09BREosS0FFSUM7TUFGSjtRQUdxQzs4QkFEakNBO1NBQ2lDLDBCQURqQ0E7U0FJZ0IsOEJBUEZwOUI7UUFPRSxPQUZkcTlCO1FBRCtCLElBR2pCLEtBTGhCRixjQUtnQjs7Y0FpQmxCMzNDOztVQUNFO1lBQWMsNEJBeEJkMDNDLE1BdUJGMTNDO1lBZndCOztnQkFPUDtpQkFMUDJxQztpQkFBS2hxQjtpQkFBTXJiO2lCQUNYMHlDLE9BTE5ELGdCQUlNcE4sSUFBS2hxQjtpQkFLRSxnQkFoQlY4MkIsU0FBU2o5QixFQVdObXdCO2lCQU1RLHVCQVhkbU4sV0FVTUc7Z0JBQ1EsR0FFTHZ1Qzs0QkFQSHN1Qzs7aUJBTU8saUJBYmJILE1BV01JLGtCQUpBRDtnQkFTSixpQkFmRkYsV0FVTUcsa0JBSkFEO2dCQUlPLFNBTEkxeUM7O3VCQWFyQnRGOzs7O1FBR0EsR0FwQkkrM0M7VUFxQkYsU0F6QkFILGNBeUJBOzs7WUFDRTtjQUFNLElBRUNNLFFBRkQsaUJBdkJOSixXQXNCRmwrQztjQUNRLEdBRUNzK0M7Y0FGRCxTQURSdCtDOzs7OztrQkFyQkVtK0M7UUFIK0I7OztNQU54QixXQW1DVjtJQTVGSCxTQThGRUksVUFBVTM5QixFQUFFbXdCO01BRWQsWUFGWW53QjtlQUdQLGlCQUhPQSxLQUFFbXdCLFFBQUZud0I7ZUFJUDtxREFKU213QixLQUFGbndCLGdCQUk4QztJQWxHMUQsU0FvR0U0OUIsTUFBSTU5QixFQUFFbXdCLElBQUlocUI7TUFDSjttQkFERm5HLEVBQUVtd0I7T0FFMEIsVUFGMUJBLElBQUlocUIsS0FFc0IsaUJBRjVCbkcsS0FDRjVnQjtNQUVKLGlCQUhNNGdCLEtBQ0Y1Z0IsWUFDQXkrQztNQUNKLE9BSE03OUI7TUFDRSxTQURGQTtNQUdOLFlBRTJDLFNBWHpDMjlCLFVBTUkzOUIsT0FLdUQ7SUF6RzdELFNBd0hFcUMsT0FBT3JDLEVBQUVtd0I7TUFDSCxnQkFEQ253QixFQUFFbXdCLEtBRWlCLHFCQUZuQm53QixLQWJhNWdCOzs7Y0FHVG9RLE9BQUcxRTtVQUNULHNCQURNMEUsRUFVRjJnQztZQVJGLE9BUUFud0I7WUFSQTtnQ0FGT2xWO3FCQUtDLGlCQUtSa1YsS0FiYTVnQixZQUdOMEw7OztRQURaLFNBYWtDO0lBMUh0QyxTQWtJRWd6QyxPQUFLOTlCLEVBQUVtd0I7TUFDSyxtQkFEUG53QixFQUFFbXdCLEtBQ0gsdUJBRENud0I7TUFDRDtZQUVLKzlCLFlBQVMvMkIsWUFBU2czQjtRQUN0QixzQkFKRTdOLElBR0U0TixXQUFTLzJCO1FBRWhCLEdBRnlCZzNCO2NBSWRDLEdBSmNELFNBSUwvMkIsR0FKSysyQixTQUlJRSxNQUpKRjtVQUtsQixzQkFSRjdOLElBT004TixXQUFTaDNCO1VBRWhCLEdBRnlCaTNCO2dCQUlkQyxHQUpjRCxTQUlMRSxHQUpLRixTQUlJRyxNQUpKSDtZQUtsQixzQkFaTi9OLElBV1VnTyxXQUFTQztzQkFBU0M7OztvQkFkMUI3dUMsV0FBRzJXLGNBQU1yYjtnQkFDYixzQkFFRXFsQyxJQUhFM2dDLFVBQUcyVzswQkFBTXJiOztjQURoQjtVQWNlO1FBSko7TUFKSixlQVVzRDtJQTlJakUsU0FzSkV3ekMsV0FBU3QrQixFQUFFbXdCO01BQ0MsbUJBREhud0IsRUFBRW13QixLQUNQLHVCQURLbndCO01BQ0w7WUFFSys5QixZQUFTLzJCLFlBQVNnM0I7UUFDdEIsc0JBSk03TixJQUdGNE4sY0FBUy8yQjtRQUVoQixHQUZ5QmczQjtjQUlkQyxHQUpjRCxTQUlMLzJCLEdBSksrMkIsU0FJSUUsTUFKSkY7VUFLbEIsc0JBUkU3TixJQU9FOE4sY0FBU2gzQjtVQUVoQixHQUZ5QmkzQjtnQkFJZEMsR0FKY0QsU0FJTEUsR0FKS0YsU0FJSUcsTUFKSkg7WUFLbEIsc0JBWkYvTixJQVdNZ08sY0FBU0M7c0JBQVNDOzs7b0JBZDFCN3VDLFdBQUcyVyxjQUFNcmI7Z0JBQ2Isc0JBRU1xbEMsSUFIRjNnQyxhQUFHMlc7MEJBQU1yYjs7Y0FEaEI7VUFjZTtRQUpKO01BSkosUUFVK0Q7SUFsSzFFLFNBb0tFeXpDLFdBQVN2K0IsRUFBRW13QjtNQUNiLFNBQVFxTztRO1FBQWlCOztnQkFHZGh2QyxhQUFHMlcsZ0JBQU1yYjtZQUNiLHNCQURJMEUsRUFKRTJnQyxlQUlDaHFCLEtBRUcsZUFGR3JiOzs7VUFEaEIsU0FJd0I7TUFDTCxtQkFSWmtWLEVBQUVtd0I7TUFRRSx1Q0FSSm53QixxQkFRNEI7SUE1S3ZDLFNBc0xFeStCLFFBQVF6K0IsRUFBRW13QixJQUFJaHFCO01BQ1I7bUJBREVuRyxFQUFFbXdCO09BQ0oseUJBREVud0IsS0FDTjVnQjthQUNBcU87OztjQVBTK0IsV0FBRzFFO1VBQ1Qsc0JBRE0wRSxFQUtEMmdDLGdCQUxJcmxDO1VBRVAsV0FHR3FsQztVQUhILFdBR09ocUI7Ozs7O1VBSWQsaUJBSlFuRyxLQUNONWdCLGVBRFErd0MsSUFBSWhxQixLQUVaMVk7VUFFRixPQUpRdVM7VUFJUixTQUpRQTtVQUlSLGVBRTJDLFNBOUYzQzI5QixVQXdGUTM5QjtVQUlSOzs7UUFyQnVCLFlBd0J0QjtJQTdMSCxTQStMRTArQixNQUFJMStCLEVBQUVtd0I7TUFNYztzQkFOaEJud0IsRUFBRW13QjtPQU1NLHlCQU5SbndCOztNQUNrQjs7VUFJcEIsSUFET3hRLFdBQUcxRSxjQUNWLHdCQURPMEUsRUFKSDJnQztVQUtKO29CQURVcmxDOztRQURWLFNBR2tDO0lBck10QyxTQXVNRTZ6QyxPQUFLcjdDLEVBQUUwYztNQUNULFNBQVE0K0I7UTtRQUFZOztnQkFHWHpPLGVBQUtocUIsZ0JBQU1yYjtZQUNkLFdBTEN4SCxFQUlFNnNDLElBQUtocUI7d0JBQU1yYjs7VUFEZCxTQUUwQjtNQUNqQixJQUFYK3pDLFNBQVcsa0JBTk43K0I7TUFNTSxPQUFYNitCLFNBQ2lCLHVCQVBaNytCO01BT29DO1FBRzNDLE1BVk9BLEtBVVAsS0FESWxILHFCQUNKOzs7VUFDRTtzQkFBVSxpQkFGUkEsRUFDSjFaO1lBQ0UsU0FERkE7OztZQUdBLFNBUEV5L0MsU0FPRixVQUFxQix1QkFiZDcrQjtRQWNLO1lBQVRqQjs7UUFBUyxHQVJWOC9CLGVBUUM5L0I7UUFDSCx1QkFmT2lCO1FBZVAsTUFER2pCLElBRU07SUF2TlgsU0F5Tk0rL0IsMEJBQTBCeDdDLEVBQUUwYyxFQUFFNWdCOzs7O1VBT3BCO1dBRE4rd0M7V0FBS2hxQjtXQUFNcmI7V0FDTCxpQkFQZ0J4SCxFQU10QjZzQyxJQUFLaHFCO1VBQ0M7Z0JBSUxPOzs7O2FBRVEsaUJBYmUxRyxLQUFFNWdCO1lBYUMsWUFGMUJzbkI7cUNBTFU1Yjs7VUFHYixPQVQwQmtWO1VBT2xCLFdBREtsVjs7UUFKakIsZ0NBQ1csaUJBSG1Ca1YsS0FBRTVnQjtJQXpOcEMsU0E2T0UyL0MsbUJBQW1CejdDLEVBQUUwYztNQUN2QixNQUR1QkEsS0FFUiwyQkFGUUE7TUFFUixPQUFYNitCLFNBQ2lCLHVCQUhFNytCO01BR3NCO2lCQUZ6Q2xIOztjQUlGMVo7VUFDRTtzQ0FOaUJrRSxFQUFFMGMsRUFLckI1Z0IsSUFDd0MsaUJBTm5CNGdCLEtBS3JCNWdCO1lBQ0UsU0FERkE7Ozs7UUFHWTtZQUFUMmY7O1FBQVMsR0FOVjgvQixlQU1DOS9CO1FBQ0gsdUJBVHFCaUI7UUFTckIsTUFER2pCLElBRU07SUF2UFgsU0F5UEVpZ0MsT0FBSzE3QyxFQUFFMGMsRUFBRWpKO01BQ1gsU0FBUTZuQyxVQUFVMzVDLEVBQUVzRDtZQUFGMDJDLE1BQUV4MkM7UUFDbEI7YUFEZ0J3MkM7WUFLRzthQURaOU8sSUFKUzhPO2FBSUo5NEIsS0FKSTg0QjthQUlFbjBDLEtBSkZtMEM7YUFLRyxrQkFOZDM3QyxFQUtFNnNDLElBQUtocUIsS0FKTTFkO2FBQUZ3MkMsSUFJRW4wQzthQUpBckM7O1VBR2QsT0FIY0EsT0FLa0I7TUFDdkIsSUFBWG8yQyxTQUFXLGtCQVBONytCO01BT00sT0FBWDYrQixTQUNpQix1QkFSWjcrQjtNQVFvQztZQUV2Q2xILEVBVkdrSCxLQVdIelgsUUFYS3dPLFdBVUwrQjs7Y0FFSjFaO1VBQ0U7cUJBRkVtSjtZQUVNLG9CQUFVLGlCQUhoQnVRLEVBRUoxWjtZQUNFLFNBREZBOzs7UUFHQSxPQVJFeS9DLFNBUW1CLHVCQWZkNytCO1FBZXNDLFNBSnpDelg7UUFNUTtZQUFUd1c7O1FBQVMsR0FWVjgvQixlQVVDOS9CO1FBQ0gsdUJBbEJPaUI7UUFrQlAsTUFER2pCLElBRU07SUE1UVgsU0FxUk1tZ0M7Ozs7VUFFVTs7OzttQkFBVDluQzs7UUFESTtJQXRSWCxTQXlSRStuQyxNQUFNbi9CO01BQ1I7WUFEUUE7T0FDUjtPQUNFOzZCQUFxQnlGLEVBQUV4Z0IsR0FBVyxXQUFid2dCLEVBQWEsZ0JBQVh4Z0IsR0FBOEI7T0FBckQscUJBREVtNkM7T0FDRixLQUZNcC9CO01BSVI7aUJBQ08vYTtVQUNLLElBQUpNLEVBQUksZ0JBRExOO1VBRVUsT0FKYm82QyxNQUdJOTVDLFNBQ1MsaUJBSmI4NUMsTUFHSTk1QyxpQkFDc0I7O01BSDlCLFVBSlF5YSxxQkFDSm8vQixJQUVBQyxNQVN3QjtJQXJTNUIsU0F5U0VDLFNBQU8xakM7TUFHVCxJQUFJMmpDLFNBSEszakM7TUFHVCxTQUVRaEwsSUFBSXhSLEVBQUVvZ0Q7WUFBRmg2QyxNQUFFaTZDO1FBQVU7YUFBVkE7Z0JBS0p0UCxJQUxJc1AsVUFLQ3Q1QixLQUxEczVCLFVBS08zMEMsS0FMUDIwQztZQU1lLGFBRG5CdFAsSUFBS2hxQixxQixPQUxQdlYsSUFBSXBMLElBS1NzRjtVQUhmLEdBRk10RixRQUZSKzVDO1VBTWdCO21DQU5oQkEsU0FFUS81QztXQUlRLElBSlJBOztXQUFFaTZDO21CQU0wQjtNQVJ4Qzs0QixPQUVRN3VDLG9CQVFHO0lBdFRYLFNBd1RFK3VDLFlBQVlsNkI7TUFBZ0Isa0JBQWhCQTtNQUFnQixvQjtNQUFBLHNCLE96QjFWeEI3YSxvQnlCMFZrQztJQXhUeEMsU0EwVEVnMUMsY0FBY242QjtNQUFnQixrQkFBaEJBO01BQWdCLG9CO01BQUEsc0IsT3pCNVYxQjdhLG9CeUI0Vm9DO0lBMVQxQyxTQTRURWkxQyxVQUFRamtDLElBQUl4YztNQUNkOztpQkFBUyx1Q0FEQ3djLElBQ0twTSxFQUFFcEksRUFBa0I7ZUFEckJoSSxFQUN1QjtJQTdUckMsU0ErVEUwZ0QsWUFBWWxrQyxJQUFJeGM7TUFDbEI7O2lCQUFTLHlDQURLd2MsSUFDQ3BNLEVBQUVwSSxFQUFzQjtlQURyQmhJLEVBQ3VCO0lBaFV6QyxTQWtVRTJnRCxTQUFPM2dELEdBQ0MsSUFBTndjLElBQU0sZUFDVixZQURJQSxJQURLeGMsR0FFVCxPQURJd2MsR0FFRDtJQXJVSDtlQXlaTStoQyxVQUFVMzlCLEVBQUVtd0I7UUFDZCxTQURZbndCO1FBQ1osdUJBRFlBLEtBQUVtd0IsV0FDb0M7ZUFFaERqdkIsSUFBSWxCLEVBQUVtd0IsSUFBSWhxQjtRQUNKO3FCQURGbkcsRUFBRW13QjtTQUUwQixVQUYxQkEsSUFBSWhxQixLQUVzQixpQkFGNUJuRyxLQUNGNWdCO1FBRUosaUJBSE00Z0IsS0FDRjVnQixZQUNBeStDO1FBQ0osT0FITTc5QjtRQUNFLFNBREZBO1FBR04sWUFFMkMsU0FSekMyOUIsVUFHSTM5QixPQUt1RDtlQWUzRHFDLE9BQU9yQyxFQUFFbXdCO1FBQ0g7cUJBRENud0IsRUFBRW13QjtTQUVpQixxQkFGbkJud0IsS0FiYTVnQjs7Ozs7Z0JBR1RvUSxPQUFHMUU7WUFDVCxtQkFETTBFLEVBVUYyZ0M7Y0FSRixPQVFBbndCO2NBUkE7a0NBRk9sVjt1QkFLQyxpQkFLUmtWLEtBYmE1Z0IsWUFHTjBMOzs7VUFEWixTQWFrQztlQVFwQ3daLEtBQUt0RSxFQUFFbXdCO1FBQ0ssbUJBRFBud0IsRUFBRW13QixLQUNILHVCQURDbndCO1FBQ0Q7Y0FFSys5QixZQUFTLzJCLFlBQVNnM0I7VUFDdEIsbUJBSkU3TixJQUdFNE4sV0FBUy8yQjtVQUVoQixHQUZ5QmczQjtnQkFJZEMsR0FKY0QsU0FJTC8yQixHQUpLKzJCLFNBSUlFLE1BSkpGO1lBS2xCLG1CQVJGN04sSUFPTThOLFdBQVNoM0I7WUFFaEIsR0FGeUJpM0I7a0JBSWRDLEdBSmNELFNBSUxFLEdBSktGLFNBSUlHLE1BSkpIO2NBS2xCLG1CQVpOL04sSUFXVWdPLFdBQVNDO3dCQUFTQzs7O3NCQWQxQjd1QyxXQUFHMlcsY0FBTXJiO2tCQUNiLG1CQUVFcWxDLElBSEUzZ0MsVUFBRzJXOzRCQUFNcmI7O2dCQURoQjtZQWNlO1VBSko7UUFKSixlQVVrRDtlQVEzRDhaLFNBQVM1RSxFQUFFbXdCO1FBQ0MsbUJBREhud0IsRUFBRW13QixLQUNQLHVCQURLbndCO1FBQ0w7Y0FFSys5QixZQUFTLzJCLFlBQVNnM0I7VUFDdEIsbUJBSk03TixJQUdGNE4sY0FBUy8yQjtVQUVoQixHQUZ5QmczQjtnQkFJZEMsR0FKY0QsU0FJTC8yQixHQUpLKzJCLFNBSUlFLE1BSkpGO1lBS2xCLG1CQVJFN04sSUFPRThOLGNBQVNoM0I7WUFFaEIsR0FGeUJpM0I7a0JBSWRDLEdBSmNELFNBSUxFLEdBSktGLFNBSUlHLE1BSkpIO2NBS2xCLG1CQVpGL04sSUFXTWdPLGNBQVNDO3dCQUFTQzs7O3NCQWQxQjd1QyxXQUFHMlcsY0FBTXJiO2tCQUNiLG1CQUVNcWxDLElBSEYzZ0MsYUFBRzJXOzRCQUFNcmI7O2dCQURoQjtZQWNlO1VBSko7UUFKSixRQVUyRDtlQUVwRWsxQyxTQUFTaGdDLEVBQUVtd0I7UUFDYixTQUFRcU87VTtVQUFpQjs7a0JBR2RodkMsYUFBUXNKLGFBQUdoTztjQUNmLG1CQURJMEUsRUFKRTJnQyxlQUlNcjNCLEVBRUwsZUFGUWhPOzs7WUFEbEIsU0FJd0I7UUFDTCxtQkFSWmtWLEVBQUVtd0I7UUFRRSx1Q0FSSm53QixxQkFRNEI7ZUFVckN5K0IsUUFBUXorQixFQUFFbXdCLElBQUlocUI7UUFDUjtxQkFERW5HLEVBQUVtd0I7U0FDSix5QkFERW53QixLQUNONWdCO2VBQ0FxTzs7O2dCQVBTK0IsV0FBRzFFO1lBQ1QscUJBRE0wRSxFQUtEMmdDLGdCQUxJcmxDO1lBRVAsV0FHR3FsQztZQUhILFdBR09ocUI7Ozs7O1lBSWQsaUJBSlFuRyxLQUNONWdCLGVBRFErd0MsSUFBSWhxQixLQUVaMVk7WUFFRixPQUpRdVM7WUFJUixTQUpRQTtZQUlSLGVBRTJDLFNBM0YzQzI5QixVQXFGUTM5QjtZQUlSOzs7VUFyQnVCLFlBd0J0QjtlQUVEb0MsSUFBSXBDLEVBQUVtd0I7UUFNYzt3QkFOaEJud0IsRUFBRW13QjtTQU1NLHlCQU5SbndCOztRQUNrQjs7WUFJcEIsSUFET3hRLFdBQUcxRSxjQUNWLHFCQURPMEUsRUFKSDJnQztZQUtKO3NCQURVcmxDOztVQURWLFNBR2tDOztjQTdleEN3eEM7Y0FLQUc7Y0FPQUM7Y0EyQkFJO2NBcVdJNTdCO2NBb0JBbUI7Y0FVQWlDO2NBb0JBTTtjQWNBbzdCO2NBa0JBdkI7Y0FTQXI4QjtjQWhUSnU4QjtjQXNDQUk7Y0FZQUM7Y0FoTUFqQztjQWdPQW9DO2NBZ0JBRztjQWVBSztjQUVBQztjQUVBQztjQUdBQztjQUdBQztJQWxVRjtNLElBZ2hCVTN6QztlQUNBa0IsS0FBTW9zQyxLQUFZOTFDLEdBQUksdUJBQUpBLEVBQVk7OzZCQUQ5QndJLE1BQ0FrQjtPQXpKUnNhO09BQ0FnRjtPQUNBcXpCO09BQ0EvK0I7T0FDQW1CO09BQ0FpQztPQUNBTTtPQUNBbzdCO09BQ0F2QjtPQUNBcjhCO09BQ0EzYjtPQUNBczRDO09BQ0FyN0I7T0FDQWxXO09BQ0EyeEM7T0FDQXY1QjtPQUNBKzVCO09BQ0FDO09BQ0FwNkI7T0FDQXM2QjtPQUNBcDZCOztlQXVJSXpGLE9BQU9pZ0MsSUFBSyw0QkFBTEEsR0FBNEI7O2NBQW5DamdDO2NBM0pKMkg7Y0FDQWdGO2NBQ0FxekI7Y0FDQS8rQjtjQUNBbUI7Y0FDQWlDO2NBQ0FNO2NBQ0FvN0I7Y0FDQXZCO2NBQ0FyOEI7Y0FDQTNiO2NBQ0FzNEM7Y0FDQXI3QjtjQUNBbFc7Y0FDQTJ4QztjQUNBdjVCO2NBQ0ErNUI7Y0FDQUM7Y0FDQXA2QjtjQUNBczZCO2NBQ0FwNkI7SUE1WUY7OztPQWdCRTQyQjtPQUtBRztPQU9BQztPQTJCQUk7T0E2Q0FjO09BOEJBRTtPQW9CQVE7T0FjQUM7T0EyQkFHO09BdkVBcjhCO09BOERBbzhCO09BaUJBRTtPQXNDQUk7T0FZQUM7T0FoTUFqQztPQXJEQVo7T0FDQUM7T0FvUkErQztPQWdCQUc7T0FlQUs7T0FFQUM7T0FFQUM7T0FHQUM7T0FHQUM7OztPQXpXQXBFO09BRUFFO09BREFEOztJQXNDRjthQ3JDRXVFLFNBQU92OEMsR0FBSSxPQUFKQSxvQkFBNEM7YUFTbkR3OEMsT0FBS0MsR0FBR3Q1QyxJQUFJQyxJQUFJcEQ7TUFDbEIsUUFEVW1EO2VBQUlDO2NBQ3VCLFNBRDlCcTVDLE9BQUd0NUMsTUFBSUM7VUFHVCxVQUhLRCxNQUFJQztVQUdULGFBSEtEO2dCQUdMM0gsRUFISzJIO1lBS047NEJBTEdzNUMsR0FHRmpoRCxFQUhhd0U7Y0FLZCxTQUZDeEU7OztVQVpRO01BV1Isd0NBS0Y7O01BMkJlLElBQWRraEQsWUFBYztlQVlkQyxVQUFVL21DLEVBQUV3RyxHQUFJLGdCQUFKQSxlQUFGeEcsZ0JBQWlEO01BWjdDLElBY2Q2NkI7TUFkYyxTQWlCZHAwQixPQUFPaWdDO1FBQ1Q7bUJBRFNBO1NBRVQsd0JBRElNO1FBR007K0JBRk5DLEtBbkJGSDtnQkFzQlMsZUFIUEc7Z0JBTEZwTTs7a0JBWUQ7TUExQmUsU0E0QmR6c0IsTUFBTXBPO1FBQ1IsU0FEUUEsd0JBQ1I7OztVQUNFOzZCQUZNQSxLQUNScGEsWUE3QkVraEQ7WUErQkEsaUJBSE05bUMsS0FDUnBhO1lBRUUsU0FGRkE7OztRQUlBLE9BbkJFaTFDO1FBbUJGO2dCQUNlO01BbENDLFNBcUNkM3dCLEtBQUtwZ0IsRUFBRWtXLEVBQUV6QztRQUNYLFNBRFN5QyxLQUNUO1FBTWlCOzBCQU5LdlUsRUFBRXlKO3VCQUFKbEosTUFBSStDO21CQUN0QjtxQkFBUSxZQURZdEQsTUFBRk8sV0FBSStDO3FCQUVoQix3QkFGY3RELEVBQUZPO3FCQUVaO3VCQUNNOzt3QkFBb0Isa0JBSjNCbEMsRUFJRThELEVBSGVtQjt3QkFHVSxJQUhkL0M7O3dCQUFJK0M7O3FCQUVoQixJQUVJLElBSlEvQzs7O2lCQURUdVIsS0FPa0M7TUE1QzdCLFNBK0NkdFEsS0FBS25ELEVBQUVrVztRQUNULFNBRFNBLEtBQ1Q7UUFNVzswQkFOV3ZVO21CLElBQUZPO21CQUNsQjtxQkFBUSxZQURZUCxNQUFGTztxQkFFWix3QkFGY1AsRUFBRk87cUJBRVo7dUJBQ00sSUFBTDRCO3VCQUFLLFdBSlA5RCxFQUlFOEQ7dUJBQUssUUFITTVCOztxQkFFWixJQUVJLElBSlFBOztzQkFNYztNQXREbEIsU0FtRVZrN0MsYUFBYXRoRCxFQUFFNkYsRUFBRXNEO1lBQUovQyxNQUFJaUQ7UUFDdkI7VUFBUSxZQURheEQsTUFBRk8sV0FBSWlEO1VBRVU7Z0NBRlp4RCxFQUFGTztXQUFJa0o7V0FBSnFEOztXQUFJdEo7bUJBRW1DO01BckUxQyxTQXdFZDJoQixNQUFNNVE7UUFDUixnQkFEUUEsS0FDUjtRQUFpQjtxQyxPQU5Ya25DOztzQkFNcUM7TUF6RTNCLFNBa0lkQyxRQUFRbm5DLEVBQUVvbkMsT0FBTzluQyxFQUFFa0gsRUFBRTZnQztRQUN2QjttQ0FEVXJuQyxLQUFhcW5DO1NBQ3ZCLHdCQURVcm5DLEtBQWFxbkM7U0FHZCxZQUZMQztTQUdTcHlCO1FBQ1g7YUFGRXd4QixNQUNTeHhCO1lBR1A7YUFERXN5QjtjQUNGLFVBSkZkO1lBSUUsR0FERWMsU0FISmQ7YUFNb0I7WUFGbEI7YUFHYywyQkFKWmM7YUFJWSx5QkFKWkE7WUFNSixlQVhBRixXQVNJRyxZQVBKZjtZQVVBLE9BWEFhLFNBU0lHLFlBUkpoQjtZQVdBLFdBZFFVLE9BVUpLLFVBUEpmLEdBSGVwbkM7WUFlZixpQkFKSW9vQyxVQVJKaEIsY0FIaUJsZ0M7WUFnQmpCLGlCQWhCTXhHLEtBQWFxbkMsb0JBVWZJO1lBT0osaUJBakJNem5DLEtBQWFxbkMsb0JBV2ZLO1lBSkYsSUFVRixLQWRBaEIsTUFITTFtQyxTQWlCTixVQWpCTUEsT0FNRnduQztZQVlxQztxQkFsQm5DeG5DO2tCQW9CSm9WO2NBQTRCO2dCQXRFbEM7c0JBa0RVcFY7aUJBbERWLHdCQWtEVUE7aUJBbERWLEtBa0RVQTtpQkFsRFYseUJBa0RVQTtpQkFoREEsV0FGTnFrQztpQkFIVSxZQUFKOTRDO2lCQU9DLG9CQUpQODRDO2dCQUlPLEdBQVB3RCxRQURBRDtrQkFhTSxpQkFoQk52RCxnQkFNV3I0QyxNQUFFbU07a0JBQ2I7dUJBSkF5dkMsWUFHYXp2QztzQkFFUixtQkFSTGtzQyxPQU1XcjRDO3dCQUVjLFFBRmRBO3NCQUdELG1CQVRWcTRDLE9BTWFsc0M7d0JBSVQsZUFWSmtzQyxPQU1hbHNDLEVBTmJrc0MsT0FNV3I0Qzt3QkFLUSwwQkFWbkIyN0MsUUFLYXh2Qzt3QkFLVCxpQkFWSnd2QyxRQUtXMzdDO3dCQUtRLElBQWYsSUFMU21NLFVBS1QsSUFMT25NLG9CQUFFbU07O3NCQU9GLFFBUEVBOzs2QkFIYnl2QztzQkFjbUIsU0FpQ2I1bkM7c0JBaENOLGlCQWdDTUEsdUJBbElSOG1DO3NCQWlHcUIsU0FpQ2I5bUM7c0JBL0JOLGlCQStCTUE7O3NCQTdCTixrQkFyQkFxa0MsT0FHQXVEO3NCQW1CQSxrQkFyQkFELFFBRUFDO29CQW1Cd0MsU0E0QmxDNW5DLE9BckRBelUsTUF5QmtDLFVBbkJ4Q3E4QyxZQStDTTVuQztvQkExQnFDLFFBMEJyQ0E7O2dCQXhCVixnQkF3QlVBO2dCQWxEVixTQXNFTW9WOzs7WUFiQSxXQVBJcFY7WUFzQk47Y0ExQ0o7bUJBb0JVQTtlQXRESSxpQkFBSjNMO3VCQW1DTnVPO2dCQUVTLGdCQUZUQSxRQXJESixLQXdFVTVDLEtBeEVWO2dCQU1ZOzJCQU5VN0gsRUF3RFA2dkM7b0IsSUF4REtoOEM7b0JBQ2xCO3NCQUFRLFlBdURLZzhDLE9BeERLaDhDO3NCQUVaLDBCQXNET2c4QyxHQXhES2g4QztzQkFFWixnQkFFSyxRQUpPQTtzQkFFWjt1QkFDUSxvQkFxRU5nVSxLQXhFWTdIO3VCQXlEbEI7aUNBekRnQnZTO21DQXlEWndoRCxPQUFPZSxHQUFHQzs0QkFBTyxzQkFEVkosR0F4REtwaUQsRUF5REx1aUQsR0FBR0MsS0FBeUI7aUNBQW5DaEI7dUJBQUosZ0JBekRnQnA3Qzt1QkF5RGhCLG1CQURjaThDLEdBeERFajhDO3NCQTJEVyxRQUp6Qis3QyxLQUVFWCxTQUNBNWdDLEVBQ3VCLFVBSnpCdWhDLEtBR0V2aEM7c0JBeERBLElBRllsSTs7O2dCQXdFVjBCLE9BakJKK25DO2dCQWlCSS9uQyxPQWpCSituQztnQkFpQkkvbkMsT0FqQkorbkM7Z0JBaUJJL25DLE9BakJKK25DO2dCQWlCSS9uQyxxQkFqQkorbkM7O2NBWUcsTzVCMUZUaDlDO2M0QjBGUzs7WUE0QkU7VUFBRyxtQkF0QlZ1OEMsU0FHU3B5QjtZQW1CcUIsUUFuQnJCQTtVQXNCVCxXQTFCUWt5QixPQUNSRSxTQUdTcHlCLElBSk01VjtVQTBCZix3QkF4QkFpb0MsT0FFU3J5QixnQkFKUTFPLEVBOEJmO01BaEtVLFNBbUtka0IsSUFBSTFILEVBQUVWO1FBQ0EsSUFBSmtILEVBQUksZ0JBREFsSDtRQUVpQixlQUZuQlUsbUJBQUVWLEdBQ0prSCxFQUNxQixVQUZuQnhHLEVBQ0Z3RyxHQUNvQztNQXJLeEIsU0F3S2Q2aEMsUUFBUXJvQyxFQUFFVixFQUFFZ3BDO1FBQ047MkJBRElocEM7U0FFQSxnQkFGRlUsRUFDTndHO1NBQ1Esd0JBRkZ4RyxLQUVOcW5DO1NBQVEsd0JBRkZybkMsS0FFTnFuQztTQUdLLFlBRkxoRDtTQUdTeitDO1FBQ1g7YUFGRThnRCxNQUNTOWdELFNBQ0ssV0FQSjBpRCxXQUNWOWhDLEVBQ0E2Z0M7VUFNVSxHQVBWN2dDLE1BT1UsaUJBSlYrZ0MsT0FFUzNoRDtZQUdILDZCQU5OeStDLE9BR1N6K0M7WUFHSDtjQUNRLElBQVBnSTtjQUFPLG1CQUFQQSxFQVZDMFI7Z0JBV1UsMEJBUmxCK2tDLE9BR1N6K0M7Z0JBS1MsWUFDQSxJQUFMb2xCLGVBQUssT0FBTEE7Z0JBREssSUFFRixJQVBQcGxCOztZQUdILElBTUMsSUFURUE7O1VBVUYsUUFWRUE7bUJBWVA7TUExTFUsU0E2TGQ2WSxNQUFNdUIsRUFBRVY7UUFDVjtpQkFEUVU7aUJBQUVWOzBCQUNPa0gsRUFBRTZnQzttQkFBUyxRQURwQnJuQyxtQkFBRVYsR0FDT2tILEVBQUU2Z0MsT0FBUyxPQURsQi9uQyxDQUNtRCxFQUFDO01BOUw5QyxTQWlNZHdMLEtBQUs5SyxFQUFFVjtRQUFJLGVBQU5VLEVBQUVWLFdBQXFCa0gsRUFBRzZnQyxPQUFVLGVBQWUsRUFBQztNQWpNM0MsU0FtTWRqOEIsU0FBU3BMLEVBQUVWO1FBQ0w7MkJBREtBO1NBRUQsZ0JBRkRVLEVBQ1B3RztTQUNRLHdCQUZEeEcsS0FFUHFuQztTQUFRLHdCQUZEcm5DLEtBRVBxbkM7U0FHSyxZQUZMaEQ7U0FHU3orQztRQUNYO2FBRkU4Z0QsTUFDUzlnRDtVQUVDLEdBUFY0Z0IsTUFPVSxpQkFKVitnQyxPQUVTM2hEO1lBR0gsNkJBTk55K0MsT0FHU3orQztZQUdIO2NBQ1EsSUFBUGdJO2NBQU8sbUJBQVBBLEVBVkUwUjtnQkFXUyxJQUNWMEwsSUFEVSxjQVJsQnE1QixPQUdTeitDO2dCQUtTLEdBQ1ZvbEI7Z0JBRFUsSUFFRixJQVBQcGxCOztZQUdILElBTUMsSUFURUE7O1VBVUYsUUFWRUE7bUJBWVA7TUFyTlUsU0F3TmQyaUQsWUFBWXZvQyxFQUFFVixFQUFFa3BDLFFBQVFGO1FBQ2xCOzJCQURRaHBDO1NBRUosZ0JBRkVVLEVBQ1Z3RztTQUNRLHdCQUZFeEcsS0FFVnFuQztTQUFRLHdCQUZFcm5DLEtBRVZxbkM7U0FHSyxZQUZMaEQ7U0FHU3orQztRQUNYO2FBRkU4Z0QsTUFDUzlnRCxTQU5hMGlEO1VBUVosR0FQVjloQyxNQU9VLGlCQUpWK2dDLE9BRVMzaEQ7WUFHSCw2QkFOTnkrQyxPQUdTeitDO1lBR0g7Y0FDUSxJQUFQZ0k7Y0FBTyxtQkFBUEEsRUFWSzBSLFVBVWlCLFdBVmZrcEMsUUFHZG5FLE9BR1N6K0M7WUFHSCxJQUVDLElBTEVBOztVQU1GLFFBTkVBO21CQVFQO01BdE9VLFNBeU9kaWpCLE9BQU83SSxFQUFFVjtRQUFJOztpQkFBTlUsRUFBRVYsV0FBeUJ5aEIsRUFBRW43QixHQUFLLHFCQUFQbTdCLEVBQUVuN0IsSUFBaUIsT0FBSTtNQXpPM0MsU0E0T2RnakIsSUFBSTVJLEVBQUVWO1FBQUksOEJBQU5VLEVBQUVWLFdBQXlCeWhCLEVBQUduN0IsR0FBTSxRQUFJLE9BQU87TUE1T3JDLFNBK09kNGdELFNBQVN4bUMsRUFBRVY7UUFDTDsyQkFES0E7U0FFRCxnQkFGRFUsRUFDUHdHO1NBQ1Esd0JBRkR4RyxLQUVQcW5DO1NBQVEsd0JBRkRybkMsS0FFUHFuQztTQUdLLFlBRkxoRDtTQUdTeitDO1NBQUVtSjtRQUNiO2FBRkUyM0MsTUFDUzlnRCxTQUFFbUo7VUFFRCxHQVBWeVgsTUFPVSxpQkFKVitnQyxPQUVTM2hEO1lBR0gsNkJBTk55K0MsT0FHU3orQztZQUdIO2NBQ1EsSUFBUGdJO2NBQU8sbUJBQVBBLEVBVkUwUjtnQkFXUywwQkFSbEIra0MsT0FHU3orQztnQkFLUztrQkFDQTs7NkJBQUxvbEIsSUFORmpjO21CQU1PLElBTlRuSjs7bUJBQUVtSjs7Z0JBS08sSUFFRixJQVBQbko7O1lBR0gsSUFNQyxJQVRFQTs7VUFVRixRQVZFQTttQkFZSjtNQWpRTyxTQW9RZCsvQyxNQUFNM2xDO1FBQ1IsUUFEUUEsZ0JBRUcsV0FqVFgybUMsU0ErU1EzbUM7UUFHUixzQkFESXlvQztRQURKO1NBRUE7U0FDYTswQyw2QkFGVEE7U0FFUyxLQUhUajdDO1NBSTJDLEtBSjNDQTtTQUkyQyxzQkFIM0NpN0M7U0FHNkIsc0JBSDdCQTtTQUdtQixzQkFIbkJBO1FBR0UsVUFKRmo3QyxJQUlFLE1BTEV3UyxHQUlKMG9DLHNCQUN3RDtNQXpRNUM7Y0FpQmRqaUM7Y0FXQTJIO2NBaUtBM1A7Y0ExQkFpSjtjQXNFQW1CO2NBeENBaUM7Y0FFQU07Y0E0Q0FvN0I7Y0FIQTU5QjtjQTdMQTNiO2NBVkFpZDtjQW1DQTBHO2NBNExBKzBCOzs7OztPQS9TRmdCOzs7OztPQVNBQzs7OzthQ2tNQStCLFVBQVV2K0MsRUFBRXdrQjtNQUNkLFNBRFl4a0IsS0FDWixLQURjd2tCO01BQ2QsYUFEY0EsT0FDVi9oQixrQkFEVStoQixPQUNWL2hCLEVBRFUraEIsT0FDVi9oQixJQU13Qjs7YUFVMUIrN0MsV0FDQWg2QjtNQURhLFNBQ2JBO01BRGE7WUFDVXhrQixVQUFVZ0MsV0FBakN3aUIsT0FBaUN4aUIsZUFBakN3aUIsU0FHQSxPQUh1QnhrQjtNQUlRLGlCQUFpQjthQUloRHkrQyxXQUFXeG1DLE1BQU15bUM7TSxJQUFZdDdDLElBQVpzN0M7TUFBTnptQyx3QkFBa0I3VTthQTFCN0JtN0MsVUEwQmlCRyxNQUFOem1DO1FBOEJYMG1DO2FBR0FDLGlCQUFpQjNtQyxNQUFNcFk7TUFBSSxrQkFBVm9ZLFVBQU1wWSxJQUFJLHNCQUFKQSxHQUE2QzthQUNwRWcvQyxrQkFBa0I1bUMsT0FBUSxrQkFBUkEsWUFBK0I7YUFLakQ2bUMsZUFBZTdtQyxNQUFNMlIsT0FBTzJDO01BQzlCLGtCQURpQnRVO01BQ2pCOztlQURpQkEsV0FBYXNVLGFBQVAzQztPQUtMLGdCQUxEM1IsU0FHYnlxQjtNQUVjLFlBQWRxYztNQUFjLFdBTEQ5bUM7TUFIWSxrQkFHWkEsb0JBUTZCO2FBSTVDK21DLFdBQVcvbUMsTUFBTXNVLE9BQVEsc0JBQWR0VSxRQUFNc1UsTUFBb0M7YUFHckQweUIsZ0JBQWdCaG5DLE1BQU1zVTtNQUN4QixXQURrQnRVLFdBQU1zVSxVQW5CSyxrQkFtQlh0VSxVQUFNc1UsTUFFSTthQU0xQjJ5QixvQkFBb0JqbkM7TUFDdEIsU0FEc0JBO01BQ3RCOzs7U0FDc0JzVTtTQUFQNHlCO2NBRk9sbkMsV0FFQXNVOztVQUVsQixTQUZXNHlCLDBCQUtSLFdBUGVsbkMsTUFFQXNVOzs7O1FBTWQ7K0JBUmN0VSxNQVFTO2FBSTdCbW5DLGNBQWNubkM7TUFFVixxQkFGVUEsV0FFVjtrQkFGVUEsWUFHZTdVO01BRHpCLFdBRlU2VSxXQUdBdE87TUFEVixRQUd5RDthQVU3RDAxQyxnQkFBZ0JwbkMsTUFBTXRPO007OztVQXNDdEIsU0F0Q2dCc087VUFzQ2hCOzs7YUFDVXFuQzthQUNBQzt1QkFBUXArQyxFQUVacStDO2dCLEdBQUFBO3NCQUFLNzlDLEVBQUw2OUM7a0JBQW1CLDZCQUZQcitDLEVBRVpuQjs4QkFGWW1CLEVBRVpxK0M7Z0NBQWdELFFBRnBDcitDLEVBRVBRO2dCQURDLFVBRE1SO1lBR1Isa0JBM0NNOFcsd0JBdUNOcW5DO1lBSUE7VUFDRjs7VUFyQlIsU0F2QmdCcm5DO1VBdUJoQixTQUNhLElBQU51bkMsV0FBTSxXQUFOQSxHQUFNO1VBQ0w7O1VBT1IsU0FoQ2dCdm5DO1VBZ0NoQixTQUNhLElBQU53bkMsYUFBTSxXQUFOQSxLQUFNO1VBQ0w7O1VBb0NSLFNBdEVnQnhuQztVQXNFaEI7Z0NBQ2tCc1U7bUJBN0dsQnl5QixXQXNDZ0IvbUMsTUF1RUVzVTtVQUNWLHlCQXhFUXRVOztVQTRFaEIsU0E1RWdCQTtVQTRFaEIsWUFDSyxjQTdFV0E7O1VBOEdmLFNBOUdlQTtVQThHZjtZQUVlO2FBRER5bkM7YUFBWkM7YUFDYSxrQkFoSEExbkMsVUErR2IwbkM7WUFFQSxpQkFqSGExbkMsTUFnSFQybkM7WUFDSixXQUZZRjtZQUVaO1VBRU07Ozs7VUFoSFQsSUFEUTcvQztVQUNSLFdBSGdCb1ksV0FBTXRPO1VBSXRCLGlCQUpnQnNPLE1BRVJwWTtVQUVSOzs7Y0EyRWFnZ0QsYUFBSDErQyxnQkEvRU04Vzs7Z0NBaUZHd3RCLG1CQUFKdHBDOztxQkFrQkEsdUJBbkdDOGIsTUErRU45VztxQkFtQkssc0JBbEdDOFcsTUErRUg0bkMsSUFFTXBhO3FCQWVILHNCQWhHQXh0QixNQStFSDRuQyxJQUVNcGE7O2VBR2YsT0FwRll4dEIsV0FBTXRPO3dCQXFGYixlQXJGT3NPLE1BK0VING5DLElBRU1wYTt3QkFLVixnQkF0Rk94dEIsTUErRU45Vzs7ZUFVTixPQXpGWThXO3dCQXlGaUIsZ0JBekZqQkEsTUErRU45Vzt3QkEvRU04VyxXQUFNdE87MEJBMkZaLGVBM0ZNc08sTUErRUg0bkMsSUFFTXBhOzRCQWpGSHh0QixXQWlGR3d0QixlQUZOb2EsV0EvRUc1bkM7NEJBOEZQLGVBOUZPQSxNQStFSDRuQyxJQUVNcGE7NEJBY1YsZ0JBL0ZPeHRCLE1BK0VOOVc7c0JBa0JLLHVCQWpHQzhXLE1BK0VOOVc7VUFzQkY7OztXQXRETTIrQztXQUFINzFDO1dBQ1A4MUMsZ0JBaERZOW5DOzs7OzthQWtETituQzthQUNBdC9CO3VCQUFLdmY7Z0I7Ozt3QkFDSlEsYUFBTDNCO29CQUFhLHFCQUFiQSxFQURTbUIsVUFDVG5CO2dDQUFLMkI7O2tCQUNDO2tCQUhGcStDOztjQU9KLElBREFoZ0Q7Y0FDQTtnQkFDTSxjQVZSKy9DLGdCQUVNQyxXQU1KeFI7Ozs7O2NBQ0EsSUFIQXlSLElBRUF6Ujs7aUJBRkF5UixJQU5GRjtZQWNGLElBQUluMkIsT0FSQXEyQixNQU5GRjtZQWNGLFlBQUluMkI7cUJBRUMsZ0JBaEVTM1IsTUE4RFYyUixTQWZLM2Y7cUJBa0JKLGVBakVTZ08sTUFzRFZnb0MsTUFQUUgsVUEvQ0U3bkM7VUFrRVI7OztXQTNET3NlO1dBQUwycEI7V0FDTkMsa0JBUllsb0M7d0JBUVprb0Msa0JBR0Ysb0JBWGNsb0M7VUFXcUI7b0JBWHJCQSxXQU9OaW9DO1dBSTJCLGNBSnRCM3BCLE9BUEN0ZSxXQUFNdE8sS0FPUDRzQjtVQVlmLGlCQU5JOHBCLFFBREFELFVBWllub0M7VUFtQmhCO2dCQVVBLElBRFVxb0MsY0FDVixjQURVQSxLQTVCTXJvQyxVQTZCaEI7O1VBNEVDLHdCQUFhLG9CQXpHRUEsVUF3R0hzb0M7VUFFWixpQkExR2V0b0MsTUF5R1h1b0M7VUFDSixjQUZZRCxXQXhHR3RvQztVQTBHZjthQW1CR3dvQyxhQUFheG9DO01BQ25CO1FBck9lLFNBb09JQTtRQXBPSjtVQUNpQzs7V0FzTzFDdE8sS0F0T21CM0o7V0FxT2tCb0QsSUFyT2xCcEQ7V0FxT0lxYixJQXJPSnJiO2dCQXNPbkIySjtzQkFIYXNPO1dBT1o7O1lBQ0ksV0FSUUE7WUFRUixJQUxMeW9DLHNCQTNMSi9CO1lBaU1FLGdCQVRlMW1DLE1BR2J5b0MsT0FEdUJybEM7WUFPekIsWUFQdUNqWSxNQUZ4QjZVOzs7UUFsT2Msa0JBOE81QjthQUdIMG9DLGFBQWExb0M7TUFDZjtRQUFJLHNCQURXQTs7OzttQkFFSTthQUlqQjJvQyxnQkFBZ0Izb0MsTUFBTW9EO01BQU0sV0FBWnBELE1BQU1vRCxLQUFNLG9CQUFacEQsTUFBb0Q7YUFRcEU0b0Msa0JBQWtCNW9DLE1BQU10TyxLQUFLOUo7TUFFVCx1QkFGRm9ZLFNBQU10TyxRQUFLOUosR0FBTDhKLE1BRWtDO0lBYS9DLG9EQUFUbTNDO0lBQVMsU0FLWEUsaUJBQWlCL29DLE9BQVEsV0FOekI4b0Msa0JBTXlCLFFBQXdDO0lBTHRELFNBZ0JYRSxTQUFTaHBDLE1BQU05YjtNQUNqQixTQURXOGI7TUFDWDs7O1NBR0tpcEM7U0FEQUM7U0FFQ3gzQyxLQUREdTNDO1NBQW1FdHJDO1NBQXRDeUYsSUFBN0I2bEM7V0FEQUMsV0FITWxwQyxpQkFPOEIsaUJBUDlCQTtRQVFQLFVBSjhCb0Q7U0FJOUIsT0FKOEJBOztZQVk1QjtzQkFoQldsZjthQWdCWDtvQkFaRCtrRCxnQkFKTWpwQyxZQUtMdE8sU0FMS3NPLFdBSTZEckM7WUFNbEU7Ozs7O2NBVld6WixJQUlaK2tELGdCQUpNanBDLFlBS0x0TyxTQUxLc08sV0FJNkRyQyxLQUp2RHpaO1lBd0JYOzs7TUFFRSxRQUFFO0lBMUNHLFNBK0NYaWxELFVBQVVucEMsTUFBTTVXLEVBQUVnYTtNQUNwQixXQURZcEQsTUFBUW9EO01BQ3BCLEdBRGtCaGEsRUFFUixTQUZFNFc7TUFFaUIsaUJBRmpCQSxVQUFRb0QsS0FBUnBEO01BRWlCLFFBRWlDO0lBbkRqRCxTQXlEWG9wQyxnQkFBZ0JwcEMsTUFBTXlxQixPQUFPNGU7TUFDL0IsWUFEa0JycEM7TUFDbEIsR0FEa0JBO1FBSWQsSUFERXNwQyxVQUhZdHBDLGlCQUFNeXFCLE9BQU80ZTtRQUkzQixpQkFKY3JwQyxRQUdac3BDO01BTU4sU0FUa0J0cEM7TUFTbEI7UUFDSyxTQVZhQSxVQWxFbEI7aUNBa0VrQkEsTUFsRWQ3VTtpQkE0RXVDO0lBbkU5QixTQTBFWG8rQyxhQUFhdnBDO01BQ2YsYUFEZUE7TUFDZjtRQUNBLEdBRmVBO1VBS1gsV0FMV0EsaUJBT1gsU0FQV0EsU0FPVSxTQVBWQTtRQU84QixZQVA5QkE7Ozs7TUFIVyxXQWF2QjtJQXBGVSxTQXdGWHdwQyxZQUFZeHBDLE1BQU0wbkM7TUFDcEIsR0FEYzFuQztRQUVkLGNBRm9CMG5DLFNBQU4xbkMsVUFJWixXQUpZQSxVQUFNMG5DO01BSWMsU0FKcEIxbkM7TUFJb0IsWUFHaEMsV0FQWUEsY0FBTTBuQyxrQkFXakI7SUFuR1UsU0F1R1grQixhQUFhenBDO01BQ2YsR0FEZUEsVUFFYixXQUZhQTtNQU1aLFNBTllBO01BTVo7UUFFSCxTQVJlQTtRQVFmO2NBRWdCeW5DLGFBQVpDO1VBQ0EsV0FYVzFuQyxVQVVYMG5DO1VBQ0EsV0FEWUQ7VUFDWjtRQUhKOzs7aUJBTUc7SUFySFUsU0F3SFhpQyxrQkFBa0IxcEMsTUFBTTVXLEdBQUksWUFBSkEsRUFBSSxRQUF3QjtJQXhIekMsU0F5SFh1Z0QsaUJBQWlCM3BDLE1BQU01VyxHQUFJLFlBQUpBLEVBQUksUUFBdUI7SUF6SHZDLFNBMEhYd2dELGtCQUFrQjVwQyxhQUFXLE9BQVhBLFNBQThCO0lBMUhyQyxTQTJIWDZwQyxpQkFBaUI3cEMsYUFBVyxPQUFYQSxTQUE2QjtJQTNIbkMsU0E0SFg4cEMsWUFBWTlwQyxNQUFNNVc7TUFDcEIsa0JBRGM0VyxNQUFNNVcsR0FDcEIsd0JBRGM0VyxNQUFNNVcsRUFDK0I7SUE3SHRDLFNBaUlYMmdELCtCQUErQi9wQztNQUFXLFVBQVhBLHdDQUtsQztJQXRJYyxTQXlJWGdxQywrQkFBK0JocUM7VUFJWmlxQyxhQUREQyxhQURBQyxhQUREQztNQURjcHFDLFlBQ2RvcUM7TUFEY3BxQyxZQUVibXFDO01BRmFucUMsWUFHYmtxQztNQUhhbHFDLFlBSVppcUM7O0lBN0lSLFNBc0pYSSxTQUFTcnFDO01BbFpYOztlQWtaV0E7TUFwYk87O01Bc2JsQixpQkFGV0E7TUFFWDs7Ozs7O2lCQUZXQTtNQS9FZSx1QkErRWZBLFVBVVU7SUFoS1IsU0F5S1hzcUMsZUFBZXRxQyxNQUFNNVc7TUFOdkIsU0FNaUI0VztNQU5qQix1QkFDWSxvQkFLS0EsUUFMZ0I7TUFRVjtlQUhOQSxXQUdmLGFBSGVBO1FBS2pCLFlBbFpFMG1DO1FBbVpGLGFBTmlCMW1DO1FBTWpCLEdBTnVCNVcsRUFPYixrQkFQTzRXO1FBT2dCLGdCQVBoQkEsT0FRSDtJQWpMRCxTQTBMWHVxQyxpQkFBaUJ2cUMsTUFBTXRPLEtBQUs5SjtNQUM5QixTQURtQm9ZO01BQ25CLFlBQ0ssa0JBRmNBLE1BQU10TyxLQUFLOUosT0FFSztJQTVMdEIsU0ErTFg0aUQsWUFBWXhxQyxNQUFNeXFDLE1BQU03aUQ7TUFDMUIsd0JBRGNvWSxNQUFNeXFDLE1BQU03aUQsRUFDa0I7SUFoTS9CLFNBbU1YOGlELGdCQUFnQjFxQyxNQUFNcFk7TUFDeEIsbUJBRGtCb1ksTUFDbEIsc0JBRHdCcFksS0FDYTtJQXBNeEIsU0F3TVgraUQsYUFBYTNxQyxNQUFNemM7TUFBMEIsdUJBQWhDeWMsTUFBZ0MscUJBQTFCemMsR0FBMkM7SUF4TW5ELFNBMk1YcW5ELGVBQWU1cUMsTUFBTXZZO01BQTBCLHVCQUFoQ3VZLE1BQWdDLGdCQUExQnZZLEdBQTZDO0lBM012RCxTQThNWG9qRCxjQUFjN3FDLE1BQU01VztNQUEwQix1QkFBaEM0VyxNQUFnQyxlQUExQjVXLEdBQTRDO0lBOU1yRCxTQWlOWDBoRCxjQUFjOXFDLE1BQU14VixHQUNGLG1CQURKd1YsUUFDSSxTQURFeFYsR0FDZTtJQWxOeEIsU0FzTlh1Z0QsYUFBYS9xQyxhQUFXLHVCQUFYQSxVQUEwQztJQXRONUMsU0F1TlhnckMsYUFBYWhyQyxNQUFNeXFCO01BQVMsdUJBQWZ6cUIsTUFBTXlxQixTQUE2QztJQXZOckQsU0F5Tlh3Z0IsY0FBY2pyQyxNQUFNeXFCO01BQVMsdUJBQWZ6cUIsTUFBTXlxQixTQUE4QztJQXpOdkQsU0EwTlh5Z0IsZUFBZWxyQyxNQUFNeXFCO01BQVMsdUJBQWZ6cUIsTUFBTXlxQixTQUErQztJQTFOekQsU0EyTlgwZ0IsWUFBWW5yQyxNQUFNeXFCLFFBQVMsdUJBQWZ6cUIsTUFBTXlxQixTQUE0QztJQTNObkQsU0FzT1gyZ0IsaUJBQWlCcHJDO01BQ25CLGVBRG1CQSxTQUNuQixrQkFEbUJBLFlBQzZCO0lBdk9uQyxTQXdPWHFyQyxlQUFlcnJDO01BQ2pCLGVBRGlCQSxTQUNqQixrQkFEaUJBLFlBQ2dDO0lBek9wQyxTQTZPWHNyQyxpQkFBaUJ0ckM7TUFDbkIsU0FEbUJBO01BQ25CLFlBQ3dCLGdCQUZMQSxxQkFFbUQ7SUEvT3pELFNBbVBYdXJDLG9CQUFvQnZyQztNQUN0QixTQURzQkE7TUFDdEIsWUFDd0IsZ0JBRkZBLHFCQUVtRDtJQXJQNUQsU0E0UFh3ckMsZUFBZXhyQyxNQUFNc1UsTUFBTTNDO01BQzdCLFNBRGlCM1I7TUFDakI7UUFFSSxJQURFc3BDLFVBRld0cEMsaUJBQU1zVSxNQUFNM0MsUUFBTjJDO1FBR25CLGlCQUhhdFUsUUFFWHNwQztpQkFLcUI7SUFuUWQsU0EyUVhtQyxlQUFlenJDLGFBQVcsc0JBQVhBLFVBQW1DO0lBM1F2QyxTQTRRWDByQyxhQUFhMXJDLGFBQVcsc0JBQVhBLFVBQW1DO0lBNVFyQyxTQWdSWDJyQyxhQUFhM3JDO01BQ2YsWUFEZUE7TUFDZixTQURlQTtNQUNmO1FBR0ksSUFERXNwQywyQkFDRix1QkFKV3RwQyxNQUdUc3BDO2lCQUVzQjtJQXJSZixTQXlSWHNDLGNBQWM1ckM7TUFDaEIsYUFEZ0JBO01BQ2hCO1FBQ0EsU0FGZ0JBO1FBRWhCO1VBRWMsSUFBUHNwQztVQUNKLGdCQUxhdHBDLE1BSVRzcEM7VUFDSixZQUxhdHBDO1VBSUY7Ozs7O2lCQUdYO0lBaFNVLFNBb1NYNnJDLGdCQUFnQjdyQyxNQUFNc1UsTUFBTTNDO01BQzlCLFNBRGtCM1I7TUFDbEI7UUFFSSxJQURFc3BDLFVBRll0cEMsaUJBQU1zVSxNQUFNM0MsUUFBTjJDO1FBR3BCLGlCQUhjdFUsUUFFWnNwQztpQkFLcUI7SUEzU2QsU0E4U1h3QyxhQUFhOXJDLGFBQVcsdUJBQVhBLFVBQW9DO0lBOVN0QyxTQWdUWCtyQyxXQUFXL3JDO01BQ2IsU0FEYUE7TUFDYixTQUVJLElBREVzcEMsZUFDRix1QkFIU3RwQyxNQUVQc3BDO2lCQUVzQjtJQXBUZixTQThUWDBDLGlCQUFpQmhzQyxNQUFNOVc7TUFBSSxhQUFKQSxNQUFJLFdBQVY4VyxZQUFNOVcscUJBQXlDO0lBOVRyRCxTQWlVWCtpRCxpQkFBaUJqc0MsYUFBVyxPQUFYQSxTQUE2QjtJQWpVbkMsU0FtVVhrc0Msa0JBQWtCbHNDO01BQVcsT0FBWEEsMkJBQW1EO0lBblUxRCxTQXNVWG1zQyxxQkFBcUJuc0MsTUFBTXBZLEdBQUksWUFBSkEsRUFBSSxRQUFzQjtJQXRVMUMsU0F1VVh3a0QscUJBQXFCcHNDLGFBQVcsT0FBWEEsU0FBNEI7SUF2VXRDLFNBMlVYcXNDLFNBQVNuakQsR0FDWCxPQURXQSwyQkFDb0M7SUE1VWxDLFNBMlZYb2pELGtCQUFrQnRzQyxNQUFNaE87TUFDMUIsUUFEb0JnTyxXQUFNaE8sUUFWMUIsVUFEOEJFO01BQzlCO1FBQ1UsSUFBSmhKLEVBQUksU0FGb0JnSjtRQUVwQixXQUFKaEo7UUFBSSxXQVNVOFc7UUFUVixnQkFTVUE7TUFmcEIsV0FnQmlEO0lBNVZwQyxTQStWWHVzQyxrQkFBa0J2c0MsYUFBVyxPQUFYQSxRQUE4QjtJQS9WckMsU0FpV1h3c0MsY0FBY3hzQyxNQUFNOVc7TUFDdEIsY0FEc0JBO01BQ3RCO1FBQ1UsSUFBSjhJLElBQUksU0FGWTlJO1FBRVosV0FBSjhJO1FBQUk7U0FFSnk2QztVQUpVenNDOztZQVdYLElBQUksSUFYT0E7UUFZc0IseUJBWnRCQSxNQUlWeXNDO2lCQVVrQztJQS9XM0IsU0FrWFhDLGNBQWMxc0MsYUFBVyxPQUFYQSxRQUEwQjtJQWxYN0IsU0FxWFgyc0MsK0JBQStCM3NDO1VBS2hCbEssV0FEQXZTLFdBREM0Z0IsV0FERjNWLFdBREMvRztNQURnQnVZLFlBQ2hCdlk7TUFEZ0J1WSxZQUVqQnhSO01BRmlCd1IsWUFHZm1FO01BSGVuRSxZQUloQnpjO01BSmdCeWMsWUFLaEJsSzs7SUExWEosU0FrWVg4MkMsK0JBQStCNXNDO01BQVcsVUFBWEEsa0RBTWxDO0lBeFljLFNBNFlYNnNDLGtDQUFrQzdzQyxNQUFNdlksRUFBRStHO01BQzVDLFlBRDBDL0csRUFDMUMsWUFENEMrRyxFQUM1QyxRQUFpRDtJQTdZcEMsU0ErWVhzK0Msa0NBQWtDOXNDO01BQ3BDLFVBRG9DQSxvQkFDSztJQWhaNUIsU0FvWlgrc0MsZ0JBQWdCL3NDO01BQVcsa0JBQVhBLHFCQUF3QztJQUczQyxJQUFiZ3RDLFdBQWE7YUFXYkMsZUFWbUJqdEMsTUFBTTlXO00sSUFBQThJO01BQzNCO3FCQUQyQkE7UUFDM0I7VUFDQSxRQUYyQkE7WUFJekIsV0FKbUJnTyxVQURuQmd0QztZQUtBLFFBSnlCaDdDOztVQUVYLGtCQUZLZ08sVUFEbkJndEMsYUFDeUJoN0M7b0JBTXhCO0lBUFksU0FlYms3Qyw2QkFBNkJsdEMsTUFBTWpWO01BQ2Q7OytCLE83QjlqQnJCSyxpQjZCNmpCbUNMO01BQ2QsNEJBQ1UscUJBRklBLEdBRUk7TUFDakIsMkIsT0FyQnRCZ2lELGdCQWtCNkIvc0M7TUFJUiwyQixPQVJyQml0QyxlQUk2Qmp0QztNQUtSLDJCLE9BVHJCaXRDLGVBSTZCanRDO01BS1IsUUFBb0I7SUFwQjVCLFNBNEJibXRDLHlCQUF5QnZsRCxHQUFVLHNCQUFWQSxVQUFpQjtJQTVCN0IsU0E2QmJ3bEQsMEJBQTBCeGxELEdBQVcsc0JBQVhBLFVBQWtCO0lBN0IvQixTQStCYnlsRCxnQztJQS9CYSxTQWdDYkMsaUM7SUFoQ2EsU0FvQ2JDLGtCQUFrQjlsRCxFQUFFK0csRUFBRTJWLEVBQUU1Z0IsRUFBRXVTO01BM3RCVixxQkErdEJoQjtNQUNGLFVBRkkyM0MsUUFEQUQ7TUE3dEJjLElBaXVCZEUsdUJBSEFELFNBL2JGM0U7TUFpY0Y7Y0FDSTRFOzs7Ozs7Ozs7Ozs7OztjN0IxMUJGaGxEOztjNkJvMUJrQmpCO2NBQUUrRztjQUFFMlY7Y0FBRTVnQjtjQUFFdVM7OztjQVIxQnEzQztjQUNBQztjQUVBQztjQUNBQztjQU1FRSxTQXFDSDtJQTNFYyxTQStFYkcsMkJBQTJCQztNQUM3QjtlQUQ2QkEsNERBTVI7SUFyRk4sU0EwRmJDLGVBQWU1aUQsT0FBTzZpRDtNQUN4QixvQjtNQUFBLG9CO01BQVU7T0FBTkM7UUFBTSxrQkFETzlpRCxPQUFPNmlELHFCO01BRUYseUIsT0EvRnBCZixnQkE4RkVnQjtNQUVpQix5QixPQWxGbkJkLGVBZ0ZFYztNQUdpQix5QixPQW5GbkJkLGVBZ0ZFYztNQUdpQixPQUhqQkEsR0FJRDtJQS9GWSxTQW1HYkMseUJBQXlCampEO01BQzNCLHFCQUFnRCxxQkFEckJBLEdBQzZCO01BQXpDOztpQixPN0JscEJiSyxpQjZCaXBCeUJMO29CQUM4QjtJQXBHMUMsU0F3R2JrakQsb0JBQW9CN2tEO01BQ3RCLG9CO01BQWU7O2lCLE9SLzFCYnNvQixjUTgxQm9CdG9CO29CQUN3QjtJQXpHL0IsSUErR2I4a0Q7SUEvR2EsU0FnSGJDLHNCQUFvQixnQkFEcEJELGVBQ2dEO0lBR3ZDOztLQUlPO0tBQ0E7S0FDQSxrQ0FOaEJFO0lBTWdCLFNBT2hCSSx1QkFBdUIvaEQsSUFBSXNoRDtNQUM3QixlQUQ2QkEsT0FFckIsSUFBSm5tRCxFQUFJLFNBRmlCNkUsS0FHekIsTUFIeUJBLEtBR3pCLE9BREk3RSxDQUVIO0lBWGlCLFNBZWhCNm1EO01BQXlCLDhCQXJCekJMLE9BTUFHLGNBZW9FO0lBZnBELFNBeUNoQkcsbUNBQ0YsWUFBaUM7SUExQ2YsU0E0Q2hCQyw2QkFBNkJDLEtBQy9CLG1CQUFrQztJQTdDaEIsU0ErQ2hCQywyQkFBMkJELEtBQzdCLFdBRDZCQSxPQUNRO0lBaERuQixTQWtEaEJFLDZCQUE2QkY7TUFDbkIsSUFBUkcsTUFBUSwyQkFEbUJIO01BRS9CLDZCQUYrQkE7TUFFL0IsT0FESUcsS0FFQztJQXJEYSxTQXVEaEJDLHlCQUF5QkosSUFBSUs7TUFDL0IsWUFEK0JBLEtBQUpMLFFBQzNCLFFBQW9FO0lBeERsRCxTQTBEaEJNLG9DQUFvQ047TUFZOUIsU0FBSm5uRCxFQVBvQkcsRUFBRXJFLEVBQUUyRixHQUNrQixnQ0FOUjBsRCxPQU1RLE1BRHRCaG5ELEVBQUVyRSxFQUFFMkY7TUFRcEIsU0FBSnNGLFFBWEYsZ0NBRm9Db2dEO01BYzlCLFNBQUp6cUMsUUFWRixnQ0FKb0N5cUM7TUFlOUIsU0FBSnJyRCxFQVJvQjJGLEdBQ3RCLGdDQVJvQzBsRCxPQU9kMWxEO01BU2hCLFNBQUo0TSxFQVBvQjVNLEdBQ3RCLGdDQVZvQzBsRCxPQVNkMWxEO01BT2hCLHlCQUpKekIsRUFDQStHLEVBQ0EyVixFQUNBNWdCLEVBQ0F1UyxFQUN1QjtJQVNiLFNBQVpxNUMsZ0IsT0E5WUFwRSxhQXdUQXNEO0lBdUZZLFNBQVplLGdCLE9BOVlBcEUsYUF1VEFxRDtJQXdGYSxTQUFiZ0IsaUIsT0E3WUFwRSxjQXFUQW9EO0lBeUZjLFNBQWRpQixrQixPQTdZQXBFLGVBb1RBbUQ7SUEwRlcsU0FBWGtCLGUsT0E3WUFwRSxZQW1UQWtEO0lBMkZZLFNBQVptQixnQixPQS9oQkFqRyxhQW9jQThFO0lBNEZXLFNBQVhvQixlLE9BbGhCQWpHLFlBc2JBNkU7SUE2RlksU0FBWnFCLGdCLE9BcGdCQWpHLGFBdWFBNEU7SUE4RlcsU0FBWHNCLG9CLE9BN2FBbkYsWUErVUE2RDtJQStGZSxTQUFmdUIscUIsT0ExYUFsRixnQkEyVUEyRDtJQWdHWSxTQUFad0Isa0IsT0F0YUFsRixhQXNVQTBEO0lBaUdjLFNBQWR5QixvQixPQXBhQWxGLGVBbVVBeUQ7SUFrR2EsU0FBYjBCLG1CLE9BL1pBakYsY0E2VEF1RDtJQW1HYSxTQUFiMkIsaUIsT0FuYUFuRixjQWdVQXdEO0lBb0djLFNBQWQ0QjtNLE9BdFhBekUsZUFrUkE2QztJQXFHWSxTQUFaNkIsZ0IsT0F2V0F4RSxhQWtRQTJDO0lBc0djLFNBQWQ4QixrQixPQXpXQTFFLGVBbVFBNEM7SUF1R2dCLFNBQWhCK0Isb0IsT0F4WUE5RSxpQkFpU0ErQztJQXdHYyxTQUFkZ0Msa0IsT0E5WUFoRixlQXNTQWdEO0lBeUdnQixTQUFoQmlDO00sT0FqWkFsRixpQkF3U0FpRDtJQTBHbUIsU0FBbkJrQztNLE9BcllBaEYsb0JBMlJBOEM7SUE0R1ksU0FBWm1DLGdCLE9BMVdBN0UsYUE4UEEwQztJQTZHYSxTQUFib0MsaUIsT0FsV0E3RSxjQXFQQXlDO0lBOEdlLFNBQWZxQztNLE9BeFZBN0UsZ0JBME9Bd0M7SUFnSFUsU0FBVnNDLGMsT0E5VUE1RSxXQThOQXNDO0lBaUhZLFNBQVp1QyxnQixPQWpWQTlFLGFBZ09BdUM7SUFtSGEsU0FBYndDLGlCLE9BaFNBckUsY0E2S0E2QjtJQW9IYSxTQUFieUMsaUIsT0FwSEF6QztJQXNIaUIsU0FBakIwQztNLE9BelNBekUsa0JBbUxBK0I7SUF1SGlCLFNBQWpCMkMscUIsT0F2SEEzQztJQXlIZ0IsU0FBaEI0QyxvQixPQXpVQWpGLGlCQWdOQXFDO0lBMEhnQixTQUFoQjZDLG9CLE9BMUhBN0M7SUEySGlCLFNBQWpCOEM7TSxPQXRVQWpGLGtCQTJNQW1DO0lBNkhvQixTQUFwQitDO00sT0FyVUFqRixxQkF3TUFrQztJQThIb0IsU0FBcEJnRCx3QixPQTlIQWhEO0lBaUlGLFNBREVpRDtNLE9BeE9BcEUsNkJBd0dBbUI7SUFvSUYsU0FERWtEO00sT0E1UkE1RSwrQkF5SkEwQjtJQXNJRixTQURFbUQ7TSxPQWpSQTVFLCtCQTRJQXlCO0lBeUlGLFNBREVvRDtNLE9BMVFBNUUsa0NBa0lBd0I7SUEySUYsU0FERXFEO00sT0F6UUE1RSxrQ0ErSEF1QjtJQThJRixTQURFc0Q7TSxPQWxoQkEzSCwrQkFxWUFxRTtJQWdKRixTQURFdUQ7TSxPQTVoQkE3SCwrQkE2WUFzRTtJQWtKRixTQURFd0Q7TSxPQXZpQkFuSSxrQkFzWkEyRTtJQW9KRixTQURFeUQscUIsT0FuSkF6RDtJQXNKRixTQURFMEQsb0IsT0ExaUJBcEksaUJBcVpBMEU7SUF3SkYsU0FERTJELG9CLE9BdkpBM0Q7SUEwSkYsU0FERTRELGUsT0EzaUJBbkksWUFrWkF1RTtJQTBKRixTQU1NNkQsY0FBZ0I5YyxJQUF1QitjLEtBQUtwRTtVQUE1QnFFOztpQkFBUyxRQUFUQSxnQkFBUzNhLGFBQVQ0YSxPQWxhcEIzRztRQWthc0Q7OztZQUl0RCxXQUoyQ3lHLEtBQUtwRTtZQUtoRCxXQUxvQnNFLE9BQTRCdEU7WUFLaEQsYUFMb0JzRTs7VUFFYixrQkFGb0NGLEtBQUtwRTtRQUMxQztJQVBSLFNBZUV3RSxjQUFjeEUsSUFBSW5tRDtNQUNwQiw4QkFEb0JBLEdBQ3BCO2VBR0lrbUQ7UUFDRixnQkFMY0MsSUFLTSxNQUxGbm1ELEVBRWhCdU4sUUFDQUMsV0FEQUQ7UUFHRjtrQkFGRUM7UUFFRixRQUMyQjs7V0FIekJBLGFBRkFqSztVQVFJLDBCQVRZdkQsRUFHaEJ3TjtVQU1JO1lBRUYsU0FDQSxpQkFaVTI0Qzs7NEJBY1YsU0FBVSxlQWRBQSxZQUdaMzRDOztRQWdCSixTQWpCSUQsWUFEQWhLO1FBa0JKLFlBQXFCLGNBQVE7SUFsQzdCLFNBc0NFcW5ELFlBQVl2bkQsT0FBT3duRDtNQUNYLHFCQUNBLHdCQUROaG1EO01BRUosV0FIY3hCLE9BRVY4aUQsSUFGaUIwRTtNQUlyQixlQUZJMUU7TUFETSxJQUlONWlELElBSkFzQjtNQUlNLFlBQU50QixJQUVDLE1BTkRzQixNQUlBdEIsYUFDWSxTQUxac0IsSUFNMkI7SUE3Qy9CLFNBMERFaW1ELHNCQUFzQjNFLElBQUlubkQ7TUFBYSxVQUFiQTtPQUFhLE9BQWJBO2dCQUNHLG9CQURQbW5EO2dCQUVPLG9CQUZQQTtnQkFJTyxzQkFKUEE7Z0JBS08sd0JBTFBBO2dCQU1PLHdCQU5QQTtnQkFRTyxxQkFSUEE7aUJBU08scUJBVFBBOztPQUFpQixPQUFibm5EOztjQUdUK3FCLE9BSFMvcUIsY0FHaEIwdEIsTUFIZ0IxdEI7aUJBdGUxQjRrRCxlQXNlc0J1QyxJQUdaejVCLE1BQU8zQztnQkFJWTs7Y0FHbEJubkIsRUFWZTVEO1VBVUcsY0FWUG1uRDtVQVVPLHFCQVZQQSxJQVVYdmpELEdBQTREO0lBcEV6RSxTQTBFTW1vRCxhQUFXNUUsSUFBSXArQztNQUFNLFVBQU5BO09BMEJTOztPQTFCSCxPQUFOQTs7Y0FTSWxJLEVBVEprSSxPQVNDcUQsRUFURHJEO1VBVW5CLGFBVmVvK0MsSUFTSy82QztVQUNwQiw2QkFWZSs2QyxJQVNRdG1EOzttQkFUSmtJOztZQWFuQixJQURvQ0M7WUFDcEMsYUFiZW0rQztZQWNDLG1CQWREQSxJQWNDLFlBZFo0RSxhQVlnQy9pRDtjQUdBQztVQUNwQyxhQWhCZWsrQztVQWlCSztvQ0FBbUIsWUFqQm5DNEUsYUFlZ0M5aUQ7V0FFaEI7O2lDQWpCTGsrQyxJQWlCVnRqQixPQUFRbW9COzttQkFqQk1qakQ7Ozs7Ozs7Ozs7O2dCQUMrQ0ksSUFEL0NKO2dCQUN1QytCO2dCQUFsQm8yQjs7Ozs7Ozs7OzBCQWtCakJsZ0MsRUFuQkorSCxPQW1CQ2s0Qjs7O21CQW5CRGw0Qjs7Ozs7Ozs7Ozs7Z0JBSzZDNEUsSUFMN0M1RTtnQkFLcUM4NEM7Z0JBQWxCaGY7Ozs7Ozs7OzswQkFnQmpCai9CLEVBckJGbUYsT0FxQkQ2NUI7OzttQkFyQkM3NUI7Ozs7Ozs7Ozs7O2dCQUMrQ0ksSUFEL0NKO2dCQUN1QytCO2dCQUFsQm8yQjs7Ozs7Ozs7OzBCQWtCakJsZ0MsRUFuQkorSCxPQW1CQ2s0Qjs7O21CQW5CRGw0Qjs7Ozs7Ozs7Ozs7Z0JBSzZDNEUsSUFMN0M1RTtnQkFLcUM4NEM7Z0JBQWxCaGY7Ozs7Ozs7OzswQkFnQmpCai9CLEVBckJGbUYsT0FxQkQ2NUI7OztjQUVKeU0sSUF2Qkt0bUMsT0F1QlJnNkIsSUF2QlFoNkI7VUF1QlMsYUF2QmJvK0MsSUF1Qkpwa0I7VUFBaUIsa0JBQWRzTSxJQXZCQzhYOztjQXdCTDhFLElBeEJTbGpELE9Bd0JTLGFBeEJibytDLElBd0JMOEUsS0FBa0Isc0JBeEJiOUU7O2NBeUJLcmtCLElBekJELzVCLE9BeUJGbWpELElBekJFbmpEO1VBeUJTLGFBekJibytDLElBeUJFK0U7VUFBVyxtQkFBUnBwQjtNOUJsd0JoQjtlOEI0dUJKLGFBSGVxa0IsSUFDeUJqbUIsS0FFeEMsd0JBSGVpbUIsSUFDMkNyOEMsS0FBUTNCOztTQU1sRSxhQVBlZytDLElBS3VCdGtCO1NBR0Usd0JBUnpCc2tCLElBS3lDdEYsT0FHaEIsU0FId0JsMEM7ZUFlcEMsYUFwQmJ3NUMsSUFtQktsbUIsS0FDUSx1QkFwQmJrbUIsSUFtQlFubUQ7Z0JBR0ssYUF0QmJtbUQsSUFxQkd2a0IsS0FDVSxxQkF0QmJ1a0IsSUFxQk12akQsR0FLUztJQXBHaEMsU0EwR011b0QsYUFBV2hGLElBQUlwK0M7TUFBTSxVQUFOQTtPQTZCUzs7T0E3QkgsT0FBTkE7O2NBWUlsSSxFQVpKa0ksT0FZQ3FELEVBWkRyRDtVQWFuQixhQWJlbytDLElBWUsvNkM7VUFDcEIsNkJBYmUrNkMsSUFZUXRtRDs7bUJBWkprSTs7WUFnQm5CLElBRG9DQztZQUNwQyxhQWhCZW0rQztZQWlCQyxtQkFqQkRBLElBaUJDLFlBakJaZ0YsYUFlZ0NuakQ7Y0FHQUM7VUFDcEMsYUFuQmVrK0M7VUFvQks7b0NBQW1CLFlBcEJuQ2dGLGFBa0JnQ2xqRDtXQUVoQjs7aUNBcEJMaytDLElBb0JWdGpCLE9BQVFtb0I7O21CQXBCTWpqRDs7Ozs7Ozs7Ozs7Z0JBQytDSSxJQUQvQ0o7Z0JBQ3VDK0I7Z0JBQWxCbzJCOzs7Ozs7Ozs7MEJBcUJqQmxnQyxFQXRCSitILE9Bc0JDazRCOzs7bUJBdEJEbDRCOzs7Ozs7Ozs7OztnQkFLNkM0RSxJQUw3QzVFO2dCQUtxQzg0QztnQkFBbEJoZjs7Ozs7Ozs7OzBCQW1CakJqL0IsRUF4QkZtRixPQXdCRDY1Qjs7O21CQXhCQzc1Qjs7Ozs7Ozs7Ozs7Z0JBQytDSSxJQUQvQ0o7Z0JBQ3VDK0I7Z0JBQWxCbzJCOzs7Ozs7Ozs7MEJBcUJqQmxnQyxFQXRCSitILE9Bc0JDazRCOzs7bUJBdEJEbDRCOzs7Ozs7Ozs7OztnQkFLNkM0RSxJQUw3QzVFO2dCQUtxQzg0QztnQkFBbEJoZjs7Ozs7Ozs7OzBCQW1CakJqL0IsRUF4QkZtRixPQXdCRDY1Qjs7O21CQXhCQzc1Qjs7OztrQkFTc0N1bUMsSUFUdEN2bUMsT0FTOEJxakQsZUFBbEJycEI7Y0FDL0IsYUFWZW9rQixJQVNnQnBrQjtjQUVTLHdCQVh6Qm9rQixJQVNrQ2lGLE9BRVQsV0FGaUI5YztjQWlCM0NELElBMUJLdG1DO1VBMEJTLGFBMUJibytDO1VBMEJtRCx1QkExQm5EQSxJQTBCbUQsV0FBcEQ5WDs7Y0FDSjRjLElBM0JTbGpELE9BMkJTLGFBM0JibytDLElBMkJMOEUsS0FBa0Isc0JBM0JiOUU7O2NBNEJLcmtCLElBNUJELzVCLE9BNEJGbWpELElBNUJFbmpEO1VBNEJTLGFBNUJibytDLElBNEJFK0U7VUFBVyxtQkFBUnBwQjtNOUJyeUJoQjtlOEI0d0JKLGFBSGVxa0IsSUFDeUJqbUIsS0FFeEMsd0JBSGVpbUIsSUFDMkNyOEMsS0FBUTNCOztTQU1sRSxhQVBlZytDLElBS3VCdGtCO1NBR0Usd0JBUnpCc2tCLElBS3lDdEYsT0FHaEIsU0FId0JsMEM7ZUFrQnBDLGFBdkJidzVDLElBc0JLbG1CLEtBQ1EsdUJBdkJia21CLElBc0JRbm1EO2dCQUdLLGFBekJibW1ELElBd0JHdmtCLEtBQ1UscUJBekJidWtCLElBd0JNdmpELEdBS1M7SUF2SWhDLFNBK0lFeW9ELFdBQVN0L0MsRUFBRW82QztVQUFhdjVCO2FsQ21KcEJvVDt3QmtDakpDbW1CLElBQUlwK0M7aUJBQU8sYUFBWG8rQyxJQUFJcCtDLEtBQU8sa0JBRlBnRSxFQUVKbzZDLElBQW9DO2VBRjlCQTs7ZUFBYXY1QjtJQS9JMUIsU0FvSkUwK0IsWUFBVXYvQyxFQUFFbzZDO00sSUFBYXY1QixvQmxDNlpyQnlVLGFrQzdaTXQxQixFQUFFbzZDLElBQWF2NUI7SUFwSjNCLFNBdUpFMitCLFVBQVFwRjtNQUFNLG9CO01BQUEsc0IsT0FSZGtGLGdCQVFRbEYsVUFBeUI7SUF2Sm5DLFNBd0pFcUYsV0FBU3JGO01BQU0sb0I7TUFBQSxzQixPQUpmbUYsaUJBSVNuRixVQUEwQjtJQXhKckMsU0F5SkVzRixTQUFPNytCLEtBQU0sNEJBblRiNjVCLGVBbVRPNzVCLElBQStCO0lBekp4QyxTQTBKRTgrQixVQUFROStCLEtBQU0sNEJBblRkODVCLGVBbVRROTVCLElBQStCO0lBMUp6QyxTQTRKRSsrQixXQUFTNS9DO01BQ0gsSUFEYzZnQixhQUNkLG9CQUNFLHdCQUROcHJCO01BQ00sU0FDTndLLFVBQUtqRTtRQUNQLGFBRkVvK0MsSUFDS3ArQztRQUVMLGtCQUxPZ0UsRUFLUCx1QkFKQXZLLEVBQ0Eya0QsS0FHOEI7TUFIeEIsbUJBQ05uNkMsUUFIa0I0Z0I7SUE1SnRCLFNBcUtFZy9CLFVBQVFoL0IsS0FBTSwyQkFBYzVzQixHQUFLLE9BQUxBLENBQU0sRUFBMUI0c0IsSUFBK0I7SUFyS3pDLFNBdUtFaS9CLFVBQVU5L0M7TUFDSixJQURlNmdCLGFBQ2Ysb0JBQ0Usd0JBRE5wckI7TUFDTSxTQUNOd0ssSUFBRW02QyxJQUFJcCtDO1FBQ1IsYUFESW8rQyxJQUFJcCtDO1FBRU4sa0JBTFFnRSxFQUtSLHVCQUpBdkssRUFFRTJrRCxLQUU0QjtNQUh4QixtQkFDTm42QyxJQURBbTZDLE1BRm1CdjVCO0lBdkt2QixTQWdMRWsvQixTQUFTbC9CLEtBQU0sMEJBQWU1c0IsR0FBSyxPQUFMQSxDQUFNLEVBQTNCNHNCLElBQWdDO0lBR3BDLFFBck9MNjdCO0lBcU9LLFNBVUxzRCxzQ0FBc0MzekMsTUFDakN2WSxFQUFTK0csRUFBVzJWLEVBQVU1Z0I7TUFDckMsa0NBRndDeWMsTUFDakN2WSxFQUFTK0c7TUFDaEIsWUFEMkIyVjtNQUMzQixZQURxQzVnQjtNQUNyQyxRQUV3QjtJQWRqQixTQWlCTHF3RCxzQ0FBc0M1ekM7TUFDeEMsVUFEd0NBLHdDQUVHO0lBSzNDLFNBREU2ekM7TSxPQWJBRjtlQXZWQXRGO0lBMFdGLFNBREV5RjtNLE9BWEFGLHNDQTlWQXZGO0lBMFdGLFNBVUUwRixVQUFRM3FEO00sSUFBV29yQjtlQUNqQjdnQixFQUFFbzZDLElBQUlwK0MsS0FBTSxhQUFWbytDLElBQUlwK0MsS0FBTSxzQkFBVm8rQyxNQUFzRDtNQUM5QyxtQkFEVnA2QyxFQUNVLG9CQUZKdkssS0FBV29yQjtJQVZyQjs7O09BN3BCRTIyQjtPQTZZQW9FO09BOWhCQWhHO09BK2hCQWlHO09BblpBekU7T0E4WUFvRTtPQTdZQW5FO09BOFlBb0U7T0E1WUFuRTtPQTZZQW9FO09BNVlBbkU7T0E2WUFvRTtPQXBhQTVFO09BMGFBa0Y7T0E5YUFwRjtPQTZhQW1GO09BcGFBaEY7T0FzYUFrRjtPQW5hQWpGO09Bb2FBa0Y7T0E5WkFoRjtPQStaQWlGO09BbGFBbEY7T0FtYUFtRjtPQXRXQXZFO09BeVdBMEU7T0F4V0F6RTtPQXVXQXdFO09BdlhBMUU7T0FzWEF5RTtPQXJZQTNFO09Bd1lBOEU7T0FsWUE3RTtPQXFZQWdGO09BaFpBbEY7T0E4WUFnRjtPQWhaQWpGO09BaVpBa0Y7T0F0UkE5RDtPQWdTQXFFO09BL1FBbkU7T0FnUkFvRTtPQXZTQXhFO09BeVNBeUU7T0FyU0F4RTtPQXNTQXlFO09BdlVBaEY7T0F5VUFpRjtPQXRVQWhGO09BdVVBaUY7T0FyVUFoRjtPQXNVQWlGO09BelhBeEY7T0EwV0E2RTtPQWpXQTVFO09Ba1dBNkU7T0EzVUExRTtPQThVQTRFO09BaFZBN0U7T0FpVkE4RTtPQTNWQS9FO09Bd1ZBNkU7T0F0VEF2RTtPQXFVQWlGO09BcFVBaEY7T0FxVUFpRjtPQXBqQkE3SDtPQWtoQkFpRztPQW5nQkFoRztPQW9nQkFpRztPQS9lQTVGO09BMmlCQW1JO09BL2lCQXZJO09BdWlCQW1JO09BdGlCQWxJO09BMGlCQW9JO09BemlCQW5JO09BdWlCQWtJO09BdGlCQWpJO09BMGlCQW1JO09BL1BBOUU7T0F3T0FvRTtPQWxRQXpFO09BMFFBNEU7T0F2UUEzRTtPQXlRQTRFO09BblNBL0U7T0E0UkE0RTtPQS9RQTNFO09BaVJBNEU7T0ExZ0JBeEg7T0FraEJBMkg7T0ExaEJBNUg7T0E0aEJBNkg7T0FuS0E1RDtPQW9CQUs7T0FDQUM7T0FoQkFMO09BV0FHO09BTUFHO09BZUFFO09BOUNBWjtPQVhBRjtPQW1GQWU7T0FHQUM7T0FHQUU7T0FHQUM7T0FLQUU7T0FHQUU7T0FvR0lnRDtPQVNKSztPQXdJQVk7T0FFQUU7T0FDQUM7T0FXQUU7T0FXQUU7T0F4QkFOO09BVEFIO09BS0FDO09BUUFLO09BV0FFO09BbURBTTtPQTlEQVI7T0E4Q0FNO09BS0FDO09BbEJBSDtPQU9BQztJQVlGO1FDanRDSUk7YUFLQUMsVUFBVUM7TUFDWjtRQUNVLElBQUoxcEQsRUFBSSxXQUZFMHBEO1FBRUYsUUFBSjFwRDtRQUFJO2dCQUZFMHBEO1FBRUYsVUFBSjFwRCxFQUZNMHBEO2VBRU4xcEQ7Ozs7VUFPSixRQWRBd3BELFVBY0EsMkJBZEFBO21CQWtCQzthQUdERyxVQUFVRCxJQUNaLE9BRFlBLFlBR1AsVUFIT0EsR0FHSzthQVFmRSxrQkFBa0JGO01BQ1osSUFBSjFwRCxFQUFJLFVBRFkwcEQsSUFDWixHQURZQSx3QkFHcEIsT0FGSTFwRCxDQUVIO2FBR0M2cEQsYUFBYUgsSUFDUixVQURRQSxJQUNSLE9BRFFBLEtBRU47YUFLUEksbUJBQW1CSixJQUFLLGFBQUxBLFNBQXlCO2FBRTVDSyxjQUFjTDtNQUNoQixTQURnQkE7TUFDaEI7Ozs7UUFFNEIsSUFBZk07UUFBZSxPQUFmQSxNQUU4QjthQUd6Q0MsV0FBV1AsSUFDYixPQURhQSx5QkFHUTthQUtuQlEsWUFBWVIsSUFBSyxhQUFMQSxNQUFvQzthQUVoRFMsd0JBQXdCVCxJQUFLLGtCQUFvQzthQXlTbkVVLGFBdlNRVjtNQUNSLGlCQURRQSxNQUVFLGFBRE5XO01BRUosUUFGSUE7TUFFSixRQUhRWDtNQUdSLE9BREk5d0MsR0FHRDthQUtEMHhDLFVBQVV4Z0MsTUFBTTQvQixJQUNsQix3QkFEa0JBLElBQ2xCLE9BRFk1L0IsS0FFUDthQUdIeWdDLFlBQVl6Z0MsTUFBTTQvQixJQUFLLGlCQUFYNS9CLGNBQU00L0IsR0FBNkI7YUFFL0NjLFdBQVcxZ0MsTUFBTTQvQixHQUFHMXBEO01BQ3RCLFNBRG1CMHBELE1BQUcxcEQsR0FDdEIsbUJBRGE4cEIsTUFBTTQvQixHQUVDO1FBR2xCZTthQUVBQyxTQUFPQyxNQUFNbG1EO01BUUc7O2NBbkdoQitrRDs7Ozs7Y0EyRmEva0Q7Y0FRRyxTQVZoQmdtRDtjQUVPRSxNQVVWO2FBR0dDLGNBQVl4dEQ7TUFDZCxzQ0FEY0E7TUFDZCxTQUVJcUg7UUFDRixHQUZFOUQsT0FEQTVIO1FBSUYsSUFBSWlILEVBQUosZ0JBTFk1QyxFQUNWckU7UUFJRjtlQUFJaUgsQ0FFSDtNQU5ILGtCQUVJeUUsS0FLbUI7O0lBR0wsU0FBaEJvbUQsc0IsT0F4QkFIO0lBd0JnQixJQXFEZC9wRDtJQXJEYyxTQThDaEJtcUQsa0JBQWtCeHBELElBQUssbUJBQUxBLElBQUssaUJBQXlDO0lBOUNoRCxTQWtEaEJ5cEQsa0JBQWtCenBELElBQU0saUJBQWlCO0lBbER6QixTQW9EaEIwcEQsUUFBUUMsY0FBY04sTUFBTXJwRDtNQUM5QjtlQUtJbUQ7UUFDRixHQUpFMUwsT0FDQTBTLFFBR2dCLElBQVV6TCxFQUFWLGVBTGhCaUMsSUFDQWxKLE1BSWdCLGNBQVVpSDtRQUM1QixHQUhFa3JEO1FBSU8sZUFUbUI1cEQsR0FFMUJXLE1BREF0QjtRQVFPLGFBTFA4SztrQkFDQXkvQyxXQUtpQixXQVZYRCxjQUFvQjNwRDtrQkFHMUJ2SSxTQU84RCxlQVI5RGtKLE9BWUM7TUFiTCxnQkFEd0Iwb0QsTUFNcEJsbUQsS0FTYTtJQXNCakIsSUFJRTBtRCxNQUpGLFFBdkNFSjtJQXVDRixTQU1FSyxhQUFhanFELFFBR2I2b0Q7TUFGRix3QkFFRUE7UUFDUyxJQUFMMW9ELEdBQUssV0FKSUgsUUFHYjZvRDtlQTlDQWdCLFFBTkFGLHFCQW9EQWQsTUFDSTFvRDtNQUZHLE9BSlA2cEQsS0FPK0M7SUFYakQ7SUFjWSxTQUdWRSxnQixPQVhBRDtJQVFVO0lBQ0ksU0FHZEUsb0IsT0FaQUY7SUFTYyxTQUtkRyxlQUFhanFELEksT0F6RGIwcEQsUUFGQUQscUJBMkRhenBELE9BQzBCO0lBTnpCLFNBU2RrcUQsU0FBUzlCO01BQ1gsU0FEV0E7TUFDWDtPQUlpQzs7UUFKakMsa0JBRUUsSUFEYXBvRCxXQUNiLDBCQURhQTtRQUVhLElBQVBtcUQ7UUFBTywwQkFBUEEsTUFDYztJQWRuQixJQWlDWkM7SUFqQ1ksU0FnQ2RDLGFBRUdWLGNBQWMzcEQ7TUFDbEI7UUFBSSxjQURjQSxHQURmb3FEOzs7O1VBS0MsSUFERWhDLEdBQ0YsUUFKQXVCLGlCQUFjM3BEO1VBSWQsZ0JBSmNBLEdBR1pvb0QsSUFKSGdDO1VBS0MsT0FERWhDO1FBM0JQLFdBOEJLO0lBSWlCLFNBQXBCa0M7TSxPQVpBRCxhQXRGQVo7SUFrR29CO2FBY3RCYyxVQUFVenVELEdBQUksc0JBQUpBLEVBQTBCO0lBZGQsU0FnQnRCMHVELGlCQUFpQjlyRDtNQUNULDBDQURTQSxHQUN1QztJQWpCbEMsU0FvQnRCK3JELGlCQUFpQkM7TUFFakIsMENBRmlCQSxTQUtOO0lBekJXLFNBb0N0QkM7TUFDRixrRUFBd0Q7SUFyQ2hDLFNBd0N0QkM7TUFDRiwrREFBcUQ7SUF6QzdCLFNBZ0R0QkMsbUJBQW1CbnNELEVBQUVvc0Q7TSxPQWxDckJQLFVBK0JGLHlCQUdxQjdyRCxFQUFFb3NELElBQ2dCO0lBakRmLFNBa0Z0QkMsZ0JBQWdCM0MsR0FBRzFwRDtNQUNaLElBQUxvc0QsR0FBSyxrQkFEUzFDO01BQ1QsT0FBTDBDLE9BRGlCcHNELEVBRU4sd0JBRkcwcEQsSUFHbEIsbUJBSHFCMXBELEVBQ2pCb3NELEdBRW1CO0lBckZDLFNBNEVsQkUsV0FXVTVDLEdBUGQzL0M7TUFIRixVQUdFQTtRQVFPLElBQUxxaUQsR0FBSyxrQkFETzFDO1FBQ1AsY0FBTDBDO2lCQUVNLHdCQUhNMUM7d0JBQ1owQztvQkFHTSx3QkFKTTFDLElBSU4sZ0JBSk1BO21CQUtULHNCQUpIMEM7Z0JBUkZyaUQ7O1NBM0JNLGdCQWtDUTIvQyxJQWpDVCxTQWlDU0E7U0FqQ1Q7V0FBdUI7aUJBRDFCMXBEO1lBQzBCOztXL0JxQ3hCLGErQmxDRix3QkE4QlkwcEQ7V0E3QlA7O01Bc0JGLHVCQU9TQSxHQVBkMy9DLElBQXlCO0lBaEZILFNBaUd0QndpRCxXQUFXN0MsSUFBSyxvQ0FBTEEsTUFBNEI7SUFqR2pCLFNBcUd0QjhDLFdBQVc5QztNQUNQLElBR0p0c0QsRUFISSxhQURPc3NEO01BQ1AsNEJBR0p0c0Q7O2lCQUFlLG1DQUFmQTs7Z0JBQXdEO0lBekdsQyxTQXNIdEJxdkQ7TUFBNkI7OztpQkFDdEI7aUJBQ0E7aUJBQ0E7aUJBQ0E7aUJBQ0E7O2lCQUNNOztNQUNSLDZCQUFZO0lBN0hLLFNBbUl0QkMsa0JBQWtCamQsS0FBS2lhO01BQ3pCLE9BRG9CamE7bUJBQ2hCNzJCLElBTWdCLFdBQU8sYUFQRjh3QzttQkFDckI5d0MsSUFJZ0IsV0FBTyxhQUxGOHdDO21CQUNyQjl3QyxJQUdnQixXQUFPLGFBSkY4d0M7bUJBQ3JCOXdDLElBS2dCLFdBQU8sYUFORjh3QztvQkFDckI5d0MsSUFFK0IsYUFIVjh3QztNQUcyQixJQUtoRHhxRCxFQUxnRCxzQkFGaEQwWjtNQUVnRCxTQUtoRDFaO2lCQUNRLGdCQVJSMFosY0FRcUMsTUFSckNBLE1BT0ExWjtNQUM0QixPQVI1QjBaLEdBUTZEO0lBNUl6QyxTQW9KdEIrekMsWUFBWWpELElBQXFCLHlDQUFyQkEsSUFBd0M7SUFwSjlCLFNBdUxsQmtELHdCQUF3QjlpQyxNQUFNNC9CO00sSUFBTjFtQjtNQUM5QjtpQkFEOEJBO1FBRXRCLElBR05oakMsRUFITSxVQUY0QjBwRDtRQUdqQyxHQUhpQ0EsYUFBTjFtQjtRQUk5QixTQUNFaGpDOztZQUlZLHdCQVRnQmdqQyxRQUFNMG1CLElBQU4xbUI7O2tCQUs1QmhqQztXQUNZLHVCQU5nQmdqQyxRQUFNMG1CLEdBS2xDMXBELEdBTDRCZ2pDO1FBV3ZCLE9BWHVCQSxRQVdsQjtJQWxNWSxTQW9RdEI4cEIsMEJBL0R3QmhqQyxNQUFNNC9CO01BQ2hDLFNBRDBCNS9CLGFBQ1I7TUFDVix3QkFGd0I0L0IsSUFFeEIsU0FBSjFwRDtNQUFJLDZCQU1JLG1DQU5SQTtNQUFJLElBR0ZnakMsUUFBUSxXQUxZbFosTUFBTTQvQixHQUU1QjFwRDtNQUdVLCtCQUFSZ2pDLFFBTDBCMG1CLEdBUW9DO0lBN001QyxTQWtPdEJxRCxnQkFBZ0JDLE1BQU1DLE9BQU9KLFFBQU1uRDtNQUdyQyxTQUgrQm1ELGVBR2I7TUFDVixJQUFKOWlELElBQUksa0JBSjZCMi9DO01BS2xDLGNBTHFCdUQsT0FJcEJsakQ7UUFFVSx1QkFOaUI4aUQsUUFBTW5ELEdBSWpDMy9DLEtBbkJnQitmO1FBQ2xCO21CQURrQkE7VUFFVixJQUdOOXBCLEVBSE0sVUFhMkIwcEQ7VUFaaEMsR0FZZ0NBLGFBZmpCNS9CO1VBS1QsY0FVYW1qQyxPQVZwQmp0RDtZQUNZLHVCQU5JOHBCLE1BZWlCNC9CLEdBVmpDMXBELEdBTGdCOHBCO29CQUtoQjlwQjtZQUlZLHdCQVRJOHBCLE1BZWlCNC9CLElBZmpCNS9CO1VBV1gsT0FYV0E7TUF3QlIsMENBTFIvZixJQUpjaWpELE9BU3lEO0lBM09uRCxTQThPdEJHO01BQWtCLHlEQUVSO0lBR1EsU0FBbEJDO00sT0FqQkFMLDJCQVlBSTtJQUtrQixTQUVsQkU7TUFBaUIseURBRVA7SUFHTyxTQUFqQkM7TSxPQXhCQVAsMEJBbUJBTTtJQUtpQixTQUVqQkU7TUFBZ0I7Ozs7OztNL0JqS1osbUIrQm1LTTtJQUdhLFNBQXZCQztNLE9BL0JBVCxnQ0EwQkFRO0lBS3VCLFNBS3ZCRSxVQUFVM2pDLE1BQU00L0I7TUFDVix3QkFEVUEsSUFDVixTQUFKMXBEO01BQUk7O2dCQUVDLGtCQUhHOHBCLE1BQU00L0IsR0FDZDFwRDs7aUJBR0ssa0JBSkc4cEIsTUFBTTQvQixHQUNkMXBEO01BSUcsT0FMSzhwQixLQUtBO0lBVmEsU0FhdkI0akMsbUNBQW1DNWpDLE1BQU00L0I7TUFDL0IsSUFBUjFtQixRQUFRLFVBRHlCbFosTUFBTTQvQjtNQUMvQixpQ0FBUjFtQixRQUR1QzBtQixHQUVUO0lBZlQsU0EwQ3ZCaUUsb0JBQW9CbGUsS0FBS3hNLFFBQU15bUI7TUFDakMsT0FEc0JqYTtlQUVKLHVCQUZTeE0sUUFBTXltQjtlQUdmLDBDQUhTem1CLFFBQU15bUI7O1NBSnJCLHNCQUllem1CLFFBQU15bUIsSUFuQjNCLG9CQW1CMkJBO1NBbkIzQixVQUNKMXBEO1dBQ1ksSUFBUjhwQixNQUFRLFdBSE1rWixRQW9CYTBtQixHQWxCL0IxcEQ7V0FDWSxTQUFSOHBCO1dBQVEsSUFFUi9mLElBQUksVUFldUIyL0M7V0FkNUIsR0FjNEJBLGFBakIzQjUvQjtXQUlKLFNBRkkvZjs7cUJBSW9CLDBCQU5wQitmLE1BaUIyQjQvQixHQWYzQjMvQyxLQWUyQjIvQztrQ0FmM0IzL0M7Ozs7OztzQkFLcUIsMkJBUHJCK2YsTUFpQjJCNC9CLEdBZjNCMy9DLEtBZTJCMi9DOztXL0JoTjNCO29CK0JvTWdDLGdDQUxoQzUvQixNQWlCMkI0L0IsR0FmM0IzL0MsS0FlMkIyL0M7b0JBVHhCLHdCQVJINS9CLE1BaUIyQjQvQjtTQVIxQixpQ0FaYTFtQixRQW9CYTBtQjtlQUtmLHNCQUxTem1CLFFBQU15bUI7ZUFNZixpQ0FOU3ptQixRQUFNeW1CO2dCQU9mLDRCQVBTem1CLFFBQU15bUIsSUFPYztJQWpEdEIsU0F1RHZCa0UscUJBQXFCOWpDLE1BQU00L0I7TUFDN0IsU0FEdUI1L0I7TUFFZixJQUdOOXBCLEVBSE0sVUFGcUIwcEQ7TUFHMUIsR0FIMEJBLGFBQU41L0I7TUFFZixhQUdOOXBCO01BREY7ZUFKdUI4cEI7ZUFNRyxtQ0FOSEEsTUFBTTQvQixHQUszQjFwRCxHQUwyQjBwRCxHQU9qQjtJQTlEYSxTQWtFdkJtRSxtQkFBbUIvakMsTUFBTTQvQjtNQUMzQixTQURxQjUvQjtNQUViLElBQUo5cEIsRUFBSSxVQUZtQjBwRDtNQUd4QixHQUh3QkEsYUFBTjUvQjtNQUlyQixVQUZJOXBCLHNCQUZpQjhwQjtNQU1nQixxREFOaEJBLE1BQU00L0IsR0FFdkIxcEQsR0FGdUIwcEQsR0FPZjtJQXpFYSxTQW9IdkJvRSxXQUFXN3FCLFFBQU04cUIsVUFBVXJFO01BbkNqQjt1QkFtQ0N6bUIsUUFBZ0J5bUI7T0FuQ2pCLGdDQUFSNS9CLE1BbUN5QjQvQjtlQUN6QjFtQiwwQkFEZStxQjtNQW5DUCxJQXNDUi90RCxFQUFJLFVBSHFCMHBEO01BSTFCLEdBSjBCQSxnQkFDekIxbUIsUUFEZStxQjtNQUtuQixVQUZJL3REO1FBSVU7NEJBTlZnakMsUUFEeUIwbUIsR0FHekIxcEQ7U0FLYyxnQkFEWjZzRCxRQVBha0I7U0FTZ0I7VUFGN0JsQjs7V0FDQW1CLGNBQzZCLHFCQUQ3QkEsWUFSdUJ0RTs7O1FBVTNCLDZCQURJd0QsUUFUdUJ4RCxJQVF2QnNFO01BSUosNkJBWEVockIsUUFEeUIwbUIsSUFBVnFFLFVBWXFCO0lBaElmLFNBbUl2QkUsOEJBQThCbmtDLE1BQU00L0IsR0FBR2hmLE1BQU0vdUM7TUFDL0MsU0FBSTZKLFVBQVV4RjtRQUNaLGFBRFlBO1FBQ1osMkJBRFlBLEVBR1YsYUFIVUEscUJBSUo7TUFKVjtpQ0FEK0NyRTtPQUMvQyxXQURnQ211QjtPQUNoQyxLQUtJbnBCO09BTEo7O1lBT0E1SDtRQUNFO1VBQVEsZ0JBVDRCMndELElBVWxCLGVBQVUsZ0JBVmlCL3RELElBUS9DNUM7VUFFSyxhQURDaUgsWUFDcUMsV0FWRjBxQztVQVVVLFNBSC9DMUgsV0FJaUIsV0FYb0IwSDtVQVk5Qix3QkFMUDFILFdBUGtDMG1CLEdBU2hDMXBEO1VBQUksU0FEVmpIOzs7TUFNQSxPQVBJaXFDLFVBT0U7SUFqSm1CLFNBb0p2QmtyQixlQUFlcGtDLE1BQU1pa0MsVUFBVXJFO01BQ2pDLGVBRGlCNS9CLFVBQ2pCLGFBQWdCLGFBRGlCNC9CO01BQ08sUUFBTTtNQUE5QztPQUNZLGtCQUZLNS9CLE1BQWdCNC9CO09BRXJCLFdBQVIxbUI7T0FBUSxhQUNJLGFBSGlCMG1CO01BR08sUUFBTTtNQUY5QyxJQUlFMXBELEVBREksVUFKMkIwcEQ7TUFJM0IsU0FDSjFwRDs7OztZQTZCWTtnQ0FoQ1ZnakMsUUFGNkIwbUIsR0FLL0IxcEQ7YUE2QlksV0FBUmlqQzthQUFRLGFBQ0ksYUFuQ2V5bUI7WUFtQ1MsUUFBTTtZQUFnQjtxQkFEMUR6bUIsUUFsQzJCeW1CLEdBN1cvQndDOzs7OztrQkFrWEFsc0Q7VUFDWTs4QkFKVmdqQyxRQUY2QjBtQixHQUsvQjFwRDtXQUNZLFdBQVJrdEQ7V0FBUSxhQUNJLGFBUGV4RDtVQU9TLFFBQU07VUFEbEM7V0FFUnlFO1lBQVEsOEJBRlJqQixRQU4yQnhELEdBN1cvQndDO1VBcVhZLFNBQVJpQztnQkFDWSxhQVRlekU7YUFVWDs4QkFWV0E7Y0FVWDs7O2NBQWQwRSxpQkFGRkQsUUFJTyxxQkFKUEEsUUFSMkJ6RTthQWE3QixTQUhJMEU7bUJBR1ksYUFiYTFFO2dCQWNULElBQ2QzL0MsSUFEYyxVQWRTMi9DO2dCQWNULFVBQ2QzL0M7a0JBQ1ksSUFBUnNrRCxRQUFRLFdBTmRELFFBVnlCMUUsR0FldkIzL0M7a0JBQ1ksU0FBUnNrRDs7O3NCQUNZLGFBakJPM0U7OztxQkFrQmYsc0JBbEJlQTtxQkFrQmY7Ozs7Ozt1QkFHWTt3Q0FMaEIyRSxRQWhCU047d0JBZ0JUTzs7OzBCQUtJTixjQUNpQixxQkFEakJBLFlBckJldEU7Ozs7dUNBZ0JuQjRFO3FCQUVJLElBRkpDOztrQkFBUSxJQUZaQyxRQUVJRDs7cUJBRkpDLFFBSkZKO2dCQWVGLFNBWElJO3NCQVdZLGFBekJXOUU7bUJBMEJuQixJQUNKMS9DLElBREksVUExQm1CMC9DO21CQTBCbkIsVUFDSjEvQywwQkFiQXdrRDttQkFZSTtvQkFFUSxtQkFkWkEsUUFkdUI5RSxHQTJCdkIxL0M7b0JBQ1ksV0FBUnlrRDtvQkFBUSxhQUNJLGFBN0JPL0U7bUJBNkJpQixRQUFNO21CQUFnQiwwQ0FEMUQrRSxRQTVCbUIvRTtnQkF5Qm1CLE9BWDFDOEU7YUFEd0MsT0FIMUNKO1VBRHdDLE9BRDFDRDs0QkFISm51RDtNL0IvVEk7UStCZ1dROzRCQXBDVmdqQyxRQUY2QjBtQixHQUsvQjFwRDtTQWlDWSxXQUFSNnNEO1NBQVEsYUFDSSxhQXZDZW5EO1FBdUNTLFFBQU07UUFBZ0I7aUJBRDFEbUQsUUF0QzJCbkQsR0E3Vy9Cd0M7TUFzWkssdUJBQWdCO0lBN0xFLFNBZ012QndDLHFCQUFxQjVrQyxNQUFNaWtDLFVBQVVyRTtNQUN2QyxlQUR1QjUvQixVQUN2QixhQUFnQixhQUR1QjQvQjtNQUNDLFFBQU07TUFBOUM7T0FDWSxnQ0FGVzUvQixNQUFnQjQvQjtPQUUzQixXQUFSMW1CO09BQVEsYUFDSSxhQUh1QjBtQjtNQUdDLFFBQU07TUFGOUMsSUFHUSxZQUorQkEsSUFJL0IsU0FBSjFwRDtNQUFJOztVQUdNOzhCQUxWZ2pDLFFBRm1DMG1CLEdBSW5DMXBEO1dBTWMsZ0JBSFppakMsUUFQdUI4cUI7V0FhTCxxQ0FIbEJDLFlBVmlDdEU7V0FhZixXQUhsQnNFLGNBR0FXO1dBQWtCLFFBTmxCMXJCLFVBU0EyckI7VUFIa0IsMEJBS2xCL0IsUUFsQmlDbkQ7Ozt3Q0FxQnJDLG1CQW5CRTFtQixRQUZtQzBtQjtNQXNCaEMsbUJBQVk7SUF0Tk0sU0F5TnZCbUYsZ0JBQWdCL2tDLE1BQU1pa0MsVUFBVXJFO01BQ2xDLGVBRGtCNS9CLFVBQ2xCLGFBQWdCLGFBRGtCNC9CO01BQ00sUUFBTTtNQUE5QztPQUNZLGtCQUZNNS9CLE1BQWdCNC9CO09BRXRCLFdBQVIxbUI7T0FBUSxhQUNJLGFBSGtCMG1CO01BR00sUUFBTTtNQUY5QyxJQUlFMXBELEVBREksVUFKNEIwcEQ7TUFJNUIsU0FDSjFwRDs7VUFpQ1k7OEJBcENWZ2pDLFFBRjhCMG1CLEdBS2hDMXBEO1dBaUNZLFdBQVJpakM7V0FBUSxhQUNJLGFBdkNnQnltQjtVQXVDUSxRQUFNO1VBQVksNEJBRHREem1CLFFBdENrQjhxQixVQUFVckU7O2dCQUtoQzFwRDtTQUNZOzZCQUpWZ2pDLFFBRjhCMG1CLEdBS2hDMXBEO1VBQ1ksV0FBUjZzRDtVQUFRLGFBQ0ksYUFQZ0JuRDtTQU9RLFFBQU07U0FEbEMsSUFHVjMvQyxJQURJLFVBUjBCMi9DO1NBUTFCLFVBQ0ozL0M7Z0NBMEJBLHFCQTdCRThpRCxRQU5rQmtCLFVBQVVyRTtTQU1wQjtVQUlFLG1CQUpWbUQsUUFONEJuRCxHQVM5QjMvQztVQUNZLFdBQVJtakQ7VUFBUSxhQUNJLGFBWGN4RDtTQVdVLFFBQU07U0FMcEM7VUFNRSw2QkFGUndELFFBVjBCeEQ7VUFZbEIsV0FBUnlFO1VBQVEsYUFDSSxhQWJjekU7U0FhVSxRQUFNO1NBUHBDLElBUVEsY0FkWUEsSUFjWixTQUNkMS9DO1NBRGM7O1lBRUYsSUFBUm9rRCxRQUFRLFdBSlpELFFBWjBCekUsR0FlMUIxL0M7WUFDWSxTQUFSb2tEOzs7Z0JBQ1ksYUFqQlUxRTs7O2VBa0JsQixvQkFsQmtCQTtlQWtCbEI7Ozs7OztpQkFHWTtrQ0FMaEIwRSxRQWhCWUw7a0JBZ0JaTzs7O29CQUtJTixjQUNpQixxQkFEakJBLFlBckJrQnRFOzs7O2lDQWdCdEI0RTtlQUVJLElBRkpEOztZQUFRLElBQVJFOzs7Ozs7d0JBSkpKOzs7U0FOTSxJQVFOSyxpQkFXSyxhQVRERDtTQVNhLFNBWGpCQztlQVlZLGFBMUJjOUU7WUEyQnRCLElBQ0p6L0MsSUFESSxVQTNCc0J5L0M7WUEyQnRCLFVBQ0p6L0MsMEJBZEF1a0Q7WUFhSTthQUVRLG1CQWZaQSxRQWQwQjlFLEdBNEIxQnovQzthQUNZLFdBQVJ3a0Q7YUFBUSxhQUNJLGFBOUJVL0U7WUE4QmMsUUFBTTtZQUFnQiwwQ0FEMUQrRSxRQTdCc0IvRTtTQTBCZ0IsT0FaMUM4RTtNQStCRCxtQkFBWTtJQXRRTSxTQStRdkJNLFlBQVlDLElBQ0RqbEMsTUFEVzQvQjtNLElBQ1gxbUI7TUFDWDtpQkFEV0E7UUFFSCxJQUFKaGpDLEVBQUksVUFIYzBwRDtRQUluQixHQUptQkEsYUFDWDFtQjtRQUlULEdBTFUrckI7VUFNSyxJQUFSaGxELElBTkdnbEQ7VUFNSyxHQUhiL3VELE1BR0srSixXQUFrQixVQUxoQmk1QixRQURXMG1CO1VBTUwsSUFDRSxtQkFOUjFtQixRQURXMG1CLEdBR2xCMXBELEdBRk9nakM7O1FBRUg7U0FNSixLQU5BaGpDO1NBTUE7US9COWJBLG1CK0JzYk9nakM7UUFFSCxJQVFRLG1CQVZMQSxRQURXMG1CLEdBR2xCMXBELEdBRk9nakM7aUJBV0g7SUEzUmUsU0ErUnZCZ3NCLFVBQVVsbEMsTUFBTTQvQjtNQUlXLGtCQUpqQjUvQixNQUFNNC9CLEdBSVcsa0JBSlhBLElBSTBDO0lBblNuQyxTQWdVdkJ1RiwwQkFDRXg4QztNQUFKLGFBQUlBLDBDQVVpQjtJQTNVSSxTQTBWdkJ5OEMsZ0JBQWdCbEQsUUFBUWxpQyxNQUFNNC9CO01BQ2hDLFNBRDBCNS9CLGFBQ1IsaUJBREFraUM7TUFFVixJQUFKaHNELEVBQUksVUFGd0IwcEQ7TUFHN0IsT0FINkJBLE1BN2pCOUIsbUNBNmpCZ0JzQyxVQUVkaHNELENBRUg7SUFHNEIsU0FBM0JtdkQ7TSxPQVBBRDtJQVE2QixTQUE3QkU7TSxPQVJBRjtJQVE2QixTQUU3Qkcsb0JBQW9CdmxDLE1BQU00L0I7TUFDdEIsSUFuRGtCNEYsR0FtRGxCLHlCQURnQnhsQyxNQUFNNC9CO01BQ3RCLFNBbkRrQjRGOzs7Ozs7OzthQWlFdEI7OztpQkFDVTs4QkFoQmdCNUY7a0JBZ0JoQixLQUFKMXBEO2tCQUFJOzs7O2lCL0IxaEJOLGdCK0IwaEJFQSxFQUdHLGlCQUhIQSxFQUdxQjtjQUNsQjtjQUNBO2NBeENKLCtCQUh3QjhGO2NBRXhCLG9DQUZxQkQ7YUFFckIsUUFESGtFOzs7O3dCQU1KLFlBTklBOzs7O3VCQUtBLG1DQU53QmxFLEdBQUdDO29CQWx3QjNCMGtELFdBd3hCa0IxZ0MsY0FBTTQvQjs7Ozs7Ozs7a0JBbERKNEY7V0F1RHRCOzs7ZUFDVSxnQkFOZ0I1RixJQU1oQixTQUVOMXBEO2VBRk0sMEJBR0QsaUJBRExBLElBQ3VCO1lBRWxCO1lBQ0E7WUE1REg7c0JBRmdCc3ZELDJCQUFHRzs7Y0FBR0M7OztXQUV0QixRQURKMXZEO29EQVFKLFlBUklBOzs7O3FCQU1BLG1DQVBvQnN2RCxHQUFHRyxLQUFHQztrQkF0dUIxQmxGLFdBd3hCa0IxZ0MsY0FBTTQvQjs7OzJCQWxESjRGO00vQnhkbEI7UStCNGNpQixVQVlDQTs7Ozs7Ozs7Ozs7OztlQXR1QnBCOUUsV0F3eEJrQjFnQyxNQUFNNC9CO01Bd0IxQix3QkExRXNCNEYsR0EwRUo7SUExQlcsU0E4QjdCSyxlQUVpQjdsQyxNQUZJNC9CO01BRXZCLFNBWUlrRyxVQUFVOWxDO1FBQ04sSUFFSjlwQixFQUZJLHlCQURNOHBCLE1BZFM0L0I7UUFlZixjQUVKMXBELEVBRFEsWUFGRThwQixNQWRTNC9CLElBaUJkLHNCQUFMMXBELEVBQThCO01BZDFCLElBRUpBLEVBRkksa0JBSGUwcEQ7TUFHZixVQUVKMXBEO1FBRGtCOzZCQUZIOHBCLE1BRkk0L0I7U0FRZiw2QkFETTFtQixRQVBTMG1CO1FBUWYsY0FHSjMvQztpQkFEVSw4QkFBcUIsWUFIckJpNUIsUUFQUzBtQjtpQkFZVCxxQkFMQTFtQixRQVBTMG1CLEdBV25CMy9DO01BTkssNkJBQUwvSixFQWNZO0lBakRlLFNBcUQ3QjZ2RCxpQkFFaUIvbEMsTUFGTTQvQjtNQUV6QixTQUtJb0csb0JBQVVobUM7USxJQUFBa1o7UUFDWjtVQUFNLElBR0poakMsRUFISSwyQkFETWdqQyxRQVBXMG1CO1VBUWpCLFVBR0oxcEQsU0FGUSxZQUZFZ2pDLFFBUFcwbUI7b0JBV3JCMXBEO1lBRHVCO2lDQUhiZ2pDLFFBUFcwbUI7YUFjakIsaUNBRFd6bUIsUUFiTXltQjtZQWNqQjtjQUVnQixxQkFITHptQixRQWJNeW1CO2NBZ0JEOzt1QkFRcEJxRzs7O2NBVHFCO21DQUZOOXNCLFFBYk15bUI7ZUFvQmpCLG1DQURTd0QsUUFuQlF4RDtjQW9CakI7Z0JBQ2dCLHFCQUZQd0QsUUFuQlF4RDtnQkFxQkQ7O3lCQUdwQnFHOztjQVRxQixJQU9OLG1CQUhGN0MsUUFuQlF4RCxPQU9YMW1COztZQUdhLElBT1IsNEJBSkFDLFFBYk15bUIsSUFPWDFtQjs7VUFDTixJQUdXLG1CQUpMQSxRQVBXMG1CLEdBV3JCMXBELEdBSlVnakM7bUJBSXFDO01BVG5ELFNBc0JJK3NCLG9CQUFZam1DO1EsSUFBQWtaO1FBQ2Q7VUFBTSxxQ0FEUUEsUUF4QlMwbUI7VUF5QmpCO1lBQ2Usd0JBRlAxbUIsUUF4QlMwbUIsSUF3QlQxbUI7VUFHUDs7bUJBcEJMOHNCLHNCQWlCWTlzQjt3Q0FqQlo4c0IsZUFpQlk5c0IsVUFHUTtNQXpCeEIsU0FLSTRzQixVQUFVOWxDLE8sdUJBQVZnbUMsY0FBVWhtQztNQUpOLElBRUo5cEIsRUFGSSxrQkFIaUIwcEQ7TUFHakIsY0FFSjFwRDtlQURrQixzQkFGSDhwQixNQUZNNC9CO2VBS2hCLHNCQUFMMXBELEVBd0JZO0lBbEZlLFNBb0c3Qmd3RCx1QkFBdUJ2ekQsU0FBU3d6RCxXQUFXbm1DLE1BQU00L0I7TUFDbkQsU0FBUXdHLFdBQVduM0QsRUFBRWcyRDtRLElBQUY1dkQ7UUFDakI7VUFBUSxnQkFGeUN1cUQsSUFFekMsU0FEU3ZxRDtVQUNUO1lBQ1EsYUFIaUN1cUQ7WUFHakM7YUFDYix3QkFKb0JqdEQsU0FFbkJ1RCxHQUVELFVBRkNBLE1BRGUrdUQ7Ozs7O1VBS2pCO1lBQVEsVzlCcGhDVjd3RCxROEI4Z0NpRHdyRCxHQUU3QzFwRCxHQUlNLFFBTE9iO3NCQU1PO01BTjFCLEdBRGtDOHdEO1FBV2hDLElBREtqd0QsRUFWMkJpd0Q7UUFXaEMsV0FYMkNubUMsTUFVdEM5cEI7UUFDTCxhQVhpRDBwRDtRQVkxQztVQUNJLElBQUwwQyxHQUFLLFVBYnNDMUM7VUFhdEMsT0FITjFwRCxNQUdDb3NELEdBRUMsd0JBZjBDMUMsSUFnQjFDLG1CQU5GMXBELEVBR0Nvc0Q7UUFKRTt3QkFUbUN0aUMsU0FnQmI7SUFwSEQsU0F3SDdCcW1DLGdCQUFnQnpHLEdBSWhCbnNEO00sR0FBQUE7V0FIYUgsRUFHYkc7O3dDQUhhSCxFQUdiRztNQUZRLElBQUp4RSxFQUFJLFdBRlEyd0Q7TUFHTiwwQ0FETjN3RCxFQURTcUU7SUF6SGdCLFNBZ0k3Qmd6RCxZQUFZMUcsR0FBRzlzRDtNQUNqQixPQURpQkE7ZUFFQyxPQUZKOHNELGFBR0ksa0JBSEpBLFlBSUssT0FKTEEsTUFJNEI7SUFwSVgsU0F3STdCMkcsaUJBQWlCeG1DO01BQVUsR0FBVkEsU0FFSCxJQUFUQyxNQUZZRCxXQUVILE9BQVRDLE1BREcsTzlCbmpDUjVyQixPOEJvakNtQjtJQTFJVSxTQTZJN0JveUQsMEJBQTBCQztNQUM1QixTQUQ0QkE7TUFFaEI7b0NBRmdCQTtPQUVoQixvQkFBTjUwRDtPQUVVLGNBRlZBLE1BQU0sc0JBQU5BO01BRVUsVUFEVm96RCxJQUNBN25CLFFBQ1E7SUFsSmlCLFNBNEp6QnNwQiw4QkFHSnJuRCxFQUFFNmdCO00sSUFBQXFEO01BQU87aUJBQVBBO1FBcUNrQyxrQkFyQ3BDbGtCOztRQUFTLE9BQVBra0I7aUJBS2tDLFVBTGxDQTtpQkFNa0MsVUFObENBO2lCQU9rQyxVQVBsQ0E7aUJBUWtDLFVBUmxDQTtpQkFTa0MsVUFUbENBO2lCQVVrQyxVQVZsQ0E7aUJBV2tDLFVBWGxDQTtpQkFZa0MsVUFabENBO2lCQWFrQyxVQWJsQ0E7aUJBY2tDLFdBZGxDQTtrQkFpQmtDLFdBakJsQ0E7a0JBa0JrQyxXQWxCbENBO2tCQW1Ca0MsV0FuQmxDQTtrQkFnQ2tDLFdBaENsQ0E7O1dBa0MyQixJQURMcDBCLEtBakN0Qm8wQixTQWlDZXh4QixNQWpDZnd4QixTQWtDMkIsZUFBVyxLQUR2Qnh4QjtXQUNZOztvQkFNN0I0MEQsc0NBeENBdG5ELE9BaUN3QmxROztvQkFPeEJ3M0QsK0JBeENBdG5ELE9BaUN3QmxRO2tCQWxCWSxXQWZsQ28wQjtrQkFnQmtDLFdBaEJsQ0E7a0JBMEJrQyxXQTFCbENBOzs7O2FBNEJzQjtjQURvQm4wQixPQTNCMUNtMEI7O2NBMkJnQzRMO2NBQ1Ysa0JBRFVBLE9BQVUvL0I7Y0EzQjFDbTBCOztXQThCc0I7WUFEb0JsMEIsT0E3QjFDazBCOztZQTZCZ0NvTTtZQUNWLGtCQURVQSxPQUFVdGdDO1lBN0IxQ2swQjs7O1dBRUYsSUFET21ILFNBRExuSDtXQUVGLGdCQUFJcWpDO2FBQ0YsU0FBSUMsTUFBTUM7ZUFBZSxrQkFIM0J6bkQsS0FFSXVuRCxPQUNRRSxjQUE4QzthQUF4RCwyQkFBSUQsTUFGQ244QixTQUc2QjtrQkFrQkEsV0F0QmxDbkg7a0JBdUJrQyxXQXZCbENBO2tCQXdCa0MsV0F4QmxDQTs7ZUFtQ2tCajBCLE9BbkNsQmkwQixTQW1DYXR3QixJQW5DYnN3QjtXQXlFVyxVQXRDRXR3QjtZQXNDRixPQXRDRUE7eUJBbkNic3dCLE1BbUNrQmowQjt5QkFuQ2xCaTBCLE1BbUNrQmowQjs7ZUF3Q3BCLGdCQUFJczNEO2lCQUNGLFNBQUlDLE1BQU1DO21CQUFlLGtCQTVFM0J6bkQsS0EyRUl1bkQsT0FDUUUsY0FBOEM7aUJBQXhELDJCQUFJRCxNQXpDY3YzRCxPQTBDVzswQkE3RTdCaTBCLE1BbUNrQmowQjs7WUFzQ1AsT0F0Q0UyRDt5QkFuQ2Jzd0IsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCO3lCQW5DbEJpMEIsTUFtQ2tCajBCOztlQXNEZSxJQUFWMkMsUUF0RFZnQjtlQXNEb0I7O3dCQWpEbkMwekQ7b0NBeENBdG5ELEVBeUZ5QnBOLFFBdERMM0M7O3dCQUtwQnEzRCwrQkF4Q0F0bkQsRUF5RnlCcE4sUUF0REwzQzswQkFuQ2xCaTBCLE1BbUNrQmowQjswQkFuQ2xCaTBCLE1BbUNrQmowQjtrQkFmZ0IsV0FwQmxDaTBCLCtCQXFDdUM7SUFwTVosU0F1TTdCb2pDLG9DQUdBdG5ELEVBQUV0TixNQUFNbXVCO00sSUFBTmp1QjtNQUFhO2lCQUFiQTtTQXFCNkI7O2tCQW5FM0J5MEQsZ0NBOENKcm5ELEVBQVE2Z0I7dUNBOUNKd21DLHlCQThDSnJuRCxFQUFRNmdCOztRQUFPLE9BQWJqdUI7aUJBUzZCLFlBVDdCQTtpQkFVNkIsWUFWN0JBO2lCQVc2QixZQVg3QkE7aUJBWTZCLFlBWjdCQTtpQkFhNkIsWUFiN0JBO2lCQWM2QixZQWQ3QkE7aUJBZTZCLFlBZjdCQTtpQkFnQjZCLFlBaEI3QkE7aUJBb0I2QixZQXBCN0JBOztXQXVCTztZQURrQjlDLEtBdEJ6QjhDO1lBc0JvQjFCLElBdEJwQjBCO1lBc0JlbkMsSUF0QmZtQztZQXVCTyxTQUFNLEtBREVuQyxLQUFLUztZQUVNLHNCQUR4QlgsR0FEdUJUO1lBdEJ6QjhDOztrQkFpQjZCLGFBakI3QkE7a0JBa0I2QixhQWxCN0JBO2tCQW1CNkIsYUFuQjdCQTs7V0FFRixJQURVeTRCLFNBRFJ6NEI7V0FFRixnQkFBSTIwRDthQUNGLFNBQUlDLE1BQU1DO2VBQWUsa0JBSDNCem5ELEtBRUl1bkQsT0FDUUUsY0FBOEM7YUFBeEQsaUNBQUlELE1BRkluOEIsU0FERnhLLElBSXNDOztXQUU5QyxJQURrQjBLLFdBTGhCMzRCO1dBTUYsZ0JBQUkyMEQ7YUFDRixTQUFJQyxNQUFNQztlQUFlLGtCQVAzQnpuRCxLQU1JdW5ELE9BQ1FFLGNBQThDO2FBQXhELGlDQUFJRCxNQUZZajhCLFdBTFYxSyxJQVFzQyxFQWdCUTtJQWxPekIsU0E0SnpCNm1DLG9CQUdKMW5ELEVBQUU2Z0I7TSx1QkFIRXdtQyx3QkFHSnJuRCxFQUFFNmdCO0lBL0oyQixTQXVNN0JpbkMsMEJBR0E5bkQsRUFBRXROLE1BQU1tdUI7TSx1QkFIUnltQyw4QkFHQXRuRCxFQUFFdE4sTUFBTW11QjtJQTFNcUIsU0F1YTdCa25DLGVBTUF4SCxHQUFHMS9CLElBQUltbkMsUUFBUTEyRCxJQUFJRSxLQUFLeTJELEtBQUtuVjtNQUFTLFVBQXZCeGhEO2tCQUFJRTs7WUFFWCxXQUZnQnkyRCxLOUJ2MUN4Qmx6RCxnQjhCdTFDQXdyRDtZQUdRLElBQUpuc0QsRUFBSSxXQUhxQjArQyxNQUE3QnlOO1lBSVMsVUFETG5zRCxFQUNLLFdBSlRtc0QsR0FBRzEvQixJQUFJbW5DO1VBd0JQO1FBbEJBLElBRDBCM29ELEVBTFA3TjtRQU1YLFdBTmdCeTJELEs5QnYxQ3hCbHpELFE4QjQxQzBCc0ssRUFMMUJraEQ7UUFNQSxJQUNJM2QsSUFBSSxXQVBxQmtRLE1BQTdCeU47UUFRUyxVQURMM2QsSUFDSyxXQVJUMmQsR0FBRzEvQixJQUFJbW5DOztRQUErQixTQUF2QjEyRDtpQ0FrQmY7bUJBbEJlQTtvQkFBSUU7O2NBVVgsV0FWZ0J5MkQsVTlCdjFDeEJsekQsUThCdTFDQXdyRDtjQVdRLElBQUp4ZCxJQUFJLFdBWHFCK1AsTUFBN0J5TjtjQVlTLFVBREx4ZCxJQUNLLFdBWlR3ZCxHQUFHMS9CLElBQUltbkM7WUFvQlA7Y0FQZ0Q5ekIsSUFiN0IxaUM7VUFjWCxXQWRnQnkyRCxVQWF3Qi96QixJQWJoRHFzQjtVQWVRLElBQUpyZCxJQUFJLFdBZnFCNFAsTUFBN0J5TjtVQWdCUyxVQURMcmQsSUFDSyxXQWhCVHFkLEdBQUcxL0IsSUFBSW1uQztRQXNCUCwrQ0FFMEM7SUFyY2IsU0FxUXpCRSxXQUdKM0gsR0FBRzEvQixJQUFJbW5DO00sSUFBSjlqQztNQUFlO2lCQUFmQTtRQTBKSDs7UUExSmtCLE9BQWZBOztXQUVILElBREtwMEIsS0FERm8wQjtXQUVLLFlBRlJxOEI7V0FFQSxJQUNJMXBELEVBQUksV0FIUjBwRDtXQUlTLFVBREwxcEQsRUFDSyxXQUpUMHBELEdBQ0t6d0QsS0FERWs0RDs7V0FNUCxJQURVajRELE9BTFBtMEI7V0FNSyxpQkFOUnE4QjtXQU1BLElBQ0kzL0MsSUFBSSxXQVBSMi9DO1dBUVMsVUFETDMvQyxJQUNLLFdBUlQyL0MsR0FLVXh3RCxPQUxIaTREOztvQkFBSjlqQzs7OztlQVdZO2dCQUQwQmwwQjtnQkFBWmlEO2dCQUNkLGdDQURjQTtnQkFDZDs7OzBCQUNOMHRCLFlBQVE0L0I7bUJBQUssc0JBRGxCcUYsS0FDS2psQyxNQUFRNC9CLEdBQW9DO2dCQUR0QyxhQUFOL3RELElBRGdDeEM7ZUFDMUI7d0JBWGZ1d0QsR0FhSTZILFNBYkdKLGVBWUhHLE9BcHhCSmxIOzs7OztrQkF1eEIwRGh4RDs7a0JBQVgyekI7a0JBQzNDeWtDOzRCQUFLMW5DLFlBQVE0L0IsSUFBSyx3QkFBYjUvQixNQUFRNC9CLEdBQW9DO2lCQUNuQzswQkFqQmxCQTswQkFpQmtCLFdBRjZCMzhCLE1BQVczekI7MEJBZm5EKzNEOzs7MEJBZ0JISzswQkF4eEJKcEg7O2dCQTJ4QjBEL3dEOztnQkFBWHc3QjtnQkFDM0M0OEI7MEJBQUszbkMsWUFBUTQvQixJQUFLLHdCQUFiNS9CLE1BQVE0L0IsR0FBb0M7ZUFDbkM7d0JBckJsQkE7d0JBcUJrQixXQUY2QjcwQixNQUFXeDdCO3dCQW5CbkQ4M0Q7Ozt3QkFvQkhNO3dCQTV4QkpySDs7V0FneUJBLElBQUlnSCxjQUFLdG5DLFlBQVE0L0IsSUFBSyxxQkFBYjUvQixNQUFRNC9CLEdBQThCO1dBQS9DLHNCQXhCQUEsUUFBT3lILGVBd0JIQyxLQWh5QkpoSDs7O1lBbXlCa0I5d0QsT0EzQmYrekI7WUEyQlU1eUIsSUEzQlY0eUI7WUE0QkNxa0MsZ0JBQUs1bkMsWUFBUTQvQixJQUFLLHdCQUFiNS9CLE1BQVE0L0IsR0FBOEI7a0JBbUkvQ3dILGVBL0pBeEgsR0EyQmtCcHdELE9BM0JYNjNELFFBMkJNMTJELE1BQ1RpM0QsT0FweUJKdEg7O1dBdXlCUTtZQURlN3dELE9BOUJwQjh6QjtZQThCYzF5QixLQTlCZDB5QjtZQThCUzN5QixNQTlCVDJ5QjtZQThCRXh5QixNQTlCRnd5QjtZQStCSyxnQ0FBMkIsY0FEOUJ4eUI7WUFDRztzQkFDQ2l2QixZQUFRNC9CO2VBQUssMkJBenZCWmphLEtBeXZCRDNsQixNQUFRNC9CLEdBQW1DO1dBQ1A7b0JBakM3Q0E7b0JBOEJ1Qm53RDtvQkE5QmhCNDNEO29CQThCS3oyRDtvQkFBS0M7b0JBRWJnM0Q7NkJBenZCV2pJO3NCQUFtQiw0Q0FBeEJqYSxLQUFLaWE7O1dBNHZCUDtZQURpQmx3RCxPQWxDdEI2ekI7WUFrQ2dCdnlCLE9BbENoQnV5QjtZQWtDV3p5QixNQWxDWHl5QjtZQWtDSXJ5QixRQWxDSnF5QjtZQW1DSyxrQ0FBMkIsY0FENUJyeUI7WUFDQztzQkFDQzh1QixZQUFRNC9CO2VBQUssMkJBeHVCVmtJLE9Bd3VCSDluQyxNQUFRNC9CLEdBQW1DO1dBQ1A7b0JBckM3Q0E7b0JBa0N5Qmx3RDtvQkFsQ2xCMjNEO29CQWtDT3YyRDtvQkFBS0U7b0JBRWYrMkQ7NkJBeHVCYW5JO3NCQUFxQiw0Q0FBMUJrSSxPQUFLbEk7O1dBMnVCVDtZQURxQmp3RCxPQXRDMUI0ekI7WUFzQ29CcHlCLE9BdENwQm95QjtZQXNDZXR5QixNQXRDZnN5QjtZQXNDUWx5QixRQXRDUmt5QjtZQXVDSyxrQ0FBMkIsY0FEeEJseUI7WUFDSDtzQkFDQzJ1QixZQUFRNC9CO2VBQUssMkJBN3VCTm9JLE9BNnVCUGhvQyxNQUFRNC9CLEdBQW1DO1dBQ1A7b0JBekM3Q0E7b0JBc0M2Qmp3RDtvQkF0Q3RCMDNEO29CQXNDV3AyRDtvQkFBS0U7b0JBRW5CODJEOzZCQTd1QmlCckk7c0JBQXlCLDRDQUE5Qm9JLE9BQUtwSTs7V0FndkJiO1lBRGlCL3ZELE9BMUN0QjB6QjtZQTBDZ0JqeUIsT0ExQ2hCaXlCO1lBMENXbnlCLE1BMUNYbXlCO1lBMENJL3hCLFFBMUNKK3hCO1lBMkNLLGtDQUEyQixjQUQ1Qi94QjtZQUNDO3NCQUNDd3VCLFlBQVE0L0I7ZUFBSywyQkEvdUJWc0ksT0ErdUJIbG9DLE1BQVE0L0IsR0FBbUM7V0FDUDtvQkE3QzdDQTtvQkEwQ3lCL3ZEO29CQTFDbEJ3M0Q7b0JBMENPajJEO29CQUFLRTtvQkFFZjYyRDs2QkEvdUJhdkk7c0JBQXFCLDhDQUExQnNJLE9BQUt0STs7b0JBbXNCZHI4Qjs7aUJBOEN3Qnh6QixPQTlDeEJ3ekIsU0E4Q2tCOXhCLE9BOUNsQjh4QixTQThDYWh5QixNQTlDYmd5QjtvQkErSkg2akM7c0JBL0pBeEgsR0E4QzJCN3ZELE9BOUNwQnMzRCxRQThDUzkxRCxNQUFLRSxPQS9ickJzekQsZ0JBdFVBbEM7O2lCQTR3QmtCN3lELFFBckRmdXpCLFNBcURTa1ksT0FyRFRsWSxTQXFESTd4QixNQXJESjZ4QjtvQkErSkg2akM7c0JBL0pBeEgsR0FxRGtCNXZELFFBckRYcTNELFFBcURBMzFELE1BQUsrcEMsT0EzZ0JaMm9CLGVBalFBdkI7ZUF5d0J3RDV5RCxRQWxEckRzekIsU0FrRCtDNmtDLE9BbEQvQzdrQyxTQWtEMEMzeEIsTUFsRDFDMnhCO2tCQStKSDZqQztvQkEvSkF4SCxHQWtEd0QzdkQsUUFsRGpEbzNELFFBa0RzQ3oxRCxNQUFLdzJELE9BeGlCbERwRSxXQWpPQW5COzs7WUE4d0JXM3lELFFBdkRScXpCO1lBdURHdnhCLE1BdkRIdXhCO1lBd0RDOGtDO2lDQUFTekk7ZUF6T1A7b0NBeU9PQTtnQkF6T1A7eUJBS0oxcEQ7OytCQUNBLFVBQ0UseUJBRkZBO2VBR0oscUJBUElvZixFQXdPV3NxQyxHQUFpQjtrQkF1RzlCd0gsZUEvSkF4SCxHQXVEVzF2RCxRQXZESm0zRCxRQXVERHIxRCxRQUNGcTJELE9BOXpCSjNGOztXQSswQkEsSUFETXZ5RCxRQXhFSG96QjtXQXlFQSxnQkF6RUhxOEIsU0FBR3I4QixNQXdFR3B6QjtXQUVEOztlQUVnQmdDLFFBNUVsQm94QixTQTRFYWhCLE1BNUViZ0I7V0E2RUgsc0IsT0E1MkJJaS9CLFdBK3hCSjVDLFVBNEVnQnI5QjtlQTVFYmdCLE1BNEVrQnB4Qjs7O2VBR0ZDLFFBL0VoQm14QixTQStFV3p4QixJQS9FWHl4QjtXQWdGSCxXQWhGQXE4QixHQStFYzl0RDtlQS9FWHl4QixNQStFZ0JueEI7OztlQUlTQyxRQW5GekJreEIsU0FtRmtCeHhCLE1BbkZsQnd4QixTQW1GU3hELFFBbkZUd0Q7V0FvRkssaUJBQWlCLGlCQURieEQsU0FuRlo2L0I7V0FxRlEsSUFBSnRzRCxFQUFJLGFBckZSc3NEO1dBcUZRO2FBRUYsZ0NBRkZ0c0QsRUFGaUJ2QixPQUdqQm01Qjs7OzthQUVrQixlQUZsQkEsTUFFa0IsVUFBUGtLO1dBRUosVUFKUGxLLE1BSU8sV0ExRlgwMEIsR0FtRjRCdnRELFFBbkZyQmcxRDs7ZUEyRnVCOTBELFFBM0YzQmd4QixTQTJGb0J0eEIsUUEzRnBCc3hCLFNBMkZXcEQsVUEzRlhvRDtXQTRGSyxpQkFBaUIsaUJBRFhwRCxXQTNGZHkvQjtXQTZGUSxJQUFKbmtELElBQUksYUE3RlJta0Q7V0E2RlE7YUFHYzswQ0FIbEJua0Q7Y0FHa0I7Y0FDQyw0QkFKbkJBO2NBSW1CO2NBY25CLGtCQWRZdXdCLE1BY0ssVUFBVyxLQXBCVC81QjtjQW1CbkIsaUJBZFkyNUIsTUFjSSxVQW5CRzM1QjtjQUduQnU1QjtjQUFLSDs7OzthQWtCYTs7NkJBQVBpWTtjQWxCWDlYO2NBQUtIO1dBcUJIO3NCQXJCRkcsTUFEQS92QjttQkFzQkUsV0FuSE5ta0QsR0FtSG9CLFdBckJYdjBCLE1BSHFCOTRCLFNBM0Z2QjgwRDtrQkEyRFA7a0JBRUE7O1dBNEU0QjtZQURJNTBELFFBeEk3Qjh3QjtZQXdJYXAxQixlQXhJYm8xQjtZQXlJeUIsOEJBRFpwMUI7V0FDaEIsc0IsT0F4NkJJcTBELFdBK3hCSjVDO1dBeUk0QixJQXpJekJyOEIsTUF3STZCOXdCOzs7b0JBeEk3Qjh3Qjs7aUJBMkkwQzd3QixRQTNJMUM2d0IseUJBMkkrQmlKO2FBQ2xDLFdBNUlBb3pCO2FBNEltQixXQTVJbkJBO2FBNkljLHNCQUZvQnB6QixNQUFXOTVCLFNBM0kxQzZ3Qjs7ZUE4STBDMXdCLFFBOUkxQzB3Qix5QkE4SStCdUo7V0FDbEMsV0EvSUE4eUI7V0ErSW1CLFdBL0luQkE7V0FnSmMsc0JBRm9COXlCLE9BQVdqNkIsU0E5STFDMHdCOzs7V0FpRUgsSUFET21ILFNBaEVKbkg7V0FpRUgsR0FqRU84akM7YUFtRUs7Y0FESVAsYUFsRVRPO2NBa0VDVCxPQWxFRFM7Y0FtRUssYUFESlQsT0FsRVJoSDthQW9FYSxVQURMbnNELEVBQ0ssV0FwRWJtc0QsR0FnRU9sMUIsU0FFU284QjtXQUlaOztvQkF0RUR2akM7O2FBc0hZO2NBRGlEeHdCO2NBQVp1MUQ7Y0FDckMsa0NBRHFDQTtjQUNyQzs7Y0FDSDthQUNaLCtCQUZJQyxPQUNBcnZCLFFBdkhKMG1CO2FBc0hlLElBR1AsaUJBekhSQSxJQXlIUSxlQUhDbHhCLE1BRHVEMzdCO2FBTXZELFVBRkx5MUQsSUFFSyxXQTNIVDVJLEdBMEhJNkksV0ExSEdwQjtXQTZISyxJQUFScm5DLE1BQVE7V0FDWiw4QkFESUEsTUE3SEo0L0I7V0E2SFksSUFFUi9zQyxJQUFJLGFBL0hSK3NDO1dBZ0lTLFVBREwvc0MsSUFDSyxXQWhJVCtzQyxRQUFPeUg7O1dBa0lLO1lBRGVyMEQsUUFqSXhCdXdCO1lBaUllendCLFFBaklmeXdCO1lBa0lTLGtCQWxJWnE4QixHQWlJa0I5c0Q7V0FFTCxVQURUbW5CLE1BQ1MsV0FuSWIybEMsR0FpSTJCNXNELFFBaklwQnEwRDs7V0FxSVAsWUFySUc5akMsU0FxSUssc0JBcklScThCO1dBc0lTLFVBREwxL0MsSUFDSyxXQXRJVDAvQyxHQW9JZTFzRCxRQXBJUm0wRDs7V0FtSnFCO1lBRFJ4eUIsUUFsSmpCdFI7WUFrSll0d0IsSUFsSlpzd0I7WUFtSnlCLHVDQURidHdCLElBQUs0aEM7WUFDUTtZQUNoQixtQkFwSlorcUIsR0FtSnFCdnlCLE9BbkpkZzZCO1dBb0pLLFlBQ1ksSUFBYnFCLG9CQUFhLE9BQWJBO1dBQ0Y7O1dBdkZULDhEQTJGRztJQWxhMEIsU0E0YzdCQyxPQUFPL0ksR0FBR2dKO1VBQWlCLzJELGFBQUxxdUI7ZUFDaEIyb0MsTUFDRjExRCxFQUFFZ3lDO1lBQUZ4RCxNQUFFbW5CO1FBQVE7YUFBUkE7WUFDaUI7YUFBWmx4RCxFQURMa3hEO2FBQ0VyMUQsRUFERnExRDthQUNpQixlQURuQm5uQixJQUNJbHVDO2FBREprdUM7YUFBRW1uQixPQUNLbHhEOztVQUNGLE9BRkwrcEMsSUFFTTtlQUVSdGlDLEVBQUVnb0QsUUFBUWwwRDtRQUNaLFlBUE95c0Q7UUFPUDtVQUNlLHVCQVJSQSxHQUFlMS9CLElBTWxCbW5DO2NBR0EwQjs7Ozs7Ozs7Ozs7OztlQUNpQjN6QixJQURqQjJ6Qjs7Z0JBRUE7a0JBQVksSUFESzN6QixJQUNFLGtCQUFrQixjQVhkdmpDOztVL0JwOUJ2QiwwQitCNjlCQWszRDs7MEJBSWEsSUFBUjVqQixhQUFRLGFBUExoeUMsRUFPSGd5QztRQUNNLElBQVA0akI7UUFBTyxrQkFkTEgsR0FBSGhKLEdBY0NtSixJQUFnQjthQTlUcEJoQyxvQkFzVEYxbkQsRUFOb0I2Z0I7SUE1Y08sU0FpZTdCOG9DLE9BQU9wSixHQUFHMS9CLEtBQU0sY0FBVDAvQixHQXpXUHlHLGdCQXlXVW5tQyxJQUFvQztJQWplakIsU0FtZTdCK29DLFFBQVEzMUQsRUFBRXMxRCxHQUFHMW9DLEtBQWMsNEJBQW5CNXNCLEdBQUVzMUQsR0FBRzFvQyxJQUE2QztJQW5lN0IsU0FvZTdCZ3BDLE9BQU81MUQsRUFBRTRzQjtNQUFjLDRCQUFoQjVzQixHQTVXUCt5RCxnQkE0V1NubUMsSUFBMEQ7SUFwZXRDLFNBc2U3QmlwQyxNQUFNanBDLEtBQU0sY0Fob0NWbWhDLE1Ba3hCRmdGLGdCQThXTW5tQyxJQUErQztJQXRleEIsU0EyZTdCa3BDLGNBR0V4SixHQUFHeUosT0FBT2wyRDtNQUNKLGlCOUJ6NUNSaUIsUThCdzVDRXdyRDtNQUVRLElBQU4vdEQsSUFBTSxhQUZSK3REO01BRVE7UUFFSixpQ0FGRi90RCxJQUZDdzNELFFBR0RucEM7Ozs7UUFFa0IsZUFGbEJBLElBRWtCLFVBQVBrVjtNQUNmLGtCQU5ZamlDLEVBR1Irc0IsSUFHRTtJQXBmdUIsU0F1ZjdCb3BDLGNBR0VoMkQsRUFBRSsxRCxPQUFPbDJEO01BQW1CLG1DQUE1QkcsR0FBRSsxRCxPQUFPbDJELEVBQW9EO0lBMWZsQyxTQTBnQjdCbzJELG1CQUFtQmoyRCxFQUFFNHNCO01BWnZCLElBQUk5cUIsRUFBSixzQkFZcUI5QjtNQUNyQixjQUE0Q0csR0FBSyxPQUFMQSxDQUFNO01BWjFDLElBQUpxQixFQUFJLFNBREpNO01BRUosU0FESU47TUFBSSxJQUNSLEtBRklNLFVBRUo7O1lBQ0FuRztRQUNFO2NBQUlpSCxFQUFKLGdCQVFtQjVDLEVBVHJCckU7VUFDRSxVQUFJaUgsRUFDYSxTQUpmcEI7VUFLRixTQUxFQSxFQUdFb0I7VUFBSixTQURGakg7OztNQUtBLFNBUEk2RjthQVJGdzBELGNBZUYsU0FQSXgwRCxHQVdtQm9yQixTQUM0QjtJQTNnQnBCLFNBOGdCN0JzcEMsVUFBVWwyRDtNQUNaLGNBQXFDRyxHQUFLLE9BQUxBLENBQU07TUFBcEMsb0NBQVEsSUFESEgsc0JBQ2dDO0lBL2dCYixTQW1oQjdCbTJELFFBQVFqeUQsR0FBR294RCxHQUFHMW9DLEtBQWMsZ0NBQXBCMW9CLElBQUdveEQsR0FBRzFvQyxJQUFvRDtJQW5oQnJDLFNBb2hCN0J3cEMsT0FBT2x5RCxHQUFHMG9CO01BQWEsZ0NBQWhCMW9CLElBNVpQNnVELGdCQTRaVW5tQyxJQUFnRTtJQXBoQjdDOzs7O1FBMXBCM0JtaEM7UUFhQUU7UUFDQUM7UUFNQUU7UUFQQUg7UUFDQUM7UUF0SEFWO1FBV0FDO1FBNkdBVTtRQTFMQTFCO1FBT0FDO1FBRUFDO1FBaUtBb0I7O09BMm5DRjJIO09BR0FFO09BRUFDO09BMUJBUjtPQXVCQU07T0FRQUc7T0FZQUU7T0FtQkFDO09BSUFDO09BTUFFO09BREFEO0lBbmhCNkI7UUM1L0I3QkU7YUFHQUMsbUJBQW1CM3pELEtBQ2pCMlk7TUFDVSxJQUFWakosS0FBVSxhQURWaUo7TUFFSixpQ0FIcUIzWSxLQUVqQjBQLEtBQzBCOzJCQU41QmdrRCxTQUdBQzs7b0JDQUt2MkIsR0FDUCxJQUFJdzJCLElBQUosZ0NBQUlBLElBQ0k7UUFZTkMsd0JBVUFDLHNCQU9BQztpQ0Flb0IxMkQ7TUFDdEIsMENBRHNCQSxXQUN0Qjs7WUFDQXJFO1FBQ0U7VUFBZ0MseUJBSFpxRSxFQUV0QnJFO1VBQ2tDLGlCQUY5Qm1KO1VBRThCLFNBRGxDbko7OztNQUlBLFVBTEltSjtNQUFKLElBT0k2eEQsaUJBUEE3eEQ7TUFTSixPQUZJNnhELEdBRUs7SUF5Q2dCO0tBcENXQzs7S0FJQUM7O0tBR0RDOztLQWdCakNDLG9CQXJEQUw7S0ErREFNO0tBR3VCO2FBSW5CRSxTQUFTNTFELEdBQ2YsV0FEZUEsRUFFZixVQUZlQSw2QkFFTztJQU5HLFNBUXZCNjFELFVBQVVDO01BQ1o7O1dBRFlBO09BQ1osd0JBQ0k3ekQscUJBVkYwekQ7TUFZRixpQkFESUksZ0JBREE5ekQ7TUFESixXQUlzQixTQUhsQkE7TUFHSixpQkFGSTh6RDtNQUZKLElBSUEsS0FISTl6RCxZQUdKOztZQUNBNUg7UUFBd0I7VUFBeUI7aUJBQWpEQTtXQUFpRCxzQkFOckN5N0QsV0FNWno3RDtVQUF3QixpQkFIcEIwN0Q7VUFHNkMsU0FBakQxN0Q7OztNQUNBLFVBeEZFODZELG9CQW9GRVksdUNBVzBCO0lBdEJMLFNBd0J2QkMsU0FBTzVuRCxNQUFNNm5EO01BQ2YsYUFEUzduRCxvQkFDVCxLQUFJOG5ELFdBRFdEO01BQ2Y7UUFDNEIsSUFDdEJFLFNBRHNCLGVBRmJGLFNBeEJiTjtRQTRCQSxPQUpPdm5ELFdBR0grbkQsV0FGRkQ7UUFHRixXQURJQztRQURzQjs7O01BakI1QixXQXFCRTtJQTlCdUI7YUE0Q3ZCRyxXQUFXQztNQUNiLElBQUl6YSxNQURTeWE7TUFFYixTQUZhQSxNQUNUemE7TUFDSixPQURJQSxLQUVDO0lBL0NvQixTQWlEdkIwYSxpQkFBaUJELE1BQU1sMUQ7TUFDekI7UUFDRSw4QkFGdUJBLEtBQU5rMUQ7Ozs7VUFJTCxJQUFSRSxNQUFRLFdBSktGO1VBS1EsK0JBTEZsMUQsS0FJbkJvMUQsTUFKYUY7VUFNUyw4QkFGdEJFLFFBSmFGO1VBTVMsT0FGdEJFO1FBUk4sV0FXTztJQXhEa0IsU0EwRHZCQyxrQkFBa0JILE1BQU1JO01BQ2hCLDRCLE9BVlJILGlCQVNrQkQsYUFBTUksTUFDYztJQTNEZixTQTZEdkJDLFdBQVdMLE1BQU1FLE1BQU1JO01BQ3pCO01BQ0csMkJBRmdCSixNQUFORjtnQkE1QmIsU0E0QmFBLE1BQU1FO2dCQTVCbkIsaUJBNEJhRixTQUFNRTs7Z0JBQU1JO2dCQUFaTixpQkFBTUUsTUFBTUksU0FBWk4sWUFLaUQ7SUFsRXJDLFNBb0V2Qk8sV0FBV1AsTUFBTUU7TUFDbkI7UUFBSSxlQURlQSxNQUFORjs7OztnQkFFSyxpQkFGTEEsU0FBTUU7bUJBRW9CO0lBdEVkLFNBd0V2Qk0sVUFBUTdvRCxLQUNWLE9BRFVBLFlBQ3FCLFFBRHJCQSxJQUNzQztJQXpFdkIsU0EyRXZCOG9ELE9BQU9ULE1BQU1VLEtBQUtDLFdBQVdDO01BQ3BCO3dCQURJRjtPQUVFLHVCQUZHQztPQUdGLHdCQUhhQztPQUlWOzt5QixPQTlCbkJYLGlCQTBCT0QsYUFFTGM7T0FHa0I7O3lCLE9BL0JwQmIsaUJBMEJPRCxhQUdMZTtNQUVrQjs7O1VBTGJmLG9DQUlMZ0IsZUFIQUg7T0FES2I7TUFDRSxJQUlXLGtCQUxiQTtNQUthLGNBT2JrQixJQUFJMWxCLEtBQUsybEI7UUFDVCxXQURBRCxJQVhMTCxRQVk0QixtQkFEdkJLLElBQUkxbEIsS0FBSzJsQixZQUNnRDtNQUZoRTs7TUFNRjtpQkFDT0csSUFBSXBCO1VBQ0ssaUNBRFRvQixJQUFJcEIsTUFIUGtCO1VBSVksU0FIWkM7VUFHWTtZQUdELDZCQUpKbkIsTUFsQkZGOzs7OztVQXFCRCxpQ0FIR0U7VUFHSCxRQUVXO1FBcEJmYTtRQUVBRTtNQW9CSjtpQkFDT0ssSUFBSXBCO1VBQ0ssaUNBRFRvQixJQUFJcEIsTUFYUGtCO1VBYWEsaUNBRk5sQixRQVZQbUI7VUFZYSxRQUE4QjtRQTFCM0NQO1FBRUFFO01BcUJKLFdBVklJO01BVUosV0FUSUM7TUFMRixJQWNGLFlBekJTckI7TUFpQ047OztpQkFDT3NCLElBQWtCQztVQUF2QixJQUFPTCxJQUFGSSxPQUNDLFdBRENKLElBOUJSRixnQkE4QndCTyxNQUFsQkQsSUFBa0JDLEdBQ2dDOzs7TUFGekQsUUFJSTtJQWhIa0IsU0FrSHZCQyxNQUFNeEI7TUFFTjtnQkFGTUE7T0FFTjs7Ozs7O01BRXVCLGNBSmpCQTtNQU1MOzs7aUJBQ083M0QsRUFBRTJEO1VBQWdCLDZCQUFoQkEsRUFQSmswRDtVQU9vQiwwQkFBaEJsMEQsT0FBRjNELEVBQTRDO1FBTlZzNUQ7UUFBd0JmO01BS2pFLFdBTEVVO01BS0YsV0FMV0M7TUFDWixTQUZNckI7TUFZTDs7O2lCQUNPc0IsSUFBa0JDO1VBQXZCLElBQU9MLElBQUZJLE9BQ0MsV0FEQ0osSUFaNENQLFlBWTVCWSxNQUFsQkQsSUFBa0JDLEdBQzRCOztRQWJoQ0c7TUFXckIsUUFJb0I7SUFsSUUsU0FvSXZCQyxTQUFTM0I7TUFDWCxJQUFJemEsTUFET3lhLFNBQ1gsV0FBSXphLGNBQUosT0FBSUEsS0FFQztJQXZJb0IsU0F5SXZCcWMsYUFBYTVCLE1BQU1sMUQ7TUFDckI7UUFBSSw2QkFEaUJBLEtBQU5rMUQ7Ozs7VUFHRCxJQUFSemEsTUFBUSxTQUhDeWE7VUFJVix3QkFKZ0JsMUQ7V0FBTmsxRCxXQUlvQixtQkFKZGwxRCxLQUdmeTZDLE1BSFN5YTtVQUtiLE9BRkl6YTtRQVBOLFdBU087SUE5SWtCLFNBZ0p2QnNjLFNBQVNscUQsS0FDUixrQkFEUUEsY0FDNEI7SUFqSmQsU0FtSnZCbXFELHNCQUFzQjlCLE1BQU0rQixNQUFNQztNQUN4Qjt3QkFEa0JEO09BQ2xCLE9BQVJFO09BQVEsTUFEd0JEO09BQ3hCLG1CQUNSRSxTQUFnQ0M7T0FEeEIsS0FDUkQ7T0FEUTs7WUFHWmg0RDtRQUNFO1VBQVc7OzZCQUxXODFELE1BS1ksaUJBSmhDaUMsUUFHSi8zRDtVQUNFLGlCQUZFa0QsSUFDSmxEO1VBQ2EsU0FEYkE7OztNQUhZLElBTVosS0FMb0NpNEQsY0FLcEM7OztRQUNFO1VBQWtCO2dCQURwQnIrRCxJQUxJbytEO1dBTWdCLGtCQVJJbEMsTUFRZSxpQkFSSGdDLEtBT3BDbCtEO1VBQ0UsaUJBTEVzSjtVQUtnQixTQURwQnRKOzs7TUFHQSxPQVBJc0osR0FPRDtJQTdKc0IsU0ErSnZCZzFELGFBQWFwQyxNQUFNbDFEO01BQ3JCO1FBQUksNkJBRGlCQSxLQUFOazFEOzs7O21CQUM2QztJQWhLbkMsU0FrS3ZCcUMsY0FBY3JDLE1BQU1JO01BQ1osNEIsT0FKUmdDLGFBR2NwQyxhQUFNSSxNQUNjO0lBbktYLFNBcUt2QmtDLGdCQUFnQnRDLE1BQU1oNEQsR0FDeEIsY0FEd0JBLEVBQU5nNEQsVUFDbEIsUUFBMkM7SUF0S2xCLFNBbUx2QnVDLGFBQWFDO01BQ2YsR0FEZUEsNEJBQ21CO01BRXZCO3NDQUhJQTtPQUlILGdCQURSeGE7TUFFSjtpQkFDT2xrRCxFQUFFdzlEO1VBQ0wsSUFBSUosS0FERHA5RDtVQUV1QiwrQkFGckJ3OUQsSUFDREosSUFISmxCO1VBSzBCLDhCQUZ0QmtCLE1BSEpsQjtVQUswQixRQUF3QztRQVR2RHdDO01BS2YsT0FESXhDLEtBT0M7SUE5TG9CLFNBZ012QnlDLFdBQVd6QztNQUNiLHFCQTFKRUYsb0JBeUpXRTtNQUVTLGVBRlRBO01BR1c7ZUFIWEE7cUJBR1csaUJBSFhBLHVDQUdrRDtJQW5NdEMsU0FxTXZCMEMsU0FBU0MsSUFBSVgsS0FBS3JCLFdBQVdDLGtCQUErQmwwQztVQUFMM0ssYUFBVjZnRDtNQUMvQyxPQURXRCxJQUFJWCxLQUFLckIsV0FBV0M7TUFDL0IsSUFDSW5sRCxLQUYwRGlSLElBR2hELFdBSGlDazJDLFFBQXBDRCxJQUE4QzVnRCxLQUdmLFdBSEs2Z0QsUUFBcENEO01BSVgsTUFKV0E7TUFDWDtPQUdBO09BTUssY0FWMEIvQjtPQVE1Qjs7O29CQUNPaUMsSUFBMkIsa0JBVDFCRixJQVMwQixpQkFUMUJBLElBU0RFLElBQStEOztPQUZsQyxjQVB4QmI7TUFPTDs7bUJBTE52bUQ7O2lCQUtNLHFCLE9BN0NSMm1ELGFBc0NTTzs7SUFyTWMsU0FpTnZCRyxXQUFXQyxVQUFVQztNQUNYLHVCQURDRCxXQUVFLG9CQUZRQyxXQUNuQmhEO01BRUosV0FGSUE7TUFHSCxxQkFGR2lELFlBRm1CRCxXQUVuQkMsV0FFcUQ7SUFyTmhDLFNBeU52QkMsaUJBQWlCSCxVQUFVQyxXQUFXRztNQUM1Qix1QkFET0osV0FFSixvQkFGY0MsV0FDekJoRDtNQUVKLFdBRklBO01BRUosZ0JBSDZCZ0Q7TUFHN0IsZ0JBRElDO01BQ0osUUFFK0I7SUE5Tk4sU0FnT3ZCRyxZQUFZQztNQUNkLFNBQUlDLGFBQWlCLG9DQURQRCxJQUM2QztNQUEzRCxVQUFJQyxvQkFDdUM7SUFsT2xCLFNBc092QkMsY0FBY3ZEO01BRWhCLElBQUk1bUQsSUFBSixtQkFGZ0I0bUQ7TUFLaEIsU0FMZ0JBO01BS2hCLHNCQUhJNW1ELElBR2dCO0lBM09LLFNBNk92Qm9xRCxrQkFBa0JDLE1BQU16RDtNQUMxQixHQURvQnlEO01BQ3dCLElBRXRDcnFELElBRnNDLG1CQURsQjRtRDtNQU14QixTQU53QkE7TUFNeEIsc0JBSEk1bUQsSUFJSDtJQXBQc0IsU0FzUG5Cc3FELE9BQU90cUQ7TTs7O2NBR1JuUCxhQUFIakM7VUFBUSxXQUFSQSxFQUhXb1I7c0JBR1JuUDs7UUFESztJQXhQZSxTQTJQdkIwNUQsaUJBQWlCdnFELElBQUk0bUQ7TUFDdkIsVUFEdUJBLFNBQ3ZCLFdBQUk0RDtNQUFKLFlBRUUsT0FIaUJ4cUQsSUFDZndxRCxXQUVjO0lBOVBPLFNBZ1F2QkMscUJBQXFCSixNQUFNcnFELElBQUk0bUQ7TUFDakMsR0FEdUJ5RCxhQUFNcnFEO01BQ2EsSUFDcEN3cUQsTUFGMkI1RDtNQUNTLFNBQ3BDNEQsTUFDZ0IsT0FIT3hxRCxJQUV2QndxRDtNQUNnQyxPQUhUeHFELEdBSzFCO0lBclFzQixTQXVRdkIwcUQsbUNBQW1DTCxNQUFNekQ7TUFDM0MsR0FEcUN5RDtNQUV6QixJQUFOcnFELElBQU0sY0FGK0I0bUQ7TUFHekMsaUJBREk1bUQsSUFGcUM0bUQ7TUFHekMsT0FESTVtRCxHQUdIO0lBNVFzQixTQXVTdkIycUQsV0FFSzV3RDtNQUZNLEdBRU5BLHNCQURJLDZCQUNpQjtJQXpTSCxTQThTdkI2d0QsV0FBV3Y2RCxFQUFFdzZELEtBQUt2aEQ7TUFDcEIsdUJBQUl0VixLQUFKO1lBRGEzRDtZQUdiM0Y7UUFDRTttQkFGRTJJO1VBRWUsMkJBSkp3M0QsS0FHZm5nRTtVQUNFLFNBREZBO2FBSGEyRixNQUdiM0Y7O01BRkEsU0FDSTJJO01BbEJrQixHQWdCRmlXLFFBZEgsd0JBZWJ0VjtNQWhCTyw2QkFzQlI7SUFyVHNCLFNBMFV2QjgyRCxjQUFjQyxLQW5CSUY7TUFvQmQsSUFwQm1CRyxTQW9CbkIsV0FEVUQ7TUFDVixHQXBCbUJDO1FBc0J2QixRQXRCa0JILHdCQUFGbmdFLE1BQU80ZTs7UUFDekI7a0JBRGtCNWU7WUFFbEIseUJBRm9CbWdFLEtBQUZuZ0UsVUFHRXVnRSxTQUhLM2hEO1lBSXZCO2NBdkJVLEdBc0JRMmhEO21DQURoQnh2QjtrQkFHTSxJQUxleXZCLFNBS2YsV0FGVUQ7a0JBRVYsR0FMZUM7b0JBUWpCLFFBUlV4Z0UsZ0JBQU80ZTtrQkFNVjtnQkFuQkYsR0FnQk8yaEQ7a0JBZEgsU0FjR0E7O2tCQWRILElBWEN2NEQsS0F3QmQrb0M7a0JBeEJrQixHQXlCRnd2QjtvQkF2QkgsY0FGQ3Y0RCxTQWFoQms0RCxXQVNnQmxnRSxVQUFFbWdFLEtBdEJGbjREO2tCQUNQO2dCQVNBO2NBTkE7VUFtQkcsT0FEVzRXO01Bd0J2QixrQkF4QmtCdWhELDZCQW1CSkUsS0FLOEI7SUEvVXJCLFNBa1l2QkksVUFBVXZFO01BQ0osSUFBSnYyRCxFQUFJLFdBREl1MkQ7TUFDSixVQUFKdjJEOzs7aUJBRThCLGlCQUh0QnUyRCwwQ0FDUnYyRDs7O1lBQ0E4SSxJQUVVLFdBSkZ5dEQ7TWpDY04sa0JpQ1pGenRELElBREE5STtNQUtKLGlCQU5ZdTJELFNBRVJ6dEQ7TUFJSixPQUpJQSxHQUtIO0lBell3QixTQTZkdkJpeUQsWUFBWXhFLE1BQU1SO01BQ3BCLFFBRG9CQSxtQkFDcEI7O1dBeERvQjE3RCxPQXdEaEI0SDtVQUVGO2dCQTFEa0I1SDtXQTBEbEIsdUJBSGtCMDdEO1dBdERwQjs7Y0FBYzt1QkFETTE3RDtjQUNOLHdCQXNETTA3RCx1QkF0RGdCO1dBQzlCO29CQW1ESmlGOzs7Y0FsRHdCOztlQXVEUUMsTUE3SWxCLFNBQUpwOEQsRyxnQkFBYThRLEtBQVEsT0FBckI5USxDQUFzQixHQUF0QkE7OztjQXVGVTs7ZUFzRFlvOEQsTUE1SWxCLFNBQU5qN0QsRyxnQkFBZTJQLEtBQU8sT0FBUEEsSUFBZjNQLE1BQTRDLEdBQTVDQTs7O2NBdUZZOztlQUFrQjtlQXFETmk3RDtnQkExSWxDLFNBRFV0b0QsRUFBRTNTLEcsZ0JBQ0gyUCxLQUNQLE9BRE9BLElBRENnRCxPQUFFM1MsTUFFbUQ7a0JBRnJEMlMsRUFBRTdKOzs7Y0F1RlU7O2VBb0RZbXlEO2dCQXhJbEIsU0FBTGo3RDttQixnQkFBYzJQLEtBQU8sa0JBQVBBLE9BQWQzUCxPQUFjMlAsSUFBcUI7a0JBQW5DM0c7OztjQXFGVzs7ZUFtRFlpeUQ7Z0JBdklsQixTQUFOajdELEcsZ0JBQWUyUCxJQUFJOVEsR0FBSyxJQUF4Qm1CLFNBQW1CbkIsRUFBSyxRQUF3QjtrQkFBaERxOEQ7OztjQXFGWTs7ZUFBa0I7ZUFrRE5EO2dCQXRJaEIsU0FBTjE4RCxFQUFFTSxHLGdCQUFhOFEsS0FBUSxrQkFBdkJwUixFQUFFTSxFQUF3QjtrQkFBMUJOLEVBQUU4dUM7OztjQXFGUTs7ZUFBa0I7ZUFpRE40dEI7Z0JBckloQixTQUFSMThELEVBQUV5QjttQixnQkFBZTJQLEtBQU8sa0JBQXhCcFIsRUFBaUJvUixJQUFmM1AsT0FBZ0Q7a0JBQWxEK3NDLElBQUVvdUI7OztjQXNGQTs7ZUFBbUI7ZUFBa0I7ZUErQ2ZGO2dCQW5JbEMsU0FEVTE4RCxFQUFFb1UsRUFBRTNTO21CLGdCQUNMMlA7cUJBQ1Asa0JBRlFwUixFQUNEb1IsSUFER2dELE9BQUUzUyxPQUVxRDtrQkFGekRndEMsSUFBRWg2QixJQUFFb29EOzs7Y0F1RlE7O2VBQWtCO2VBNkNOSDtnQkFqSWhCLFNBQVAxOEQsRUFBRXlCO21CLGdCQUFjMlA7cUJBQVMsa0JBQXpCcFIsRUFBeUIsV0FBVG9SLE9BQWQzUCxPQUFjMlAsS0FBeUI7a0JBQXpDdTlCLElBQUVtdUI7OztjQXNGRDs7ZUFBa0I7ZUFBa0I7ZUEyQ2RKO2dCQWhJUixTQUFSMThELEVBQUVNLEVBQUVDO21CLGdCQUFhNlEsS0FBUSxrQkFBekJwUixFQUFFTSxFQUFFQyxFQUEwQjtrQkFBOUJ3dUMsSUFBRUUsSUFBRTF1Qzs7O2NBd0ZWOztlQUFrQjtlQUFrQjtlQXdDZG04RDtnQkEvSFIsU0FBVjE4RCxFQUFFTSxFQUFFbUI7bUIsZ0JBQWUyUCxLQUFPLGtCQUExQnBSLEVBQUVNLEVBQWlCOFEsSUFBZjNQLE9BQWtEO2tCQUF0RDZ0QyxJQUFFRixJQUFFMnRCOzs7Y0EwRlI7O2VBQWtCO2VBQWtCO2VBQW1CO2VBcUNqQ0w7Z0JBMUhsQyxTQURnQjE4RCxFQUFFTSxFQUFFOFQsRUFBRTNTO21CLGdCQUNiMlA7cUJBQ1Asa0JBRmNwUixFQUFFTSxFQUNUOFEsSUFEV2dELE9BQUUzUyxPQUUrQztrQkFGckQrdEMsSUFBRXd0QixJQUFFcjlDLElBQUVzOUM7OztjQXlGVjs7ZUFBa0I7ZUFBa0I7ZUFrQ2RQO2dCQTlIVCxTQUFSMThELEVBQUVNLEVBQUVtQjttQixnQkFBYTJQO3FCQUFXLGtCQUE1QnBSLEVBQUVNLEVBQTBCLFdBQVg4USxPQUFiM1AsT0FBYTJQLEtBQTJCO2tCQUE1Q3ErQixJQUFFeXRCLElBQUVDOzs7Y0ErRlQ7O2VBQWtCO2VBQWtCO2VBK0JkVDtnQkE3SFYsU0FBUjE4RCxFQUFFeUIsRUFBRW5CO21CLGdCQUFhOFEsS0FBTyxrQkFBeEJwUixFQUFpQm9SLElBQWYzUCxPQUFFbkIsRUFBZ0Q7a0JBQXBEODhELElBQUVDLElBQUVDOzs7Y0FpR1I7O2VBQWtCO2VBQW1CO2VBQWtCO2VBNEJqQ1o7Z0JBdkhsQyxTQURnQjE4RCxFQUFFb1UsRUFBRTNTLEVBQUVuQjttQixnQkFDYjhRO3FCQUNQLGtCQUZjcFIsRUFDUG9SLElBRFNnRCxPQUFFM1MsT0FBRW5CLEVBRStDO2tCQUZyRGk5RCxJQUFFQyxJQUFFQyxLQUFFQzs7O2NBK0ZWOztlQUFrQjtlQUFrQjtlQXlCZGhCO2dCQTVIVCxTQUFSMThELEVBQUV5QixFQUFFbkI7bUIsZ0JBQWE4UTtxQkFBUyxrQkFBMUJwUixFQUEwQixXQUFUb1IsT0FBZjNQLE9BQWUyUCxLQUFiOVEsRUFBd0M7a0JBQTVDcTlELElBQUVDLEtBQUVDOzs7Y0FzR1Q7O2VBQWtCO2VBc0JJbkI7Z0JBckhYLFNBQU5qN0QsRUFBRW5CO21CLGdCQUFhOFE7cUJBQU8sa0JBQVBBLE9BQWYzUCxPQUFlMlAsSUFBYjlRLEVBQStDO2tCQUFqRHc5RCxLQUFFQzs7O2NBaUdQOztlQUFrQjtlQW9CSXJCO2dCQW5IbEMsU0FEZWo3RCxFQUFFMGdCO21CLGdCQUNSL1E7cUJBQU8sa0JBQVBBLE9BRE0zUCxPQUNOMlAsUUFEUStRLE9BQ2lEO2tCQURuRDY3QyxLQUFFNzdDOzs7Y0FrR0w7O2VBQWtCO2VBQWtCO2VBa0JkdTZDO2dCQWpIbEMsU0FEZWo3RCxFQUFFMlMsRUFBRStOO21CLGdCQUNWL1E7cUJBQU8sa0JBQVBBLE9BRE0zUCxPQUNOMlAsUUFEUWdELE9BQUUrTixPQUVnRDtrQkFGcEQ4N0MsS0FBRUMsSUFBRTU2Qzs7O2NBbUdQOztlQUFrQjtlQWVJbzVDO2dCQTlHbEMsU0FEZ0JqN0QsRUFBRTBnQjttQixnQkFDVC9RO3FCQUFpQyxvQkFBakNBLE9BRFMrUSxPQUNUL1E7cUJBQWlDLGtCQUFqQ0EsT0FETzNQLE9BQ1AyUCxTQUFpRDtrQkFEMUMrc0QsS0FBRWw2Qzs7O2NBa0dOOztlQUFrQjtlQUF5QixZQVV6Qyt6QztlQUdvQjBFO2dCQTVHbEMsU0FEYXY2QyxFQUFFN2hCLEVBQUV5QzttQixnQkFDUnFPO3FCQUFPLHlDQUREOVEsRUFBRjZoQixLQUFFN2hCLEVBQUV5QyxFQUN1QztrQkFEM0NxN0QsSUFBRUMsSUFBRXQ3RDs7O2NBa0dMOztlQUFrQjtlQUF3QixjQVF4Q2kxRDtlQUdvQjBFO2dCQTFHbEMsU0FEV3Y2QyxFQUFFMWdCLEVBQUVzQjttQixnQkFDTnFPO3FCQUNQLFNBRE9BLElBREkzUDtxQkFFWCw4Q0FGUzBnQixVQUFJcGYsRUFHZTtrQkFIbkJ1N0QsSUFBRUMsS0FBRXp4RDs7O2NBa0dIOztlQUFrQjtlQUFrQjtlQUM3QixjQUtMa3JEO2VBR29CMEU7Z0JBdEdsQyxTQURXdjZDLEVBQUUvTixFQUFFM1MsRUFBRXNCO21CLGdCQUNScU87cUJBQ1AsU0FET0EsSUFESWdELE9BQUUzUztxQkFFYiw4Q0FGUzBnQixVQUFNcGYsRUFLZTtrQkFMckJ5N0QsSUFBRUMsSUFBRUMsS0FBRTN4RDs7O2NBaUdMOztlQUFrQjtlQUF5QixjQUd6Q2lyRDtlQUdvQjBFO2dCQWhHbEMsU0FEWXY2QyxFQUFFMWdCLEVBQUVzQjttQixnQkFDUHFPO3FCQUNHLG9CQURIQSxPQURLM1AsT0FDTDJQO3FCQUNHLDhDQUZBK1EsVUFBSXBmLEVBRXlDO2tCQUY3QzQ3RCxJQUFFQyxLQUFFNXhEOztlQWlHa0IwdkQsTUFMaENEO1VBTUEsV0FKWXpFLE1BR1JFLE1BQTRCd0U7VUFDaEM7O1FBMURZLFNBNERWO0lBbmVxQixTQTBldkJtQztNQUNGLFVBOWVFMUgsZUF5Q0FVLGdCQUNBQyxrQkFxY3VEO0lBNWVoQzs7OztPQTRDdkJDO09BNkZBNkI7T0FVQUU7T0FZQU07T0FHQUM7T0FqSEFwQztPQVNBRTtPQVVBSTtPQVBBRjtPQWdhQW1FO09BbFpBL0Q7T0F1Q0FlO09BbURBYztPQWxMQXBEO09BZ01BcUQ7T0FhQUU7T0FLQUM7T0FZQUk7T0FRQUk7T0FPQUU7O09BTUFHO09BT0FDO09BY0FHO09BS0FFO09BT0FDO09BbUVBSTtPQTdaQXZGO09BNmpCQWtJO0lBMWV1Qjs7Ozs7Ozs7O0tDL0ZOO2VBQWpCQztLQUFpQjthQUtqQkc7TUFBa0IsWUFMbEJILGVBS2tCLHNCQUFxQztJQUx0QyxTQU9qQkksTUFBTW44RDtNQUNSLHdCQU5FZzhELGNBQ0FDO1FBS3NDLElBQ2xDRyxVQURrQyxzQkFMdENIO1FBT0EsS0FSQUQsWUFPSUksWUFOSkg7UUFPQSxZQURJRztNQUlOLGVBWEVKLFVBQ0FDLFVBSU1qOEQ7TUFNUjtjQUNXO0lBZFEsU0FnQmpCcThEO01BQ00sSUFBSmovRCxFQUFJLFdBZk40K0QsWUFDQUM7TUFjTSxZQWpCTkY7TUFpQk0sT0FBSjMrRCxDQUFxRTtJQWpCdEQsU0FxQmpCay9ELFdBQVdDO01BQ0csSUFBWkMsVUFBWTtNQUNoQjtpQkFBZXAvRCxHQUFLLG9DQURoQm8vRCxVQUNXcC9ELFFBQW9DO1FBRnRDbS9EO01BRWIsU0FDSUUsaUJBQWlCQztRQUNuQjtVQUFJLHNDQUhGRixVQUVpQkU7Ozs7VUFERCxXQUdLO01BSHpCLFNBSUlDLGlCQUFpQjM4RDtRQUNYLElBQUo1QyxFQUFJLFNBRFc0QztRQUNYO1VBQ0osc0NBUEZ3OEQsVUFNRXAvRDs7OytDQUUrQiwwQkFGL0JBO1VBSEosV0FLOEQ7TUFQaEUsU0FpRkl3L0Qsa0JBQW1COTNDO1FBQ3JCO1VBQU0saUJBRGVBO1VBQ2Y7O3VDQUVGLEtBSGlCQSxNQUdxQjtVQUNTLGtDQUFmLGlCQUFpQjtNQXJGdkQsU0E0RUkrM0MsY0FBZS8zQztRQUNYLGlCQURXQTtRQUNYOztVbEMyWUY7WWtDellBLEtBSGFBLE1BR3lCLHFDQUh6QkE7UUFJVix5QkFKVUEsS0FJYztNQWhGakMsU0E0RElnNEMsT0FjMEIxL0Q7UUFiNUI7VUFBTSxpQkFhc0JBO1VBYnRCOzs7O2NsQzJaRixla0NyWkEsS0FPd0JBLEdBUGMsK0JBT2RBOzs7Z0JBVHhCLEtBU3dCQTtnQkFUYztnQkFLMUM7a0JBQU0sbUJBSXNCQTtrQkFKdEI7Ozs7aURBRUYsS0FFd0JBLEdBRmM7Ozs7d0JBRXRDLEtBQXdCQSxHQUFjLCtCQUFkQTtrQkFDdUIsa0NBQWY7NkJBWmhDLEtBV3dCQSxHQVhjO1VBS0ssZ0NBQWYsaUJBQWlCO01BcEVuRCxTQStDSTIvRCxPQUFRajRDO1FBQ1Y7VUFBTSxpQkFESUE7VUFDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lsQ3dhRixla0NwYUEsS0FMTUEsTUFLZ0M7VUFDOUIsMkJBQWtCLGdCQUFnQjtNQXJEaEQsU0FzRElrNEMsV0FJTTUvRDtRQUhGLGlCQUdFQTtRQUhGOzs7WUFFRixLQUNJQSxHQUFjLGdCQUFpQixVQUFXLDBCQUExQ0E7UUFDaUI7UUFBaUI7c0JBRGxDQSxFQUNxRDtNQTNEL0QsU0F5Q0l1ckIsTUFBTzdEO1FBQ1Q7VUFBTSxpQkFER0E7VUFDSDs7Ozs7Ozs7OztZbEM4YUYsZWtDM2FBLEtBSktBLE1BSWlDO1VBQzlCLDJCQUFrQixnQkFBZ0I7TUE5Q2hELFNBU1FtNEMscUJBeUZFbjRDO1FBeEZSO1VBQU0saUJBd0ZFQTtVQXhGRjs7Ozs7Ozs7Ozs7OztvQkF5QkYsS0ErRElBO29CQTlEYztvQkFtRHRCO3NCQUFNLG1CQVdFQTtzQkFYRjs7d0NBQ1MsS0FVUEEsbUJBVk87OzBCQUVYLEtBUUlBOzBCQVJKOzRCQUVNLElBREYvYSxJQUNFLE9BTUYrYTs7Ozs7MEJBSGMsTUFKZC9hOzt3QkFLSSxLQUVKK2E7d0JBRjBDOztzQkFDM0M7O29CQXhFSCxLQXlFSUE7b0JBekVKO3NCQTBFRSxtQkFERUE7c0JBQ0Y7Ozt3QkFFRixLQUhJQTt3QkFHSjswQkFDVSxnQkFKTkE7Ozs7MEJBUUQ7NEJBaEZDOWtCOzt3QkErRUksS0FQSjhrQixVQXhFQTlrQjs7Ozs7b0JBSVEsbUJBb0VSOGtCO29CQXBFUTsyQ0FDRyxLQW1FWEEsTUFuRVcsYUFMWDlrQjtvQkFNRzs7b0JBTUcsS0E0RE44a0I7b0JBNURNOzs2QkEyRlpxNEMsd0JBL0JNcjRDO2tEQStCTnE0QyxpQkEvQk1yNEM7MkJBN0RNLEtBNkROQSxNQTdETSxrQkE2RE5BOzs7Ozs7MkJBdEZKLEtBc0ZJQTs7Ozs7Ozs7Ozs7b0JBNUVKLEtBNEVJQSxNQTNFYyxnQkFBaUIsMEJBMkUvQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lsQ3NYSjtxQmtDamJRLEtBMkRKQSxNQTNENkI7O2VBekJqQyxLQW9GSUEsTUFuRmMsZ0JBQWlCLHlCQW1GL0JBOztlQS9FSixLQStFSUEsTUE5RWMsZ0JBQWlCLDBCQThFL0JBO1VBMURELFNBQUk7TUF4Q2IsU0FpSUlxNEMsc0JBQWVyNEM7UUFDWCxpQkFEV0E7UUFDWDs7V0FFRixLQUhhQTtXQUd5QixRQUh6QkE7V0FHeUI7O29CQTNIcENtNEMsdUJBd0hXbjRDO3lDQXhIWG00QyxnQkF3SFduNEM7UUFJTCwrQkFBc0I7TUFySXBDLFNBU1F1NEMsV0F5RkV2NEMsTSx1QkF6RkZtNEMsZUF5RkVuNEM7TUFsR1YsU0EyR0lvNEMsT0FBUXA0QztRQUNKLGlCQURJQTtRQUNKOzs7Ozs7c0JBQ1EsS0FGSkEsTUFFSTtzQkFDQSxLQUhKQSxNQUdJO3NCQUNBLEtBSkpBLE1BSUk7Ozs7YUFFVixLQU5NQTthQU9NLG1CQVBOQTthQU9NOzs7aUJBRVIsS0FURUE7aUJBVVUsbUJBVlZBO2lCQVVVOzs7cUJBRVIsS0FaRkE7cUJBWUU7Ozs7Ozs7Ozs7aUJBSUc7YUFFSjtVQUVDLEtBcEJGQTtVQW9CRTtRQUNMLGVBQW9CO01BaEk3QixTQXNJSXM0QyxRQVdtQnQ0QztRO1FBVnJCO1VBQU0saUJBVWVBO1VBVmY7Ozs7O2dCQUNRLEtBU09BO2dCQUpmLG1CQUllQTtnQkFKZjt3Q0FDUSxLQUdPQSxNQUgrQixRQUcvQkE7a0JBRlQsS0FFU0E7O2dCQURkOzs7Z0JBUE8sS0FRT0E7Z0JBQ3JCO2tCQUFNLG1CQURlQTtrQkFDZjs7b0NBQ1EsS0FGT0EsTUFFUDtvQ0FDQSxLQUhPQTtvQkFJVCxLQUpTQTs7a0JBS2Q7WUFaSyxLQU9TQTs7VUFOZCxnQkFBb0I7TUEzSTdCLGdCQXdKSXpqQjtRQUFTLHFCQUFpQjBpQixPQUFVLGtCQUFwQzFpQixNQUFvRCxFQUFDO0lBL0t0QyxxQkFxQmpCaTdEO0lBckJpQjs7TSxJQzRDYnRtQix5QjtlQUVBcDhCLE9BQVNneEIsSUFBcUNzTDtRQUNoRCxHQURXdEw7U0FBUyxRQUFUQSxjQUFTcUM7O2FBQVRrSixPQUFTO1lBUEE1NEM7UUFDcEI7Z0JBTWdEMjRDLGdCQVA1QjM0Qzs7YUFHZixRQUhlQTthQU9UNDRDO1dBRWU7OEJBSnhCSDtZQUl3QixrQkFKeEJBLHFCaEIvQ0ozeUIsaUJnQitDSTJ5QjtZQUlFM0MsS0FBc0I7O2VBQXRCQTtVQUM4QywyQkFWOUI5MUMsS0FTaEI4MUMsS0FUZ0I5MUMsR0FVa0Q7ZUFFcEVna0IsTUFBTTVIO1FBQ1I7Z0JBRFFBLGdCQUNSLEtBQ0loWixZQURKOztjQUVBNUg7VUFDRTs2QkFKTTRnQixLQUdSNWdCO1lBQ0UsU0FERkE7OztnQkFFSTtlQUVGd3RCLE1BQU01TTtRQUNSLElBQUloWixJQURJZ1o7UUFDUixPQUFJaFosUUFESWdaO2lCQUdOLE1BSE1BO2tDQU1JLGVBTkpBLFVBT0w7ZUFFRGlnQyxLQUFLbHBDO1FBQUksU0FBSkEsUUFBSSxLQUFKQSxRQUFvQixZQUFwQkE7UUFBb0IsVUFBcEJBLHVCQUF1QztlQUU1QzRtQyxVQUFVMzlCLEVBQUUyakQsTUFDZCxPQURjQSxRQUFGM2pELHdCQUN1QjtlQUVqQzRqRCxNQUFNNWpEO1FBQ1IsU0FBUTQrQjtVO1VBQVk7O2tCQUdMdC9DLGdCQUFIK0c7Y0FBa0IsbUJBQWxCQSxvQkFJUSxVQUpML0c7Y0FDVCxPQUxFMGdCOzBCQUlPMWdCOztZQURULFNBSzZCO1FBUG5DLE1BRFEwZ0IsS0FDUixLQVNJbEgscUJBVEo7O2NBVUExWjtVQUNFO1lBQVMsbUJBQVUsaUJBRmpCMFosRUFDSjFaO1lBQ0UsaUJBRkUwWixFQUNKMVo7WUFDVyxTQURYQTs7O2dCQUVJO2VBc0JGeXRCLE9BQU83TTtRQUNULFVBRFNBLEtBQ1QsTUFBSWs5QixpQkFBSixNQUNJQztRQUVKLE1BSlNuOUI7UUFDVDtTQUdBLEtBRElvOUI7U0FDSixXQUZJRCxvQkFGS245QjtRQUtxRDtjQUN4RHE5QixNQUR3RCxlQUYxREQ7VUFFMEQsT0FDeERDO1VBRHdEOzs7Y0FHcEM7b0JBRUgvOUMsY0FBTjZtQixjQUFOdzlDO2dCQUNILGNBRGVya0U7Z0JBRUosSUFBUG0rQyxLQUFPLFVBWlZ6OUIsRUFVRTJqRDtnQkFHOEIsT0FQbkN0bUIsTUFNTUk7OzBCQUZEa21CLEtBQU14OUMsS0FHd0IsaUJBUG5DazNCLE1BTU1JO2NBSEcsUUFJdUM7V0FSUSxLQUgxRE47V0FHMEQ7O2dCQVM1RC85QztZQUNFOzRCQUFjLGlCQWRkODlDLE1BYUY5OUM7Y0FDRSxTQURGQTs7O1VBVDREOzs7UUF2QzFDLFdBbURqQjtlQUVEOGhCLElBQUlsQixFQUFFbXdCLElBQUkyRztRQUNEOzhCQURMOTJCLEtBQUVtd0I7U0FFQSxZQUZGbndCLEVBQ0YyakQ7U0FFWSwwQkFIUnh6QixJQUFJMkc7U0FJdUIsVUFIL0I2c0IsS0FFQUcsVUFDK0IsaUJBSjdCOWpELEtBRUY1Z0I7UUFHSixpQkFMTTRnQixLQUVGNWdCLFlBRUF5K0M7UUFDSixPQUxNNzlCO1FBQ0ssU0FETEE7UUFLTixZQUUyQyxPQVByQ0EsT0FPNkM7ZUFFakRxQyxPQUFPckMsRUFBRW13QjtRQUNBLElBQVB3ekIsS0FBTyxnQkFERjNqRCxLQUFFbXdCO1FBQ0EsU0FDSDR6QjtVO1VBQWdCOztrQkFFUmo1RCxnQkFBSHpFLGFBQUoyOUQ7aUJBSExMLFNBR0tLO2dCQUNTLDBCQURMMzlELEVBSkY4cEM7Z0JBS087eUJBQ0QsT0FOUm53QixhQU1RLE9BRkRsVjt5QkFHYyxVQUhyQms1RCxHQUFJMzlELEVBR2lCLGNBSGR5RTswQkFPTixPQVhEa1YseUJBSU9sVjtjQVVtQixVQVYxQms1RCxHQUFJMzlELEVBVXNCLGNBVm5CeUU7WUFESCxTQVd5QztRQUM5QztxQkFmQ2tWLEVBQ0wyakQ7U0FlVSxtQkFBYyxpQkFoQm5CM2pELEtBZUw1Z0I7UUFDVSx3QkFoQkw0Z0IsS0FlTDVnQixnQkFDa0M7ZUEwQnBDa2xCLEtBQUt0RSxFQUFFbXdCO1FBQ0U7OEJBREpud0IsS0FBRW13QjtTQUdrQixlQUhwQm53QixFQXBCWTJqRDtTQXVCRCx5QkFIWDNqRDs7OztnQkFqQk8xZ0IsY0FBSCtHLFdBQUoyOUQ7ZUFIWUwsU0FHWks7Y0FDUywwQkFETDM5RCxFQWlCRjhwQztjQWhCTzs7aUJBRUksNEJBSFQ5cEM7aUJBR1MsWUFLQSxJQUFMeVMsYUFBSyxPQUFMQTtpQkFMSyxVQUhOeFo7Ozs7OztVQURWLGdCQXFCeUM7ZUFzQjNDc2xCLFNBQVM1RSxFQUFFbXdCO1FBQ0Y7OEJBREFud0IsS0FBRW13QjtTQUdrQixlQUhwQm53QixFQXBCWTJqRDtTQXVCRCx5QkFIWDNqRDs7OztnQkFqQkcxZ0IsY0FBSCtHLFdBQUoyOUQ7ZUFIZ0JMLFNBR2hCSztjQUNTLDBCQURMMzlELEVBaUJFOHBDO2NBaEJHOztpQkFFSSxJQUtWcjNCLEVBTFUsZ0JBSFR6UztpQkFHUyxHQUtWeVM7aUJBTFUsVUFITnhaOzs7Ozs7VUFEVixTQXFCNkM7ZUFFL0MwZ0QsU0FBU2hnQyxFQUFFbXdCO1FBQ0YsSUFBUHd6QixLQUFPLGdCQURBM2pELEtBQUVtd0I7UUFDRixTQUNIcU87VTtVQUFpQjs7a0JBRVhsL0MsZ0JBQUgrRyxhQUFKMjlEO2lCQUhITCxTQUdHSztnQkFDUywwQkFETDM5RCxFQUpFOHBDO2dCQUtHOzttQkFDVyw0QkFGaEI5cEM7bUJBRWdCO3FCQUdQLElBQUx5UyxhQUFRLFVBQVJBLEVBQVEsZUFMVHhaO21CQUVhLFlBRmJBOzs7Ozs7WUFESCxTQWFZO1FBQ0EsbUJBakJaMGdCLEVBQ1AyakQ7UUFnQlcsdUNBakJKM2pELHFCQWlCNkI7ZUFHdEN5K0IsUUFBUXorQixFQUFFbXdCLElBQUkyRztRQUNMLElBQVA2c0IsS0FBTyxnQkFERDNqRCxLQUFFbXdCO1FBQ0QsU0FDSDh6QjtVO1VBQWlCOztrQkFFVG41RCxnQkFBSHpFLGFBQUoyOUQ7aUJBSExMLFNBR0tLO2dCQUNTLDBCQURMMzlELEVBSkQ4cEM7Z0JBS00sc0JBQ0QsZ0JBRko5cEMsRUFKRDhwQyxJQUFJMkc7Z0JBS0UsWUFERmhzQzs7OztZQURILGdCQU00QjtRQUVqQyxnQkFYRWtWLEVBQ04yakQsTUFVSSxtQkFYRTNqRCxLQVdONWdCO1FBQUk7VUFHTix3QkFGRW1HOzs7O1lBSWMsSUFBWnUrRCxVQUFZLGdCQWhCTjN6QixJQUFJMkc7WUFpQmQsaUJBakJROTJCLEtBV041Z0IsZUFWQXVrRSxLQWVFRyxVQUpGditEO1lBS0YsT0FqQlF5YTtZQWdCUSxTQWhCUkE7WUFpQlIsWUFFMkMsT0FuQm5DQTtVQWxCZSxXQXFDNEI7ZUFFbkRvQyxJQUFJcEMsRUFBRW13QjtRQUNHOzhCQURMbndCLEtBQUVtd0I7U0FXYyxlQVhoQm53QixFQUNGMmpEO1NBVVUseUJBWFIzakQ7O1FBRWtCOztnQkFHVjFnQixjQUFIK0csV0FBSjI5RDtzQkFKSEw7Y0FLWSwwQkFETHQ5RCxFQUxIOHBDO2NBTVE7d0JBREY3d0M7Ozs7VUFEVixTQU9tQztlQUVyQzRrRSxPQUFLNWdFLEVBQUUwYztRQUNULFFBRFNBLEtBQ1QsS0FRSWhILHVCQVJKOztjQVNBNVo7O1VBQ0U7WUFBVSw2QkFGUjRaLElBQ0o1WjtZQVRvQjs7Z0JBSUY7aUJBREhFO2lCQUFIK0c7aUJBQ00sc0JBRE5BO2lCQUNtQix3QkFEbkJBO2dCQUNtQjs7dUJBRVZ5UyxhQUFSdEo7bUJBQWEsV0FQbkJsTSxFQU9Na00sRUFBUXNKOzs7Ozs7Z0JBRkgsVUFESHhaOzt1QkFNZkY7Ozs7UUFyQndCLFFBdUJwQjtlQUVGc2tCLEtBQUtwZ0IsRUFBRTBjLEVBQUVqSjtRQUNYLFFBRFNpSixLQUNULFVBRFdqSixNQUNYLEtBVUlpQyx1QkFWSjs7Y0FZQTVaOztVQUNFOztrQkFGRXNQO2FBRWdCLHFCQUhoQnNLLElBRUo1WjthQVprQjZGO2FBQUVzRDtZQUNsQjtpQkFEZ0J0RDtnQkFLVztpQkFEZDNGLEtBSkcyRjtpQkFJTm9CLEVBSk1wQjtpQkFLVyxzQkFEakJvQjtpQkFDOEIsd0JBRDlCQTtnQkFDOEI7OzttQkFFbkJ5UzttQkFBUnRKO21CQVBLL0csT0FPUSxXQVJyQm5GLEVBUVFrTSxFQUFRc0osRUFQSHZROzs7Ozs7Z0JuQzJObEIsa0JtQzNOa0JFO2dCQUtTLElBTFh4RCxFQUlIM0YsS0FKS2lKOztjQVdoQm1HLFlBWGdCbkc7dUJBWXBCbko7Ozs7UUFHQSxPQUpJc1AsU0FJQztlQUVIcXdDLG1CQUFtQno3QyxFQUFFMGM7UUFDdkIsU0FBUTQrQjtVO1VBQVk7O2NBSVI7ZUFESXQvQztlQUFIK0c7ZUFBSjI5RDtlQUNHLHNCQURDMzlEO2VBQ1ksd0JBRFpBO2NBQ1k7O2lCQUlULElBREt5UyxhQUFSdEosV0FDRyxtQkFUS2xNLEVBUVJrTSxFQUFRc0o7aUJBQ0w7bUJBSUYsSUFER3FyRDttQkFDSCxnQkFURDk5RCxFQUlBbUosRUFJSTIwRDttQkFFUyxVQVZqQkgsR0FBSTM5RCxFQVVhLFVBVlYvRztpQkFLQSxZQUxBQTs7Y0FDSixZQURJQTs7WUFEVixTQVdtQztRQWJ6QyxNQUR1QjBnQixLQUN2QixLQWVJbEgscUJBZko7O2NBZ0JBMVo7VUFDRTtZQUFTLG1CQUFVLGlCQUZqQjBaLEVBQ0oxWjtZQUNFLGlCQUZFMFosRUFDSjFaO1lBQ1csU0FEWEE7OztnQkFFSTtlQUVGb08sT0FBT3dTLEdBQUksT0FBSkEsSUFBVTtlQUViay9COzs7O1lBRWdCOzs7O3FCQUFUOW5DOztVQURGO2VBR1QrbkMsTUFBTW4vQjtRQUNSO2NBRFFBO1NBQ1I7U0FDRTs7cUJBQXFCeUYsRUFBRXhnQixHQUFXLFdBQWJ3Z0IsRUFBYSxnQkFBWHhnQixHQUE4QjtTQUFyRCxxQkFERW02QztTQUNGLEtBRk1wL0I7UUFJUjttQkFDTy9hO1lBQ00sSUFBSk0sRUFBSSxnQkFETk47WUFFVyxPQUpkbzZDLE1BR0s5NUMsU0FDUyxpQkFKZDg1QyxNQUdLOTVDLGlCQUNzQjs7UUFIL0IsVUFKUXlhLHFCQUNKby9CLElBRUFDLE1BU3dCO2VBRXRCK2tCOzs7O2dCQUVPOWtFLGdCQUFIK0c7WUFBYyxtQkFBZEE7Y0FDTixnREFEUy9HOzs7VUFERjtlQUtUK2tFLFlBQVlya0Q7UUFDZDs7Y0FEY0E7U0FDZDtTQUVFOztxQkFBcUJ5RixFQUFFeGdCLEdBQVcsV0FBYndnQixFQUFhLHNCQUFYeGdCLEdBQW9DO1NBQTNELHFCQURFbTZDO1NBQ0YsS0FIWXAvQjtRQUtkO21CQUNPL2E7WUFDTSxJQUFKTSxFQUFJLHNCQUROTjtZQUNNLFVBTlRzSSxVQU1LaEk7WUFFUyxPQUxkODVDLE1BR0s5NUMsU0FFUyxpQkFMZDg1QyxNQUdLOTVDLGlCQUVzQjs7UUFKL0IsVUFKSWdJLFFBRFV5UyxnQkFFVm8vQixJQUVBQyxNQVV3QjtlQUUxQno1QixPQUFPaEs7UUFHVCxJQUFJMmpDLFNBSEszakM7UUFHVCxTQUVRaEwsSUFBSXhSLEVBQUVvZ0Q7Y0FBRmg2QyxNQUFFaTZDO1VBQVU7ZUFBVkE7Y0FNSTtlQURGMzBDLEtBTEYyMEM7ZUFLRHA1QyxFQUxDbzVDO2VBTUksc0JBRExwNUM7ZUFDa0Isd0JBRGxCQTtjQUNrQjs7cUJBRU44ZixnQkFBVmdxQjtpQkFDb0I7NEJBRHBCQSxJQUFVaHFCO3dDLE9BUmpCdlYsSUFBSXBMLElBS0lzRjtjQUNFLElBTkoyMEMsT0FLRTMwQzs7WUFIVixHQUZNdEYsUUFGUis1QztZQU1nQjtxQ0FOaEJBLFNBRVEvNUM7YUFJUSxJQUpSQTs7YUFBRWk2QztxQkFVTDtRQVpUOzhCLE9BRVE3dUMsb0JBWUc7ZUFFVCt1QyxZQUFZbDZCO1FBQWdCLGdCQUFoQkE7UUFBZ0Isb0I7UUFBQSxzQixPaENyWDVCN2Esb0JnQ3FYc0M7ZUFFdENnMUMsY0FBY242QjtRQUFnQixnQkFBaEJBO1FBQWdCLG9CO1FBQUEsc0IsT2hDdlg5QjdhLG9CZ0N1WHdDO2VBRXhDNGEsUUFBUTVKLElBQUl4YztRQUNkOzttQkFBUyxxQ0FEQ3djLElBQ0twTSxFQUFFcEksRUFBa0I7aUJBRHJCaEksRUFDdUI7ZUFFbkMwZ0QsWUFBWWxrQyxJQUFJeGM7UUFDbEI7O21CQUFTLHlDQURLd2MsSUFDQ3BNLEVBQUVwSSxFQUFzQjtpQkFEckJoSSxFQUN1QjtlQUV2Q3NtQixPQUFPdG1CLEdBQ0MsSUFBTndjLElBQU0sYUFDVixZQURJQSxJQURLeGMsR0FFVCxPQURJd2MsR0FFRDs7Y0F0VkRxRTtjQUtBMkg7Y0FPQWdGO2NBU0FxekI7Y0EyREEvK0I7Y0FTQW1CO2NBMENBaUM7Y0F5QkFNO2NBS0FvN0I7Y0FvQkF2QjtjQXFCQXI4QjtjQWFBOGhEO2NBZ0NBbmxCO2NBbEJBcjdCO2NBdUNBbFc7Y0FNQTJ4QztjQW9DQXY1QjtjQW1CQSs1QjtjQUVBQztjQUVBcDZCO2NBR0FzNkI7Y0FHQXA2QjtjQXpUQWsrQztjQTRRQVM7YUFtRUZDLGdCQUF3QiwyQkFBZTthQUV2Q0MsUUFBUy9xRCxHQUFtQyx5QkFBbkNBLElBQXVEO2FBQ2hFZ3JELGFBQWNockQsR0FBbUMseUJBQW5DQSxJQUE0RDthQUMxRWlyRCxRQUFTanJELEVBQWNoSyxHQUFlLHlCQUE3QmdLLElBQWNoSyxFQUE4QzthQUNyRWsxRCxVQUFXbHJELEdBQXNCLHlCQUF0QkEsSUFBMEM7YUFDckRtckQsVUFBV25yRCxHQUFzQix5QkFBdEJBLElBQTBDO2FBRXJEb3JELFNBQVV2MUQsR0FBZUYsSUFDM0IseUJBRFlFLEtBQWVGLE9BQ0E7YUFFekIwMUQsV0FBVXJyRCxHQUFtQyx5QkFBbkNBLEVBQXNEO2FBQ2hFc3JELGNBQWV0ckQsR0FBbUMsMEJBQW5DQSxFQUEyRDthQUMxRXVyRCxTQUFVdnJELEVBQWNWLEdBQWUsMEJBQTdCVSxFQUFjVixFQUE2QzthQUNyRWtzRCxXQUFZeHJELEdBQXNCLDBCQUF0QkEsRUFBeUM7YUFDckR5ckQsV0FBWXpyRCxHQUFzQiwwQkFBdEJBLEVBQXlDO2FBQ3JEMHJELFVBQVc3MUQsR0FBY0YsSUFBc0IsMEJBQXBDRSxHQUFjRixHQUE0Qzs7ZUFNakU4USxPQUFPelEsRUFBRXNKO1FBQ0gsSUFBSnpTLEVBQUksWUFDUixTQURJQSxFQURPeVMsR0FHWCxRQUZJelMsRUFES21KLEdBR1QsT0FGSW5KLENBR0g7VUFDQ2lIO2VBQ0FsQixNQUFNL0YsRUFBRW1KO1FBR0osa0JBSEVuSjtRQUdGLFVBR0YsSUFER29KLGFBQ0EsdUJBTkdELEVBS0hDO1FBREcsUUFFMEQ7ZUFHbEUwMUQsYUFBYTkrRCxFQUFFbUosRUFBRXNKO1FBQ25CLFdBRGV6UyxHQUVmLFFBRmVBLEVBQUVtSixHQUVqQixnQkFGZW5KLEVBQUl5UyxFQUdQOztrQkFsQlZtSCxPQUtBM1MsS0FDQWxCLE1BakJKeTRELFdBVEFOLFFBbUNJWSxhQS9CSlI7O00sSUEwQ012NEQ7ZUFDQWtCLEtBQU1vc0MsS0FBWTkxQyxHQUFJLHVCQUFKQSxFQUFZOzsrQkFEOUJ3SSxNQUNBa0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FoZFZzMkQ7T0FDQVM7O2VBaWRNcGtELE9BQU9pZ0MsSUFBSyw0QkFBTEEsR0FBNEI7O2NBQW5DamdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBbGROMmpEO2NBQ0FTO2FBeWRJZSxnQkFBNkIsMkJBQWU7YUFFNUNDLFNBQVU3ckQsR0FBeUMseUJBQXpDQSxJQUE2RDthQUN2RThyRCxjQUFlOXJELEdBQ1QseUJBRFNBLElBQ2dCO2FBQy9CK3JELFNBQVUvckQsRUFBbUJoSyxHQUMvQix5QkFEWWdLLElBQW1CaEssRUFDQTthQUM3QmcyRCxXQUFZaHNELEdBQTJCLHlCQUEzQkEsSUFBK0M7YUFDM0Rpc0QsV0FBWWpzRCxHQUEyQix5QkFBM0JBLElBQStDO2FBRTNEa3NELFNBQVVsc0QsR0FBeUMseUJBQXpDQSxJQUE2RDthQUN2RW1zRCxjQUFlbnNELEdBQ1QseUJBRFNBLElBQ2dCO2FBQy9Cb3NELFNBQVVwc0QsRUFBbUJoSyxHQUMvQix5QkFEWWdLLElBQW1CaEssRUFDQTthQUM3QnEyRCxXQUFZcnNELEdBQTJCLHlCQUEzQkEsSUFBK0M7YUFDM0Rzc0QsV0FBWXRzRCxHQUEyQix5QkFBM0JBLElBQStDO2FBRzNEdXNELFVBQVcxMkQsR0FBaUJGLElBQzlCLHlCQURhRSxLQUFpQkYsT0FDSDthQUN6QjYyRCxVQUFXMzJELEdBQWlCRixJQUM5Qix5QkFEYUUsS0FBaUJGLE9BQ0g7YUFDekI4MkQsV0FBWTUyRCxHQUFtQkYsSUFDakMseUJBRGNFLEtBQW1CRixPQUNOO2FBRXpCKzJELFdBQVUxc0QsR0FBd0MseUJBQXhDQSxFQUEyRDthQUNyRTJzRCxnQkFBZTNzRCxHQUNULDBCQURTQSxFQUNlO2FBQzlCNHNELFdBQVU1c0QsRUFBbUJWLEdBQy9CLDBCQURZVSxFQUFtQlYsRUFDRDthQUM1QnV0RCxhQUFZN3NELEdBQTJCLDBCQUEzQkEsRUFBOEM7YUFDMUQ4c0QsYUFBWTlzRCxHQUEyQiwwQkFBM0JBLEVBQThDO2FBQzFEK3NELFlBQVdsM0QsR0FBZ0JGLElBQXdCLDBCQUF4Q0UsR0FBZ0JGLEdBQThDOztlQVFyRThRLGFBQWVuSDtRQUNULElBREttbEMsWUFBSEYsWUFDRjtRQUNSLFdBREkxM0MsRUFEYXlTO1FBR2pCLFNBRkl6UyxFQURNMDNDO1FBR0ssU0FGWDEzQyxFQURTNDNDO1FBR0UsT0FGWDUzQztlQUlGaUgsS0FBS29zQztRQUNXO1NBREZ1RTtTQUFIRjtTQUNLLHNCQURYckUsS0FBU3VFO1FBQ2hCLHdCQURPdkUsS0FBTXFFO2VBRVgzeEMsTUFBTS9GO1FBQ0YsSUFEUTQzQyxZQUFIRixZQUNMLGVBREUxM0MsR0FDVSxpQkFEVkE7UUFDVTs7ZUFFRG1nRSxnQkFBVkM7V0FDQSxvQkFKSTFvQixHQUdKMG9CLFNBQ21CLGlCQUpaeG9CLEdBR0d1b0I7V0FFZ0I7UUFIVDtlQUt0QmpDLFFBQVFsK0Q7UUFDSixtQkFESUEsR0FDUSxpQkFEUkE7UUFDUTt5QkFFRDQzQyxjQUFWRiw0QkFBVUU7UUFETyxRQUNlO2VBQ3JDa25CLGFBQWE5K0QsUUFBVXlTO1lBQUptbEMsWUFBSEY7UUFDbEIsYUFEZTEzQztRQUVmLFNBRmVBLEVBQUcwM0M7UUFFSCxTQUZBMTNDLEVBQU00M0M7UUFFTixrQkFGQTUzQyxFQUFVeVM7ZUFJdkI2ckQsVUFBVXQrRDtRQUFJLG9CQUFKQSxHQUFJLFlBL0NsQnkvRCxXQStDY3ovRCxPQUFnQzs7a0JBdEIxQzRaLE9BS0EzUyxLQUVBbEIsTUF0Qko4NUQsV0E2QkkzQixRQUlBWSxhQUlBUjs7TSxJQWNJdjREO2VBQ0FrQixLQUFNb3NDLEtBQVk5MUMsR0FBSSx3QkFBSkEsRUFBYTtVQU4vQndKLHNCQUtBaEIsTUFDQWtCO2VBTEFzSixPQUFNOGlDLEtBQVk5MUMsR0FBSSx3QkFBSkEsRUFBYTs7K0JBRC9Cd0osUUFDQXdKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbmlCWmd0RDtPQUNBUzs7ZUF5aUJNcGtELE9BQU9pZ0MsSUFBSyw0QkFBTEEsR0FBNEI7O2NBQW5DamdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBMWlCTjJqRDtjQUNBUzthQWlqQklxQyxTQUFPM2hFLEdBQWdCLHlCQUFoQkEsRUFBK0I7YUFDdEM0aEUsU0FBUW4zRCxHQUFxQix5QkFBckJBLEVBQW9DO2FBRTVDbzNELFVBQVNwdEQsRUFBY3pVLEdBQTZCLHlCQUEzQ3lVLEVBQWN6VSxFQUFpRDthQUN4RThoRSxlQUFjcnRELEVBQWN6VSxHQUN0Qix5QkFEUXlVLEVBQWN6VSxFQUNHO2FBQy9CK2hFLFVBQVN0dEQsRUFBY3pVLEVBQVF5SyxHQUNqQyx5QkFEV2dLLEVBQWN6VSxFQUFReUssRUFDRjthQUM3QnUzRCxZQUFXdnRELEVBQWN6VSxHQUFnQix5QkFBOUJ5VSxFQUFjelUsRUFBb0M7YUFDN0RpaUUsWUFBV3h0RCxFQUFjelUsR0FBZ0IseUJBQTlCeVUsRUFBY3pVLEVBQW9DO2FBRTdEa2lFLFdBQVU1M0QsR0FBZTYzRCxHQUFTLzNELEdBQWVnNEQsR0FBUzVoRTtNQUM1RCx5QkFEWThKLEdBQWU2M0QsR0FBUy8zRCxHQUFlZzRELEdBQVM1aEUsRUFDL0I7YUFFM0I2aEUsV0FBVTV0RCxHQUFtQyx5QkFBbkNBLEVBQXNEO2FBQ2hFNnRELGdCQUFlN3RELEdBQW1DLDBCQUFuQ0EsRUFBMkQ7YUFDMUU4dEQsV0FBVTl0RCxFQUFjVixHQUFlLDBCQUE3QlUsRUFBY1YsRUFBNkM7YUFDckV5dUQsYUFBWS90RCxHQUFzQiwwQkFBdEJBLEVBQXlDO2FBQ3JEZ3VELGFBQVlodUQsR0FBc0IsMEJBQXRCQSxFQUF5QzthQUNyRGl1RCxZQUFXcDRELEdBQWNGLElBQXNCLDBCQUFwQ0UsR0FBY0YsR0FBNEM7O2VBTWpFOFEsT0FBT3pRLEVBQUVzSjtRQUNILElBQUp6UyxFQUFJLFNBRENtSjtRQUVULFdBREluSixFQURPeVM7UUFDSCxJQUNSLEtBRlN0SixxQkFFVDs7Y0FDQXBRO1VBQ0U7c0JBSEVpSCxFQUVKakgsRUFDYyxpQkFKTG9RLEVBR1RwUTtZQUNFLFNBREZBOzs7UUFHQSxPQUxJaUgsQ0FLSDtlQUNDaUgsS0FBS29zQyxLQUFLbHFDO1FBQ1osaUJBRFlBLHFCQUNaOztjQUNBcFE7VUFDRTtxQkFGRTRnQixLQUVlLHNCQUhQeFEsRUFFWnBRO1lBQ08sd0JBSEFzNkM7WUFHTCxTQURGdDZDOzs7UUFHQSxPQUpJNGdCLElBSUY7ZUFDQTVULE1BS3NCL0YsRUFBRm1KO1FBSnRCLFFBSXNCQSxhQUhYLGVBR2FuSjtRQUhiLEdBRFBXLFFBQ0FjO1FBREosSUFJRSxJQUpFZCxZQUlzQjVIO1FBQ3RCO2tCQURzQkE7WUFHZCxvQkFIWWlILEVBQUVqSDtZQUdkO2NBR0YsZ0JBQVcsc0JBTkNvUSxFQUFJcFE7Y0FNYix3QkFEQXNvRSxLQUVFLFFBUFd0b0U7Y0FRWDtZQUpDO1VBSEUsU0FTTztlQUV2Qm1sRSxRQUFRbCtEO1FBQ0EsSUFBTlcsSUFBTSxTQURBWDtRQUNBLFNBQU5XO1FBQU0sVUFHRixVQUpFWDtRQUlGO1VBR0YsaUNBTkZXLElBS0syZ0UsSUFDSCxJQU5GM2dFLFlBTWlCNUg7VUFDYjtvQkFEYUE7Y0FHTCxzQkFWTmlILEVBT1dqSDtjQUdMO2dCQUdGLElBREdzb0U7Z0JBQ0gsaUJBTktoaEUsRUFBRXRILFlBS0pzb0U7Z0JBQ0gsUUFOT3RvRTs7Y0FJRDtZQUhFLFVBREhzSDtRQUZQLFFBWVE7ZUFDbEJ5K0QsYUFBYTkrRCxFQUFFbUosRUFBRXNKO1FBQ25CLGFBRGV6UztRQUNmLFNBRGlCbUoscUJBQ2pCOztjQUNBcFE7VUFDRTtzQkFIYWlILEVBRWZqSCxFQUNjLGlCQUhHb1EsRUFFakJwUTtZQUNFLFNBREZBOzs7UUFHQSxrQkFMZWlILEVBQUl5UyxFQUtQO2VBQ1Y2ckQsVUFBVXQrRDtRQUdILGlCQUhHQSxXQUNJakg7UUFDZDttQkFEY0E7VUFDZDs7O1lBQVUscUJBRkFpSCxFQUNJakg7WUFDSixhQURJb0c7WUFDSjtVQURaLFlBRXNCOztrQkF6RHBCeWEsT0FPQTNTLEtBTUFsQixNQXhCSmc3RCxXQXlDSTdDLFFBa0JBWSxhQU1BUjs7TSxJQVVFdjREO2VBQ0FrQixLQUFNb3NDLEtBQVk5MUMsR0FBSSx1QkFBSkEsRUFBWTs7K0JBRDlCd0ksTUFDQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BNW9CVnMyRDtPQUNBUzs7ZUE2b0JNcGtELE9BQU9pZ0MsSUFBSyw0QkFBTEEsR0FBNEI7O2NBQW5DamdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBOW9CTjJqRDtjQUNBUzs7Ozs7UUE4WklDO1FBRUFDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBRUFDO1FBR0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDOzs7O1FBMkNBRTtRQUVBQztRQUNBQztRQUVBQztRQUVBQztRQUNBQztRQUVBQztRQUNBQztRQUVBQztRQUVBQztRQUNBQztRQUdBQztRQUVBQztRQUVBQztRQUdBQztRQUNBQztRQUVBQztRQUVBQztRQUNBQztRQUNBQzs7OztRQXVEQUc7UUFHQUU7UUFDQUM7UUFFQUM7UUFFQUM7UUFDQUM7UUFFQUM7UUFHQUc7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7Ozs7O1U7OzthckNuakJGRyxpQkFBaUJDLFdBQVdycEUsaUJBQWlCNEg7TUFVNUMscUJBVjRDQSxvQkFBakI1SDtNQVl6Qiw4QkFaMEM0SCxjQUM5QnJCO01BQ2Y7Z0JBRGVBO1VBRVAsY0FIUzhpRSxXQUE0QnpoRSxLQUM5QnJCLElBRWdCLFFBRmhCQTtVQUdWLE1BSFVBLFVBSUpnSixJQUpJaEo7VUFLZjtvQkFEV2dKO2NBRUgsY0FQUzg1RCxXQUE0QnpoRSxLQUtsQzJIO3NCQUVvQixNQVBjM0gsS0FLbEMySCxhQUFFYyxJQUFGZDtjQUdOLFFBSE1BOztZQUNHLGFBTitCM0gsT0FLaEN5STtRQUhDLGFBRitCekksVUFZVDthQU1wQzBoRSxnQkFBZ0JELFdBQVdycEUsaUJBQWlCNEg7TUFjM0MscUJBZDJDQSxvQkFBakI1SDtNQWdCeEIsOEJBaEJ5QzRILGNBQ3pCckI7TUFDbkI7Z0JBRG1CQTtVQUVYLGNBSFE4aUUsV0FBNEJ6aEUsS0FDekJyQixJQUVZLFFBRlpBO2NBSVpnSixJQUpZaEo7VUFLbkI7b0JBRE9nSjtjQUVDLGNBUFE4NUQsV0FBNEJ6aEUsS0FLckMySDtvQkFJWW15RCxJQUpabnlEO2dCQUtQOzBCQURtQm15RDtvQkFFWCxjQVhRMkgsV0FBNEJ6aEUsS0FTekI4NUQ7c0JBRVksUUFGWkE7b0JBR2QsYUFadUM5NUQsT0FTekI4NUQ7a0JBQ0wsYUFWOEI5NUQ7Y0FRdkMsUUFIRTJIOztZQUNPLE9BTmF2UDtRQUViLGFBRjhCNEgsVUFnQko7YUFNdEN5aEUsV0FBV3BrRSxFQUFFckUsR0FBSSw4QkFBTnFFLEVBQUVyRSxNQUFlO2FBQzVCMm9FLFlBQVloakU7TUFBSTtrQ0FBSkE7T0FBSSxxQkFBdUIsZ0JBQTNCQTtpQkFBdUM7YUFDbkRpakUsWUFBWWpqRTtNQUNkLHFCQURjQTtNQUNkOztvQ0FEY0E7c0JBRTZCLHFCQUFoQixNQUZiQTtRQUVxQzs7cUNBRnJDQTt1QkFHYSwyQkFIYkE7Ozs7O01BREksV0FJbUM7YUFDbkRrakUsYUFBYTdoRSxLQUFLOGhFO01BQ3BCO2tDQURvQkEsU0FDcEIsc0JBRGU5aEU7T0FDZjs7VUFDQTs7Y0FGZUE7a0VBQUs4aEU7Ozs7TUFIcEIsV0FNMkM7O01BRXZDOzs7OztJQUNNLFNBK0VSQyxNQXZKdUIxa0U7TUFDM0IsNEJBRDJCQSxHQUVuQixXQURKOEI7TUFFSixTQURJTjtNQURKLElBRUEsS0FGSU0sVUFFSjs7WUFDQW5HO1FBQ0U7VUFBRywwQkFMc0JxRSxFQUkzQnJFO1dBRU8sV0FKSDZGLEVBRll0Rzs7V0FPVCxTQUxIc0csRUFLc0IsZ0JBUEN4QixFQUkzQnJFO1VBRytCLFNBSC9CQTs7O01BS0EsU0FQSTZGO01BT0osZ0JBUElBO0lBdUVXLFNBQVhtakU7TSxPQXJERlIsaUJBd0NFQyxXQUhBcnBFO0lBaUJVLFNBQVY2cEU7TSxPQXBDRlAsZ0JBc0JFRCxXQUhBcnBFO0lBaUJVLFNBT1Y4cEUsYUFBVzdrRSxFQUFFckU7TUFBSSxzQkFBTnFFLEVBQUVyRSxHQUFJLFlBQUlpSDtNQUFKOzs7dUJBQUlBO2lCQUEyQztJQVB0RCxTQVFWa2lFLGNBQVl4akU7TUFDZDtrQ0FEY0E7T0FDZCxxQkFBd0IsZ0JBRFZBOzs7OzhCQUVhLGdCQUZiQTs7OzsrQkFHYSxnQkFIYkE7Ozs7O2lCQUcwQjtJQVg1QixTQVlWeWpFLGNBQVl6akU7TUFDZCx1QkFEY0E7TUFDZDs7b0NBRGNBO3NCQUU2QixxQkFBaEIsTUFGYkE7UUFFcUM7O3NDQUZyQ0E7d0JBRzZCLHFCQUFoQixNQUhiQTtVQUdzQzs7d0NBSHRDQTswQkFJNkIscUJBQWhCLE1BSmJBO1lBSXNDOzt5Q0FKdENBOzJCQUthLDJCQUxiQTs7Ozs7Ozs7O01BSGQsV0FRc0Q7SUFqQjFDLFNBa0JWMGpFLGVBQWFyaUUsS0FBSzhoRTtNQUNyQiwrQkFEcUJBLFNBQ3JCLHNCQURnQjloRTtNQUNoQjtPQUNTOzs7V0FGT0E7K0RBQUs4aEU7O1FBSU8sdUJBSlBBO2FBSXBCLG9DQUZJemtFOzs7TUFQSixXQVN1RDtJQXRCM0M7TUF3QlIsbUNBREZpbEU7Ozs7O2FBRUFDLFFBQU1sbEU7TUFDUiw0QkFEUUEsR0FFQSxXQURKOEI7TUFFSixTQURJTjtNQUNKLFNBaUJJMmpFLE9BQU83akU7UUFBSTtjQUFKQTtjQUFJNE07VUFBbUI7cUJBbEI5QjFNO1lBa0I4QixTQUFuQjBNO2VBQUo1TSxNQUFJNE07O1FBbkJmLFFBbUI4RDtNQWpCOUQsU0FDUWszRCxlQUFLenBFO1EsSUFBQW9HO1FBQ1g7YUFEV0EsUUFIVEQsU0FJWSxTQUhaTjtVQUlJLElBR0pvQixFQUhJLGdCQU5BNUMsRUFJSytCO1VBRUwsVUFHSmE7WUFGUTs7O3FCQUdSeWlFLHVCQU5TdGpFOzBDQU1Uc2pFLGdCQU5TdGpFO29CQUtUYTtZQURROzs7cUJBRVJ5aUUsdUJBTlN0akU7MENBTVRzakUsZ0JBTlN0akU7VUFLRCxTQVBSUCxFQU9Bb0I7VUFISSxJQUdJLElBTENiO21CQUsrQjtNQU41QyxTQU9Jc2pFLGdCQUFRL2pFLEVBQUUzRjtZQUFGeU8sTUFBRXJJO1FBQ1o7YUFEWUEsUUFUVkQsR0FXQSxTQVZBTixNQVVBLGNBRlE0STtVQUtGLDBCQWZGcEssRUFVTStCO1VBS0o7WUFDSSxZQU5GcUk7WUFNa0IsU0FkMUI1STtZQWMwQixTQU5oQk87WUFNZ0I7bURBWnRCcWpFOzs7WUFhTSxRQVBBcmpFLFlBT0EsSUFQRnFJLG9CQUFFckk7VUFRQSxPQVJGcUk7VUFRRTtpREFkTmc3RCxpQkFNTXJqRTt3Q0FOTnFqRSxVQU1NcmpFLE1BU1Q7TUFoQkwsU0FDUXN1QyxLQUFLMTBDLEcsdUJBQUx5cEUsU0FBS3pwRTtNQWtCYjtzQkFwQkk2RixFQXFCYTthQU9mOGpFLGVBQWV0bEU7TUFMakIsb0NBS2lCQTtNQUxqQjtPQUlrQzs4QkFDakJBO1FBTEQ7UUU2WFo7eUJGelh1QyxnQkFDMUJBOzs7O1FBRU8sZUFGUEEsSUFFWixzQkFGWUE7UUFFWCxnQkFGV0E7TUFHWixpQkFIWUEsRUFHTDthQUNWdWxFLFVBQVF2bEU7TUFDVTs0QkFEVkE7T0FDVTs7T0FDVixvQkF0RFI2a0UsYUFIQTFwRSxtQkF3RFVxcUU7TUFDRixXQURMQyxNQUNEQyxJQUNPO2FBQ1RDLFdBQVMzbEU7TUFDVSx5QkFEVkEsR0FDVTs4QkF6RG5CNmtFLGFBSEExcEUsbUJBNERXcXFFLEtBQ29DO0lBYXBDLFNBQVhJO00sT0FwSUZ6QixpQkE2REVVLGFBOERBdnBFO0lBVVUsU0FBVnVxRTtNLE9BbkhGeEIsZ0JBMkNFUSxhQThEQXZwRTtJQVVVOzs7T0FHWHdxRSxtQkFuR0MvcUU7T0FtR2lCZ3JFLGtCQWxHakIvcUU7T0FrR2tDZ3JFLFVBakdsQy9xRTtPQWlHMkNnckUsYUFoRzNDN0I7T0FpR0Q4QixjQWhHQzVCO09BZ0dZNkIsY0EvRlo1QjtPQStGeUI2QixlQTNGekI1QjtPQTJGdUM2QjtPQUFlQyxRQU50RDVCO09BTTZENkIsV0FwRjdENUI7T0FxRkQ2QixVQXBGQzVCOzs7Ozs7U0FJQXpwRTtTQUNBQztTQUNBQztTQUNBd3BFO1NBQ0FDO1NBSUFDO1NBTUFDO1NBS0FDO1NBRUFDO1NBc0NBUztTQUpBSjs7Ozs7O1FBVUFqcUU7UUFDQUM7UUFDQUM7UUFoRUFxcEU7UUFDQUM7UUFJQUM7UUFNQUM7O1FBMkRBTjtRQUNBa0I7UUFDQUM7O0lFZ1dFOztNRjdWSEM7TUFBa0JDO01BQWlCQztNQUFTQyxhQTNFM0NwQjtNQTRFRHFCLGNBM0VDcEI7TUEyRVlxQixjQXZFWnBCO01BdUV5QnFCLGVBakV6QnBCO01BaUV1Q3FCO01BQWVDO01BQU9DO01BQzlEQzthQWtCREMsU0FBTzdCLFFBQVF4dkI7TUFDakIsSUFBSXR6QyxFQUFKLHNCQURTOGlFO01BQ1QsU0FBSTlpRTtZQUNRLGFBRkg4aUUsUUFDTDlpRTtlQUdXLElBSk44aUUsUUFJTSxJQXhCdUJvQixVQW9CckI1d0I7TUFHWixXQUhJd3ZCLFFBQVF4dkIsU0FJZ0I7YUFFL0JzeEIsWUFBWS9qRSxLQUFLOGhFO01BQ25CLElBQUluakUsRUFBSixzQkFEY3FCLFFBQ2Qsc0JBRG1COGhFO01BQ25CLFlBQUluakUsRUFDa0QsTUFGeENxQixPQUNWckIsR0FDVSxxQ0FBMkQ7YUFFdkVxbEUsY0FBY2hrRTtNQUNoQiw4QkFEZ0JBLGNBTUcyTDtNQUNqQjtnQkFEaUJBO2NBQ0wsYUFQRTNMLEtBTUcyTDtXQUVULDBCQVJNM0wsS0FNRzJMO2FBRVcsUUFGWEEsWUFMRjNTO2FBQ2Y7dUJBRGVBO3FCQUNILGFBRkVnSCxLQUNDaEg7a0JBRVAsMEJBSE1nSCxLQUNDaEg7b0JBRWEsUUFGYkE7a0JBR1YsNkJBSlNnSCxRQU1HMkw7ZUFKa0I7V0FPOUIsUUFIWUE7O1FBQ2tCLFNBSUY7YUFFakNzNEQsVUFBVWprRTtNQUNKLElBQUpiLEVBQUksY0FESWE7TUFDSixhQUFKYixTQUNrQixNQUZWYSxLQUVVLHNCQUZWQSxRQUNSYixRQUM0RDthQUU5RCtrRSxlQUFlbGtFO01BQ1QsSUFBSmIsRUFBSSxjQURTYTtNQUNULGFBQUpiO2VBQ1U7ZUFDVCxNQUhZYSxPQUdaLHNCQUhZQSxRQUNiYixNQUUyQzthQUU3Q2dsRSxpQkFBaUJua0U7TUFDWCxJQUFKYixFQUFJLGNBRFdhO01BQ1gsYUFBSmIsRUFEZWEsS0FFSyxNQUZMQSxPQUVLLHNCQUZMQSxRQUNmYixNQUM4RDtRQUtoRWlsRSwyQjthQUVBQyxlQUFlQyxTQUFTajdCLE9BQU9DO01BQ2pDO3lCQUhFODZCO09BR0Y7cUJBSEVBLHVCcUJoTkE5Z0QsaUJyQmdOQThnRDtPQUdRO01BQ00sZ0JBRkNFLFNBRUQseUJBRlVqN0IsT0FDdEJrN0IsSUFENkJqN0IsUUFFNEI7UUFHM0RrN0IseUJBakV5Q2Q7YUFtRXpDZSxrQkFBa0JwbkUsR0FBSSwyQkFBSkEsRUFBSSxRQUEwQjthQUNoRHFuRSx5QkFBdUIsT0FIdkJGLHdCQUc2QzthQUU3Q0csVUFBWTk1QixJQUFtQ3hCLE9BQU9DO01BQ3hELEdBRGN1QjtPQUFXLFFBQVhBLGdCQUFXcUM7O1dBQVhvM0IsU0FMWkU7TUFNRixTQUFRSSxTQUFTL25FO1EsSUFBQTZtQztRQUNmO1VBQVcsSUFBUDFqQyxLQUFPLGVBRkNza0UsU0FBbUNqN0IsT0FBT0M7VUFFM0M7WUFFNEQsdUJBQTNELGNBRlJ0cEM7Z0JBSUNzUjs7O2NBQ0gsVUFOYW95QixnQkFLVnB5QjtjQUNrQyxjQU54Qm95Qjs7a0JBS1ZweUIsR0FDd0Q7TUFOL0Qsa0JBT2E7YUFFWHd6RCxlQUFpQmo2QixjQUNtQ3hCLE9BQU9DO01BQzdELEdBRm1CdUIsSUFBTyxRQUFQQSxZQUFPcUMsYUFBUHB0QztNQUVuQixRQUZpRCxrQkFBUmtsRSxNQUFRRCxlQUFSQztNQUV6QztPQUQ4QixrQkFBWFYsU0FBV1c7O1dBQVhYLFNBaEJqQkU7TUFpQkYsU0FBUUksU0FBUy9uRTtRLElBQUE2bUM7UUFDZjtVQUFXLElBQVAxakMsS0FBTyxlQUZNc2tFLFNBQW1DajdCLE9BQU9DO1VBRWhEO1lBR1IsWUFIQ3RwQyxLQUdELDRCQU5jRixRQUFzQmtsRSxNQUduQ2hsRTs7Z0JBSUNzUjs7O2NBQ0gsVUFOYW95QixnQkFLVnB5QjtjQUNrQyxjQU54Qm95Qjs7a0JBS1ZweUIsR0FDd0Q7TUFOL0Qsa0JBT2E7Ozs7T0ExRlY2eEQ7T0FBa0JDO09BQWlCQztPQW9CcENTO09BbkJDUDtPQUFhQztPQUFhQztPQXlCM0JNO09BaUJBRTtPQVNBRTtPQUxBRDtPQTlDK0ROO09BQzlEQztPQXFFRGM7T0FVQUc7T0FaQUo7T0FEQUQ7T0FuRXlDZjtPQUFlQzs7YUNySnhEdUIsTUFBSTFuRSxFQUFFQyxHQUFJLFlBQU5ELE9BQUVDLEtBQUZELE9BQUVDLEtBQTRDO2FBRWxEMG5FLE1BQUkzbkUsRUFBRUMsR0FBSSxZQUFORCxPQUFFQyxLQUFGRCxPQUFFQyxLQUE0QzthQUVsRDJuRSxJQUFJNW5FLEdBQUksY0FBSkEsWUFBa0M7YUFFdEM2bkUsS0FBSzduRSxHQUFJLFlBQUpBLFlBQStCO2FBRXBDOG5FLElBQUk5bkUsRUFBRUM7TUFBSSxZQUFORCxPQUFFQyxPQUFGRCxPQUFFQyxLQUFGRCxPQUFFQyxPQUFGRCxPQUFFQyxLQUN5QzthQUUvQzhuRSxJQUFJL25FLEVBQUVDO01BQ1IsWUFEUUEsU0FDUixTQURRQTtRQUVOLE1BRk1BLFlBRU4sRUFGTUEsT0FFRmtFLElBRkVsRTtRQUVOLGFBRklELE9BRUFtRSxJQUZBbkUsUUFHQWtWLEdBSEFsVixPQUVBbUUsSUFGQW5FLFFBR0FrVjtNQUlKLFFBUE1qVixZQU9OLElBUE1BLE9BT0ZpZSxNQVBFamU7TUFPTixhQUFJaWUsTUFQQWxlLGVBUUFvVixLQURBOEksTUFQQWxlLGVBUUFvVixJQUU2QjthQUVqQzR5RCxJQUFJaG9FLEdBQUksV0ExQlJ6RSxNQTBCSXlFLEVBQWE7YUFFakJpb0UsTUFBTWpvRSxHQUFJLE9BQUpBLHlCQUFnQzthQUV0Q2tvRSxLQUFLbG9FO01BRVAsZUFGT0EsTUFFUCxXQUZPQTtNQUVQLEdBQUltRSxjQUF1QjNJO01BRXRCLEdBRnNCQSxjQUF2QjJJO01BR0MsR0FIc0IzSSxLQUF2QjJJLEdBSUYsSUFBSXFnQixFQUpxQmhwQixJQUF2QjJJLEVBSXFCLE9BSnJCQSxJQUlxQixjQUFuQnFnQjtNQUpOLElBTU0yakQsSUFORmhrRSxJQUF1QjNJO01BTUYsT0FORUEsSUFNRixjQUFuQjJzRSxVQUFzQzthQUUxQ3B0RCxJQUFJL2EsR0FBSSxrQkFBSkEsVUFBbUI7YUFFdkJvb0UsTUFBTWpuRSxFQUFFMkIsR0FBVyxxQkFBWEEsS0FBRjNCLEVBQThCLFNBQTVCMkIsS0FBRjNCLEVBQTBDO2FBRWhEa25FLEtBQUtyb0U7TUFDUCxHQURPQTtNQUVGLGVBRkVBLE1BRUYsV0FGRUE7TUFFRixHQUN3QnhFLEtBQXZCMkk7T0FFYTtVQUZVM0ksSUFBdkIySTtRQUNBd3lCLEVBR0EsVUFKQXh5QixLQUlXLHFCQUFvQixjQUQzQnFnQjs7T0FFRztZQUxQcmdCLElBQXVCM0k7UUFDdkJtN0IsRUFNQSxVQVB1Qm43QixLQU9aLGlCQURQMnNFLE1BQ3lCLGNBRHpCQTtNQUdSLFFBWktub0UsaUJBSUQyMkIsUUFKQzMyQixPQUlEMjJCO01BRkQsSUFFQzJ4QyxTQUpDdG9FLEtBSUQyMkI7d0JBRHVCbjdCLElBQ3ZCbTdCLE1BV0g7YUFFRDR4QyxJQUFJdm9FO01BQ04sSUFBSThULEVBQUosU0FETTlULE1BQzBCLFlBQTVCOFQsSUFBNEIsU0FEMUI5VCxNQUNGOFQsSUFBZ0QsU0FEOUM5VCxNQUN3RDthQUU1RHdvRSxJQUFJeG9FO01BQThCLG9CQUE5QkEsV0FBdUIscUJBQVIsS0FBZkEsU0FBK0M7YUFFbkR5b0UsSUFBSXpvRSxFQUFFQyxHQUFRLGVBQVJBLEVBQWUsSUFBakJELElBQXlCOzs7O09BbkU3QjFFO09BQ0FDO09BQ0FDO09BTUFvc0U7T0FFQUM7T0FOQUg7T0FFQUM7T0FNQUc7T0FlQUU7T0FaQUQ7T0E4QkFNO09BaEJBSjtPQUVBQztPQVVBbnREO09BRUFxdEQ7T0FtQkFHO09BR0FDO09BRUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09HakVBNytEO09BSUEzSDs7O09BRkE2SDtPQU1BOUg7T0FJQStIO09BUUFLO09BZUFNOztPQVBBM0k7T0FFSXNJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJa0NsQ00sSUFBVnErRCxRQUFVO2FBRVZDLHFCQUFxQmpwRSxHQUN2QixPQUhFZ3BFLFFBR2MsV0FET2hwRSxNQUNLO0lBSGhCLFNBa0JSa3BFLFNBQVF2RDtNQUNQO1FBQ2EscUJBRk5BLE1BR1IsS0FESXdEO1FBT0osMENBTElqekQ7UUFLSixPQUxJQTtNQU9HLFVuQzZQVHpULFNtQ3pQRztJQWpDTyxTQXVDUjJtRSxXQUFZQyxLQUFLbnpELEVBQUdvekQ7TUFDdEI7O2lCQUNFOzBCQUZZRCxLQUFLbnpELEtBQUdvekQsV0FFa0IsRUFBQztJQXpDL0IsU0ErQ1JDLGVBQWdCRixLQUFLbnpEO01BQ3ZCOztpQkFDRSxHQUZxQkEsS0FFSjtpQkFDakIsMENBSGdCbXpELEtBQUtuekQ7aUJBSXJCLFVBSnFCQTtpQkFJckI7eUJBQ2dCLEVBQUM7SUFwRFQsY0FrQlJnekQsU0FxQkFFLFdBUUFHO0lBL0NRLFNBNERSQyxPQUFNSDtVQUFzQkYsaUJBQWZNO2FBMURmUjs7aUJBNERFLEdBRmFRLE9BRUU7aUJBQ2Y7OzBCQUhNSixLQUFzQkYsUUFJVjtJQWhFVixnQkE0RFJLO0lBNURRLFNBdUVWRSxtQ0FBb0NKO01BQ3RDOztpQkFDRSxpREFGb0NBLFdBRVUsRUFBQztJQXpFckM7O1NBQVZOLHdCQXVFQVU7SUF2RVU7O0tDeUNWQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBNzNCO2FBRUE4M0I7O2VBQ1c7ZUFDQTtlQUNJO2VBQ0U7ZUFDRDtlQUNFO2VBQ1Q7ZUFDQTtlQUNGO2VBQ007Z0JBQ0E7Z0JBQ0E7Z0JBQ0wsU0FBQztRQUtUQyxXQUNBQzthQVlFQyxLQUFLdG5FO01BQ1AsdUJBRE9BLEdBQ1AsaUJBQUkzQixLQUFKLEtBQUlBLFVBQUo7O1lBRUEzRjtRQUFvQjtVQUFTLDZCQUh0QnNILEVBR1B0SDtVQUFvQixpQkFEaEIwWixFQUNKMVo7VUFBNkIsU0FBN0JBOzs7TUFDQSxPQUZJMFosQ0FFSDthQU9DbTFELGNBQWNoN0Q7TUFDMkM7aUJBRDNDQTtPQUMyQztPQUF6Qjt3QztNQUFsQyxtQ0FBb0IsYUFESkEsV0FDc0Q7b0JBWnBFKzZELEtBV0FDO2FBcUJBQyxTQUFPQyxLQUFLQyxRQUNkLHNCQURTRCxLQUFLQyxXQUNrQjthQUM5QkMsSUFBSXA3RCxLQUFNLG1DQUFOQSxRQUEyQjthQUMvQnE3RCxJQUFJcjdEO01BQU07NEIsbUNBQU5BLGVBQTJCO2FBTy9CczdELGdCQUFjdDdEO01BQXlCLHVDQUF6QkEsS0FBbUM7YUFLakR1N0QsU0FBU0wsS0FBS0MsT0FBT2huRTtNQUNmLElBQUpWLEVBQUksU0FER3luRSxLQUFLQyxRQUVoQixlQURJMW5FLEdBRG1CVSxHQUV2QixPQURJVixDQUVIO2FBS0MrbkUsU0FBT04sS0FBS0MsT0FBT007TUFDckIsc0JBRFNQLEtBQUtDLFVBQU9NLEtBQ2M7YUFhakNDLGdCQUFjMTdEO01BQ2hCLHVCQURnQkE7TUFDaEIsbUNBQW9CLGFBREpBLFdBQzJCO2FBR3pDMjdELE1BQWdCbG9FLEVBQTBCM0I7TUFDdEMsaUNBRFkyQjtNQUNaLG1CQUNTLGNBRkdBLEtBQTBCM0IsSUFHdkIsY0FISDJCLEtBQTBCM0IsR0FHNEI7YUFHdEU4cEUsU0FBa0JWLEtBQU1DLE9BQWtCam9EO01BQ25DO21CQURXZ29ELEtBQU1DLE9BQWtCam9EO09BQ25DLFVBRGlCaW9EO09BTzFCLEtBUDRDam9EO09BTzVDOzs7UUFBc0M7O1lBTmxDMm9ELEdBTUoxdkUsSUFMSTJILFFBSzBELGlCQVBsQm9mLEtBTzVDL21CO1VBQXNDLFNBQXRDQTs7O01BQ0EsT0FQSTB2RSxFQU9GO2FBS0FDLFVBQU9aLEtBQUtDLE9BQU9ZLEtBQUtDO01BQzFCLHNCQURTZCxLQUFLQyxVQUFPWSxLQUFLQyxNQUNnQjthQWV4Q0MsZ0JBQWNqOEQ7TUFDaEIsdUJBRGdCQSxLQUNoQixtQkFEZ0JBO01BQ2hCOzJDQUFvQixhQURKQSxpQkFDeUM7YUFPdkRrOEQsV0FBV3pvRSxFQUFFM0IsR0FBSSxxQkFBTjJCLEtBQUUzQixHQUErQjthQUM1Q3FxRSxZQUFZMW9FLEVBQUUzQixHQUFJLHFCQUFOMkIsS0FBRTNCLEdBQWdDO2FBRzlDc3FFLFdBQWtCbEIsS0FBTUMsT0FBa0Jqb0Q7TUFDNUM7WUFENENBO09BQzVDLFdBQUk2b0QsT0FDNEMsaUJBRko3b0Q7T0FHbkMsYUFIV2dvRCxLQUFNQyxPQUN0QlksS0FDQUM7T0FDSyxVQUhpQmI7T0FTMUIsS0FSSVk7T0FRSjs7O1FBQ0U7Y0FBSU0sSUFBSixpQkFWMENucEQsS0FTNUMvbUI7VUFDRSxHQUFJa3dFLG1CQVJGTDtXQVVBO1VBRkYsSUFFK0QsS0FWN0RBLGFBVTZEOztnQkFDL0R0OUQ7WUFDRTs7Z0JBWEFtOUQsR0FNSjF2RSxJQUxJMkgsUUFTRjRLLElBVEU1SyxRQVVrQyxpQkFKaEN1b0UsSUFHSjM5RDtjQUNFLFNBREZBOzs7VUFIQSxTQURGdlM7OztNQVFBLE9BZEkwdkUsRUFjRjthQUtBUyxVQUFPcEIsS0FBS0MsT0FBT1ksS0FBS0MsS0FBS087TUFDL0Isc0JBRFNyQixLQUFLQyxVQUFPWSxLQUFLQyxLQUFLTyxNQUNpQjthQWlCOUNDLGdCQUFjeDhEO01BQ2hCO2tDQURnQkE7T0FDaEIsbUJBRGdCQTtPQUNoQixtQkFEZ0JBO01BQ2hCOzs2Q0FBb0IsYUFESkE7b0JBQ3NEO2FBT3BFeThELGFBQWFocEUsRUFBRTNCLEVBQUUwZ0IsR0FBSSxxQkFBUi9lLEtBQUUzQixFQUFFMGdCLEdBQWtDO2FBQ25Ea3FELGNBQWNqcEUsRUFBRTNCLEVBQUUwZ0IsR0FBSSxxQkFBUi9lLEtBQUUzQixFQUFFMGdCLEdBQW1DO2FBQ3JEbXFELGFBQWFscEUsRUFBRTNCLEdBQUkscUJBQU4yQixLQUFFM0IsR0FBK0I7YUFDOUM4cUUsY0FBY25wRSxFQUFFM0IsR0FBSSxxQkFBTjJCLEtBQUUzQixHQUFnQzthQUdoRCtxRSxXQUFrQjNCLEtBQU1DLE9BQWtCam9EO01BQzVDO1lBRDRDQTtPQUM1QyxXQUFJNm9ELE9BQzRDLGlCQUZKN29EO09BRzVDO2NBREk4b0Q7O1VBQ29ELGlCQUFSLGlCQUhKOW9EO09BSW5DLGFBSldnb0QsS0FBTUMsT0FDdEJZLEtBQ0FDLEtBQ0FPO09BQ0ssVUFKaUJwQjtPQVUxQixLQVRJWTtPQVNKOzs7UUFDRTtjQUFJTSxJQUFKLGlCQVgwQ25wRCxLQVU1Qy9tQjtVQUNFLEdBQUlrd0UsbUJBVEZMO1dBV0E7VUFGRixJQUV5RCxLQVh2REEsYUFXdUQ7O2dCQUN6RHQ5RDtZQUNFO2tCQUFJbytELElBQUosaUJBSkVULElBR0ozOUQ7Y0FDRSxHQUFJbytELG1CQVpKUDtlQWNFO2NBRkYsSUFFeUQsS0FkekRBLGFBY3lEOztvQkFDekRoZ0U7Z0JBQ0U7O29CQWZGcy9EO29CQU1KMXZFLElBTEkySDtvQkFTRjRLLElBVEU1SztvQkFhQXlJLElBYkF6STtvQkFjOEMsaUJBSjFDZ3BFLElBR0p2Z0U7a0JBQ0UsU0FERkE7OztjQUhBLFNBREZtQzs7O1VBSEEsU0FERnZTOzs7TUFhQSxPQW5CSTB2RSxFQW1CRjthQVdGa0IsbUJBQW1CdHBFO01BQ2xCLDhCQURrQkE7O2VBRWhCLDRDQUF5QzthQUM1Q3VwRSxtQkFBbUJ2cEU7TUFDbEIsOEJBRGtCQTs7ZUFFaEIsNENBQXlDO2FBQzVDd3BFLG1CQUFtQnhwRTtNQUNsQiw4QkFEa0JBOztlQUVoQiw0Q0FBeUM7YUFDNUN5cEUsbUJBQW1CenBFO01BQ2xCLDhCQURrQkE7O2VBRWhCLDRDQUF5QzthQUs1QzBwRSxVQUFVMXBFLEdBQUksdUJBQUpBLE1BQWtCO2FBQzVCMnBFLFVBQVUzcEUsRUFBRXNvRSxNQUFPLHVCQUFUdG9FLEtBQUVzb0UsTUFBeUI7YUFDckNzQixVQUFVNXBFLEVBQUVzb0UsS0FBS0MsTUFBTyx1QkFBZHZvRSxLQUFFc29FLEtBQUtDLE1BQThCO2FBQy9Dc0IsVUFBVTdwRSxFQUFFc29FLEtBQUtDLEtBQUtPO01BQU8sdUJBQW5COW9FLEtBQUVzb0UsS0FBS0MsS0FBS08sTUFBbUM7Ozs7T0FoUnpEdkM7T0FDQUM7T0FTQVM7T0FDQUM7T0FUQVQ7T0FDQUM7T0FDQUM7T0FDQUM7T0FHQUc7T0FGQUY7T0FDQUM7T0FFQUU7T0FHQTMzQjtPQUVBODNCO09Ba0JBQztPQUNBQzs7VUE0Q0VHLCtCQVVBSyxnQkFSQUYsSUFDQUMsSUFZQUU7VUFRQUMsK0JBY0FFLGdCQUlBQyxNQU1BQzs7UUFhQUU7O1FBZ0JBRztRQVFBQztRQUNBQztRQUdBQzs7UUFzQkFFOztRQWtCQUU7UUFRQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFHQUM7T0FrQ0ZFO09BR0FDO09BR0FDO09BR0FDOztPQU9BQztPQUNBQztPQUNBQztPQUNBQzs7VTs7Ozs7OztJQTNVTDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ0NBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OzREREFBRDs7O0lFNkN3QixXRjdDeEJFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJRTZDd0IsU0FBbkJDO01BQW1COztTQUNuQixXRjlDTEQ7U0U4Q0s7O1NBQ0EsV0YvQ0xBO1NFK0NLO2VBQ0EsV0ZoRExBLGdCRWdESzs7U0FDQSxXRmpETEEsZ0JFaURLOztTQUNBLFdGbERMQTtTRWtESztlQUNBLFdGbkRMQSxnQkVtREs7O1NBQ0EsV0ZwRExBLGdCRW9ESzs7U0FDQSxXRnJETEEsZ0JFcURLOztTQUNBLFdGdERMQTtTRXNESzs7U0FDQSxXRnZETEE7U0V1REs7O1NBQ0EsV0Z4RExBO1NFd0RLOztTQUNBLFdGekRMQTtTRXlESzs7U0FDQSxXRjFETEE7U0UwREs7O1NBQ0EsV0YzRExBO1NFMkRLOztTQUNBLFdGNURMQTtTRTRESzs7U0FDQSxXRjdE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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ0FBQzs7Ozs7Ozs7Ozs7Ozs7S0NBQUM7Ozs7S0M4RGFDO0tBUkFDO0tBWkFDO0tBMUNiQzs7Ozs7Ozs7Ozs7Ozt5REpBQVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQVlzQjs7O1FBR2Y7Ozs7U0FEQTs7U0FEQTs7TUFLRjtlQUFJUzs7U0FBT0M7U0FBUUM7U0FBSkM7U0FBUUM7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QTtTQTZFdUI7VUFqQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkFGVmxHOzs7VUFIQzttQkFBUDZEO0lBaENKO1VMUkgiLCJzb3VyY2VzIjpbIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC91Y2hhci5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9pbnQ2NC5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9sZXhpbmcubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0Lm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL3ByaW50ZXhjLm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL2ZpbGVuYW1lLm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL2NvbXBsZXgubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0QmFzaWNzLm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL3N0ZGxpYi5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9saXN0Lm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL3NlcS5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9jaGFyLm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL25hdGl2ZWludC5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9ieXRlcy5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9zdHJpbmcubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvc29ydC5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9tYXJzaGFsLm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL29iai5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9hcnJheS5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9pbnQzMi5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9wYXJzaW5nLm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL3NldC5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9tYXAubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvc3RhY2subWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvcXVldWUubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvY2FtbGludGVybmFsTGF6eS5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9sYXp5Lm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL3N0cmVhbS5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9idWZmZXIubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvcHJpbnRmLm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL2FyZy5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9nYy5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9kaWdlc3QubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvcmFuZG9tLm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL2hhc2h0YmwubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvd2Vhay5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9mb3JtYXQubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvc2NhbmYubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvY2FsbGJhY2subWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvY2FtbGludGVybmFsT08ubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvZ2VubGV4Lm1sIiwiL2hvbWUvdmluY2VudC8ub3BhbS80LjA3LjEvbGliL29jYW1sL2VwaGVtZXJvbi5tbCIsIi9ob21lL3ZpbmNlbnQvLm9wYW0vNC4wNy4xL2xpYi9vY2FtbC9zcGFjZXRpbWUubWwiLCIvaG9tZS92aW5jZW50Ly5vcGFtLzQuMDcuMS9saWIvb2NhbWwvYmlnYXJyYXkubWwiLCIvaG9tZS92aW5jZW50L0Ryb3Bib3gvSGFja2luZy9Qb3J0Zm9saW8vSnNPZk9DYWlyby9fYnVpbGQvZGVmYXVsdC9zcmMvQ2Fpcm9Nb2NrLm1sIiwiL2hvbWUvdmluY2VudC9Ecm9wYm94L0hhY2tpbmcvUG9ydGZvbGlvL0pzT2ZPQ2Fpcm8vX2J1aWxkL2RlZmF1bHQvc3JjL0pzT2ZPQ2Fpcm8ubWwiLCIvaG9tZS92aW5jZW50L0Ryb3Bib3gvSGFja2luZy9Qb3J0Zm9saW8vSnNPZk9DYWlyby9fYnVpbGQvZGVmYXVsdC9zcmMvQmFja2VuZC5pbmNsLm1sIiwiL2hvbWUvdmluY2VudC9Ecm9wYm94L0hhY2tpbmcvUG9ydGZvbGlvL0pzT2ZPQ2Fpcm8vX2J1aWxkL2RlZmF1bHQvc3JjL0NhaXJvTW9jay5jcHBvLm1sIiwiL2hvbWUvdmluY2VudC9Ecm9wYm94L0hhY2tpbmcvUG9ydGZvbGlvL0pzT2ZPQ2Fpcm8vX2J1aWxkL2RlZmF1bHQvc3JjL0pzT2ZPQ2Fpcm8uY3Bwby5tbCIsIi9ob21lL3ZpbmNlbnQvRHJvcGJveC9IYWNraW5nL1BvcnRmb2xpby9Kc09mT0NhaXJvL19idWlsZC9kZWZhdWx0L3RzdC9UZXN0cy9Vbml2ZXJzYWwubWwiLCIvaG9tZS92aW5jZW50L0Ryb3Bib3gvSGFja2luZy9Qb3J0Zm9saW8vSnNPZk9DYWlyby9fYnVpbGQvZGVmYXVsdC90c3QvVGVzdHMvRGVjb3JhdGlvbi5tbCIsIi9ob21lL3ZpbmNlbnQvRHJvcGJveC9IYWNraW5nL1BvcnRmb2xpby9Kc09mT0NhaXJvL19idWlsZC9kZWZhdWx0L3RzdC9UZXN0cy9EcmF3aW5nLm1sIiwiL2hvbWUvdmluY2VudC9Ecm9wYm94L0hhY2tpbmcvUG9ydGZvbGlvL0pzT2ZPQ2Fpcm8vX2J1aWxkL2RlZmF1bHQvdHN0L1Rlc3RzL0xpbWl0YXRpb25zLm1sIiwiL2hvbWUvdmluY2VudC9Ecm9wYm94L0hhY2tpbmcvUG9ydGZvbGlvL0pzT2ZPQ2Fpcm8vX2J1aWxkL2RlZmF1bHQvdHN0L1Rlc3RzL1Rlc3RzLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgRGFuaWVsIEMuIEJ1ZW56bGkgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuXG5sZXQgZXJyX25vX3ByZWQgPSBcIlUrMDAwMCBoYXMgbm8gcHJlZGVjZXNzb3JcIlxubGV0IGVycl9ub19zdWNjID0gXCJVKzEwRkZGRiBoYXMgbm8gc3VjY2Vzc29yXCJcbmxldCBlcnJfbm90X3N2IGkgPSBmb3JtYXRfaW50IFwiJVhcIiBpIF4gXCIgaXMgbm90IGFuIFVuaWNvZGUgc2NhbGFyIHZhbHVlXCJcbmxldCBlcnJfbm90X2xhdGluMSB1ID0gXCJVK1wiIF4gZm9ybWF0X2ludCBcIiUwNFhcIiB1IF4gXCIgaXMgbm90IGEgbGF0aW4xIGNoYXJhY3RlclwiXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgbWluID0gMHgwMDAwXG5sZXQgbWF4ID0gMHgxMEZGRkZcbmxldCBsb19ib3VuZCA9IDB4RDdGRlxubGV0IGhpX2JvdW5kID0gMHhFMDAwXG5cbmxldCBib20gPSAweEZFRkZcbmxldCByZXAgPSAweEZGRkRcblxubGV0IHN1Y2MgdSA9XG4gIGlmIHUgPSBsb19ib3VuZCB0aGVuIGhpX2JvdW5kIGVsc2VcbiAgaWYgdSA9IG1heCB0aGVuIGludmFsaWRfYXJnIGVycl9ub19zdWNjIGVsc2VcbiAgdSArIDFcblxubGV0IHByZWQgdSA9XG4gIGlmIHUgPSBoaV9ib3VuZCB0aGVuIGxvX2JvdW5kIGVsc2VcbiAgaWYgdSA9IG1pbiB0aGVuIGludmFsaWRfYXJnIGVycl9ub19wcmVkIGVsc2VcbiAgdSAtIDFcblxubGV0IGlzX3ZhbGlkIGkgPSAobWluIDw9IGkgJiYgaSA8PSBsb19ib3VuZCkgfHwgKGhpX2JvdW5kIDw9IGkgJiYgaSA8PSBtYXgpXG5sZXQgb2ZfaW50IGkgPSBpZiBpc192YWxpZCBpIHRoZW4gaSBlbHNlIGludmFsaWRfYXJnIChlcnJfbm90X3N2IGkpXG5leHRlcm5hbCB1bnNhZmVfb2ZfaW50IDogaW50IC0+IHQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB0b19pbnQgOiB0IC0+IGludCA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX2NoYXIgdSA9IHUgPCAyNTZcbmxldCBvZl9jaGFyIGMgPSBDaGFyLmNvZGUgY1xubGV0IHRvX2NoYXIgdSA9XG4gIGlmIHUgPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyAoZXJyX25vdF9sYXRpbjEgdSkgZWxzZVxuICBDaGFyLnVuc2FmZV9jaHIgdVxuXG5sZXQgdW5zYWZlX3RvX2NoYXIgPSBDaGFyLnVuc2FmZV9jaHJcblxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBQZXJ2YXNpdmVzLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFBlcnZhc2l2ZXMuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXggKilcblxudHlwZSBwb3NpdGlvbiA9IHtcbiAgcG9zX2ZuYW1lIDogc3RyaW5nO1xuICBwb3NfbG51bSA6IGludDtcbiAgcG9zX2JvbCA6IGludDtcbiAgcG9zX2NudW0gOiBpbnQ7XG59XG5cbmxldCBkdW1teV9wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMDtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gLTE7XG59XG5cbnR5cGUgbGV4YnVmID1cbiAgeyByZWZpbGxfYnVmZiA6IGxleGJ1ZiAtPiB1bml0O1xuICAgIG11dGFibGUgbGV4X2J1ZmZlciA6IGJ5dGVzO1xuICAgIG11dGFibGUgbGV4X2J1ZmZlcl9sZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfYWJzX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9hY3Rpb24gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfZW9mX3JlYWNoZWQgOiBib29sO1xuICAgIG11dGFibGUgbGV4X21lbSA6IGludCBhcnJheTtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wIDogcG9zaXRpb247XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wIDogcG9zaXRpb247XG4gIH1cblxudHlwZSBsZXhfdGFibGVzID1cbiAgeyBsZXhfYmFzZTogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHQ6IHN0cmluZztcbiAgICBsZXhfdHJhbnM6IHN0cmluZztcbiAgICBsZXhfY2hlY2s6IHN0cmluZztcbiAgICBsZXhfYmFzZV9jb2RlIDogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHRfY29kZSA6IHN0cmluZztcbiAgICBsZXhfdHJhbnNfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY2hlY2tfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY29kZTogc3RyaW5nO31cblxuZXh0ZXJuYWwgY19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50ID0gXCJjYW1sX2xleF9lbmdpbmVcIlxuZXh0ZXJuYWwgY19uZXdfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX25ld19sZXhfZW5naW5lXCJcblxubGV0IGVuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5cbmxldCBuZXdfZW5naW5lIHRibCBzdGF0ZSBidWYgPVxuICBsZXQgcmVzdWx0ID0gY19uZXdfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5cbmxldCBsZXhfcmVmaWxsIHJlYWRfZnVuIGF1eF9idWZmZXIgbGV4YnVmID1cbiAgbGV0IHJlYWQgPVxuICAgIHJlYWRfZnVuIGF1eF9idWZmZXIgKEJ5dGVzLmxlbmd0aCBhdXhfYnVmZmVyKSBpblxuICBsZXQgbiA9XG4gICAgaWYgcmVhZCA+IDBcbiAgICB0aGVuIHJlYWRcbiAgICBlbHNlIChsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWU7IDApIGluXG4gICgqIEN1cnJlbnQgc3RhdGUgb2YgdGhlIGJ1ZmZlcjpcbiAgICAgICAgPC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tPlxuICAgICAgICB8ICBqdW5rIHwgICAgICB2YWxpZCBkYXRhICAgICB8ICAganVuayAgICB8XG4gICAgICAgIF4gICAgICAgXiAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgIF5cbiAgICAgICAgMCAgICBzdGFydF9wb3MgICAgICAgICAgICAgYnVmZmVyX2VuZCAgICBCeXRlcy5sZW5ndGggYnVmZmVyXG4gICopXG4gIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG4gPiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIgdGhlbiBiZWdpblxuICAgICgqIFRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuXG4gICAgICAgPD0gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyXG4gICAgdGhlbiBiZWdpblxuICAgICAgKCogQnV0IHRoZXJlIGlzIGVub3VnaCBzcGFjZSBpZiB3ZSByZWNsYWltIHRoZSBqdW5rIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgIG9mIHRoZSBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcylcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgKCogV2UgbXVzdCBncm93IHRoZSBidWZmZXIuICBEb3VibGluZyBpdHMgc2l6ZSB3aWxsIHByb3ZpZGUgZW5vdWdoXG4gICAgICAgICBzcGFjZSBzaW5jZSBuIDw9IFN0cmluZy5sZW5ndGggYXV4X2J1ZmZlciA8PSBTdHJpbmcubGVuZ3RoIGJ1ZmZlci5cbiAgICAgICAgIFdhdGNoIG91dCBmb3Igc3RyaW5nIGxlbmd0aCBvdmVyZmxvdywgdGhvdWdoLiAqKVxuICAgICAgbGV0IG5ld2xlbiA9XG4gICAgICAgIG1pbiAoMiAqIEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlcikgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGluXG4gICAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG4gPiBuZXdsZW5cbiAgICAgIHRoZW4gZmFpbHdpdGggXCJMZXhpbmcubGV4X3JlZmlsbDogY2Fubm90IGdyb3cgYnVmZmVyXCI7XG4gICAgICBsZXQgbmV3YnVmID0gQnl0ZXMuY3JlYXRlIG5ld2xlbiBpblxuICAgICAgKCogQ29weSB0aGUgdmFsaWQgZGF0YSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXcgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBuZXdidWYgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKTtcbiAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDwtIG5ld2J1ZlxuICAgIGVuZDtcbiAgICAoKiBSZWFsbG9jYXRpb24gb3Igbm90LCB3ZSBoYXZlIHNoaWZ0ZWQgdGhlIGRhdGEgbGVmdCBieVxuICAgICAgIHN0YXJ0X3BvcyBjaGFyYWN0ZXJzOyB1cGRhdGUgdGhlIHBvc2l0aW9ucyAqKVxuICAgIGxldCBzID0gbGV4YnVmLmxleF9zdGFydF9wb3MgaW5cbiAgICBsZXhidWYubGV4X2Fic19wb3MgPC0gbGV4YnVmLmxleF9hYnNfcG9zICsgcztcbiAgICBsZXhidWYubGV4X2N1cnJfcG9zIDwtIGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIDwtIDA7XG4gICAgbGV4YnVmLmxleF9sYXN0X3BvcyA8LSBsZXhidWYubGV4X2xhc3RfcG9zIC0gcztcbiAgICBsZXhidWYubGV4X2J1ZmZlcl9sZW4gPC0gbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gcyA7XG4gICAgbGV0IHQgPSBsZXhidWYubGV4X21lbSBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC0xIGRvXG4gICAgICBsZXQgdiA9IHQuKGkpIGluXG4gICAgICBpZiB2ID49IDAgdGhlblxuICAgICAgICB0LihpKSA8LSB2LXNcbiAgICBkb25lXG4gIGVuZDtcbiAgKCogVGhlcmUgaXMgbm93IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgQnl0ZXMuYmxpdCBhdXhfYnVmZmVyIDAgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9idWZmZXJfbGVuIG47XG4gIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuXG5cbmxldCB6ZXJvX3BvcyA9IHtcbiAgcG9zX2ZuYW1lID0gXCJcIjtcbiAgcG9zX2xudW0gPSAxO1xuICBwb3NfYm9sID0gMDtcbiAgcG9zX2NudW0gPSAwO1xufVxuXG5sZXQgZnJvbV9mdW5jdGlvbiBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSB6ZXJvX3BvcztcbiAgICBsZXhfY3Vycl9wID0gemVyb19wb3M7XG4gIH1cblxubGV0IGZyb21fY2hhbm5lbCBpYyA9XG4gIGZyb21fZnVuY3Rpb24gKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgcyA9XG4gIHsgcmVmaWxsX2J1ZmYgPSAoZnVuIGxleGJ1ZiAtPiBsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWUpO1xuICAgIGxleF9idWZmZXIgPSBCeXRlcy5vZl9zdHJpbmcgczsgKCogaGF2ZSB0byBtYWtlIGEgY29weSBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB1bnNhZmUtc3RyaW5nIG1vZGUgKilcbiAgICBsZXhfYnVmZmVyX2xlbiA9IFN0cmluZy5sZW5ndGggcztcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gdHJ1ZTtcbiAgICBsZXhfc3RhcnRfcCA9IHplcm9fcG9zO1xuICAgIGxleF9jdXJyX3AgPSB6ZXJvX3BvcztcbiAgfVxuXG5sZXQgbGV4ZW1lIGxleGJ1ZiA9XG4gIGxldCBsZW4gPSBsZXhidWYubGV4X2N1cnJfcG9zIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3BvcyBsZW5cblxubGV0IHN1Yl9sZXhlbWUgbGV4YnVmIGkxIGkyID1cbiAgbGV0IGxlbiA9IGkyLWkxIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuXG5cbmxldCBzdWJfbGV4ZW1lX29wdCBsZXhidWYgaTEgaTIgPVxuICBpZiBpMSA+PSAwIHRoZW4gYmVnaW5cbiAgICBsZXQgbGVuID0gaTItaTEgaW5cbiAgICBTb21lIChCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlbilcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICBOb25lXG4gIGVuZFxuXG5sZXQgc3ViX2xleGVtZV9jaGFyIGxleGJ1ZiBpID0gQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGlcblxubGV0IHN1Yl9sZXhlbWVfY2hhcl9vcHQgbGV4YnVmIGkgPVxuICBpZiBpID49IDAgdGhlblxuICAgIFNvbWUgKEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpKVxuICBlbHNlXG4gICAgTm9uZVxuXG5cbmxldCBsZXhlbWVfY2hhciBsZXhidWYgaSA9XG4gIEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciAobGV4YnVmLmxleF9zdGFydF9wb3MgKyBpKVxuXG5sZXQgbGV4ZW1lX3N0YXJ0IGxleGJ1ZiA9IGxleGJ1Zi5sZXhfc3RhcnRfcC5wb3NfY251bVxubGV0IGxleGVtZV9lbmQgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AucG9zX2NudW1cblxubGV0IGxleGVtZV9zdGFydF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfc3RhcnRfcFxubGV0IGxleGVtZV9lbmRfcCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcFxuXG5sZXQgbmV3X2xpbmUgbGV4YnVmID1cbiAgbGV0IGxjcCA9IGxleGJ1Zi5sZXhfY3Vycl9wIGluXG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHsgbGNwIHdpdGhcbiAgICBwb3NfbG51bSA9IGxjcC5wb3NfbG51bSArIDE7XG4gICAgcG9zX2JvbCA9IGxjcC5wb3NfY251bTtcbiAgfVxuXG5cblxuKCogRGlzY2FyZCBkYXRhIGxlZnQgaW4gbGV4ZXIgYnVmZmVyLiAqKVxuXG5sZXQgZmx1c2hfaW5wdXQgbGIgPVxuICBsYi5sZXhfY3Vycl9wb3MgPC0gMDtcbiAgbGIubGV4X2Fic19wb3MgPC0gMDtcbiAgbGIubGV4X2N1cnJfcCA8LSB7bGIubGV4X2N1cnJfcCB3aXRoIHBvc19jbnVtID0gMH07XG4gIGxiLmxleF9idWZmZXJfbGVuIDwtIDA7XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICgqIFRvb2xzIHRvIG1hbmlwdWxhdGUgc2Nhbm5pbmcgc2V0IG9mIGNoYXJzIChzZWUgJVsuLi5dKSAqKVxuXG50eXBlIG11dGFibGVfY2hhcl9zZXQgPSBieXRlc1xuXG4oKiBDcmVhdGUgYSBmcmVzaCwgZW1wdHksIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgY3JlYXRlX2NoYXJfc2V0ICgpID0gQnl0ZXMubWFrZSAzMiAnXFwwMDAnXG5cbigqIEFkZCBhIGNoYXIgaW4gYSBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIEJ5dGVzLnNldCBjaGFyX3NldCBzdHJfaW5kXG4gICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxvciBtYXNrKSlcblxubGV0IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCA9XG4gIEJ5dGVzLnRvX3N0cmluZyBjaGFyX3NldFxuXG4oKiBDb21wdXRlIHRoZSBjb21wbGVtZW50IG9mIGEgY2hhciBzZXQuICopXG5sZXQgcmV2X2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgbGV0IGNoYXJfc2V0JyA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICBmb3IgaSA9IDAgdG8gMzEgZG9cbiAgICBCeXRlcy5zZXQgY2hhcl9zZXQnIGlcbiAgICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgaSkgbHhvciAweEZGKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY2hhcl9zZXQnXG5cbigqIFJldHVybiB0cnVlIGlmIGEgYGMnIGlzIGluIGBjaGFyX3NldCcuICopXG5sZXQgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbGFuZCBtYXNrKSA8PiAwXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBJZ25vcmVkIHBhcmFtIGNvbnZlcnNpb24gKilcblxuKCogR0FEVCB1c2VkIHRvIGFic3RyYWN0IGFuIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVyLiAqKVxuKCogU2VlIHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdC4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmIgPSBQYXJhbV9mb3JtYXRfRUJCIDpcbiAgICAoJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmJcblxuKCogQ29tcHV0ZSBhIHBhZGRpbmcgYXNzb2NpYXRlZCB0byBhIHBhZF9vcHRpb24gKHNlZSBcIiVfNDJkXCIpLiAqKVxubGV0IHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3BhZGRpbmdcbiAgfCBTb21lIHdpZHRoIC0+IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG5cbigqIENvbXB1dGUgYSBwcmVjaXNpb24gYXNzb2NpYXRlZCB0byBhIHByZWNfb3B0aW9uIChzZWUgXCIlXy40MmZcIikuICopXG5sZXQgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCA9IG1hdGNoIHByZWNfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3ByZWNpc2lvblxuICB8IFNvbWUgbmRlYyAtPiBMaXRfcHJlY2lzaW9uIG5kZWNcblxuKCogVHVybiBhbiBpZ25vcmVkIHBhcmFtIGludG8gaXRzIGVxdWl2YWxlbnQgbm90LWlnbm9yZWQgZm9ybWF0IG5vZGUuICopXG4oKiBVc2VkIGZvciBmb3JtYXQgcHJldHR5LXByaW50aW5nIGFuZCBTY2FuZi4gKilcbmxldCBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT4gKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhcmFtX2Zvcm1hdF9lYmIgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDaGFyIGZtdClcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfY2hhciBmbXQpXG4gIHwgSWdub3JlZF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFN0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX3N0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2ludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoSW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50MzIgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQzMiAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKE5hdGl2ZWludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDY0IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50NjQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9mbG9hdCAocGFkX29wdCwgcHJlY19vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZsb2F0IChGbG9hdF9mLCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfYm9vbCBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQm9vbCAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFJlYWRlciBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX25leHRfY2hhciBmbXQpXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGVzICopXG5cbnR5cGUgKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuID1cbiAgfCBBY2Nfb3Blbl90YWcgb2YgKCdiLCAnYykgYWNjXG4gIHwgQWNjX29wZW5fYm94IG9mICgnYiwgJ2MpIGFjY1xuXG4oKiBSZXZlcnNlZCBsaXN0IG9mIHByaW50aW5nIGF0b21zLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHByaW50ZiBhcmd1bWVudHMuICopXG5hbmQgKCdiLCAnYykgYWNjID1cbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgb2YgKCdiLCAnYykgYWNjICogZm9ybWF0dGluZ19saXRcbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW5cbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIExpdGVyYWwgc3RyaW5nICopXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogTGl0ZXJhbCBjaGFyICopXG4gIHwgQWNjX2RhdGFfc3RyaW5nICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogR2VuZXJhdGVkIHN0cmluZyAqKVxuICB8IEFjY19kYXRhX2NoYXIgICAgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIEdlbmVyYXRlZCBjaGFyICopXG4gIHwgQWNjX2RlbGF5ICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAqICgnYiAtPiAnYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIERlbGF5ZWQgcHJpbnRpbmcgKCVhLCAldCkgKilcbiAgfCBBY2NfZmx1c2ggICAgICAgICAgb2YgKCdiLCAnYykgYWNjICAgICAgICAgICAgICAoKiBGbHVzaCAqKVxuICB8IEFjY19pbnZhbGlkX2FyZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmdcbiAgICAgICgqIFJhaXNlIEludmFsaWRfYXJndW1lbnQgbXNnICopXG4gIHwgRW5kX29mX2FjY1xuXG4oKiBMaXN0IG9mIGhldGVyb2dlbmVvdXMgdmFsdWVzLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHNjYW5mIGNhbGxiYWNrIGFyZ3VtZW50cy4gKilcbnR5cGUgKCdhLCAnYikgaGV0ZXJfbGlzdCA9XG4gIHwgQ29ucyA6ICdjICogKCdhLCAnYikgaGV0ZXJfbGlzdCAtPiAoJ2MgLT4gJ2EsICdiKSBoZXRlcl9saXN0XG4gIHwgTmlsIDogKCdiLCAnYikgaGV0ZXJfbGlzdFxuXG4oKiBFeGlzdGVudGlhbCBCbGFjayBCb3hlcy4gKilcbigqIFVzZWQgdG8gYWJzdHJhY3Qgc29tZSBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlcnMuICopXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZGRpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9IFBhZGRpbmdfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZHByZWMgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9IFBhZHByZWNfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3opIHByZWNpc2lvbiAqICgneiwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkZGluZ19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmIgPSBQYWRkaW5nX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHBhZGRpbmcgKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYiA9IFByZWNpc2lvbl9mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYiA9IFBhZHByZWNfZm10X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdwIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCB0aGUgJ2EgYW5kICdkIHBhcmFtZXRlcnMgb2YgYW4gZm10LiAqKVxuKCogT3V0cHV0IHR5cGUgb2YgdGhlIGZvcm1hdCBwYXJzaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmIgPSBGbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfZm9ybWF0X2dlbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgPSBGbXRfZm10dHlfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdCAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiID0gRm10dHlfZm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXR0eSAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXRfZm10dHlfZWJiIC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBmbXR0eSB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgZm9ybWF0IHR5cGVzLiAqKVxudHlwZSBmbXR0eV9lYmIgPSBGbXR0eV9FQkIgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT4gZm10dHlfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwYWRkaW5nIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwYWRkaW5ncy4gKilcbnR5cGUgcGFkZGluZ19lYmIgPSBQYWRkaW5nX0VCQiA6ICgnYSwgJ2IpIHBhZGRpbmcgLT4gcGFkZGluZ19lYmJcblxuKCogQWJzdHJhY3QgYWxsIHByZWNpc2lvbiB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcHJlY2lzaW9ucy4gKilcbnR5cGUgcHJlY2lzaW9uX2ViYiA9IFByZWNpc2lvbl9FQkIgOiAoJ2EsICdiKSBwcmVjaXNpb24gLT4gcHJlY2lzaW9uX2ViYlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnN0YW50cyAqKVxuXG4oKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgZmxvYXQgcHJpbnRpbmcuICopXG5sZXQgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gPSAtNlxuICAoKiBGb3IgJWggYW5kICVIIGZvcm1hdHMsIGEgbmVnYXRpdmUgcHJlY2lzaW9uIG1lYW5zIFwiYXMgbWFueSBkaWdpdHMgYXNcbiAgICAgbmVjZXNzYXJ5XCIuICBGb3IgdGhlIG90aGVyIEZQIGZvcm1hdHMsIHdlIHRha2UgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgIG9mIHRoZSBwcmVjaXNpb24sIGhlbmNlIDYgZGlnaXRzIGJ5IGRlZmF1bHQuICopXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXh0ZXJuYWxzICopXG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfaW50MzI6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9uYXRpdmVpbnQ6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDY0OiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5leHRlcm5hbCBoZXhzdHJpbmdfb2ZfZmxvYXQ6IGZsb2F0IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXRcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgKCogVG9vbHMgdG8gcHJldHR5LXByaW50IGZvcm1hdHMgKilcblxuKCogVHlwZSBvZiBleHRlbnNpYmxlIGNoYXJhY3RlciBidWZmZXJzLiAqKVxudHlwZSBidWZmZXIgPSB7XG4gIG11dGFibGUgaW5kIDogaW50O1xuICBtdXRhYmxlIGJ5dGVzIDogYnl0ZXM7XG59XG5cbigqIENyZWF0ZSBhIGZyZXNoIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY3JlYXRlIGluaXRfc2l6ZSA9IHsgaW5kID0gMDsgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgaW5pdF9zaXplIH1cblxuKCogQ2hlY2sgc2l6ZSBvZiB0aGUgYnVmZmVyIGFuZCBncm93IGl0IGlmIG5lZWRlZC4gKilcbmxldCBidWZmZXJfY2hlY2tfc2l6ZSBidWYgb3ZlcmhlYWQgPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1Zi5ieXRlcyBpblxuICBsZXQgbWluX2xlbiA9IGJ1Zi5pbmQgKyBvdmVyaGVhZCBpblxuICBpZiBtaW5fbGVuID4gbGVuIHRoZW4gKFxuICAgIGxldCBuZXdfbGVuID0gbWF4IChsZW4gKiAyKSBtaW5fbGVuIGluXG4gICAgbGV0IG5ld19zdHIgPSBCeXRlcy5jcmVhdGUgbmV3X2xlbiBpblxuICAgIEJ5dGVzLmJsaXQgYnVmLmJ5dGVzIDAgbmV3X3N0ciAwIGxlbjtcbiAgICBidWYuYnl0ZXMgPC0gbmV3X3N0cjtcbiAgKVxuXG4oKiBBZGQgdGhlIGNoYXJhY3RlciBgYycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX2NoYXIgYnVmIGMgPVxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgMTtcbiAgQnl0ZXMuc2V0IGJ1Zi5ieXRlcyBidWYuaW5kIGM7XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIDFcblxuKCogQWRkIHRoZSBzdHJpbmcgYHMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHMgPVxuICBsZXQgc3RyX2xlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgc3RyX2xlbjtcbiAgU3RyaW5nLmJsaXQgcyAwIGJ1Zi5ieXRlcyBidWYuaW5kIHN0cl9sZW47XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIHN0cl9sZW5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIHRoZSBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NvbnRlbnRzIGJ1ZiA9XG4gIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmLmJ5dGVzIDAgYnVmLmluZFxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgY29udmVyc2lvbiB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfaWNvbnYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgLT4gJ2QnIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgLT4gJ2knXG4gIHwgSW50X3ggfCBJbnRfQ3ggLT4gJ3gnIHwgSW50X1ggfCBJbnRfQ1ggLT4gJ1gnIHwgSW50X28gfCBJbnRfQ28gLT4gJ28nXG4gIHwgSW50X3UgLT4gJ3UnXG5cbigqIENvbnZlcnQgYSBmbG9hdCBjb252ZXJzaW9uIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9mY29udiBmY29udiA9IG1hdGNoIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIHwgRmxvYXRfcGYgfCBGbG9hdF9zZiAtPiAnZicgfCBGbG9hdF9lIHwgRmxvYXRfcGUgfCBGbG9hdF9zZSAtPiAnZSdcbiAgfCBGbG9hdF9FIHwgRmxvYXRfcEUgfCBGbG9hdF9zRSAtPiAnRScgfCBGbG9hdF9nIHwgRmxvYXRfcGcgfCBGbG9hdF9zZyAtPiAnZydcbiAgfCBGbG9hdF9HIHwgRmxvYXRfcEcgfCBGbG9hdF9zRyAtPiAnRycgfCBGbG9hdF9GIC0+ICdGJ1xuICB8IEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoIC0+ICdoJyB8IEZsb2F0X0ggfCBGbG9hdF9wSCB8IEZsb2F0X3NIIC0+ICdIJ1xuXG5cbigqIENvbnZlcnQgYSBzY2FubmluZyBjb3VudGVyIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIgPSBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgIC0+ICdsJ1xuICB8IENoYXJfY291bnRlciAgLT4gJ24nXG4gIHwgVG9rZW5fY291bnRlciAtPiAnTidcblxuKCoqKilcblxuKCogUHJpbnQgYSBjaGFyX3NldCBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBPQ2FtbCBmb3JtYXQgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQgPVxuICBsZXQgcmVjIHByaW50X3N0YXJ0IHNldCA9XG4gICAgbGV0IGlzX2Fsb25lIGMgPVxuICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIgPSBDaGFyLihjaHIgKGNvZGUgYyAtIDEpLCBjaHIgKGNvZGUgYyArIDEpKSBpblxuICAgICAgaXNfaW5fY2hhcl9zZXQgc2V0IGNcbiAgICAgICYmIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IGJlZm9yZSAmJiBpc19pbl9jaGFyX3NldCBzZXQgYWZ0ZXIpIGluXG4gICAgaWYgaXNfYWxvbmUgJ10nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSc7XG4gICAgcHJpbnRfb3V0IHNldCAxO1xuICAgIGlmIGlzX2Fsb25lICctJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nO1xuICBhbmQgcHJpbnRfb3V0IHNldCBpID1cbiAgICBpZiBpIDwgMjU2IHRoZW5cbiAgICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlbiBwcmludF9maXJzdCBzZXQgaVxuICAgICAgZWxzZSBwcmludF9vdXQgc2V0IChpICsgMSlcbiAgYW5kIHByaW50X2ZpcnN0IHNldCBpID1cbiAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICdcXDI1NScgLT4gcHJpbnRfY2hhciBidWYgMjU1O1xuICAgIHwgJ10nIHwgJy0nIC0+IHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICB8IF8gLT4gcHJpbnRfc2Vjb25kIHNldCAoaSArIDEpO1xuICBhbmQgcHJpbnRfc2Vjb25kIHNldCBpID1cbiAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW5cbiAgICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgICAgfCAnXFwyNTUnIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NDtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU1O1xuICAgICAgfCAnXScgfCAnLScgd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICAgIHwgXyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDIpO1xuICAgICAgfCBfIC0+XG4gICAgICAgIHByaW50X2luIHNldCAoaSAtIDEpIChpICsgMik7XG4gICAgZWxzZSAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIClcbiAgYW5kIHByaW50X2luIHNldCBpIGogPVxuICAgIGlmIGogPSAyNTYgfHwgbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGopKSB0aGVuIChcbiAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaW50X29mX2NoYXIgJy0nKTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChqIC0gMSk7XG4gICAgICBpZiBqIDwgMjU2IHRoZW4gcHJpbnRfb3V0IHNldCAoaiArIDEpO1xuICAgICkgZWxzZVxuICAgICAgcHJpbnRfaW4gc2V0IGkgKGogKyAxKTtcbiAgYW5kIHByaW50X2NoYXIgYnVmIGkgPSBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICclJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgfCAnQCcgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0AnO1xuICAgIHwgYyAgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgaW5cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnWyc7XG4gIHByaW50X3N0YXJ0IChcbiAgICBpZiBpc19pbl9jaGFyX3NldCBjaGFyX3NldCAnXFwwMDAnXG4gICAgdGhlbiAoIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ14nOyByZXZfY2hhcl9zZXQgY2hhcl9zZXQgKVxuICAgIGVsc2UgY2hhcl9zZXRcbiAgKTtcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSdcblxuKCoqKilcblxuKCogUHJpbnQgYSBwYWR0eSBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eSA9IG1hdGNoIHBhZHR5IHdpdGhcbiAgfCBMZWZ0ICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICctJ1xuICB8IFJpZ2h0IC0+ICgpXG4gIHwgWmVyb3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnMCdcblxuKCogUHJpbnQgdGhlICdfJyBvZiBhbiBpZ25vcmVkIGZsYWcgaWYgbmVlZGVkLiAqKVxubGV0IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnID1cbiAgaWYgaWduX2ZsYWcgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICdfJ1xuXG4oKioqKVxuXG5sZXQgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSB3aWR0aCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgd2lkdGgpXG5cbigqKiopXG5cbigqIFByaW50IHBhZGRpbmcgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWRkaW5nIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHBhZGRpbmcgLT4gdW5pdCA9XG5mdW4gYnVmIHBhZCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT4gKClcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIG4pIC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgbik7XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyonXG5cbigqIFByaW50IHByZWNpc2lvbiBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3ByZWNpc2lvbiA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwcmVjaXNpb24gLT4gdW5pdCA9XG4gIGZ1biBidWYgcHJlYyAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gLT4gKClcbiAgfCBMaXRfcHJlY2lzaW9uIG4gLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgbik7XG4gIHwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIi4qXCJcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIG9yICcjJyBhc3NvY2lhdGVkIHRvIGFuIGludCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfcGQgfCBJbnRfcGkgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBJbnRfc2QgfCBJbnRfc2kgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBJbnRfQ3ggfCBJbnRfQ1ggfCBJbnRfQ28gLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBJbnRfZCB8IEludF9pIHwgSW50X3ggfCBJbnRfWCB8IEludF9vIHwgSW50X3UgLT4gKClcblxuKCogUHJpbnQgYW4gY29tcGxldGUgaW50IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJTMuKmRcIikuICopXG5sZXQgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqIFByaW50IGEgY29tcGxldGUgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjIGMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnIGFzc29jaWF0ZWQgdG8gYSBmbG9hdCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udiA9IG1hdGNoIGZjb252IHdpdGhcbiAgfCBGbG9hdF9wZiB8IEZsb2F0X3BlIHwgRmxvYXRfcEVcbiAgfCBGbG9hdF9wZyB8IEZsb2F0X3BHIHwgRmxvYXRfcGggfCBGbG9hdF9wSCAtPlxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgRmxvYXRfc2YgfCBGbG9hdF9zZSB8IEZsb2F0X3NFXG4gIHwgRmxvYXRfc2cgfCBGbG9hdF9zRyB8IEZsb2F0X3NoIHwgRmxvYXRfc0ggLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRVxuICB8IEZsb2F0X2cgfCBGbG9hdF9HIHwgRmxvYXRfRiB8IEZsb2F0X2ggfCBGbG9hdF9IIC0+XG4gICAgKClcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmbG9hdCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUrKi4zZlwiKS4gKilcbmxldCBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2Zjb252IGZjb252KVxuXG4oKiBDb21wdXRlIHRoZSBsaXRlcmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGZvcm1hdHRpbmdfbGl0LiAqKVxuKCogQWxzbyB1c2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0ID0gbWF0Y2ggZm9ybWF0dGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgIC0+IFwiQF1cIlxuICB8IENsb3NlX3RhZyAgICAgICAgICAgIC0+IFwiQH1cIlxuICB8IEJyZWFrIChzdHIsIF8sIF8pICAgIC0+IHN0clxuICB8IEZGbHVzaCAgICAgICAgICAgICAgIC0+IFwiQD9cIlxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgIC0+IFwiQFxcblwiXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgLT4gXCJALlwiXG4gIHwgTWFnaWNfc2l6ZSAoc3RyLCBfKSAgLT4gc3RyXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgLT4gXCJAQFwiXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgLT4gXCJAJVwiXG4gIHwgU2Nhbl9pbmRpYyBjIC0+IFwiQFwiIF4gKFN0cmluZy5tYWtlIDEgYylcblxuKCogQ29tcHV0ZSB0aGUgbGl0ZXJhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBmb3JtYXR0aW5nLiAqKVxuKCogQWxzbyB1c2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZvcm1hdHRpbmdfZ2VuIC0+IHN0cmluZyA9XG4gIGZ1biBmb3JtYXR0aW5nX2dlbiAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoXywgc3RyKSkgLT4gc3RyXG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoXywgc3RyKSkgLT4gc3RyXG5cbigqKiopXG5cbigqIFByaW50IGEgbGl0ZXJhbCBjaGFyIGluIGEgYnVmZmVyLCBlc2NhcGUgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHIgPSBtYXRjaCBjaHIgd2l0aFxuICB8ICclJyAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlJVwiXG4gIHwgXyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGNoclxuXG4oKiBQcmludCBhIGxpdGVyYWwgc3RyaW5nIGluIGEgYnVmZmVyLCBlc2NhcGUgYWxsICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHIgPVxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdHIgLSAxIGRvXG4gICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgc3RyLltpXVxuICBkb25lXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwcmV0dHktcHJpbnRpbmcgKilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgdHlwZSAoYW4gZm10dHkpIGluIGEgYnVmZmVyLiAqKVxubGV0IHJlYyBicHJpbnRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgICBidWZmZXIgLT4gKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiB1bml0ID1cbmZ1biBidWYgZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVjXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlaVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDMyX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVsaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJW5pXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlTGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZsb2F0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVmXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQm9vbF90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbHBoYV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlYVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFRoZXRhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV0XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQW55X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJT9cIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBSZWFkZXJfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlclwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVfclwiO1xuICAgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIle1wiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlfVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHksIF8sIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJShcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRW5kX29mX2ZtdHR5IC0+ICgpXG5cbigqKiopXG5cbmxldCByZWMgaW50X29mX2N1c3RvbV9hcml0eSA6IHR5cGUgYSBiIGMgLlxuICAoYSwgYiwgYykgY3VzdG9tX2FyaXR5IC0+IGludCA9XG4gIGZ1bmN0aW9uXG4gIHwgQ3VzdG9tX3plcm8gLT4gMFxuICB8IEN1c3RvbV9zdWNjIHggLT4gMSArIGludF9vZl9jdXN0b21fYXJpdHkgeFxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfZm10IGJ1ZiBmbXQgPVxuICBsZXQgcmVjIGZtdGl0ZXIgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYm9vbCAtPiB1bml0ID1cbiAgZnVuIGZtdCBpZ25fZmxhZyAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdzJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdTJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ2wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICduJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdMJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdDJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdhJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAndCc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICBmb3IgX2kgPSAxIHRvIGludF9vZl9jdXN0b21fYXJpdHkgYXJpdHkgZG9cbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICc/JztcbiAgICAgIGRvbmU7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBSZWFkZXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncic7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUhXCI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0cjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICd7JztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICd9JztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgd2lkdGhfb3B0OyBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0O1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfY291bnRlciBjb3VudGVyKTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgXCIwY1wiOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICAgIGZtdGl0ZXIgZm10JyB0cnVlO1xuXG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0KTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBcIkB7XCI7XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19nZW4gZm10aW5nX2dlbik7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEVuZF9vZl9mb3JtYXQgLT4gKClcblxuICBpbiBmbXRpdGVyIGZtdCBmYWxzZVxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHRvIHN0cmluZy4gKilcbmxldCBzdHJpbmdfb2ZfZm10IGZtdCA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXQgYnVmIGZtdDtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlIGV4dHJhY3Rpb24gKilcblxudHlwZSAoXywgXykgZXEgPSBSZWZsIDogKCdhLCAnYSkgZXFcblxuKCogSW52YXJpYW50OiB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBpZGVudGl0eSBvbiB2YWx1ZXMuXG5cbiAgIEluIHBhcnRpY3VsYXIsIGlmICh0eTEsIHR5MikgaGF2ZSBlcXVhbCB2YWx1ZXMsIHRoZW5cbiAgICh0cmFucyAoc3ltbSB0eTEpIHR5MikgcmVzcGVjdHMgdGhlICd0cmFucycgcHJlY29uZGl0aW9uLiAqKVxubGV0IHJlYyBzeW1tIDogdHlwZSBhMSBiMSBjMSBkMSBlMSBmMSBhMiBiMiBjMiBkMiBlMiBmMiAuXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdHR5X3JlbFxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPiBDaGFyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT4gSW50X3R5IChzeW1tIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPiBJbnQzMl90eSAoc3ltbSByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT4gSW50NjRfdHkgKHN5bW0gcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBOYXRpdmVpbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+IEZsb2F0X3R5IChzeW1tIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+IEJvb2xfdHkgKHN5bW0gcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPiBTdHJpbmdfdHkgKHN5bW0gcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+IFRoZXRhX3R5IChzeW1tIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPiBBbHBoYV90eSAoc3ltbSByZXN0KVxuICB8IEFueV90eSByZXN0IC0+IEFueV90eSAoc3ltbSByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+IFJlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT4gSWdub3JlZF9yZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgc3ltbSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIsIHR5MSwgc3ltbSByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxubGV0IHJlYyBmbXR0eV9yZWxfZGV0IDogdHlwZSBhMSBiIGMgZDEgZTEgZjEgYTIgZDIgZTIgZjIgLlxuICAoYTEsIGIsIGMsIGQxLCBlMSwgZjEsXG4gICBhMiwgYiwgYywgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKChmMSwgZjIpIGVxIC0+IChhMSwgYTIpIGVxKVxuICAqICgoYTEsIGEyKSBlcSAtPiAoZjEsIGYyKSBlcSlcbiAgKiAoKGUxLCBlMikgZXEgLT4gKGQxLCBkMikgZXEpXG4gICogKChkMSwgZDIpIGVxIC0+IChlMSwgZTIpIGVxKVxuPSBmdW5jdGlvblxuICB8IEVuZF9vZl9mbXR0eSAtPlxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKVxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG5cbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBGb3JtYXRfYXJnX3R5IChfdHksIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBsZXQgYWcsIGdhLCBkaiwgamQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBsZXQgUmVmbCA9IGFnIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZ2EgUmVmbCBpbiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBsZXQgUmVmbCA9IGRqIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gamQgUmVmbCBpbiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcblxuKCogUHJlY29uZGl0aW9uOiB3ZSBhc3N1bWUgdGhhdCB0aGUgdHdvIGZtdHR5X3JlbCBhcmd1bWVudHMgaGF2ZSBlcXVhbFxuICAgdmFsdWVzIChhdCBwb3NzaWJseSBkaXN0aW5jdCB0eXBlcyk7IHRoaXMgaW52YXJpYW50IGNvbWVzIGZyb20gdGhlIHdheVxuICAgZm10dHlfcmVsIHdpdG5lc3NlcyBhcmUgcHJvZHVjZWQgYnkgdGhlIHR5cGUtY2hlY2tlclxuXG4gICBUaGUgY29kZSBiZWxvdyB1c2VzIChhc3NlcnQgZmFsc2UpIHdoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbi4gVGhlXG4gICBjb2RlIHBhdHRlcm4gaXMgdGhlIGZvbGxvd2luZzpcblxuICAgICB8IEZvbyB4LCBGb28geSAtPlxuICAgICAgICgqIGNhc2Ugd2hlcmUgaW5kZWVkIGJvdGggdmFsdWVzXG4gICAgICAgICAgc3RhcnQgd2l0aCBjb25zdHJ1Y3RvciBGb28gKilcbiAgICAgfCBGb28gXywgX1xuICAgICB8IF8sIEZvbyBfIC0+XG4gICAgICAgKCogZGlmZmVyZW50IGhlYWQgY29uc3RydWN0b3JzOiBicm9rZW4gcHJlY29uZGl0aW9uICopXG4gICAgICAgYXNzZXJ0IGZhbHNlXG4qKVxuYW5kIHRyYW5zIDogdHlwZVxuICBhMSBiMSBjMSBkMSBlMSBmMVxuICBhMiBiMiBjMiBkMiBlMiBmMlxuICBhMyBiMyBjMyBkMyBlMyBmM1xuLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbi0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuPSBmdW4gdHkxIHR5MiAtPiBtYXRjaCB0eTEsIHR5MiB3aXRoXG4gIHwgQ2hhcl90eSByZXN0MSwgQ2hhcl90eSByZXN0MiAtPiBDaGFyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBTdHJpbmdfdHkgcmVzdDEsIFN0cmluZ190eSByZXN0MiAtPiBTdHJpbmdfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEJvb2xfdHkgcmVzdDEsIEJvb2xfdHkgcmVzdDIgLT4gQm9vbF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50X3R5IHJlc3QxLCBJbnRfdHkgcmVzdDIgLT4gSW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQzMl90eSByZXN0MSwgSW50MzJfdHkgcmVzdDIgLT4gSW50MzJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDY0X3R5IHJlc3QxLCBJbnQ2NF90eSByZXN0MiAtPiBJbnQ2NF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QxLCBOYXRpdmVpbnRfdHkgcmVzdDIgLT4gTmF0aXZlaW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBGbG9hdF90eSByZXN0MSwgRmxvYXRfdHkgcmVzdDIgLT4gRmxvYXRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuXG4gIHwgQWxwaGFfdHkgcmVzdDEsIEFscGhhX3R5IHJlc3QyIC0+IEFscGhhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbHBoYV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFscGhhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBUaGV0YV90eSByZXN0MSwgVGhldGFfdHkgcmVzdDIgLT4gVGhldGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFRoZXRhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgVGhldGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEFueV90eSByZXN0MSwgQW55X3R5IHJlc3QyIC0+IEFueV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQW55X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQW55X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBSZWFkZXJfdHkgcmVzdDEsIFJlYWRlcl90eSByZXN0MiAtPiBSZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFJlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFJlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDEsIElnbm9yZWRfcmVhZGVyX3R5IHJlc3QyIC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgSWdub3JlZF9yZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9hcmdfdHkgKHR5MSwgcmVzdDEpLCBGb3JtYXRfYXJnX3R5ICh0eTIsIHJlc3QyKSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHRyYW5zIHR5MSB0eTIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9hcmdfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfYXJnX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MTIsIHJlc3QxKSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MjEsIHR5MjIsIHJlc3QyKSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MTIpIHR5MjEgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkyMiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X3N1YnN0X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBFbmRfb2ZfZm10dHksIEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcbiAgfCBFbmRfb2ZfZm10dHksIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRW5kX29mX2ZtdHR5IC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVjIGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm9ybWF0dGluZ19nZW4gLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEV4dHJhY3QgdGhlIHR5cGUgcmVwcmVzZW50YXRpb24gKGFuIGZtdHR5KSBvZiBhIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG5cbiAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDMyX3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChOYXRpdmVpbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50NjRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoRmxvYXRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG5cbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBCb29sIChwYWQsIHJlc3QpICAgICAgICAgICAtPiBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoQm9vbF90eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgIC0+IEFscGhhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAtPiBUaGV0YV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgICAgLT4gZm10dHlfb2ZfY3VzdG9tIGFyaXR5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBSZWFkZXIgcmVzdCAgICAgICAgICAgICAgICAtPiBSZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eSwgdHksIGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPiBTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+IEludF90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgLT4gZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAgLT5cbiAgICBjb25jYXRfZm10dHkgKGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIGZtdGluZ19nZW4pIChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgIC0+IEVuZF9vZl9mbXR0eVxuXG5hbmQgZm10dHlfb2ZfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAoeSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGFyaXR5IGZtdHR5IC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBmbXR0eVxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+IEFueV90eSAoZm10dHlfb2ZfY3VzdG9tIGFyaXR5IGZtdHR5KVxuXG4oKiBFeHRyYWN0IHRoZSBmbXR0eSBvZiBhbiBpZ25vcmVkIHBhcmFtZXRlciBmb2xsb3dlZCBieSB0aGUgcmVzdCBvZlxuICAgdGhlIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IGNvbmNhdF9mbXR0eSBmbXR0eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IElnbm9yZWRfcmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcGFkZGluZyBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpzXCIpLiAqKVxuYW5kIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcGFkZGluZyBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcGFkZGluZyBfIC0+IEludF90eSBmbXR0eVxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcHJlY2lzaW9uIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpLiopXG5hbmQgZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgICB8IE5vX3ByZWNpc2lvbiAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3ByZWNpc2lvbiBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcHJlY2lzaW9uICAgLT4gSW50X3R5IGZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGluZyAqKVxuXG4oKiBFeGNlcHRpb24gcmFpc2VkIHdoZW4gYSBmb3JtYXQgZG9lcyBub3QgbWF0Y2ggYSBnaXZlbiBmb3JtYXQgdHlwZS4gKilcbmV4Y2VwdGlvbiBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBwYWRkaW5nLiAqKVxuKCogVGFrZSBhbiBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgdGhlIGludGVnZXIgc2hvdWxkIGJlIGtlcHQgYXMgYXJndW1lbnQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZGRpbmcgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkZGluZ19mbXR0eV9lYmIgPVxuZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQsIGZtdHR5IHdpdGhcbiAgfCBOb19wYWRkaW5nLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChOb19wYWRkaW5nLCBmbXR0eSlcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChMaXRfcGFkZGluZyAocGFkdHksdyksZm10dHkpXG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEludF90eSByZXN0IC0+IFBhZGRpbmdfZm10dHlfRUJCIChBcmdfcGFkZGluZyBwYWR0eSxyZXN0KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBDb252ZXJ0IGEgKHVwYWRkaW5nLCB1cHJlY2lzaW9uKSB0byBhIChwYWRkaW5nLCBwcmVjaXNpb24pLiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiBuZWVkZWQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZHByZWMgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSB6IC5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHopIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkcHJlY19mbXR0eV9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMsIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBOb19wcmVjaXNpb24sIHJlc3QpXG4gIHwgTGl0X3ByZWNpc2lvbiBwLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIExpdF9wcmVjaXNpb24gcCwgcmVzdClcbiAgfCBBcmdfcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBJbnRfdHkgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBBcmdfcHJlY2lzaW9uLCByZXN0KVxuICB8IF8sIFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogSWYgdHlwaW5nIHN1Y2NlZWQsIGdlbmVyYXRlIGEgY29weSBvZiB0aGUgZm9ybWF0IHdpdGggdGhlIHNhbWVcbiAgICB0eXBlIHBhcmFtZXRlcnMgYXMgdGhlIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgcmVjIHR5cGVfZm9ybWF0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IHdpdGhcbiAgfCBGbXRfZm10dHlfRUJCIChmbXQnLCBFbmRfb2ZfZm10dHkpIC0+IGZtdCdcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0X2dlbiA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIGZtdCwgZm10dHkgd2l0aFxuICB8IENoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBDYW1sX2NoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDYW1sX2NoYXIgZm10JywgZm10dHknKVxuICB8IFN0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChTdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBDYW1sX3N0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChDYW1sX3N0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDMyX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQ2NF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEZsb2F0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBCb29sIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBCb29sX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChCb29sIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmx1c2ggZm10X3Jlc3QsIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRmx1c2ggZm10JywgZm10dHknKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZ19saXRlcmFsIChzdHIsIGZtdCcpLCBmbXR0eScpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyX2xpdGVyYWwgKGNociwgZm10JyksIGZtdHR5JylcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1Yl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eScsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eTEsIF9zdWJfZm10dHkyLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5MSkgdGhlblxuICAgICAgcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9XG4gICAgICB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgKGVyYXNlX3JlbCBmbXR0eV9yZXN0KVxuICAgIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkxLCBmbXQnKSwgZm10dHknKVxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgQWxwaGEgZm10X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQWxwaGEgZm10JywgZm10dHknKVxuICB8IFRoZXRhIGZtdF9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFRoZXRhIGZtdCcsIGZtdHR5JylcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZ19nZW4sIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfZm9ybWF0dGluZ19nZW4gZm9ybWF0dGluZ19nZW4gZm10X3Jlc3QgZm10dHlfcmVzdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgZm10X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFJlYWRlciBmbXQnLCBmbXR0eScpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10X3Jlc3QpLCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQnKSwgZm10dHknKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10JyksIGZtdHR5JylcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtIGlnbiByZXN0IGZtdHR5X3Jlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QgLT4gRm10X2ZtdHR5X0VCQiAoRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdClcblxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYTEgYTMgYjEgYjMgYzEgYzMgZDEgZDMgZTEgZTIgZTMgZjEgZjIgZjMgLlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChmMSwgYjEsIGMxLCBlMSwgZTIsIGYyKSBmbXQgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHkgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10X2ZtdHR5X2ViYiA9XG5mdW4gZm9ybWF0dGluZ19nZW4gZm10MCBmbXR0eTAgLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG5cbigqIFR5cGUgYW4gSWdub3JlZF9wYXJhbSBub2RlIGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHAgcSB4IHkgeiB0IHUgdiBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIHksIHosIHQsIHEsIHApIGlnbm9yZWQgLT5cbiAgICAocCwgeSwgeiwgcSwgdSwgdikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGlnbiBmbXQgZm10dHkgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludCBfICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDMyIF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCBfICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDY0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zsb2F0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIChJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkpIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eScsIEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eSBmbXQgZm10dHkgaW5cbiAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10JyksXG4gICAgICAgICAgICAgICAgICAgZm10dHknKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+IChcbiAgICBtYXRjaCBmbXR0eSB3aXRoXG4gICAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSA6IHR5cGUgYTEgYTIgYjEgYjIgYzEgYzIgZDEgZDIgZTEgZTIgZjEgZjIgLlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZDIsIGEyKSBpZ25vcmVkIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdCAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eSAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBpZ24gZm10IGZtdHR5IC0+XG4gIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSBpblxuICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChpZ24sIGZtdCcpLCBmbXR0eScpXG5cbigqIFR5cGluZyBvZiB0aGUgY29tcGxleCBjYXNlOiBcIiVfKC4uLiUpXCIuICopXG5hbmQgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gOiB0eXBlIHcgeCB5IHogcCBzIHQgdSBhIGIgYyBkIGUgZiAuXG4gICAgKHcsIHgsIHksIHosIHMsIHApIGZtdHR5IC0+XG4gICAgKHAsIHgsIHksIHMsIHQsIHUpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlfZm10X2ViYiA9XG5mdW4gc3ViX2ZtdHR5IGZtdCBmbXR0eSAtPiBtYXRjaCBzdWJfZm10dHksIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQzMl90eSBzdWJfZm10dHlfcmVzdCwgSW50MzJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCwgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDY0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBGbG9hdF90eSBzdWJfZm10dHlfcmVzdCwgRmxvYXRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QsIEJvb2xfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQm9vbF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBUaGV0YV90eSBzdWJfZm10dHlfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHksIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViMl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViMl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIHN1Yl9mbXR0eV9yZXN0JyksIGZtdCcpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5LCAgc3ViMl9mbXR0eSwgIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICAoKiBUT0RPIGRlZmluZSBGbXR0eV9yZWxfRUJCIHRvIHJlbW92ZSB0aG9zZSBlcmFzZV9yZWwgKilcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBzdWJfZm10dHknID0gdHJhbnMgKHN5bW0gc3ViMV9mbXR0eScpIHN1YjJfZm10dHknIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgc3ViX2ZtdHR5JyBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIChlcmFzZV9yZWwgc3ViX2ZtdHR5X3Jlc3QpIGZtdCBmbXR0eV9yZXN0XG4gICAgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bW0gc3ViX2ZtdHR5X3Jlc3QnKSxcbiAgICAgICAgICAgICAgICAgICBmbXQnKVxuICB8IEVuZF9vZl9mbXR0eSwgZm10dHkgLT5cbiAgICBGbXR0eV9mbXRfRUJCIChFbmRfb2ZfZm10dHksIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgYHJlY2FzdGAgaXMgYSBiaXQgZGlzYXBwb2ludGluZy4gVGhlXG4gICBpbnZhcmlhbnQgcHJvdmlkZWQgYnkgdGhlIHR5cGUgYXJlIHZlcnkgc3Ryb25nOiB0aGUgaW5wdXQgZm9ybWF0J3NcbiAgIHR5cGUgaXMgaW4gcmVsYXRpb24gdG8gdGhlIG91dHB1dCB0eXBlJ3MgYXMgd2l0bmVzc2VkIGJ5IHRoZVxuICAgZm10dHlfcmVsIGFyZ3VtZW50LiBPbmUgd291bGQgYXQgZmlyc3QgZXhwZWN0IHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgIHRvdGFsLCBhbmQgaW1wbGVtZW50YWJsZSBieSBleGhhdXN0aXZlIHBhdHRlcm4gbWF0Y2hpbmcuIEluc3RlYWQsXG4gICB3ZSByZXVzZSB0aGUgaGlnaGx5IHBhcnRpYWwgYW5kIG11Y2ggbGVzcyB3ZWxsLWRlZmluZWQgZnVuY3Rpb25cbiAgIGB0eXBlX2Zvcm1hdGAgdGhhdCBoYXMgbG9zdCBhbGwga25vd2xlZGdlIG9mIHRoZSBjb3JyZXNwb25kZW5jZVxuICAgYmV0d2VlbiB0aGUgYXJndW1lbnQncyB0eXBlcy5cblxuICAgQmVzaWRlcyB0aGUgZmFjdCB0aGF0IHRoaXMgZnVuY3Rpb24gcmV1c2VzIGEgbG90IG9mIHRoZVxuICAgYHR5cGVfZm9ybWF0YCBsb2dpYyAoZWcuOiBzZWVpbmcgSW50X3R5IGluIHRoZSBmbXR0eSBwYXJhbWV0ZXIgZG9lc1xuICAgbm90IGxldCB5b3UgbWF0Y2ggb24gSW50IG9ubHksIGFzIHlvdSBtYXkgaW4gZmFjdCBoYXZlIEZsb2F0XG4gICAoQXJnX3BhZGRpbmcsIC4uLikgKFwiJS4qZFwiKSBiZWdpbm5pbmcgd2l0aCBhbiBJbnRfdHkpLCBpdCBpcyBhbHNvXG4gICBhIHBhcnRpYWwgZnVuY3Rpb24sIGJlY2F1c2UgdGhlIHR5cGluZyBpbmZvcm1hdGlvbiBpbiBhIGZvcm1hdCBpc1xuICAgbm90IHF1aXRlIGVub3VnaCB0byByZWNvbnN0cnVjdCBpdCB1bmFtYmlndW91c2x5LiBGb3IgZXhhbXBsZSwgdGhlXG4gICBmb3JtYXQgdHlwZXMgb2YgXCIlZCVfclwiIGFuZCBcIiVfciVkXCIgaGF2ZSB0aGUgc2FtZSBmb3JtYXQ2XG4gICBwYXJhbWV0ZXJzLCBidXQgdGhleSBhcmUgbm90IGF0IGFsbCBleGNoYW5nZWFibGUsIGFuZCBwdXR0aW5nIG9uZVxuICAgaW4gcGxhY2Ugb2YgdGhlIG90aGVyIG11c3QgcmVzdWx0IGluIGEgZHluYW1pYyBmYWlsdXJlLlxuXG4gICBHaXZlbiB0aGF0OlxuICAgLSB3ZSdkIGhhdmUgdG8gZHVwbGljYXRlIGEgbG90IG9mIG5vbi10cml2aWFsIHR5cGluZyBsb2dpYyBmcm9tIHR5cGVfZm9ybWF0XG4gICAtIHRoaXMgd291bGRuJ3QgZXZlbiBlbGltaW5hdGUgKGFsbCkgdGhlIGR5bmFtaWMgZmFpbHVyZXNcbiAgIHdlIGRlY2lkZWQgdG8ganVzdCByZXVzZSB0eXBlX2Zvcm1hdCBkaXJlY3RseSBmb3Igbm93LlxuKilcbmxldCByZWNhc3QgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPlxuICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFByaW50aW5nIHRvb2xzICopXG5cbigqIEFkZCBwYWRkaW5nIHNwYWNlcyBhcm91bmQgYSBzdHJpbmcuICopXG5sZXQgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggc3RyID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCwgcGFkdHkgPVxuICAgIGFicyB3aWR0aCxcbiAgICAoKiB3aGlsZSBsaXRlcmFsIHBhZGRpbmcgd2lkdGhzIGFyZSBhbHdheXMgbm9uLW5lZ2F0aXZlLFxuICAgICAgIGR5bmFtaWNhbGx5LXNldCB3aWR0aHMgKEFyZ19wYWRkaW5nLCBlZy4gJSpkKSBtYXkgYmUgbmVnYXRpdmU7XG4gICAgICAgd2UgaW50ZXJwcmV0IHRob3NlIGFzIHNwZWNpZnlpbmcgYSBwYWRkaW5nLXRvLXRoZS1sZWZ0OyB0aGlzXG4gICAgICAgbWVhbnMgdGhhdCAnMCcgbWF5IGdldCBkcm9wcGVkIGV2ZW4gaWYgaXQgd2FzIGV4cGxpY2l0bHkgc2V0LFxuICAgICAgIGJ1dDpcbiAgICAgICAtIHRoaXMgaXMgd2hhdCB0aGUgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRvZXMsIGFuZFxuICAgICAgICAgd2UgcHJlc2VydmUgY29tcGF0aWJpbGl0eSBpZiBwb3NzaWJsZVxuICAgICAgIC0gd2UgY291bGQgb25seSBzaWduYWwgdGhpcyBpc3N1ZSBieSBmYWlsaW5nIGF0IHJ1bnRpbWUsXG4gICAgICAgICB3aGljaCBpcyBub3QgdmVyeSBuaWNlLi4uICopXG4gICAgaWYgd2lkdGggPCAwIHRoZW4gTGVmdCBlbHNlIHBhZHR5IGluXG4gIGlmIHdpZHRoIDw9IGxlbiB0aGVuIHN0ciBlbHNlXG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2Ugd2lkdGggKGlmIHBhZHR5ID0gWmVyb3MgdGhlbiAnMCcgZWxzZSAnICcpIGluXG4gICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgIHwgTGVmdCAgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzIDAgbGVuXG4gICAgfCBSaWdodCAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMCAmJiAoc3RyLlswXSA9ICcrJyB8fCBzdHIuWzBdID0gJy0nIHx8IHN0ci5bMF0gPSAnICcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDAgc3RyLlswXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAod2lkdGggLSBsZW4gKyAxKSAobGVuIC0gMSlcbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMSAmJiBzdHIuWzBdID0gJzAnICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAod2lkdGggLSBsZW4gKyAyKSAobGVuIC0gMilcbiAgICB8IFplcm9zIC0+XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICBlbmQ7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQWRkICcwJyBwYWRkaW5nIHRvIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG5sZXQgZml4X2ludF9wcmVjaXNpb24gcHJlYyBzdHIgPVxuICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBtYXRjaCBzdHIuWzBdIHdpdGhcbiAgfCAoJysnIHwgJy0nIHwgJyAnKSBhcyBjIHdoZW4gcHJlYyArIDEgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDEpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMCBjO1xuICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAocHJlYyAtIGxlbiArIDIpIChsZW4gLSAxKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyB3aGVuIHByZWMgKyAyID4gbGVuICYmIGxlbiA+IDEgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDIpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAocHJlYyAtIGxlbiArIDQpIChsZW4gLSAyKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyB3aGVuIHByZWMgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSBwcmVjICcwJyBpblxuICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAocHJlYyAtIGxlbikgbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgXyAtPlxuICAgIHN0clxuXG4oKiBFc2NhcGUgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpbmcgY29udmVudGlvbi4gKilcbmxldCBzdHJpbmdfdG9fY2FtbF9zdHJpbmcgc3RyID1cbiAgbGV0IHN0ciA9IFN0cmluZy5lc2NhcGVkIHN0ciBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcXCInIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2ludC9pbnQzMi9uYXRpdmVpbnQvaW50NjQgZmlyc3QgYXJndW1lbnRcbiAgIGZyb20gYW4gaW50X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2ljb252ID0gZnVuY3Rpb25cbiAgfCBJbnRfZCAtPiBcIiVkXCIgfCBJbnRfcGQgLT4gXCIlK2RcIiB8IEludF9zZCAtPiBcIiUgZFwiXG4gIHwgSW50X2kgLT4gXCIlaVwiIHwgSW50X3BpIC0+IFwiJStpXCIgfCBJbnRfc2kgLT4gXCIlIGlcIlxuICB8IEludF94IC0+IFwiJXhcIiB8IEludF9DeCAtPiBcIiUjeFwiXG4gIHwgSW50X1ggLT4gXCIlWFwiIHwgSW50X0NYIC0+IFwiJSNYXCJcbiAgfCBJbnRfbyAtPiBcIiVvXCIgfCBJbnRfQ28gLT4gXCIlI29cIlxuICB8IEludF91IC0+IFwiJXVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252TCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgLT4gXCIlTGRcIiB8IEludF9wZCAtPiBcIiUrTGRcIiB8IEludF9zZCAtPiBcIiUgTGRcIlxuICB8IEludF9pIC0+IFwiJUxpXCIgfCBJbnRfcGkgLT4gXCIlK0xpXCIgfCBJbnRfc2kgLT4gXCIlIExpXCJcbiAgfCBJbnRfeCAtPiBcIiVMeFwiIHwgSW50X0N4IC0+IFwiJSNMeFwiXG4gIHwgSW50X1ggLT4gXCIlTFhcIiB8IEludF9DWCAtPiBcIiUjTFhcIlxuICB8IEludF9vIC0+IFwiJUxvXCIgfCBJbnRfQ28gLT4gXCIlI0xvXCJcbiAgfCBJbnRfdSAtPiBcIiVMdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZsID0gZnVuY3Rpb25cbiAgfCBJbnRfZCAtPiBcIiVsZFwiIHwgSW50X3BkIC0+IFwiJStsZFwiIHwgSW50X3NkIC0+IFwiJSBsZFwiXG4gIHwgSW50X2kgLT4gXCIlbGlcIiB8IEludF9waSAtPiBcIiUrbGlcIiB8IEludF9zaSAtPiBcIiUgbGlcIlxuICB8IEludF94IC0+IFwiJWx4XCIgfCBJbnRfQ3ggLT4gXCIlI2x4XCJcbiAgfCBJbnRfWCAtPiBcIiVsWFwiIHwgSW50X0NYIC0+IFwiJSNsWFwiXG4gIHwgSW50X28gLT4gXCIlbG9cIiB8IEludF9DbyAtPiBcIiUjbG9cIlxuICB8IEludF91IC0+IFwiJWx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udm4gPSBmdW5jdGlvblxuICB8IEludF9kIC0+IFwiJW5kXCIgfCBJbnRfcGQgLT4gXCIlK25kXCIgfCBJbnRfc2QgLT4gXCIlIG5kXCJcbiAgfCBJbnRfaSAtPiBcIiVuaVwiIHwgSW50X3BpIC0+IFwiJStuaVwiIHwgSW50X3NpIC0+IFwiJSBuaVwiXG4gIHwgSW50X3ggLT4gXCIlbnhcIiB8IEludF9DeCAtPiBcIiUjbnhcIlxuICB8IEludF9YIC0+IFwiJW5YXCIgfCBJbnRfQ1ggLT4gXCIlI25YXCJcbiAgfCBJbnRfbyAtPiBcIiVub1wiIHwgSW50X0NvIC0+IFwiJSNub1wiXG4gIHwgSW50X3UgLT4gXCIlbnVcIlxuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2Zsb2F0IGZpcnN0IGFyZ3VtZW50IGZvcm0gYSBmbG9hdF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjID1cbiAgaWYgZmNvbnYgPSBGbG9hdF9GIHRoZW4gXCIlLjEyZ1wiIGVsc2VcbiAgICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gICAgbGV0IHN5bWIgPSBjaGFyX29mX2Zjb252IGZjb252IGluXG4gICAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChzdHJpbmdfb2ZfaW50IHByZWMpO1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgc3ltYjtcbiAgICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gYSBjb252ZXJzaW9uLiAqKVxubGV0IGNvbnZlcnRfaW50IGljb252IG4gPSBmb3JtYXRfaW50IChmb3JtYXRfb2ZfaWNvbnYgaWNvbnYpIG5cbmxldCBjb252ZXJ0X2ludDMyIGljb252IG4gPSBmb3JtYXRfaW50MzIgKGZvcm1hdF9vZl9pY29udmwgaWNvbnYpIG5cbmxldCBjb252ZXJ0X25hdGl2ZWludCBpY29udiBuID0gZm9ybWF0X25hdGl2ZWludCAoZm9ybWF0X29mX2ljb252biBpY29udikgblxubGV0IGNvbnZlcnRfaW50NjQgaWNvbnYgbiA9IGZvcm1hdF9pbnQ2NCAoZm9ybWF0X29mX2ljb252TCBpY29udikgblxuXG4oKiBDb252ZXJ0IGEgZmxvYXQgdG8gc3RyaW5nLiAqKVxuKCogRml4IHNwZWNpYWwgY2FzZSBvZiBcIk9DYW1sIGZsb2F0IGZvcm1hdFwiLiAqKVxubGV0IGNvbnZlcnRfZmxvYXQgZmNvbnYgcHJlYyB4ID1cbiAgbWF0Y2ggZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoIHwgRmxvYXRfSCB8IEZsb2F0X3BIIHwgRmxvYXRfc0ggLT5cbiAgICBsZXQgc2lnbiA9XG4gICAgICBtYXRjaCBmY29udiB3aXRoXG4gICAgICB8IEZsb2F0X3BoIHwgRmxvYXRfcEggLT4gJysnXG4gICAgICB8IEZsb2F0X3NoIHwgRmxvYXRfc0ggLT4gJyAnXG4gICAgICB8IF8gLT4gJy0nIGluXG4gICAgbGV0IHN0ciA9IGhleHN0cmluZ19vZl9mbG9hdCB4IHByZWMgc2lnbiBpblxuICAgIGJlZ2luIG1hdGNoIGZjb252IHdpdGhcbiAgICB8IEZsb2F0X0ggfCBGbG9hdF9wSCB8IEZsb2F0X3NIIC0+IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgc3RyXG4gICAgfCBfIC0+IHN0clxuICAgIGVuZFxuICB8IF8gLT5cbiAgICBsZXQgc3RyID0gZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeCBpblxuICAgIGlmIGZjb252IDw+IEZsb2F0X0YgdGhlbiBzdHIgZWxzZVxuICAgICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgICBsZXQgcmVjIGlzX3ZhbGlkIGkgPVxuICAgICAgICBpZiBpID0gbGVuIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICAgIHwgJy4nIHwgJ2UnIHwgJ0UnIC0+IHRydWVcbiAgICAgICAgICB8IF8gLT4gaXNfdmFsaWQgKGkgKyAxKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHggd2l0aFxuICAgICAgfCBGUF9ub3JtYWwgfCBGUF9zdWJub3JtYWwgfCBGUF96ZXJvIC0+XG4gICAgICAgIGlmIGlzX3ZhbGlkIDAgdGhlbiBzdHIgZWxzZSBzdHIgXiBcIi5cIlxuICAgICAgfCBGUF9pbmZpbml0ZSAtPlxuICAgICAgICBpZiB4IDwgMC4wIHRoZW4gXCJuZWdfaW5maW5pdHlcIiBlbHNlIFwiaW5maW5pdHlcIlxuICAgICAgfCBGUF9uYW4gLT4gXCJuYW5cIlxuXG4oKiBDb252ZXJ0IGEgY2hhciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBmb3JtYXRfY2FtbF9jaGFyIGMgPVxuICBsZXQgc3RyID0gQ2hhci5lc2NhcGVkIGMgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXCcnIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHR5cGUgdG8gc3RyaW5nICopXG5sZXQgc3RyaW5nX29mX2ZtdHR5IGZtdHR5ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBwcmludGluZyBmdW5jdGlvbiAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBwcmludGluZyBmdW5jdGlvbi4gKilcbigqIFVzZWQgdG8gZ2VuZXJhdGUgUHJpbnRmIGFuZCBGb3JtYXQgcHJpbnRpbmcgZnVuY3Rpb25zLiAqKVxuKCogUGFyYW1ldGVyczpcbiAgICAgazogYSBjb250aW51YXRpb24gZmluYWxseSBhcHBsaWVkIHRvIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gICAgIG86IHRoZSBvdXRwdXQgc3RyZWFtIChzZWUgaywgJWEgYW5kICV0KS5cbiAgICAgYWNjOiByZXYgbGlzdCBvZiBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzaCwgZm9ybWF0dGluZywgLi4uKS5cbiAgICAgZm10OiB0aGUgZm9ybWF0LiAqKVxubGV0IHJlYyBtYWtlX3ByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIG8gYWNjIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfY2FtbF9jaGFyIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyByZXN0XG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgbyBhY2MgcmVzdCBwYWQgKGZ1biBzdHIgLT4gc3RyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgbyBhY2MgcmVzdCBwYWQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludCBpY29udlxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDMyIGljb252XG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X25hdGl2ZWludCBpY29udlxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgbyBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDY0IGljb252XG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gYWNjIHJlc3QgcGFkIHByZWMgZmNvbnZcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgbyBhY2MgcmVzdCBwYWQgc3RyaW5nX29mX2Jvb2xcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgZnVuIGYgeCAtPiBtYWtlX3ByaW50ZiBrIG8gKEFjY19kZWxheSAoYWNjLCBmdW4gbyAtPiBmIG8geCkpIHJlc3RcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgZnVuIGYgLT4gbWFrZV9wcmludGYgayBvIChBY2NfZGVsYXkgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIG1ha2VfY3VzdG9tIGsgbyBhY2MgcmVzdCBhcml0eSAoZiAoKSlcbiAgfCBSZWFkZXIgXyAtPlxuICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gKilcbiAgICAoKiBJbmRlZWQsIHNpbmNlIHByaW50ZiBhbmQgY28uIHRha2UgYSBmb3JtYXQ0IGFzIGFyZ3VtZW50LCB0aGUgJ2QgYW5kICdlXG4gICAgICAgdHlwZSBwYXJhbWV0ZXJzIG9mIGZtdCBhcmUgb2J2aW91c2x5IGVxdWFscy4gVGhlIFJlYWRlciBpcyB0aGVcbiAgICAgICBvbmx5IGNvbnN0cnVjdG9yIHdoaWNoIHRvdWNoICdkIGFuZCAnZSB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIGZvcm1hdFxuICAgICAgIHR5cGUsIGl0IGFkZHMgYW4gKC0+KSB0byB0aGUgJ2QgcGFyYW1ldGVycy4gQ29uc2VxdWVudGx5LCBhIGZvcm1hdDRcbiAgICAgICBjYW5ub3QgY29udGFpbiBhIFJlYWRlciBub2RlLCBleGNlcHQgaW4gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0b1xuICAgICAgIGFuICV7Li4uJX0uIEl0J3Mgbm90IGEgcHJvYmxlbSBiZWNhdXNlIG1ha2VfcHJpbnRmIGRvIG5vdCBjYWxsXG4gICAgICAgaXRzZWxmIHJlY3Vyc2l2ZWx5IG9uIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG8gJXsuLi4lfS4gKilcbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgbWFrZV9wcmludGYgayBvIChBY2NfZmx1c2ggYWNjKSByZXN0XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX3N0cmluZ19saXRlcmFsIChhY2MsIHN0cikpIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19jaGFyX2xpdGVyYWwgKGFjYywgY2hyKSkgcmVzdFxuXG4gIHwgRm9ybWF0X2FyZyAoXywgc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHN0cmluZ19vZl9mbXR0eSBzdWJfZm10dHkgaW5cbiAgICAoZnVuIHN0ciAtPlxuICAgICAgaWdub3JlIHN0cjtcbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHR5KSkgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPiBtYWtlX3ByaW50ZiBrIG8gYWNjXG4gICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgbGV0IG5ld19hY2MgPSBBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVbXCIpIGluXG4gICAgZnVuIF8gLT4gbWFrZV9wcmludGYgayBvIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgKCogVGhpcyBjYXNlIHNob3VsZCBiZSByZWZ1c2VkIGZvciBQcmludGYuICopXG4gICAgKCogQWNjZXB0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuICopXG4gICAgKCogSW50ZXJwcmV0ICVsLCAlbiBhbmQgJUwgYXMgJXUuICopXG4gICAgZnVuIG4gLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9pbnQgXCIldVwiIG4pIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbWFrZV9pZ25vcmVkX3BhcmFtIGsgbyBhY2MgaWduIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChhY2MsIGZtdGluZ19saXQpKSByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga29jIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayBrb2MgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl90YWcga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBvIEVuZF9vZl9hY2MgZm10J1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGtvYyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsga29jIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fYm94IGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgbyBFbmRfb2ZfYWNjIGZtdCdcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBrIG8gYWNjXG5cbigqIERlbGF5IHRoZSBlcnJvciAoSW52YWxpZF9hcmd1bWVudCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikuICopXG4oKiBHZW5lcmF0ZSBmdW5jdGlvbnMgdG8gdGFrZSByZW1haW5pbmcgYXJndW1lbnRzIChhZnRlciB0aGUgXCIlX1wiKS4gKilcbmFuZCBtYWtlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBvIGFjYyBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuXG5cbigqIFNwZWNpYWwgY2FzZSBvZiBwcmludGYgXCIlXyhcIi4gKilcbmFuZCBtYWtlX2Zyb21fZm10dHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgZm10dHkgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgbyBhY2MgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBSZWFkZXJfdHkgXyAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogSW5zZXJ0IGFuIEFjY19pbnZhbGlkX2FyZyBpbiB0aGUgYWNjdW11bGF0b3IgYW5kIGNvbnRpbnVlIHRvIGdlbmVyYXRlXG4gICBjbG9zdXJlcyB0byBnZXQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG5hbmQgbWFrZV9pbnZhbGlkX2FyZyA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIG8gYWNjIGZtdCAtPlxuICBtYWtlX3ByaW50ZiBrIG8gKEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikpIGZtdFxuXG4oKiBGaXggcGFkZGluZywgdGFrZSBpdCBhcyBhbiBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50IGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX3BhZGRpbmcgOiB0eXBlIHggeiBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHogLT4gYSkgcGFkZGluZyAtPiAoeiAtPiBzdHJpbmcpIC0+IHggPVxuICBmdW4gayBvIGFjYyBmbXQgcGFkIHRyYW5zIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCB0cmFucyB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIG5ld19hY2MgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIG5ld19hY2MgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIGZtdFxuXG4oKiBGaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGZvciBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQuICopXG4oKiBUYWtlIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IChpbnRfY29udiAtPiB6IC0+IHN0cmluZykgLT5cbiAgICBpbnRfY29udiAtPiB4ID1cbiAgZnVuIGsgbyBhY2MgZm10IHBhZCBwcmVjIHRyYW5zIGljb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSB0cmFucyBpY29udiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5cbigqIENvbnZlcnQgYSBmbG9hdCwgZml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBpZiBuZWVkZWQuICopXG4oKiBUYWtlIHRoZSBmbG9hdCBhcmd1bWVudCBhbmQgb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgZmxvYXQgLT4gYSkgcHJlY2lzaW9uIC0+IGZsb2F0X2NvbnYgLT4geCA9XG4gIGZ1biBrIG8gYWNjIGZtdCBwYWQgcHJlYyBmY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24geCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuYW5kIG1ha2VfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geCAtPiB5ID1cbiAgZnVuIGsgbyBhY2MgcmVzdCBhcml0eSBmIC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgZnVuIHggLT5cbiAgICAgIG1ha2VfY3VzdG9tIGsgbyBhY2MgcmVzdCBhcml0eSAoZiB4KVxuXG5sZXQgY29uc3QgeCBfID0geFxuXG5sZXQgcmVjIG1ha2VfaXByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYuXG4gIChiIC0+IGYpIC0+IGIgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbiAgZnVuIGsgbyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQ2FtbF9zdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgQm9vbCAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX2N1c3RvbV9hcml0eSBrIG8gcmVzdCBhcml0eVxuICAgIHwgUmVhZGVyIF8gLT5cbiAgICAgICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAgU2VlIHRoZVxuICAgICAgICAgICBub3RlIGluIHRoZSBjb3JyZXNwb25kaW5nIGNhc2UgZm9yIG1ha2VfcHJpbnRmLiAqKVxuICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPlxuICAgICAgICAgIG1ha2VfaXByaW50ZiBrIG9cbiAgICAgICAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuICAgIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaWdub3JlZF9wYXJhbSAoZnVuIHggXyAtPiBrIHgpIG8gKEVuZF9vZl9hY2MpIGlnbiByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICAgICAgayBvXG5hbmQgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gOlxuICB0eXBlIHggeSB6IGEgYiBjIGQgZSBmLlxuICAoYiAtPiBmKSAtPiBiIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IHggPVxuICBmdW4gayBvIGZtdCBwYWQgcHJlYyAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICwgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpKVxuYW5kIGZuX29mX2N1c3RvbV9hcml0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKGIgLT4gZikgLT4gYiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geSA9XG4gIGZ1biBrIG8gZm10IC0+IGZ1bmN0aW9uXG4gICAgfCBDdXN0b21femVybyAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIGZtdFxuICAgIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICAgICAgY29uc3QgKGZuX29mX2N1c3RvbV9hcml0eSBrIG8gZm10IGFyaXR5KVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb250aW51YXRpb25zIGZvciBtYWtlX3ByaW50ZiAqKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIG8gYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAe1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAW1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfY2hhciBvIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGYgb1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZmx1c2ggb1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIG8gcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgYnVmcHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IGYgYlxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gYnVmcHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIGJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mICVhIGFuZCAldC4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIChmICgpKVxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXJyb3IgbWFuYWdlbWVudCAqKVxuXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIHByZXR0eS1wcmludGVkIGVycm9yIG1lc3NhZ2UuICopXG5sZXQgZmFpbHdpdGhfbWVzc2FnZSAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDI1NiBpblxuICBsZXQgayAoKSBhY2MgPSBzdHJwdXRfYWNjIGJ1ZiBhY2M7IGZhaWx3aXRoIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrICgpIEVuZF9vZl9hY2MgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0dGluZyB0b29scyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIG9wZW4gYmxvY2sgZGVzY3JpcHRpb24gKGluZGVudCwgYmxvY2tfdHlwZSkgKilcbmxldCBvcGVuX2JveF9vZl9zdHJpbmcgc3RyID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuICgwLCBQcF9ib3gpIGVsc2VcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgaW52YWxpZF9ib3ggKCkgPSBmYWlsd2l0aF9tZXNzYWdlIFwiaW52YWxpZCBib3ggZGVzY3JpcHRpb24gJVNcIiBzdHIgaW5cbiAgICBsZXQgcmVjIHBhcnNlX3NwYWNlcyBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBpIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgLT4gcGFyc2Vfc3BhY2VzIChpICsgMSlcbiAgICAgICAgfCBfIC0+IGlcbiAgICBhbmQgcGFyc2VfbHdvcmQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJ2EnIC4uICd6JyAtPiBwYXJzZV9sd29yZCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGpcbiAgICBhbmQgcGFyc2VfaW50IGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gcGFyc2VfaW50IGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4gaiBpblxuICAgIGxldCB3c3RhcnQgPSBwYXJzZV9zcGFjZXMgMCBpblxuICAgIGxldCB3ZW5kID0gcGFyc2VfbHdvcmQgd3N0YXJ0IHdzdGFydCBpblxuICAgIGxldCBib3hfbmFtZSA9IFN0cmluZy5zdWIgc3RyIHdzdGFydCAod2VuZCAtIHdzdGFydCkgaW5cbiAgICBsZXQgbnN0YXJ0ID0gcGFyc2Vfc3BhY2VzIHdlbmQgaW5cbiAgICBsZXQgbmVuZCA9IHBhcnNlX2ludCBuc3RhcnQgbnN0YXJ0IGluXG4gICAgbGV0IGluZGVudCA9XG4gICAgICBpZiBuc3RhcnQgPSBuZW5kIHRoZW4gMCBlbHNlXG4gICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHN0ciBuc3RhcnQgKG5lbmQgLSBuc3RhcnQpKVxuICAgICAgICB3aXRoIEZhaWx1cmUgXyAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIGxldCBleHBfZW5kID0gcGFyc2Vfc3BhY2VzIG5lbmQgaW5cbiAgICBpZiBleHBfZW5kIDw+IGxlbiB0aGVuIGludmFsaWRfYm94ICgpO1xuICAgIGxldCBib3hfdHlwZSA9IG1hdGNoIGJveF9uYW1lIHdpdGhcbiAgICAgIHwgXCJcIiB8IFwiYlwiIC0+IFBwX2JveFxuICAgICAgfCBcImhcIiAgICAgIC0+IFBwX2hib3hcbiAgICAgIHwgXCJ2XCIgICAgICAtPiBQcF92Ym94XG4gICAgICB8IFwiaHZcIiAgICAgLT4gUHBfaHZib3hcbiAgICAgIHwgXCJob3ZcIiAgICAtPiBQcF9ob3Zib3hcbiAgICAgIHwgXyAgICAgICAgLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICAoaW5kZW50LCBib3hfdHlwZSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQYXJzaW5nIHRvb2xzICopXG5cbigqIENyZWF0ZSBhIHBhZGRpbmdfZm10X2ViYiBmcm9tIGEgcGFkZGluZyBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkZGluZ19mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwYWRkaW5nX2ZtdF9lYmIgPVxuZnVuIHBhZCBmbXQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChOb19wYWRkaW5nLCBmbXQpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZGRpbmdfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBmbXQpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgZm10KVxuXG4oKiBDcmVhdGUgYSBwcmVjaXNpb25fZm10X2ViYiBmcm9tIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwcmVjaXNpb24gLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHByZWNpc2lvbl9mbXRfZWJiID1cbmZ1biBwcmVjIGZtdCAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKE5vX3ByZWNpc2lvbiwgZm10KVxuICB8IExpdF9wcmVjaXNpb24gcCAtPiBQcmVjaXNpb25fZm10X0VCQiAoTGl0X3ByZWNpc2lvbiBwLCBmbXQpXG4gIHwgQXJnX3ByZWNpc2lvbiAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChBcmdfcHJlY2lzaW9uLCBmbXQpXG5cbigqIENyZWF0ZSBhIHBhZHByZWNfZm10X2ViYiBmcm9tIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyBhbmQgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudHNcbiAgIGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgOiB0eXBlIHggeSB6IHQgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT5cbiAgICAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgKF8sIF8sIF8sIF8sIF8pIHBhZHByZWNfZm10X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10IC0+XG4gIGxldCBQcmVjaXNpb25fZm10X0VCQiAocHJlYywgZm10JykgPSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIHByZWMgZm10IGluXG4gIG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoTm9fcGFkZGluZywgcHJlYywgZm10JylcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkcHJlY19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIHByZWMsIGZtdCcpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgcHJlYywgZm10JylcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHBhcnNpbmcgKilcblxuKCogUGFyc2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZm9ybWF0IGFuZCBjcmVhdGUgYSBmbXRfZWJiLiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIGluIGNhc2Ugb2YgaW52YWxpZCBmb3JtYXQuICopXG5sZXQgZm10X2ViYl9vZl9zdHJpbmcgP2xlZ2FjeV9iZWhhdmlvciBzdHIgPVxuICAoKiBQYXJhbWV0ZXJzIG5hbWluZyBjb252ZW50aW9uOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBsaXRfc3RhcnQ6IHN0YXJ0IG9mIHRoZSBsaXRlcmFsIHNlcXVlbmNlLiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN0cl9pbmQ6IGN1cnJlbnQgaW5kZXggaW4gdGhlIHN0cmluZy4gICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gZW5kX2luZDogZW5kIG9mIHRoZSBjdXJyZW50IChzdWItKWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwY3RfaW5kOiBpbmRleCBvZiB0aGUgJyUnIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgKilcbiAgKCogICAtIHplcm86ICBpcyB0aGUgJzAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gbWludXM6IGlzIHRoZSAnLScgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwbHVzOiAgaXMgdGhlICcrJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGhhc2g6ICBpcyB0aGUgJyMnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gc3BhY2U6IGlzIHRoZSAnICcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBpZ246ICAgaXMgdGhlICdfJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBhZDogcGFkZGluZyBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcHJlYzogcHJlY2lzaW9uIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzeW1iOiBjaGFyIHJlcHJlc2VudGluZyB0aGUgY29udmVyc2lvbiAoJ2MnLCAncycsICdkJywgLi4uKS4gKilcbiAgKCogICAtIGNoYXJfc2V0OiBzZXQgb2YgY2hhcmFjdGVycyBhcyBiaXRtYXAgKHNlZSBzY2FuZiAlWy4uLl0pLiAgICAqKVxuXG4gIGxldCBsZWdhY3lfYmVoYXZpb3IgPSBtYXRjaCBsZWdhY3lfYmVoYXZpb3Igd2l0aFxuICAgIHwgU29tZSBmbGFnIC0+IGZsYWdcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAoKiAgV2hlbiB0aGlzIGZsYWcgaXMgZW5hYmxlZCwgdGhlIGZvcm1hdCBwYXJzZXIgdHJpZXMgdG8gYmVoYXZlIGFzXG4gICAgICB0aGUgPDQuMDIgaW1wbGVtZW50YXRpb25zLCBpbiBwYXJ0aWN1bGFyIGl0IGlnbm9yZXMgbW9zdCBiZW5pbmVcbiAgICAgIG5vbnNlbnNpY2FsIGZvcm1hdC4gV2hlbiB0aGUgZmxhZyBpcyBkaXNhYmxlZCwgaXQgd2lsbCByZWplY3QgYW55XG4gICAgICBmb3JtYXQgdGhhdCBpcyBub3QgYWNjZXB0ZWQgYnkgdGhlIHNwZWNpZmljYXRpb24uXG5cbiAgICAgIEEgdHlwaWNhbCBleGFtcGxlIHdvdWxkIGJlIFwiJSsgZFwiOiBzcGVjaWZ5aW5nIGJvdGggJysnIChpZiB0aGVcbiAgICAgIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGggYSAnKycgdG8gZ2V0IHRoZSBzYW1lIHdpZHRoIGFzXG4gICAgICBuZWdhdGl2ZSBudW1iZXJzKSBhbmQgJyAnIChpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aFxuICAgICAgYSBzcGFjZSkgZG9lcyBub3QgbWFrZSBzZW5zZSwgYnV0IHRoZSBsZWdhY3kgKDwgNC4wMilcbiAgICAgIGltcGxlbWVudGF0aW9uIHdhcyBoYXBweSB0byBqdXN0IGlnbm9yZSB0aGUgc3BhY2UuXG4gICopXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kIG1zZyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgbXNnXG4gIGluXG5cbiAgKCogVXNlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIGZvcm1hdCAob3IgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdCkgd2FzIGVuY291bnRlcmVkXG4gICAgICB1bmV4cGVjdGVkbHkuICopXG4gIGxldCB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBlbmRfaW5kXG4gICAgICBcInVuZXhwZWN0ZWQgZW5kIG9mIGZvcm1hdFwiXG4gIGluXG5cbiAgKCogVXNlZCBmb3IgJTBjOiBubyBvdGhlciB3aWR0aHMgYXJlIGltcGxlbWVudGVkICopXG4gIGxldCBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmRcbiAgICAgIFwibm9uLXplcm8gd2lkdGhzIGFyZSB1bnN1cHBvcnRlZCBmb3IgJWMgY29udmVyc2lvbnNcIlxuICBpblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gb3B0aW9uIGRlcGVuZGVuY3lcbiAgICAgcHJvYmxlbS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X3dpdGhvdXQgc3RyX2luZCBjIHMgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICclYycgd2l0aG91dCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBjIHNcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gdW5leHBlY3RlZFxuICAgICBjaGFyYWN0ZXIuICopXG4gIGxldCBleHBlY3RlZF9jaGFyYWN0ZXIgc3RyX2luZCBleHBlY3RlZCByZWFkID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzIGV4cGVjdGVkLCByZWFkICVDXCJcbiAgICAgIHN0ciBzdHJfaW5kIGV4cGVjdGVkIHJlYWRcbiAgaW5cblxuICAoKiBQYXJzZSB0aGUgc3RyaW5nIGZyb20gYmVnX2luZCAoaW5jbHVkZWQpIHRvIGVuZF9pbmQgKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBwYXJzZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBiZWdfaW5kIGVuZF9pbmQgLT4gcGFyc2VfbGl0ZXJhbCBiZWdfaW5kIGJlZ19pbmQgZW5kX2luZFxuXG4gICgqIFJlYWQgbGl0ZXJhbCBjaGFyYWN0ZXJzIHVwIHRvICclJyBvciAnQCcgc3BlY2lhbCBjaGFyYWN0ZXJzLiAqKVxuICBhbmQgcGFyc2VfbGl0ZXJhbCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgRW5kX29mX2Zvcm1hdCBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfZm9ybWF0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9hZnRlcl9hdCAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9saXRlcmFsIGxpdF9zdGFydCAoc3RyX2luZCArIDEpIGVuZF9pbmRcblxuICAoKiBQYXJzZSBhIGZvcm1hdCBhZnRlciAnJScgKilcbiAgYW5kIHBhcnNlX2Zvcm1hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIGVuZF9pbmQgLT4gcGFyc2VfaWduIHBjdF9pbmQgKHBjdF9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgYW5kIHBhcnNlX2lnbiA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXycgLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCAoc3RyX2luZCsxKSBlbmRfaW5kIHRydWVcbiAgICAgIHwgXyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBmYWxzZVxuXG4gIGFuZCBwYXJzZV9mbGFncyA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiAoXywgXywgZSwgZikgZm10X2ViYlxuICA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBpZ24gLT5cbiAgICBsZXQgemVybyA9IHJlZiBmYWxzZSBhbmQgbWludXMgPSByZWYgZmFsc2VcbiAgICBhbmQgcGx1cyA9IHJlZiBmYWxzZSBhbmQgc3BhY2UgPSByZWYgZmFsc2VcbiAgICBhbmQgaGFzaCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBzZXRfZmxhZyBzdHJfaW5kIGZsYWcgPVxuICAgICAgKCogaW4gbGVnYWN5IG1vZGUsIGR1cGxpY2F0ZSBmbGFncyBhcmUgYWNjZXB0ZWQgKilcbiAgICAgIGlmICFmbGFnICYmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgZHVwbGljYXRlIGZsYWcgJUNcIlxuICAgICAgICAgIHN0ciBzdHJfaW5kIHN0ci5bc3RyX2luZF07XG4gICAgICBmbGFnIDo9IHRydWU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHJlYWRfZmxhZ3Mgc3RyX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICcwJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHplcm87ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJy0nIC0+IHNldF9mbGFnIHN0cl9pbmQgbWludXM7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnKycgLT4gc2V0X2ZsYWcgc3RyX2luZCBwbHVzOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcjJyAtPiBzZXRfZmxhZyBzdHJfaW5kIGhhc2g7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnICcgLT4gc2V0X2ZsYWcgc3RyX2luZCBzcGFjZTsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZFxuICAgICAgICAgICF6ZXJvICFtaW51cyAhcGx1cyAhaGFzaCAhc3BhY2UgaWduXG4gICAgICBlbmRcbiAgICBpblxuICAgIHJlYWRfZmxhZ3Mgc3RyX2luZFxuXG4gICgqIFRyeSB0byByZWFkIGEgZGlnaXRhbCBvciBhICcqJyBwYWRkaW5nLiAqKVxuICBhbmQgcGFyc2VfcGFkZGluZyA6IHR5cGUgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHplcm8gbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhZHR5ID0gbWF0Y2ggemVybywgbWludXMgd2l0aFxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gUmlnaHRcbiAgICAgIHwgZmFsc2UsIHRydWUgIC0+IExlZnRcbiAgICAgIHwgIHRydWUsIGZhbHNlIC0+IFplcm9zXG4gICAgICB8ICB0cnVlLCB0cnVlICAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMZWZ0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICctJyBcIjBcIiBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgbGV0IG5ld19pbmQsIHdpZHRoID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAoTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiAoQXJnX3BhZGRpbmcgcGFkdHkpXG4gICAgfCBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgICB8IExlZnQgIC0+XG4gICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLScgXCJwYWRkaW5nXCI7XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIHwgWmVyb3MgLT5cbiAgICAgICAgICgqIGEgJzAnIHBhZGRpbmcgaW5kaWNhdGlvbiBub3QgZm9sbG93ZWQgYnkgYW55dGhpbmcgc2hvdWxkXG4gICAgICAgICAgIGJlIGludGVycHJldGVkIGFzIGEgUmlnaHQgcGFkZGluZyBvZiB3aWR0aCAwLiBUaGlzIGlzIHVzZWRcbiAgICAgICAgICAgYnkgc2Nhbm5pbmcgY29udmVyc2lvbnMgJTBzIGFuZCAlMGMgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgKExpdF9wYWRkaW5nIChSaWdodCwgMCkpXG4gICAgICB8IFJpZ2h0IC0+XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIGVuZFxuXG4gICgqIElzIHByZWNpc2lvbiBkZWZpbmVkPyAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcGFkZGluZyA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcuJyAtPlxuICAgICAgcGFyc2VfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkXG4gICAgfCBzeW1iIC0+XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIE5vX3ByZWNpc2lvbiBwYWQgc3ltYlxuXG4gICgqIFJlYWQgdGhlIGRpZ2l0YWwgb3IgJyonIHByZWNpc2lvbi4gKilcbiAgYW5kIHBhcnNlX3ByZWNpc2lvbiA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kID1cbiAgICAgIGxldCBuZXdfaW5kLCBwcmVjID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiBwcmVjKSBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmRcbiAgICB8ICgnKycgfCAnLScpIGFzIHN5bWIgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT5cbiAgICAgICgqIExlZ2FjeSBtb2RlIHdvdWxkIGFjY2VwdCBhbmQgaWdub3JlICcrJyBvciAnLScgYmVmb3JlIHRoZVxuICAgICAgICAgaW50ZWdlciBkZXNjcmliaW5nIHRoZSBkZXNpcmVkIHByZWNpc2lvbjsgbm90ZSB0aGF0IHRoaXNcbiAgICAgICAgIGNhbm5vdCBoYXBwZW4gZm9yIHBhZGRpbmcgd2lkdGgsIGFzICcrJyBhbmQgJy0nIGFscmVhZHkgaGF2ZVxuICAgICAgICAgYSBzZW1hbnRpY3MgdGhlcmUuXG5cbiAgICAgICAgIFRoYXQgc2FpZCwgdGhlIGlkZWEgKHN1cHBvcnRlZCBieSB0aGlzIHR3ZWFrKSB0aGF0IHdpZHRoIGFuZFxuICAgICAgICAgcHJlY2lzaW9uIGxpdGVyYWxzIGFyZSBcImludGVnZXIgbGl0ZXJhbHNcIiBpbiB0aGUgT0NhbWwgc2Vuc2UgaXNcbiAgICAgICAgIHN0aWxsIGJsYXRhbnRseSB3cm9uZywgYXMgMTIzXzQ1NiBvciAweEZGIGFyZSByZWplY3RlZC4gKilcbiAgICAgIHBhcnNlX2xpdGVyYWwgKG1pbnVzIHx8IHN5bWIgPSAnLScpIChzdHJfaW5kICsgMSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gcGFkIEFyZ19wcmVjaXNpb25cbiAgICB8IF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIG5vdGUgdGhhdCBsZWdhY3kgaW1wbGVtZW50YXRpb24gZGlkIG5vdCBpZ25vcmUgJy4nIHdpdGhvdXRcbiAgICAgICAgICAgYSBudW1iZXIgKGFzIGl0IGRvZXMgZm9yIHBhZGRpbmcgaW5kaWNhdGlvbnMpLCBidXRcbiAgICAgICAgICAgaW50ZXJwcmV0cyBpdCBhcyAnLjAnICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIDApXG4gICAgICBlbHNlXG4gICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLicgXCJwcmVjaXNpb25cIlxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiB0IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfY29udiAodHlwZSB1KSAodHlwZSB2KSAocGFkcHJlYyA6ICh1LCB2KSBwYWRkaW5nKSA9XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIHByZWMgcGFkcHJlYyBzdHIuW3N0cl9pbmRdIGluXG4gICAgKCogaW4gbGVnYWN5IG1vZGUsIHNvbWUgZm9ybWF0cyAoJXMgYW5kICVTKSBhY2NlcHQgYSB3ZWlyZCBtaXggb2ZcbiAgICAgICBwYWRkaW5nIGFuZCBwcmVjaXNpb24sIHdoaWNoIGlzIG1lcmdlZCBhcyBhIHNpbmdsZSBwYWRkaW5nXG4gICAgICAgaW5mb3JtYXRpb24uIEZvciBleGFtcGxlLCBpbiAlLjEwcyB0aGUgcHJlY2lzaW9uIGlzIGltcGxpY2l0bHlcbiAgICAgICB1bmRlcnN0b29kIGFzIHBhZGRpbmcgJTEwcywgYnV0IHRoZSBsZWZ0LXBhZGRpbmcgY29tcG9uZW50IG1heVxuICAgICAgIGJlIHNwZWNpZmllZCBlaXRoZXIgYXMgYSBsZWZ0IHBhZGRpbmcgb3IgYSBuZWdhdGl2ZSBwcmVjaXNpb246XG4gICAgICAgJS0uM3MgYW5kICUuLTNzIGFyZSBlcXVpdmFsZW50IHRvICUtM3MgKilcbiAgICBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAtPiAoXG4gICAgICBtYXRjaCBtaW51cywgcHJlYyB3aXRoXG4gICAgICAgIHwgXywgTm9fcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgTm9fcGFkZGluZ1xuICAgICAgICB8IGZhbHNlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKSlcbiAgICAgICAgfCB0cnVlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKExlZnQsIG4pKVxuICAgICAgICB8IGZhbHNlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIFJpZ2h0KVxuICAgICAgICB8IHRydWUsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgTGVmdClcbiAgICApXG4gICAgfCBwYWQgLT4gcGFyc2VfY29udiBwYWRcblxuICAoKiBDYXNlIGFuYWx5c2lzIG9uIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9jb252ZXJzaW9uIDogdHlwZSB4IHkgeiB0IHUgdiBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiAoeCwgeSkgcGFkZGluZyAtPlxuICAgICAgICAoeiwgdCkgcHJlY2lzaW9uIC0+ICh1LCB2KSBwYWRkaW5nIC0+IGNoYXIgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyBwYWRwcmVjIHN5bWIgLT5cbiAgICAoKiBGbGFncyB1c2VkIHRvIGNoZWNrIG9wdGlvbiB1c2FnZXMvY29tcGF0aWJpbGl0aWVzLiAqKVxuICAgIGxldCBwbHVzX3VzZWQgID0gcmVmIGZhbHNlIGFuZCBoYXNoX3VzZWQgPSByZWYgZmFsc2VcbiAgICBhbmQgc3BhY2VfdXNlZCA9IHJlZiBmYWxzZSBhbmQgaWduX3VzZWQgICA9IHJlZiBmYWxzZVxuICAgIGFuZCBwYWRfdXNlZCAgID0gcmVmIGZhbHNlIGFuZCBwcmVjX3VzZWQgID0gcmVmIGZhbHNlIGluXG5cbiAgICAoKiBBY2Nlc3MgdG8gb3B0aW9ucywgdXBkYXRlIGZsYWdzLiAqKVxuICAgIGxldCBnZXRfcGx1cyAgICAoKSA9IHBsdXNfdXNlZCAgOj0gdHJ1ZTsgcGx1c1xuICAgIGFuZCBnZXRfaGFzaCAgICgpID0gaGFzaF91c2VkIDo9IHRydWU7IGhhc2hcbiAgICBhbmQgZ2V0X3NwYWNlICAgKCkgPSBzcGFjZV91c2VkIDo9IHRydWU7IHNwYWNlXG4gICAgYW5kIGdldF9pZ24gICAgICgpID0gaWduX3VzZWQgICA6PSB0cnVlOyBpZ25cbiAgICBhbmQgZ2V0X3BhZCAgICAgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZFxuICAgIGFuZCBnZXRfcHJlYyAgICAoKSA9IHByZWNfdXNlZCAgOj0gdHJ1ZTsgcHJlY1xuICAgIGFuZCBnZXRfcGFkcHJlYyAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkcHJlYyBpblxuXG4gICAgbGV0IGdldF9pbnRfcGFkICgpID1cbiAgICAgICgqICU1LjNkIGlzIGFjY2VwdGVkIGFuZCBtZWFuaW5nZnVsOiBwYWQgdG8gbGVuZ3RoIDUgd2l0aFxuICAgICAgICAgc3BhY2VzLCBidXQgZmlyc3QgcGFkIHdpdGggemVyb3MgdXB0byBsZW5ndGggMyAoMC1wYWRkaW5nXG4gICAgICAgICBpcyB0aGUgaW50ZXJwcmV0YXRpb24gb2YgXCJwcmVjaXNpb25cIiBmb3IgaW50ZWdlciBmb3JtYXRzKS5cblxuICAgICAgICAgJTA1LjNkIGlzIHJlZHVuZGFudDogcGFkIHRvIGxlbmd0aCA1ICp3aXRoIHplcm9zKiwgYnV0XG4gICAgICAgICBmaXJzdCBwYWQgd2l0aCB6ZXJvcy4uLiBUbyBhZGQgaW5zdWx0IHRvIHRoZSBpbmp1cnksIHRoZVxuICAgICAgICAgbGVnYWN5IGltcGxlbWVudGF0aW9uIGlnbm9yZXMgdGhlIDAtcGFkZGluZyBpbmRpY2F0aW9uIGFuZFxuICAgICAgICAgZG9lcyB0aGUgNSBwYWRkaW5nIHdpdGggc3BhY2VzIGluc3RlYWQuIFdlIHJldXNlIHRoaXNcbiAgICAgICAgIGludGVycHJldGF0aW9uIGZvciBjb21wYXRpYmlsaXR5LCBidXQgc3RhdGljYWxseSByZWplY3QgdGhpc1xuICAgICAgICAgZm9ybWF0IHdoZW4gdGhlIGxlZ2FjeSBtb2RlIGlzIGRpc2FibGVkLCB0byBwcm90ZWN0IHN0cmljdFxuICAgICAgICAgdXNlcnMgZnJvbSB0aGlzIGNvcm5lciBjYXNlLiAqKVxuICAgICAgIG1hdGNoIGdldF9wYWQgKCksIGdldF9wcmVjICgpIHdpdGhcbiAgICAgICAgIHwgcGFkLCBOb19wcmVjaXNpb24gLT4gcGFkXG4gICAgICAgICB8IE5vX3BhZGRpbmcsIF8gICAgIC0+IE5vX3BhZGRpbmdcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCBuKSwgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIG4pXG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIFplcm9zLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IExpdF9wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZFxuICAgICAgICAgfCBBcmdfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWQgaW5cblxuICAgICgqIENoZWNrIHRoYXQgcGFkdHkgPD4gWmVyb3MuICopXG4gICAgbGV0IGNoZWNrX25vXzAgc3ltYiAodHlwZSBhKSAodHlwZSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpID1cbiAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nICgoTGVmdCB8IFJpZ2h0KSwgXykgLT4gcGFkXG4gICAgICB8IEFyZ19wYWRkaW5nIChMZWZ0IHwgUmlnaHQpIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgICB8IEFyZ19wYWRkaW5nIFplcm9zIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICBpblxuXG4gICAgKCogR2V0IHBhZGRpbmcgYXMgYSBwYWRfb3B0aW9uIChzZWUgXCIlX1wiLCBcIiV7XCIsIFwiJShcIiBhbmQgXCIlW1wiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBvcHRfb2ZfcGFkIGMgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9IG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gTm9uZVxuICAgICAgfCBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKSAtPiBTb21lIHdpZHRoXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicwJ1wiXG4gICAgICB8IExpdF9wYWRkaW5nIChMZWZ0LCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJy0nXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicqJ1wiXG4gICAgaW5cbiAgICBsZXQgZ2V0X3BhZF9vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZCAoKSkgaW5cbiAgICBsZXQgZ2V0X3BhZHByZWNfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWRwcmVjICgpKSBpblxuXG4gICAgKCogR2V0IHByZWNpc2lvbiBhcyBhIHByZWNfb3B0aW9uIChzZWUgXCIlX2ZcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgZ2V0X3ByZWNfb3B0ICgpID0gbWF0Y2ggZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgfCBOb19wcmVjaXNpb24gICAgICAgLT4gTm9uZVxuICAgICAgfCBMaXRfcHJlY2lzaW9uIG5kZWMgLT4gU29tZSBuZGVjXG4gICAgICB8IEFyZ19wcmVjaXNpb24gICAgICAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJyonXCJcbiAgICBpblxuXG4gICAgbGV0IGZtdF9yZXN1bHQgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICcsJyAtPlxuICAgICAgcGFyc2Ugc3RyX2luZCBlbmRfaW5kXG4gICAgfCAnYycgLT5cbiAgICAgIGxldCBjaGFyX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICVjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChDaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBzY2FuX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICUwYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9zY2FuX25leHRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBiZWdpbiBtYXRjaCBnZXRfcGFkX29wdCAnYycgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIDAgLT4gc2Nhbl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIF9uIC0+XG4gICAgICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3JcbiAgICAgICAgICAgdGhlbiBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kXG4gICAgICAgICAgIGVsc2UgKCogbGVnYWN5IGlnbm9yZXMgJWMgd2lkdGhzICopIGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICBlbmRcbiAgICB8ICdDJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NhbWxfY2hhcixmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKENhbWxfY2hhciBmbXRfcmVzdClcbiAgICB8ICdzJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKFN0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdTJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9jYW1sX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT5cbiAgICAgIGxldCBpY29udiA9IGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdOJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gVG9rZW5fY291bnRlciBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgfCAnbicgfCAnTCcgd2hlbiBzdHJfaW5kPWVuZF9pbmQgfHwgbm90IChpc19pbnRfYmFzZSBzdHIuW3N0cl9pbmRdKSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gY291bnRlcl9vZl9jaGFyIHN5bWIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQzMiAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDMyIChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnbicgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSlcbiAgICAgICAgICAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ0wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQ2NCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDY0IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnZicgfCAnZScgfCAnRScgfCAnZycgfCAnRycgfCAnRicgfCAnaCcgfCAnSCcgLT5cbiAgICAgIGxldCBmY29udiA9IGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgKGdldF9wbHVzICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mbG9hdCAoZ2V0X3BhZF9vcHQgJ18nLCBnZXRfcHJlY19vcHQgKCkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEZsb2F0IChmY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnYicgfCAnQicgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfYm9vbCAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQm9vbCAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdhJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEFscGhhIGZtdF9yZXN0KVxuICAgIHwgJ3QnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoVGhldGEgZm10X3Jlc3QpXG4gICAgfCAncicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2UgRm10X0VCQiAoUmVhZGVyIGZtdF9yZXN0KVxuICAgIHwgJyEnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRmx1c2ggZm10X3Jlc3QpXG4gICAgfCAoJyUnIHwgJ0AnKSBhcyBjIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsIChjLCBmbXRfcmVzdCkpXG4gICAgfCAneycgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICd9JyBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfYXJnIChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfYXJnIChnZXRfcGFkX29wdCAneycsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJygnIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnKScgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICcoJywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnWycgLT5cbiAgICAgIGxldCBuZXh0X2luZCwgY2hhcl9zZXQgPSBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnXycsIGNoYXJfc2V0KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdbJywgY2hhcl9zZXQsIGZtdF9yZXN0KSlcbiAgICB8ICctJyB8ICcrJyB8ICcjJyB8ICcgJyB8ICdfJyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgZmxhZyAlQyBpcyBvbmx5IGFsbG93ZWQgYWZ0ZXIgdGhlICclJScsIGJlZm9yZSBwYWRkaW5nIGFuZCBwcmVjaXNpb25cIlxuICAgICAgICBzdHIgcGN0X2luZCBzeW1iXG4gICAgfCBfIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBpbnZhbGlkIGNvbnZlcnNpb24gXFxcIiUlJWNcXFwiXCIgc3RyIChzdHJfaW5kIC0gMSkgc3ltYlxuICAgIGluXG4gICAgKCogQ2hlY2sgZm9yIHVudXNlZCBvcHRpb25zLCBhbmQgcmVqZWN0IHRoZW0gYXMgaW5jb21wYXRpYmxlLlxuXG4gICAgICAgU3VjaCBjaGVja3MgbmVlZCB0byBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSwgYXMgdGhlIGxlZ2FjeVxuICAgICAgIHBhcnNlciBzaWxlbnRseSBpZ25vcmVkIGluY29tcGF0aWJsZSBmbGFncy4gKilcbiAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW4gYmVnaW5cbiAgICBpZiBub3QgIXBsdXNfdXNlZCAmJiBwbHVzIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCI7XG4gICAgaWYgbm90ICFoYXNoX3VzZWQgJiYgaGFzaCB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicjJ1wiO1xuICAgIGlmIG5vdCAhc3BhY2VfdXNlZCAmJiBzcGFjZSB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiO1xuICAgIGlmIG5vdCAhcGFkX3VzZWQgICYmIFBhZGRpbmdfRUJCIHBhZCA8PiBQYWRkaW5nX0VCQiBOb19wYWRkaW5nIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiYHBhZGRpbmcnXCI7XG4gICAgaWYgbm90ICFwcmVjX3VzZWQgJiYgUHJlY2lzaW9uX0VCQiBwcmVjIDw+IFByZWNpc2lvbl9FQkIgTm9fcHJlY2lzaW9uIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAoaWYgaWduIHRoZW4gJ18nIGVsc2Ugc3ltYilcbiAgICAgICAgXCJgcHJlY2lzaW9uJ1wiO1xuICAgIGlmIGlnbiAmJiBwbHVzIHRoZW4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicrJ1wiO1xuICAgIGVuZDtcbiAgICAoKiB0aGlzIGxhc3QgdGVzdCBtdXN0IG5vdCBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSxcbiAgICAgICBhcyBpZ25vcmluZyBpdCB3b3VsZCB0eXBpY2FsbHkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHR5cGluZ1xuICAgICAgIHRoYW4gd2hhdCB0aGUgbGVnYWN5IHBhcnNlciB1c2VkICopXG4gICAgaWYgbm90ICFpZ25fdXNlZCAmJiBpZ24gdGhlblxuICAgICAgYmVnaW4gbWF0Y2ggc3ltYiB3aXRoXG4gICAgICAgICgqIGFyZ3VtZW50LWxlc3MgZm9ybWF0cyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgaW4gbGVnYWN5IG1vZGUgKilcbiAgICAgICAgfCAoJ0AnIHwgJyUnIHwgJyEnIHwgJywnKSB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiAoKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIidfJ1wiXG4gICAgICBlbmQ7XG4gICAgZm10X3Jlc3VsdFxuXG4gICgqIFBhcnNlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb25zIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgYW5kIGNoZWNrX29wZW5fYm94IDogdHlwZSBhIGIgYyBkIGUgZiAuIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gdW5pdCA9XG4gIGZ1biBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIEVuZF9vZl9mb3JtYXQpIC0+IChcbiAgICAgIHRyeSBpZ25vcmUgKG9wZW5fYm94X29mX3N0cmluZyBzdHIpIHdpdGggRmFpbHVyZSBfIC0+XG4gICAgICAgICgoKiBFbWl0IHdhcm5pbmc6IGludmFsaWQgb3BlbiBib3ggKikpXG4gICAgKVxuICAgIHwgXyAtPiAoKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8bmFtZT4gYWZ0ZXIgXCJAe1wiIG9yIFwiQFtcIi4gKilcbiAgYW5kIHBhcnNlX3RhZyA6IHR5cGUgZSBmIC4gYm9vbCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGlzX29wZW5fdGFnIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIHRyeVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIGxldCBpbmQgPSBTdHJpbmcuaW5kZXhfZnJvbSBzdHIgKHN0cl9pbmQgKyAxKSAnPicgaW5cbiAgICAgICAgaWYgaW5kID49IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgc3RyX2luZCAoaW5kIC0gc3RyX2luZCArIDEpIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKGluZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgKGluZCArIDEpIGluXG4gICAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChzdWJfZm10LCBzdWJfc3RyKSBpblxuICAgICAgICBsZXQgZm9ybWF0dGluZyA9IGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIChcbiAgICAgICAgICBjaGVja19vcGVuX2JveCBzdWJfZm10O1xuICAgICAgICAgIE9wZW5fYm94IHN1Yl9mb3JtYXQpIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBmbG9hdF9jb252LiAqKVxuICBhbmQgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIHNwYWNlIHN5bWIgPVxuICBtYXRjaCBwbHVzLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsICdmJyAtPiBGbG9hdF9mICB8IGZhbHNlLCBmYWxzZSwgJ2UnIC0+IEZsb2F0X2VcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgJ2YnIC0+IEZsb2F0X3NmIHwgZmFsc2UsICB0cnVlLCAnZScgLT4gRmxvYXRfc2VcbiAgICB8ICB0cnVlLCBmYWxzZSwgJ2YnIC0+IEZsb2F0X3BmIHwgIHRydWUsIGZhbHNlLCAnZScgLT4gRmxvYXRfcGVcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ0UnIC0+IEZsb2F0X0UgIHwgZmFsc2UsIGZhbHNlLCAnZycgLT4gRmxvYXRfZ1xuICAgIHwgZmFsc2UsICB0cnVlLCAnRScgLT4gRmxvYXRfc0UgfCBmYWxzZSwgIHRydWUsICdnJyAtPiBGbG9hdF9zZ1xuICAgIHwgIHRydWUsIGZhbHNlLCAnRScgLT4gRmxvYXRfcEUgfCAgdHJ1ZSwgZmFsc2UsICdnJyAtPiBGbG9hdF9wZ1xuICAgIHwgZmFsc2UsIGZhbHNlLCAnRycgLT4gRmxvYXRfR1xuICAgIHwgZmFsc2UsICB0cnVlLCAnRycgLT4gRmxvYXRfc0dcbiAgICB8ICB0cnVlLCBmYWxzZSwgJ0cnIC0+IEZsb2F0X3BHXG4gICAgfCBmYWxzZSwgZmFsc2UsICdoJyAtPiBGbG9hdF9oXG4gICAgfCBmYWxzZSwgIHRydWUsICdoJyAtPiBGbG9hdF9zaFxuICAgIHwgIHRydWUsIGZhbHNlLCAnaCcgLT4gRmxvYXRfcGhcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ0gnIC0+IEZsb2F0X0hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgJ0gnIC0+IEZsb2F0X3NIXG4gICAgfCAgdHJ1ZSwgZmFsc2UsICdIJyAtPiBGbG9hdF9wSFxuICAgIHwgZmFsc2UsIGZhbHNlLCAnRicgLT4gRmxvYXRfRlxuICAgIHwgIHRydWUsICB0cnVlLCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJyAnIFwiJysnXCJcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8ICB0cnVlLCBmYWxzZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2Ugc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiXG4gICAgfCBmYWxzZSwgZmFsc2UsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGluY29tcGF0aWJsZSBvcHRpb25zLiopXG4gIGFuZCBpbmNvbXBhdGlibGVfZmxhZyA6IHR5cGUgYSAuIGludCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmcgLT4gYSA9XG4gICAgZnVuIHBjdF9pbmQgc3RyX2luZCBzeW1iIG9wdGlvbiAtPlxuICAgICAgbGV0IHN1YmZtdCA9IFN0cmluZy5zdWIgc3RyIHBjdF9pbmQgKHN0cl9pbmQgLSBwY3RfaW5kKSBpblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgJXMgaXMgaW5jb21wYXRpYmxlIHdpdGggJyVjJyBpbiBzdWItZm9ybWF0ICVTXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgb3B0aW9uIHN5bWIgc3ViZm10XG5cbiAgaW4gcGFyc2UgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAoKiBHdWFyZGVkIHN0cmluZyB0byBmb3JtYXQgY29udmVyc2lvbnMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHN0ciBmbXR0eSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgZm10dHksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCJcbiAgICAgIHN0ciAoc3RyaW5nX29mX2ZtdHR5IGZtdHR5KVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBhbiBvdGhlciBmb3JtYXQuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgKEZvcm1hdCAoZm10Jywgc3RyJykpID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCAoZm10dHlfb2ZfZm10IGZtdCcpLCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiIHN0ciBzdHInXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gUHJpbnRmXG5cbmxldCBwcmludGVycyA9IHJlZiBbXVxuXG5sZXQgbG9jZm10ID0gZm9ybWF0X29mX3N0cmluZyBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDogJXNcIlxuXG5sZXQgZmllbGQgeCBpID1cbiAgbGV0IGYgPSBPYmouZmllbGQgeCBpIGluXG4gIGlmIG5vdCAoT2JqLmlzX2Jsb2NrIGYpIHRoZW5cbiAgICBzcHJpbnRmIFwiJWRcIiAoT2JqLm1hZ2ljIGYgOiBpbnQpICAgICAgICAgICAoKiBjYW4gYWxzbyBiZSBhIGNoYXIgKilcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouc3RyaW5nX3RhZyB0aGVuXG4gICAgc3ByaW50ZiBcIiVTXCIgKE9iai5tYWdpYyBmIDogc3RyaW5nKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5kb3VibGVfdGFnIHRoZW5cbiAgICBzdHJpbmdfb2ZfZmxvYXQgKE9iai5tYWdpYyBmIDogZmxvYXQpXG4gIGVsc2VcbiAgICBcIl9cIlxuXG5sZXQgcmVjIG90aGVyX2ZpZWxkcyB4IGkgPVxuICBpZiBpID49IE9iai5zaXplIHggdGhlbiBcIlwiXG4gIGVsc2Ugc3ByaW50ZiBcIiwgJXMlc1wiIChmaWVsZCB4IGkpIChvdGhlcl9maWVsZHMgeCAoaSsxKSlcblxubGV0IGZpZWxkcyB4ID1cbiAgbWF0Y2ggT2JqLnNpemUgeCB3aXRoXG4gIHwgMCAtPiBcIlwiXG4gIHwgMSAtPiBcIlwiXG4gIHwgMiAtPiBzcHJpbnRmIFwiKCVzKVwiIChmaWVsZCB4IDEpXG4gIHwgXyAtPiBzcHJpbnRmIFwiKCVzJXMpXCIgKGZpZWxkIHggMSkgKG90aGVyX2ZpZWxkcyB4IDIpXG5cbmxldCB0b19zdHJpbmcgeCA9XG4gIGxldCByZWMgY29udiA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2ggdHJ5IGhkIHggd2l0aCBfIC0+IE5vbmUgd2l0aFxuICAgICAgICB8IFNvbWUgcyAtPiBzXG4gICAgICAgIHwgTm9uZSAtPiBjb252IHRsKVxuICAgIHwgW10gLT5cbiAgICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICAgIHwgT3V0X29mX21lbW9yeSAtPiBcIk91dCBvZiBtZW1vcnlcIlxuICAgICAgICB8IFN0YWNrX292ZXJmbG93IC0+IFwiU3RhY2sgb3ZlcmZsb3dcIlxuICAgICAgICB8IE1hdGNoX2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgICAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzUpIFwiUGF0dGVybiBtYXRjaGluZyBmYWlsZWRcIlxuICAgICAgICB8IEFzc2VydF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICAgICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIkFzc2VydGlvbiBmYWlsZWRcIlxuICAgICAgICB8IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICAgICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIlVuZGVmaW5lZCByZWN1cnNpdmUgbW9kdWxlXCJcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgICAgICAgICAgIGlmIE9iai50YWcgeCA8PiAwIHRoZW5cbiAgICAgICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIHggMCkgOiBzdHJpbmcpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjb25zdHJ1Y3RvciA9XG4gICAgICAgICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIChPYmouZmllbGQgeCAwKSAwKSA6IHN0cmluZykgaW5cbiAgICAgICAgICAgICAgY29uc3RydWN0b3IgXiAoZmllbGRzIHgpIGluXG4gIGNvbnYgIXByaW50ZXJzXG5cbmxldCBwcmludCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZmx1c2ggc3RkZXJyO1xuICAgIHJhaXNlIHhcblxubGV0IGNhdGNoIGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGZsdXNoIHN0ZG91dDtcbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZXhpdCAyXG5cbnR5cGUgcmF3X2JhY2t0cmFjZV9zbG90XG50eXBlIHJhd19iYWNrdHJhY2VcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2U6XG4gIHVuaXQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2VcIlxuXG5leHRlcm5hbCByYWlzZV93aXRoX2JhY2t0cmFjZTogZXhuIC0+IHJhd19iYWNrdHJhY2UgLT4gJ2FcbiAgPSBcIiVyYWlzZV93aXRoX2JhY2t0cmFjZVwiXG5cbnR5cGUgYmFja3RyYWNlX3Nsb3QgPVxuICB8IEtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlICAgIDogYm9vbDtcbiAgICAgIGZpbGVuYW1lICAgIDogc3RyaW5nO1xuICAgICAgbGluZV9udW1iZXIgOiBpbnQ7XG4gICAgICBzdGFydF9jaGFyICA6IGludDtcbiAgICAgIGVuZF9jaGFyICAgIDogaW50O1xuICAgICAgaXNfaW5saW5lICAgOiBib29sO1xuICAgIH1cbiAgfCBVbmtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlIDogYm9vbFxuICAgIH1cblxuKCogdG8gYXZvaWQgd2FybmluZyAqKVxubGV0IF8gPSBbS25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlOyBmaWxlbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfbnVtYmVyID0gMDsgc3RhcnRfY2hhciA9IDA7IGVuZF9jaGFyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfaW5saW5lID0gZmFsc2UgfTtcbiAgICAgICAgIFVua25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlIH1dXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90OlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2U6XG4gIHJhd19iYWNrdHJhY2UgLT4gYmFja3RyYWNlX3Nsb3QgYXJyYXkgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlXCJcblxubGV0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidCA9XG4gIHRyeSBTb21lIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBwb3Mgc2xvdCA9XG4gIGxldCBpbmZvIGlzX3JhaXNlID1cbiAgICBpZiBpc19yYWlzZSB0aGVuXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYXRcIiBlbHNlIFwiUmUtcmFpc2VkIGF0XCJcbiAgICBlbHNlXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYnkgcHJpbWl0aXZlIG9wZXJhdGlvbiBhdFwiIGVsc2UgXCJDYWxsZWQgZnJvbVwiXG4gIGluXG4gIG1hdGNoIHNsb3Qgd2l0aFxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgaWYgbC5pc19yYWlzZSB0aGVuXG4gICAgICAgICgqIGNvbXBpbGVyLWluc2VydGVkIHJlLXJhaXNlLCBza2lwcGVkICopIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIHVua25vd24gbG9jYXRpb25cIiAoaW5mbyBmYWxzZSkpXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIGZpbGUgXFxcIiVzXFxcIiVzLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkXCJcbiAgICAgICAgICAgICAgKGluZm8gbC5pc19yYWlzZSkgbC5maWxlbmFtZVxuICAgICAgICAgICAgICAoaWYgbC5pc19pbmxpbmUgdGhlbiBcIiAoaW5saW5lZClcIiBlbHNlIFwiXCIpXG4gICAgICAgICAgICAgIGwubGluZV9udW1iZXIgbC5zdGFydF9jaGFyIGwuZW5kX2NoYXIpXG5cbmxldCBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgICBmcHJpbnRmIG91dGNoYW5cbiAgICAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gZnByaW50ZiBvdXRjaGFuIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmVcblxubGV0IHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiByYXdfYmFja3RyYWNlID1cbiAgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6IHByaW50cyB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgcHJpbnRfYmFja3RyYWNlIG91dGNoYW4gPVxuICBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5sZXQgYmFja3RyYWNlX3RvX3N0cmluZyBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGJwcmludGYgYiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHJhd19iYWNrdHJhY2UgPVxuICBiYWNrdHJhY2VfdG9fc3RyaW5nIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfaW5saW5lXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG5cbnR5cGUgbG9jYXRpb24gPSB7XG4gIGZpbGVuYW1lIDogc3RyaW5nO1xuICBsaW5lX251bWJlciA6IGludDtcbiAgc3RhcnRfY2hhciA6IGludDtcbiAgZW5kX2NoYXIgOiBpbnQ7XG59XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgU29tZSB7XG4gICAgICBmaWxlbmFtZSAgICA9IGwuZmlsZW5hbWU7XG4gICAgICBsaW5lX251bWJlciA9IGwubGluZV9udW1iZXI7XG4gICAgICBzdGFydF9jaGFyICA9IGwuc3RhcnRfY2hhcjtcbiAgICAgIGVuZF9jaGFyICAgID0gbC5lbmRfY2hhcjtcbiAgICB9XG5cbmxldCBiYWNrdHJhY2Vfc2xvdHMgcmF3X2JhY2t0cmFjZSA9XG4gICgqIFRoZSBkb2N1bWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gZ3VhcmFudGVlcyB0aGF0IFNvbWUgaXNcbiAgICAgcmV0dXJuZWQgb25seSBpZiBhIHBhcnQgb2YgdGhlIHRyYWNlIGlzIHVzYWJsZS4gVGhpcyBnaXZlcyB1c1xuICAgICBhIGJpdCBtb3JlIHdvcmsgdGhhbiBqdXN0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSwgYnV0IGl0IG1ha2VzIHRoZVxuICAgICBBUEkgbW9yZSB1c2VyLWZyaWVuZGx5IC0tIG90aGVyd2lzZSBtb3N0IHVzZXJzIHdvdWxkIGhhdmUgdG9cbiAgICAgcmVpbXBsZW1lbnQgdGhlIFwiUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIHNvcnJ5XCIgbG9naWNcbiAgICAgdGhlbXNlbHZlcy4gKilcbiAgbWF0Y2ggY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGJhY2t0cmFjZSAtPlxuICAgICAgbGV0IHVzYWJsZV9zbG90ID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcbiAgICAgICAgfCBLbm93bl9sb2NhdGlvbiBfIC0+IHRydWUgaW5cbiAgICAgIGxldCByZWMgZXhpc3RzX3VzYWJsZSA9IGZ1bmN0aW9uXG4gICAgICAgIHwgKC0xKSAtPiBmYWxzZVxuICAgICAgICB8IGkgLT4gdXNhYmxlX3Nsb3QgYmFja3RyYWNlLihpKSB8fCBleGlzdHNfdXNhYmxlIChpIC0gMSkgaW5cbiAgICAgIGlmIGV4aXN0c191c2FibGUgKEFycmF5Lmxlbmd0aCBiYWNrdHJhY2UgLSAxKVxuICAgICAgdGhlbiBTb21lIGJhY2t0cmFjZVxuICAgICAgZWxzZSBOb25lXG5cbm1vZHVsZSBTbG90ID0gc3RydWN0XG4gIHR5cGUgdCA9IGJhY2t0cmFjZV9zbG90XG4gIGxldCBmb3JtYXQgPSBmb3JtYXRfYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGlzX3JhaXNlID0gYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2VcbiAgbGV0IGlzX2lubGluZSA9IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZVxuICBsZXQgbG9jYXRpb24gPSBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvblxuZW5kXG5cbmV4dGVybmFsIHJhd19iYWNrdHJhY2VfbGVuZ3RoIDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgLT4gcmF3X2JhY2t0cmFjZV9zbG90ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiByYXdfYmFja3RyYWNlX3Nsb3Qgb3B0aW9uXG4gID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XCJcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6XG4gICByZXR1cm5zIHRoZSAqc3RyaW5nKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBnZXRfYmFja3RyYWNlICgpID0gcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5leHRlcm5hbCByZWNvcmRfYmFja3RyYWNlOiBib29sIC0+IHVuaXQgPSBcImNhbWxfcmVjb3JkX2JhY2t0cmFjZVwiXG5leHRlcm5hbCBiYWNrdHJhY2Vfc3RhdHVzOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfYmFja3RyYWNlX3N0YXR1c1wiXG5cbmxldCByZWdpc3Rlcl9wcmludGVyIGZuID1cbiAgcHJpbnRlcnMgOj0gZm4gOjogIXByaW50ZXJzXG5cbmV4dGVybmFsIGdldF9jYWxsc3RhY2s6IGludCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFja1wiXG5cbmxldCBleG5fc2xvdCB4ID1cbiAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gIGlmIE9iai50YWcgeCA9IDAgdGhlbiBPYmouZmllbGQgeCAwIGVsc2UgeFxuXG5sZXQgZXhuX3Nsb3RfaWQgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMSkgOiBpbnQpXG5cbmxldCBleG5fc2xvdF9uYW1lIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDApIDogc3RyaW5nKVxuXG5cbmxldCB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA9IHJlZiBOb25lXG5cbmxldCBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZm4gPSB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA6PSBTb21lIGZuXG5cbmxldCBlbXB0eV9iYWNrdHJhY2UgOiByYXdfYmFja3RyYWNlID0gT2JqLm9iaiAoT2JqLm5ld19ibG9jayBPYmouYWJzdHJhY3RfdGFnIDApXG5cbmxldCB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgPVxuICB0cnlcbiAgICBnZXRfcmF3X2JhY2t0cmFjZSAoKVxuICB3aXRoIF8gKCogT3V0X29mX21lbW9yeT8gKikgLT5cbiAgICBlbXB0eV9iYWNrdHJhY2VcblxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICAoKiBHZXQgdGhlIGJhY2t0cmFjZSBub3csIGluIGNhc2Ugb25lIG9mIHRoZSBbYXRfZXhpdF0gZnVuY3Rpb25cbiAgICAgICBkZXN0cm95cyBpdC4gKilcbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9XG4gICAgICBpZiBkZWJ1Z2dlcl9pbl91c2UgKCogU2FtZSB0ZXN0IGFzIGluIFtieXRlcnVuL3ByaW50ZXhjLmNdICopIHRoZW5cbiAgICAgICAgZW1wdHlfYmFja3RyYWNlXG4gICAgICBlbHNlXG4gICAgICAgIHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKVxuICAgIGluXG4gICAgKHRyeSBQZXJ2YXNpdmVzLmRvX2F0X2V4aXQgKCkgd2l0aCBfIC0+ICgpKTtcbiAgICBtYXRjaCAhdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgICAgICAgZmx1c2ggc3RkZXJyXG4gICAgfCBTb21lIGhhbmRsZXIgLT5cbiAgICAgICAgdHJ5XG4gICAgICAgICAgaGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZVxuICAgICAgICB3aXRoIGV4bicgLT5cbiAgICAgICAgICBsZXQgcmF3X2JhY2t0cmFjZScgPSB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvciBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcjogZXhjZXB0aW9uICVzXFxuXCJcbiAgICAgICAgICAgICh0b19zdHJpbmcgZXhuJyk7XG4gICAgICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZSc7XG4gICAgICAgICAgZmx1c2ggc3RkZXJyXG4gIHdpdGhcbiAgICB8IE91dF9vZl9tZW1vcnkgLT5cbiAgICAgICAgcHJlcnJfZW5kbGluZVxuICAgICAgICAgIFwiRmF0YWwgZXJyb3I6IG91dCBvZiBtZW1vcnkgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJcIlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBbY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25dIGluXG4gICBbYnl0ZXJ1bi9wcmludGV4Yy5jXSB3aGljaCBleHBlY3RzIG5vIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZVxuICB3aXRoIF8gLT5cbiAgICAoKiBUaGVyZSBpcyBub3QgbXVjaCB3ZSBjYW4gZG8gYXQgdGhpcyBwb2ludCAqKVxuICAgICgpXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIlxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgVW5peCA9IHN0cnVjdFxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIi9cIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBzLltpXSA9ICcvJ1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9IFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgIFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSA9IHN1ZmZcbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVE1QRElSXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIvdG1wXCJcbiAgbGV0IHF1b3RlID0gZ2VuZXJpY19xdW90ZSBcIidcXFxcJydcIlxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgV2luMzIgPSBzdHJ1Y3RcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCJcXFxcXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gbGV0IGMgPSBzLltpXSBpbiBjID0gJy8nIHx8IGMgPSAnXFxcXCcgfHwgYyA9ICc6J1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9XG4gICAgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICdcXFxcJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBuLlsxXSA8PiAnOicpXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi5cXFxcXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLlxcXFxcIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgKGxldCBzID0gU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgaW5cbiAgICBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmYpXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRFTVBcIiB3aXRoIE5vdF9mb3VuZCAtPiBcIi5cIlxuICBsZXQgcXVvdGUgcyA9XG4gICAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIicgZWxzZVxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnXFxcIicgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgYyAgICAtPiBCdWZmZXIuYWRkX2NoYXIgYiBjOyBsb29wIChpKzEpO1xuICAgIGFuZCBsb29wX2JzIG4gaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICAgICAgYWRkX2JzIG47XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICAgIHwgJ1xcXCInIC0+IGFkZF9icyAoMipuKzEpOyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7IGxvb3AgKGkrMSk7XG4gICAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgKG4rMSkgKGkrMSk7XG4gICAgICAgIHwgXyAgICAtPiBhZGRfYnMgbjsgbG9vcCBpXG4gICAgICBlbmRcbiAgICBhbmQgYWRkX2JzIG4gPSBmb3IgX2ogPSAxIHRvIG4gZG8gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXFwnOyBkb25lXG4gICAgaW5cbiAgICBsb29wIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IGhhc19kcml2ZSBzID1cbiAgICBsZXQgaXNfbGV0dGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBTdHJpbmcubGVuZ3RoIHMgPj0gMiAmJiBpc19sZXR0ZXIgcy5bMF0gJiYgcy5bMV0gPSAnOidcbiAgbGV0IGRyaXZlX2FuZF9wYXRoIHMgPVxuICAgIGlmIGhhc19kcml2ZSBzXG4gICAgdGhlbiAoU3RyaW5nLnN1YiBzIDAgMiwgU3RyaW5nLnN1YiBzIDIgKFN0cmluZy5sZW5ndGggcyAtIDIpKVxuICAgIGVsc2UgKFwiXCIsIHMpXG4gIGxldCBkaXJuYW1lIHMgPVxuICAgIGxldCAoZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGxldCBkaXIgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGggaW5cbiAgICBkcml2ZSBeIGRpclxuICBsZXQgYmFzZW5hbWUgcyA9XG4gICAgbGV0IChfZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgQ3lnd2luID0gc3RydWN0XG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwID0gV2luMzIuaXNfZGlyX3NlcFxuICBsZXQgaXNfcmVsYXRpdmUgPSBXaW4zMi5pc19yZWxhdGl2ZVxuICBsZXQgaXNfaW1wbGljaXQgPSBXaW4zMi5pc19pbXBsaWNpdFxuICBsZXQgY2hlY2tfc3VmZml4ID0gV2luMzIuY2hlY2tfc3VmZml4XG4gIGxldCB0ZW1wX2Rpcl9uYW1lID0gVW5peC50ZW1wX2Rpcl9uYW1lXG4gIGxldCBxdW90ZSA9IFVuaXgucXVvdGVcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubGV0IChjdXJyZW50X2Rpcl9uYW1lLCBwYXJlbnRfZGlyX25hbWUsIGRpcl9zZXAsIGlzX2Rpcl9zZXAsXG4gICAgIGlzX3JlbGF0aXZlLCBpc19pbXBsaWNpdCwgY2hlY2tfc3VmZml4LCB0ZW1wX2Rpcl9uYW1lLCBxdW90ZSwgYmFzZW5hbWUsXG4gICAgIGRpcm5hbWUpID1cbiAgbWF0Y2ggU3lzLm9zX3R5cGUgd2l0aFxuICB8IFwiV2luMzJcIiAtPlxuICAgICAgKFdpbjMyLmN1cnJlbnRfZGlyX25hbWUsIFdpbjMyLnBhcmVudF9kaXJfbmFtZSwgV2luMzIuZGlyX3NlcCxcbiAgICAgICBXaW4zMi5pc19kaXJfc2VwLFxuICAgICAgIFdpbjMyLmlzX3JlbGF0aXZlLCBXaW4zMi5pc19pbXBsaWNpdCwgV2luMzIuY2hlY2tfc3VmZml4LFxuICAgICAgIFdpbjMyLnRlbXBfZGlyX25hbWUsIFdpbjMyLnF1b3RlLCBXaW4zMi5iYXNlbmFtZSwgV2luMzIuZGlybmFtZSlcbiAgfCBcIkN5Z3dpblwiIC0+XG4gICAgICAoQ3lnd2luLmN1cnJlbnRfZGlyX25hbWUsIEN5Z3dpbi5wYXJlbnRfZGlyX25hbWUsIEN5Z3dpbi5kaXJfc2VwLFxuICAgICAgIEN5Z3dpbi5pc19kaXJfc2VwLFxuICAgICAgIEN5Z3dpbi5pc19yZWxhdGl2ZSwgQ3lnd2luLmlzX2ltcGxpY2l0LCBDeWd3aW4uY2hlY2tfc3VmZml4LFxuICAgICAgIEN5Z3dpbi50ZW1wX2Rpcl9uYW1lLCBDeWd3aW4ucXVvdGUsIEN5Z3dpbi5iYXNlbmFtZSwgQ3lnd2luLmRpcm5hbWUpXG4gIHwgXyAtPiAoKiBub3JtYWxseSBcIlVuaXhcIiAqKVxuICAgICAgKFVuaXguY3VycmVudF9kaXJfbmFtZSwgVW5peC5wYXJlbnRfZGlyX25hbWUsIFVuaXguZGlyX3NlcCxcbiAgICAgICBVbml4LmlzX2Rpcl9zZXAsXG4gICAgICAgVW5peC5pc19yZWxhdGl2ZSwgVW5peC5pc19pbXBsaWNpdCwgVW5peC5jaGVja19zdWZmaXgsXG4gICAgICAgVW5peC50ZW1wX2Rpcl9uYW1lLCBVbml4LnF1b3RlLCBVbml4LmJhc2VuYW1lLCBVbml4LmRpcm5hbWUpXG5cbmxldCBjb25jYXQgZGlybmFtZSBmaWxlbmFtZSA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBkaXJuYW1lIGluXG4gIGlmIGwgPSAwIHx8IGlzX2Rpcl9zZXAgZGlybmFtZSAobC0xKVxuICB0aGVuIGRpcm5hbWUgXiBmaWxlbmFtZVxuICBlbHNlIGRpcm5hbWUgXiBkaXJfc2VwIF4gZmlsZW5hbWVcblxubGV0IGNob3Bfc3VmZml4IG5hbWUgc3VmZiA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmIGluXG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX3N1ZmZpeFwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgblxuXG5sZXQgZXh0ZW5zaW9uX2xlbiBuYW1lID1cbiAgbGV0IHJlYyBjaGVjayBpMCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaTAgKGkgLSAxKVxuICAgIGVsc2UgU3RyaW5nLmxlbmd0aCBuYW1lIC0gaTBcbiAgaW5cbiAgbGV0IHJlYyBzZWFyY2hfZG90IGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpIChpIC0gMSlcbiAgICBlbHNlIHNlYXJjaF9kb3QgKGkgLSAxKVxuICBpblxuICBzZWFyY2hfZG90IChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5sZXQgZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpIGxcblxubGV0IGNob3BfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9leHRlbnNpb25cIlxuICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5sZXQgcmVtb3ZlX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBuYW1lIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmV4dGVybmFsIG9wZW5fZGVzYzogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuZXh0ZXJuYWwgY2xvc2VfZGVzYzogaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX2Nsb3NlXCJcblxubGV0IHBybmcgPSBsYXp5KFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcm5kID0gKFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpKSBsYW5kIDB4RkZGRkZGIGluXG4gIGNvbmNhdCB0ZW1wX2RpciAoUHJpbnRmLnNwcmludGYgXCIlcyUwNnglc1wiIHByZWZpeCBybmQgc3VmZml4KVxuXG5cbmxldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgPSByZWYgdGVtcF9kaXJfbmFtZVxuXG5sZXQgc2V0X3RlbXBfZGlyX25hbWUgcyA9IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA6PSBzXG5sZXQgZ2V0X3RlbXBfZGlyX25hbWUgKCkgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lXG5cbmxldCB0ZW1wX2ZpbGUgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgY2xvc2VfZGVzYyhvcGVuX2Rlc2MgbmFtZSBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fZXhjbF0gMG82MDApO1xuICAgICAgbmFtZVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuXG5sZXQgb3Blbl90ZW1wX2ZpbGUgPyhtb2RlID0gW09wZW5fdGV4dF0pID8ocGVybXMgPSAwbzYwMClcbiAgICAgICAgICAgICAgICAgICA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENvbXBsZXggbnVtYmVycyAqKVxuXG50eXBlIHQgPSB7IHJlOiBmbG9hdDsgaW06IGZsb2F0IH1cblxubGV0IHplcm8gPSB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG5sZXQgb25lID0geyByZSA9IDEuMDsgaW0gPSAwLjAgfVxubGV0IGkgPSB7IHJlID0gMC4wOyBpbSA9IDEuMCB9XG5cbmxldCBhZGQgeCB5ID0geyByZSA9IHgucmUgKy4geS5yZTsgaW0gPSB4LmltICsuIHkuaW0gfVxuXG5sZXQgc3ViIHggeSA9IHsgcmUgPSB4LnJlIC0uIHkucmU7IGltID0geC5pbSAtLiB5LmltIH1cblxubGV0IG5lZyB4ID0geyByZSA9IC0uIHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBjb25qIHggPSB7IHJlID0geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IG11bCB4IHkgPSB7IHJlID0geC5yZSAqLiB5LnJlIC0uIHguaW0gKi4geS5pbTtcbiAgICAgICAgICAgICAgICBpbSA9IHgucmUgKi4geS5pbSArLiB4LmltICouIHkucmUgfVxuXG5sZXQgZGl2IHggeSA9XG4gIGlmIGFic19mbG9hdCB5LnJlID49IGFic19mbG9hdCB5LmltIHRoZW5cbiAgICBsZXQgciA9IHkuaW0gLy4geS5yZSBpblxuICAgIGxldCBkID0geS5yZSArLiByICouIHkuaW0gaW5cbiAgICB7IHJlID0gKHgucmUgKy4gciAqLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAoeC5pbSAtLiByICouIHgucmUpIC8uIGQgfVxuICBlbHNlXG4gICAgbGV0IHIgPSB5LnJlIC8uIHkuaW0gaW5cbiAgICBsZXQgZCA9IHkuaW0gKy4gciAqLiB5LnJlIGluXG4gICAgeyByZSA9IChyICouIHgucmUgKy4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHIgKi4geC5pbSAtLiB4LnJlKSAvLiBkIH1cblxubGV0IGludiB4ID0gZGl2IG9uZSB4XG5cbmxldCBub3JtMiB4ID0geC5yZSAqLiB4LnJlICsuIHguaW0gKi4geC5pbVxuXG5sZXQgbm9ybSB4ID1cbiAgKCogV2F0Y2ggb3V0IGZvciBvdmVyZmxvdyBpbiBjb21wdXRpbmcgcmVeMiArIGltXjIgKilcbiAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gIGlmIHIgPSAwLjAgdGhlbiBpXG4gIGVsc2UgaWYgaSA9IDAuMCB0aGVuIHJcbiAgZWxzZSBpZiByID49IGkgdGhlblxuICAgIGxldCBxID0gaSAvLiByIGluIHIgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuICBlbHNlXG4gICAgbGV0IHEgPSByIC8uIGkgaW4gaSAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG5cbmxldCBhcmcgeCA9IGF0YW4yIHguaW0geC5yZVxuXG5sZXQgcG9sYXIgbiBhID0geyByZSA9IGNvcyBhICouIG47IGltID0gc2luIGEgKi4gbiB9XG5cbmxldCBzcXJ0IHggPVxuICBpZiB4LnJlID0gMC4wICYmIHguaW0gPSAwLjAgdGhlbiB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgICBsZXQgdyA9XG4gICAgICBpZiByID49IGkgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcSA9IGkgLy4gciBpblxuICAgICAgICBzcXJ0KHIpICouIHNxcnQoMC41ICouICgxLjAgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgcSA9IHIgLy4gaSBpblxuICAgICAgICBzcXJ0KGkpICouIHNxcnQoMC41ICouIChxICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGluXG4gICAgaWYgeC5yZSA+PSAwLjBcbiAgICB0aGVuIHsgcmUgPSB3OyAgaW0gPSAwLjUgKi4geC5pbSAvLiB3IH1cbiAgICBlbHNlIHsgcmUgPSAwLjUgKi4gaSAvLiB3OyAgaW0gPSBpZiB4LmltID49IDAuMCB0aGVuIHcgZWxzZSAtLiB3IH1cbiAgZW5kXG5cbmxldCBleHAgeCA9XG4gIGxldCBlID0gZXhwIHgucmUgaW4geyByZSA9IGUgKi4gY29zIHguaW07IGltID0gZSAqLiBzaW4geC5pbSB9XG5cbmxldCBsb2cgeCA9IHsgcmUgPSBsb2cgKG5vcm0geCk7IGltID0gYXRhbjIgeC5pbSB4LnJlIH1cblxubGV0IHBvdyB4IHkgPSBleHAgKG11bCB5IChsb2cgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBhZGRpbmcgcG9zaXRpb24uICopXG50eXBlIHBhZHR5ID1cbiAgfCBMZWZ0ICAgKCogVGV4dCBpcyBsZWZ0IGp1c3RpZmllZCAoJy0nIG9wdGlvbikuICAgICAgICAgICAgICAgKilcbiAgfCBSaWdodCAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgKG5vICctJyBvcHRpb24pLiAgICAgICAgICAgKilcbiAgfCBaZXJvcyAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgYnkgemVyb3MgKHNlZSAnMCcgb3B0aW9uKS4gKilcblxuKCoqKilcblxuKCogSW50ZWdlciBjb252ZXJzaW9uLiAqKVxudHlwZSBpbnRfY29udiA9XG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgICAgICAgICgqICAlZCB8ICUrZCB8ICUgZCAgKilcbiAgfCBJbnRfaSB8IEludF9waSB8IEludF9zaSAgICAgICAgKCogICVpIHwgJStpIHwgJSBpICAqKVxuICB8IEludF94IHwgSW50X0N4ICAgICAgICAgICAgICAgICAoKiAgJXggfCAlI3ggICAgICAgICopXG4gIHwgSW50X1ggfCBJbnRfQ1ggICAgICAgICAgICAgICAgICgqICAlWCB8ICUjWCAgICAgICAgKilcbiAgfCBJbnRfbyB8IEludF9DbyAgICAgICAgICAgICAgICAgKCogICVvIHwgJSNvICAgICAgICAqKVxuICB8IEludF91ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJXUgICAgICAgICAgICAgICopXG5cbigqIEZsb2F0IGNvbnZlcnNpb24uICopXG50eXBlIGZsb2F0X2NvbnYgPVxuICB8IEZsb2F0X2YgfCBGbG9hdF9wZiB8IEZsb2F0X3NmICAoKiAgJWYgfCAlK2YgfCAlIGYgICopXG4gIHwgRmxvYXRfZSB8IEZsb2F0X3BlIHwgRmxvYXRfc2UgICgqICAlZSB8ICUrZSB8ICUgZSAgKilcbiAgfCBGbG9hdF9FIHwgRmxvYXRfcEUgfCBGbG9hdF9zRSAgKCogICVFIHwgJStFIHwgJSBFICAqKVxuICB8IEZsb2F0X2cgfCBGbG9hdF9wZyB8IEZsb2F0X3NnICAoKiAgJWcgfCAlK2cgfCAlIGcgICopXG4gIHwgRmxvYXRfRyB8IEZsb2F0X3BHIHwgRmxvYXRfc0cgICgqICAlRyB8ICUrRyB8ICUgRyAgKilcbiAgfCBGbG9hdF9GICAgICAgICAgICAgICAgICAgICAgICAgKCogICVGICAgICAgICAgICAgICAqKVxuICB8IEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoICAoKiAgJWggfCAlK2ggfCAlIGggICopXG4gIHwgRmxvYXRfSCB8IEZsb2F0X3BIIHwgRmxvYXRfc0ggICgqICAlSCB8ICUrSCB8ICUgSCAgKilcblxuKCoqKilcblxuKCogQ2hhciBzZXRzIChzZWUgJVsuLi5dKSBhcmUgYml0bWFwcyBpbXBsZW1lbnRlZCBhcyAzMi1jaGFyIHN0cmluZ3MuICopXG50eXBlIGNoYXJfc2V0ID0gc3RyaW5nXG5cbigqKiopXG5cbigqIENvdW50ZXIgdXNlZCBpbiBTY2FuZi4gKilcbnR5cGUgY291bnRlciA9XG4gIHwgTGluZV9jb3VudGVyICAgICAoKiAgJWwgICAgICAqKVxuICB8IENoYXJfY291bnRlciAgICAgKCogICVuICAgICAgKilcbiAgfCBUb2tlbl9jb3VudGVyICAgICgqICAlTiwgJUwgICopXG5cbigqKiopXG5cbigqIFBhZGRpbmcgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycy4gKilcbnR5cGUgKCdhLCAnYikgcGFkZGluZyA9XG4gICgqIE5vIHBhZGRpbmcgKGV4OiBcIiVkXCIpICopXG4gIHwgTm9fcGFkZGluZyAgOiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIExpdGVyYWwgcGFkZGluZyAoZXg6IFwiJThkXCIpICopXG4gIHwgTGl0X3BhZGRpbmcgOiBwYWR0eSAqIGludCAtPiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIFBhZGRpbmcgYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqZFwiKSAqKVxuICB8IEFyZ19wYWRkaW5nIDogcGFkdHkgLT4gKGludCAtPiAnYSwgJ2EpIHBhZGRpbmdcblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZCxcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwYWRkaW5nIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHBhZF9vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIFByZWNpc2lvbiBvZiBmbG9hdHMgYW5kICcwJy1wYWRkaW5nIG9mIGludGVnZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwcmVjaXNpb24gPVxuICAoKiBObyBwcmVjaXNpb24gKGV4OiBcIiVmXCIpICopXG4gIHwgTm9fcHJlY2lzaW9uIDogKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIExpdGVyYWwgcHJlY2lzaW9uIChleDogXCIlLjNmXCIpICopXG4gIHwgTGl0X3ByZWNpc2lvbiA6IGludCAtPiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogUHJlY2lzaW9uIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpICopXG4gIHwgQXJnX3ByZWNpc2lvbiA6IChpbnQgLT4gJ2EsICdhKSBwcmVjaXNpb25cblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZixcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwcmVjaXNpb24gb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcHJlY19vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIHNlZSB0aGUgQ3VzdG9tIGZvcm1hdCBjb21iaW5hdG9yICopXG50eXBlICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgPVxuICB8IEN1c3RvbV96ZXJvIDogKCdhLCBzdHJpbmcsICdhKSBjdXN0b21fYXJpdHlcbiAgfCBDdXN0b21fc3VjYyA6ICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgLT5cbiAgICAoJ2EsICd4IC0+ICdiLCAneCAtPiAnYykgY3VzdG9tX2FyaXR5XG5cbigqKiopXG5cbigqICAgICAgICBSZWxhdGlvbmFsIGZvcm1hdCB0eXBlc1xuXG5JbiB0aGUgZmlyc3QgZm9ybWF0K2dhZHRzIGltcGxlbWVudGF0aW9uLCB0aGUgdHlwZSBmb3IgJSguLiUpIGluIHRoZVxuZm10IEdBRFQgd2FzIGFzIGZvbGxvd3M6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKiAoJ2QxLCAncTEsICdkMiwgJ3EyKSByZWFkZXJfbmJfdW5pZmllciAqXG4gICAgKCd4LCAnYiwgJ2MsICdkMSwgJ3ExLCAndSkgZm10dHkgKlxuICAgICgndSwgJ2IsICdjLCAncTEsICdlMSwgJ2YpIGZtdCAtPlxuICAgICAgKCgneCwgJ2IsICdjLCAnZDIsICdxMiwgJ3UpIGZvcm1hdDYgLT4gJ3gsICdiLCAnYywgJ2QxLCAnZTEsICdmKSBmbXRcblxuTm90aWNlIHRoYXQgdGhlICd1IHBhcmFtZXRlciBpbiAnZiBwb3NpdGlvbiBpbiB0aGUgZm9ybWF0IGFyZ3VtZW50XG4oKCd4LCAuLiwgJ3UpIGZvcm1hdDYgLT4gLi4pIGlzIGVxdWFsIHRvIHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2FcbnBvc2l0aW9uIGluIHRoZSBmb3JtYXQgdGFpbCAoKCd1LCAuLiwgJ2YpIGZtdCkuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbnR5cGUgb2YgdGhlIGV4cGVjdGVkIGZvcm1hdCBwYXJhbWV0ZXIgZGVwZW5kcyBvZiB3aGVyZSB0aGUgJSguLi4lKVxuYXJlIGluIHRoZSBmb3JtYXQgc3RyaW5nOlxuXG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSlcIlxuICAtIDogKHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IHVuaXRcbiAgPSA8ZnVuPlxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpJWRcIlxuICAtIDogKGludCAtPiB1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIGludCAtPiB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gaW50IC0+IHVuaXRcbiAgPSA8ZnVuPlxuXG5PbiB0aGUgY29udHJhcnksIHRoZSBsZWdhY3kgdHlwZXIgZ2l2ZXMgYSBjbGV2ZXIgdHlwZSB0aGF0IGRvZXMgbm90XG5kZXBlbmQgb24gdGhlIHBvc2l0aW9uIG9mICUoLi4lKSBpbiB0aGUgZm9ybWF0IHN0cmluZy4gRm9yIGV4YW1wbGUsXG4lKCUpIHdpbGwgaGF2ZSB0aGUgcG9seW1vcnBoaWMgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSk6IGl0IGNhblxuYmUgY29uY2F0ZW5hdGVkIHRvIGFueSBmb3JtYXQgdHlwZSwgYW5kIG9ubHkgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRcbnRoYXQgaXRzICdhIGFuZCAnZiBwYXJhbWV0ZXJzIGFyZSBlcXVhbCAobm8gZm9ybWF0IGFyZ3VtZW50cykgYW5kICdkXG5hbmQgJ2UgYXJlIGVxdWFsIChubyByZWFkZXIgYXJndW1lbnQpLlxuXG5UaGUgd2Vha2VuaW5nIG9mIHRoaXMgcGFyYW1ldGVyIHR5cGUgaW4gdGhlIEdBRFQgdmVyc2lvbiBicm9rZSB1c2VyXG5jb2RlIChpbiBmYWN0IGl0IGVzc2VudGlhbGx5IG1hZGUgJSguLi4lKSB1bnVzYWJsZSBleGNlcHQgYXQgdGhlIGxhc3RcbnBvc2l0aW9uIG9mIGEgZm9ybWF0KS4gSW4gcGFydGljdWxhciwgdGhlIGZvbGxvd2luZyB3b3VsZCBub3Qgd29ya1xuYW55bW9yZTpcblxuICBmdW4gc2VwIC0+XG4gICAgRm9ybWF0LnByaW50ZiBcImZvbyUoJSliYXIlKCUpYmF6XCIgc2VwIHNlcFxuXG5BcyB0aGUgdHlwZS1jaGVja2VyIHdvdWxkIHJlcXVpcmUgdHdvICppbmNvbXBhdGlibGUqIHR5cGVzIGZvciB0aGUgJSglKVxuaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cblxuVGhlIHNvbHV0aW9uIHRvIHJlZ2FpbiBhIGdlbmVyYWwgdHlwZSBmb3IgJSguLiUpIGlzIHRvIGdlbmVyYWxpemUgdGhpc1xudGVjaG5pcXVlLCBub3Qgb25seSBvbiB0aGUgJ2QsICdlIHBhcmFtZXRlcnMsIGJ1dCBvbiBhbGwgc2l4XG5wYXJhbWV0ZXJzIG9mIGEgZm9ybWF0OiB3ZSBpbnRyb2R1Y2UgYSBcInJlbGF0aW9uYWxcIiB0eXBlXG4gICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG53aG9zZSB2YWx1ZXMgYXJlIHByb29mcyB0aGF0ICgnYTEsIC4uLCAnZjEpIGFuZCAoJ2EyLCAuLiwgJ2YyKSBtb3JhbGx5XG5jb3JyZXNwb25kIHRvIHRoZSBzYW1lIGZvcm1hdCB0eXBlOiAnYTEgaXMgb2J0YWluZWQgZnJvbSAnZjEsJ2IxLCdjMVxuaW4gdGhlIGV4YWN0IHNhbWUgd2F5IHRoYXQgJ2EyIGlzIG9idGFpbmVkIGZyb20gJ2YyLCdiMiwnYzIsIGV0Yy5cblxuRm9yIGV4YW1wbGUsIHRoZSByZWxhdGlvbiBiZXR3ZWVuIHR3byBmb3JtYXQgdHlwZXMgYmVnaW5uaW5nIHdpdGggYSBDaGFyXG5wYXJhbWV0ZXIgaXMgYXMgZm9sbG93czpcblxufCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbkluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSB0ZXJtIHN0cnVjdHVyZSBvZiBmbXR0eV9yZWwgaXMgKGFsbW9zdFsxXSlcbmlzb21vcnBoaWMgdG8gdGhlIGZtdHR5IG9mIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbjogZXZlcnlcbmNvbnN0cnVjdG9yIGlzIHJlLXJlYWQgd2l0aCBhIGJpbmFyeSwgcmVsYXRpb25hbCB0eXBlLCBpbnN0ZWFkIG9mIHRoZVxucHJldmlvdXMgdW5hcnkgdHlwaW5nLiBmbXR0eSBjYW4gdGhlbiBiZSByZS1kZWZpbmVkIGFzIHRoZSBkaWFnb25hbCBvZlxuZm10dHlfcmVsOlxuXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5cbk9uY2Ugd2UgaGF2ZSB0aGlzIGZtdHR5X3JlbCB0eXBlIGluIHBsYWNlLCB3ZSBjYW4gZ2l2ZSB0aGUgbW9yZVxuZ2VuZXJhbCB0eXBlIHRvICUoLi4uJSk6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG5XZSBhY2NlcHQgYW55IGZvcm1hdCAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYpICh0aGlzIGlzXG5jb21wbGV0ZWx5IHVucmVsYXRlZCB0byB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBmb3JtYXQpLCBidXQgYWxzb1xucmVxdWlyZSBhIHByb29mIHRoYXQgdGhpcyBmb3JtYXQgaXMgaW4gcmVsYXRpb24gdG8gYW5vdGhlciBmb3JtYXQgdGhhdFxuaXMgY29uY2F0ZW5hYmxlIHRvIHRoZSBmb3JtYXQgdGFpbC4gV2hlbiBleGVjdXRpbmcgYSAlKC4uLiUpIGZvcm1hdFxuKGluIGNhbWxpbnRlcm5hbEZvcm1hdC5tbDptYWtlX3ByaW50ZiBvciBzY2FuZi5tbDptYWtlX3NjYW5mKSwgd2VcbnRyYW5zdHlwZSB0aGUgZm9ybWF0IGFsb25nIHRoaXMgcmVsYXRpb24gdXNpbmcgdGhlICdyZWNhc3QnIGZ1bmN0aW9uXG50byB0cmFuc3Bvc2UgYmV0d2VlbiByZWxhdGVkIGZvcm1hdCB0eXBlcy5cblxuICB2YWwgcmVjYXN0IDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEpIGZtdFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10XG5cbk5PVEUgWzFdOiB0aGUgdHlwaW5nIG9mIEZvcm1hdF9zdWJzdF90eSByZXF1aXJlcyBub3Qgb25lIGZvcm1hdCB0eXBlLCBidXRcbnR3bywgb25lIHRvIGVzdGFibGlzaCB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXQgYXJndW1lbnQgYW5kIHRoZVxuZmlyc3Qgc2l4IHBhcmFtZXRlcnMsIGFuZCB0aGUgb3RoZXIgZm9yIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdFxuYXJndW1lbnQgYW5kIHRoZSBsYXN0IHNpeCBwYXJhbWV0ZXJzLlxuXG58IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuV2hlbiB3ZSBnZW5lcmF0ZSBhIGZvcm1hdCBBU1QsIHdlIGdlbmVyYXRlIGV4YWN0bHkgdGhlIHNhbWUgd2l0bmVzc1xuZm9yIGJvdGggcmVsYXRpb25zLCBhbmQgdGhlIHdpdG5lc3MtY29udmVyc2lvbiBmdW5jdGlvbnMgaW5cbmNhbWxpbnRlcm5hbEZvcm1hdCBkbyByZWx5IG9uIHRoaXMgaW52YXJpYW50LiBGb3IgZXhhbXBsZSwgdGhlXG5mdW5jdGlvbiB0aGF0IHByb3ZlcyB0aGF0IHRoZSByZWxhdGlvbiBpcyB0cmFuc2l0aXZlXG5cbiAgdmFsIHRyYW5zIDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcblxuZG9lcyBhc3N1bWUgdGhhdCB0aGUgdHdvIGlucHV0cyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGVybSBzdHJ1Y3R1cmVcbihhbmQgaXMgb25seSBldmVyeSB1c2VkIGZvciBhcmd1bWVudCB3aXRuZXNzZXMgb2YgdGhlXG5Gb3JtYXRfc3Vic3RfdHkgY29uc3RydWN0b3IpLlxuKilcblxuKCogVHlwZSBvZiBhIGJsb2NrIHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCAgICgqIEhvcml6b250YWwgYmxvY2sgbm8gbGluZSBicmVha2luZyAqKVxuICB8IFBwX3Zib3ggICAoKiBWZXJ0aWNhbCBibG9jayBlYWNoIGJyZWFrIGxlYWRzIHRvIGEgbmV3IGxpbmUgKilcbiAgfCBQcF9odmJveCAgKCogSG9yaXpvbnRhbC12ZXJ0aWNhbCBibG9jazogc2FtZSBhcyB2Ym94LCBleGNlcHQgaWYgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICBpcyBzbWFsbCBlbm91Z2ggdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUgKilcbiAgfCBQcF9ob3Zib3ggKCogSG9yaXpvbnRhbCBvciBWZXJ0aWNhbCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2sgKilcbiAgfCBQcF9ib3ggICAgKCogSG9yaXpvbnRhbCBvciBJbmRlbnQgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrLCBvclxuICAgICAgICAgICAgICAgICB3aGVuIGl0IGxlYWRzIHRvIGEgbmV3IGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgKilcbiAgfCBQcF9maXRzICAgKCogSW50ZXJuYWwgdXNhZ2U6IHdoZW4gYSBibG9jayBmaXRzIG9uIGEgc2luZ2xlIGxpbmUgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgZm9ybWF0dGluZ19saXQgPVxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXSAgICopXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEB9ICAgKilcbiAgfCBCcmVhayBvZiBzdHJpbmcgKiBpbnQgKiBpbnQgICAgICAgICAgKCogQCwgfCBAICB8IEA7IHwgQDs8PiAqKVxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPyAgICopXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBcXG4gICopXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAuICAgKilcbiAgfCBNYWdpY19zaXplIG9mIHN0cmluZyAqIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQDxuPiAqKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAQCAgICopXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAlJSAgKilcbiAgfCBTY2FuX2luZGljIG9mIGNoYXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFggICAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW4gPVxuICB8IE9wZW5fdGFnIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAeyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG4gIHwgT3Blbl9ib3ggOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEBbICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgdHlwZSBlbGVtZW50cy4gKilcbigqIEluIHBhcnRpY3VsYXIgdXNlZCB0byByZXByZXNlbnQgJSguLi4lKSBhbmQgJXsuLi4lfSBjb250ZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuYW5kICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgPVxuICB8IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFN0cmluZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKHN0cmluZyAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIHN0cmluZyAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50MzJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50MzIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQzMiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBOYXRpdmVpbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5kICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChuYXRpdmVpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBuYXRpdmVpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50NjRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50NjQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQ2NCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBGbG9hdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWYgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChmbG9hdCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGZsb2F0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEJvb2xfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGJvb2wgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBib29sIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRm9ybWF0X2FyZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuICB8IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzLiAqKVxuICB8IEFscGhhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ3ggLT4gJ2MxKSAtPiAneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ3ggLT4gJ2MyKSAtPiAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBUaGV0YV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICdjMSkgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICdjMikgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQW55X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBVc2VkIGZvciBjdXN0b20gZm9ybWF0cyAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRW5kX29mX2ZtdHR5IDpcbiAgICAgICgnZjEsICdiMSwgJ2MxLCAnZDEsICdkMSwgJ2YxLFxuICAgICAgICdmMiwgJ2IyLCAnYzIsICdkMiwgJ2QyLCAnZjIpIGZtdHR5X3JlbFxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCBlbGVtZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ID1cbiAgfCBDaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlUyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQzMiAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IE5hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgbmF0aXZlaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQ2NCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGXSAqKVxuICAgICAgZmxvYXRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGZsb2F0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtiQl0gKilcbiAgICAgICgneCwgYm9vbCAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsdXNoIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IFN0cmluZ19saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIGFiYyAqKVxuICAgICAgc3RyaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2hhcl9saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogeCAqKVxuICAgICAgY2hhciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgRm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICpcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IEFscGhhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ3ggLT4gJ2MpIC0+ICd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFRoZXRhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV0ICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ2MpIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcjogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgZm9ybWF0dGluZ19saXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXR0aW5nX2dlbiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgICgnYTEsICdiLCAnYywgJ2QxLCAnZTEsICdmMSkgZm9ybWF0dGluZ19nZW4gKlxuICAgICAgKCdmMSwgJ2IsICdjLCAnZTEsICdlMiwgJ2YyKSBmbXQgLT4gKCdhMSwgJ2IsICdjLCAnZDEsICdlMiwgJ2YyKSBmbXRcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4IC0+ICdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVsuLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChzdHJpbmcgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtubE5MXSAqKVxuICAgICAgY291bnRlciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGludCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IElnbm9yZWRfcGFyYW0gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgaWdub3JlZCAqICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEN1c3RvbSBwcmludGluZyBmb3JtYXQgKFBSIzY0NTIsIEdQUiMxNDApXG5cbiAgICAgV2UgaW5jbHVkZSBhIHR5cGUgQ3VzdG9tIG9mIFwiY3VzdG9tIGNvbnZlcnRlcnNcIiwgd2hlcmUgYW5cbiAgICAgYXJiaXRyYXJ5IGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNvbnZlcnQgb25lIG9yIG1vcmVcbiAgICAgYXJndW1lbnRzLiBUaGVyZSBpcyBubyBzeW50YXggZm9yIGN1c3RvbSBjb252ZXJ0ZXJzLCBpdCBpcyBvbmx5XG4gICAgIGludGVuZGVkIGZvciBjdXN0b20gcHJvY2Vzc29ycyB0aGF0IHdpc2ggdG8gcmVseSBvbiB0aGVcbiAgICAgc3RkbGliLWRlZmluZWQgZm9ybWF0IEdBRFRzLlxuXG4gICAgIEZvciBpbnN0YW5jZSBhIHByZS1wcm9jZXNzb3IgY291bGQgY2hvb3NlIHRvIGludGVycHJldCBzdHJpbmdzXG4gICAgIHByZWZpeGVkIHdpdGggW1wiIVwiXSBhcyBmb3JtYXQgc3RyaW5ncyB3aGVyZSBbJXt7IC4uLiB9fV0gaXNcbiAgICAgYSBzcGVjaWFsIGZvcm0gdG8gcGFzcyBhIHRvX3N0cmluZyBmdW5jdGlvbiwgc28gdGhhdCBvbmUgY291bGRcbiAgICAgd3JpdGU6XG5cbiAgICAge1tcbiAgICAgICB0eXBlIHQgPSB7IHggOiBpbnQ7IHkgOiBpbnQgfVxuXG4gICAgICAgbGV0IHN0cmluZ19vZl90IHQgPSBQcmludGYuc3ByaW50ZiBcInsgeCA9ICVkOyB5ID0gJWQgfVwiIHQueCB0LnlcblxuICAgICAgIFByaW50Zi5wcmludGYgIVwidCA9ICV7e3N0cmluZ19vZl90fX1cIiB7IHggPSA0MjsgeSA9IDQyIH1cbiAgICAgXX1cbiAgKilcbiAgfCBDdXN0b20gOlxuICAgICAgKCdhLCAneCwgJ3kpIGN1c3RvbV9hcml0eSAqICh1bml0IC0+ICd4KSAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBlbmQgb2YgYSBmb3JtYXQgc3BlY2lmaWNhdGlvbiAqKVxuICB8IEVuZF9vZl9mb3JtYXQgOlxuICAgICAgICAoJ2YsICdiLCAnYywgJ2UsICdlLCAnZikgZm10XG5cbigqKiopXG5cbigqIFR5cGUgZm9yIGlnbm9yZWQgcGFyYW1ldGVycyAoc2VlIFwiJV9cIikuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWQgPVxuICB8IElnbm9yZWRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9zICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9TICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDMyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX25kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDY0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2YgKilcbiAgICAgIHBhZF9vcHRpb24gKiBwcmVjX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfYm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQiAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfey4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8oLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3JlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgKilcbiAgICAgICgnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1suLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1tubE5MXSAqKVxuICAgICAgY291bnRlciAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG5cbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gIEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ICogc3RyaW5nXG5cbmxldCByZWMgZXJhc2VfcmVsIDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gIChhLCBiLCBjLCBkLCBlLCBmLFxuICAgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eVxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgX3R5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkxLCBlcmFzZV9yZWwgcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwZSBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXQgdHlwZXMuICopXG4oKiBVc2VkIGJ5OlxuICAgKiByZWFkZXJfbmJfdW5pZmllcl9vZl9mbXR0eSB0byBjb3VudCByZWFkZXJzIGluIGFuIGZtdHR5LFxuICAgKiBTY2FuZi50YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIHRvIGV4dHJhY3QgcmVhZGVycyBpbnNpZGUgJSguLi4lKSxcbiAgICogQ2FtbGludGVybmFsRm9ybWF0LmZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IHRvIGV4dHJhY3QgZm9ybWF0IHR5cGUuICopXG5cbigqXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10dHkgPVxuKilcbmxldCByZWMgY29uY2F0X2ZtdHR5IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gICAgICAgZzEgajEgZzIgajJcbiAgLlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZDEsIGExLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZDIsIGEyKSBmbXR0eV9yZWwgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKGcxLCBiMSwgYzEsIGoxLCBlMSwgZjEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBlMiwgZjIpIGZtdHR5X3JlbCA9XG5mdW4gZm10dHkxIGZtdHR5MiAtPiBtYXRjaCBmbXR0eTEgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IGZtdHR5MlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdHMuICopXG5sZXQgcmVjIGNvbmNhdF9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10ID1cbmZ1biBmbXQxIGZtdDIgLT4gbWF0Y2ggZm10MSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgU3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgQ2FtbF9zdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IENoYXIgKHJlc3QpIC0+XG4gICAgQ2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBDYW1sX2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBCb29sIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBBbHBoYSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIFRoZXRhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIEN1c3RvbSAoYXJpdHksIGYsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFJlYWRlciByZXN0IC0+XG4gICAgUmVhZGVyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgRmx1c2ggKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBDaGFyX2xpdGVyYWwgICAoY2hyLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdF9hcmcgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZyAgIChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX25leHRfY2hhciAocmVzdCkgLT5cbiAgICBTY2FuX25leHRfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIElnbm9yZWRfcGFyYW0gKGlnbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGZtdDJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIFBlcnZhc2l2ZXMgPSBzdHJ1Y3RcbigqIHR5cGUgJ2Egb3B0aW9uID0gTm9uZSB8IFNvbWUgb2YgJ2EgKilcblxuKCogRXhjZXB0aW9ucyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gICgqIGZvciBhc21ydW4vZmFpbC5jICopXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5hcnJheV9ib3VuZF9lcnJvclwiXG4gICAgKEludmFsaWRfYXJndW1lbnQgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpXG5cblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5cbmxldCBmYWlsd2l0aCBzID0gcmFpc2UoRmFpbHVyZSBzKVxubGV0IGludmFsaWRfYXJnIHMgPSByYWlzZShJbnZhbGlkX2FyZ3VtZW50IHMpXG5cbmV4Y2VwdGlvbiBFeGl0XG5cbigqIENvbXBvc2l0aW9uIG9wZXJhdG9ycyAqKVxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuKCogRGVidWdnaW5nICopXG5cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5cbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5cbigqIENvbXBhcmlzb25zICopXG5cbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuXG5sZXQgbWluIHggeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICE9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXFcIlxuXG4oKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCBvciApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuXG4oKiBJbnRlZ2VyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LSApIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCAoIH4rICkgOiBpbnQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCAoIC8gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsICggbW9kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5cbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxuXG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG5sZXQgbG5vdCB4ID0geCBseG9yICgtMSlcblxuZXh0ZXJuYWwgKCBsc2wgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5leHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuXG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcblxuKCogRmxvYXRpbmctcG9pbnQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFic19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZF9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbmV4dGVybmFsIGZsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBmbG9hdF9vZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRydW5jYXRlIDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBpbnRfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5sZXQgaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmVnX2luZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweEZGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5hbiA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMUxcbmxldCBtYXhfZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRUZfRkZfRkZfRkZfRkZfRkZfRkZMXG5sZXQgbWluX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDAwXzEwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IGVwc2lsb25fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4M0NfQjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5cbnR5cGUgZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuXG4oKiBTdHJpbmcgYW5kIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZXMgU3RyaW5nIGFuZCBCeXRlcyAqKVxuXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgc3RyaW5nX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCAoIF4gKSBzMSBzMiA9XG4gIGxldCBsMSA9IHN0cmluZ19sZW5ndGggczEgYW5kIGwyID0gc3RyaW5nX2xlbmd0aCBzMiBpblxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAobDEgKyBsMikgaW5cbiAgc3RyaW5nX2JsaXQgczEgMCBzIDAgbDE7XG4gIHN0cmluZ19ibGl0IHMyIDAgcyBsMSBsMjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIENoYXIgKilcblxuZXh0ZXJuYWwgaW50X29mX2NoYXIgOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaGFyX29mX2ludCA6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50IG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJjaGFyX29mX2ludFwiIGVsc2UgdW5zYWZlX2NoYXJfb2ZfaW50IG5cblxuKCogVW5pdCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiBQYWlyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgZnN0IDogJ2EgKiAnYiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCBzbmQgOiAnYSAqICdiIC0+ICdiID0gXCIlZmllbGQxXCJcblxuKCogUmVmZXJlbmNlcyAqKVxuXG50eXBlICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcblxuKCogUmVzdWx0IHR5cGUgKilcblxudHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2JcblxuKCogU3RyaW5nIGNvbnZlcnNpb24gZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxubGV0IHN0cmluZ19vZl9ib29sIGIgPVxuICBpZiBiIHRoZW4gXCJ0cnVlXCIgZWxzZSBcImZhbHNlXCJcbmxldCBib29sX29mX3N0cmluZyA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IF8gLT4gaW52YWxpZF9hcmcgXCJib29sX29mX3N0cmluZ1wiXG5cbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG4gIHwgXyAtPiBOb25lXG5cbmxldCBzdHJpbmdfb2ZfaW50IG4gPVxuICBmb3JtYXRfaW50IFwiJWRcIiBuXG5cbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5leHRlcm5hbCBzdHJpbmdfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcblxubGV0IHZhbGlkX2Zsb2F0X2xleGVtIHMgPVxuICBsZXQgbCA9IHN0cmluZ19sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA+PSBsIHRoZW4gcyBeIFwiLlwiIGVsc2VcbiAgICBtYXRjaCBzdHJpbmdfZ2V0IHMgaSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgIHwgXyAtPiBzXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3RyaW5nX29mX2Zsb2F0IGYgPSB2YWxpZF9mbG9hdF9sZXhlbSAoZm9ybWF0X2Zsb2F0IFwiJS4xMmdcIiBmKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGZsb2F0X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbigqIExpc3Qgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBMaXN0ICopXG5cbmxldCByZWMgKCBAICkgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBoZCA6OiB0bCAtPiBoZCA6OiAodGwgQCBsMilcblxuKCogSS9PIG9wZXJhdGlvbnMgKilcblxudHlwZSBpbl9jaGFubmVsXG50eXBlIG91dF9jaGFubmVsXG5cbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9vdXQgOiBpbnQgLT4gb3V0X2NoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFwiXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3JfaW4gOiBpbnQgLT4gaW5fY2hhbm5lbCA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cIlxuXG5sZXQgc3RkaW4gPSBvcGVuX2Rlc2NyaXB0b3JfaW4gMFxubGV0IHN0ZG91dCA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMVxubGV0IHN0ZGVyciA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMlxuXG4oKiBHZW5lcmFsIG91dHB1dCBmdW5jdGlvbnMgKilcblxudHlwZSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5IHwgT3Blbl93cm9ubHkgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXQgfCBPcGVuX3RydW5jIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnkgfCBPcGVuX3RleHQgfCBPcGVuX25vbmJsb2NrXG5cbmV4dGVybmFsIG9wZW5fZGVzYyA6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcblxuZXh0ZXJuYWwgc2V0X291dF9jaGFubmVsX25hbWU6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9vdXRfZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0KG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X291dF9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX291dCBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl90ZXh0XSAwbzY2NiBuYW1lXG5cbmxldCBvcGVuX291dF9iaW4gbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fYmluYXJ5XSAwbzY2NiBuYW1lXG5cbmV4dGVybmFsIGZsdXNoIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9mbHVzaFwiXG5cbmV4dGVybmFsIG91dF9jaGFubmVsc19saXN0IDogdW5pdCAtPiBvdXRfY2hhbm5lbCBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFwiXG5cbmxldCBmbHVzaF9hbGwgKCkgPVxuICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgW10gLT4gKClcbiAgICB8IGE6OmwgLT5cbiAgICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgICBmbHVzaCBhXG4gICAgICAgIHdpdGggU3lzX2Vycm9yIF8gLT5cbiAgICAgICAgICAoKSAoKiBpZ25vcmUgY2hhbm5lbHMgY2xvc2VkIGR1cmluZyBhIHByZWNlZGluZyBmbHVzaC4gKilcbiAgICAgICAgZW5kO1xuICAgICAgICBpdGVyIGxcbiAgaW4gaXRlciAob3V0X2NoYW5uZWxzX2xpc3QgKCkpXG5cbmV4dGVybmFsIHVuc2FmZV9vdXRwdXQgOiBvdXRfY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0X2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9vdXRwdXRfc3RyaW5nIDogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0XCJcblxuZXh0ZXJuYWwgb3V0cHV0X2NoYXIgOiBvdXRfY2hhbm5lbCAtPiBjaGFyIC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuXG5sZXQgb3V0cHV0X2J5dGVzIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0IG9jIHMgMCAoYnl0ZXNfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXRfc3RyaW5nIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIDAgKHN0cmluZ19sZW5ndGggcylcblxubGV0IG91dHB1dCBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dFwiXG4gIGVsc2UgdW5zYWZlX291dHB1dCBvYyBzIG9mcyBsZW5cblxubGV0IG91dHB1dF9zdWJzdHJpbmcgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IHN0cmluZ19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0X3N1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyBvZnMgbGVuXG5cbmV4dGVybmFsIG91dHB1dF9ieXRlIDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuZXh0ZXJuYWwgb3V0cHV0X2JpbmFyeV9pbnQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfaW50XCJcblxuZXh0ZXJuYWwgbWFyc2hhbF90b19jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gdW5pdCBsaXN0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmxldCBvdXRwdXRfdmFsdWUgY2hhbiB2ID0gbWFyc2hhbF90b19jaGFubmVsIGNoYW4gdiBbXVxuXG5leHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XCJcbmV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX291dFwiXG5leHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX291dF9jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9vdXQgb2MgPSBmbHVzaCBvYzsgY2xvc2Vfb3V0X2NoYW5uZWwgb2NcbmxldCBjbG9zZV9vdXRfbm9lcnIgb2MgPVxuICAodHJ5IGZsdXNoIG9jIHdpdGggXyAtPiAoKSk7XG4gICh0cnkgY2xvc2Vfb3V0X2NoYW5uZWwgb2Mgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX291dCA6IG91dF9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBHZW5lcmFsIGlucHV0IGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBzZXRfaW5fY2hhbm5lbF9uYW1lOiBpbl9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9pbl9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9pbihvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9pbl9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX2luIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fdGV4dF0gMCBuYW1lXG5cbmxldCBvcGVuX2luX2JpbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX2JpbmFyeV0gMCBuYW1lXG5cbmV4dGVybmFsIGlucHV0X2NoYXIgOiBpbl9jaGFubmVsIC0+IGNoYXIgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5cbmV4dGVybmFsIHVuc2FmZV9pbnB1dCA6IGluX2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9pbnB1dFwiXG5cbmxldCBpbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcImlucHV0XCJcbiAgZWxzZSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWMgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBsZW4gPD0gMCB0aGVuICgpIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW4gaW5cbiAgICBpZiByID0gMFxuICAgIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyAob2ZzICsgcikgKGxlbiAtIHIpXG4gIGVuZFxuXG5sZXQgcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwicmVhbGx5X2lucHV0XCJcbiAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gPVxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSBsZW4gaW5cbiAgcmVhbGx5X2lucHV0IGljIHMgMCBsZW47XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG5leHRlcm5hbCBpbnB1dF9zY2FuX2xpbmUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcIlxuXG5sZXQgaW5wdXRfbGluZSBjaGFuID1cbiAgbGV0IHJlYyBidWlsZF9yZXN1bHQgYnVmIHBvcyA9IGZ1bmN0aW9uXG4gICAgW10gLT4gYnVmXG4gIHwgaGQgOjogdGwgLT5cbiAgICAgIGxldCBsZW4gPSBieXRlc19sZW5ndGggaGQgaW5cbiAgICAgIGJ5dGVzX2JsaXQgaGQgMCBidWYgKHBvcyAtIGxlbikgbGVuO1xuICAgICAgYnVpbGRfcmVzdWx0IGJ1ZiAocG9zIC0gbGVuKSB0bCBpblxuICBsZXQgcmVjIHNjYW4gYWNjdSBsZW4gPVxuICAgIGxldCBuID0gaW5wdXRfc2Nhbl9saW5lIGNoYW4gaW5cbiAgICBpZiBuID0gMCB0aGVuIGJlZ2luICAgICAgICAgICAgICAgICAgICgqIG4gPSAwOiB3ZSBhcmUgYXQgRU9GICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICAgIHwgXyAgLT4gYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gYWNjdVxuICAgIGVuZCBlbHNlIGlmIG4gPiAwIHRoZW4gYmVnaW4gICAgICAgICAgKCogbiA+IDA6IG5ld2xpbmUgZm91bmQgaW4gYnVmZmVyICopXG4gICAgICBsZXQgcmVzID0gYnl0ZXNfY3JlYXRlIChuIC0gMSkgaW5cbiAgICAgIGlnbm9yZSAodW5zYWZlX2lucHV0IGNoYW4gcmVzIDAgKG4gLSAxKSk7XG4gICAgICBpZ25vcmUgKGlucHV0X2NoYXIgY2hhbik7ICAgICAgICAgICAoKiBza2lwIHRoZSBuZXdsaW5lICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmVzXG4gICAgICB8ICBfIC0+IGxldCBsZW4gPSBsZW4gKyBuIC0gMSBpblxuICAgICAgICAgICAgICBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiAocmVzIDo6IGFjY3UpXG4gICAgZW5kIGVsc2UgYmVnaW4gICAgICAgICAgICAgICAgICAgICAgICAoKiBuIDwgMDogbmV3bGluZSBub3QgZm91bmQgKilcbiAgICAgIGxldCBiZWcgPSBieXRlc19jcmVhdGUgKC1uKSBpblxuICAgICAgaWdub3JlKHVuc2FmZV9pbnB1dCBjaGFuIGJlZyAwICgtbikpO1xuICAgICAgc2NhbiAoYmVnIDo6IGFjY3UpIChsZW4gLSBuKVxuICAgIGVuZFxuICBpbiBieXRlc191bnNhZmVfdG9fc3RyaW5nIChzY2FuIFtdIDApXG5cbmV4dGVybmFsIGlucHV0X2J5dGUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcbmV4dGVybmFsIGlucHV0X2JpbmFyeV9pbnQgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9pbnRcIlxuZXh0ZXJuYWwgaW5wdXRfdmFsdWUgOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5cIlxuZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX2luXCJcbmV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX2luX25vZXJyIGljID0gKHRyeSBjbG9zZV9pbiBpYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfaW4gOiBpbl9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgb3V0cHV0ICopXG5cbmxldCBwcmludF9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRvdXQgY1xubGV0IHByaW50X3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgc1xubGV0IHByaW50X2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3Rkb3V0IHNcbmxldCBwcmludF9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJpbnRfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmludF9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzOyBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxubGV0IHByaW50X25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGVycm9yICopXG5cbmxldCBwcmVycl9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRlcnIgY1xubGV0IHByZXJyX3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgc1xubGV0IHByZXJyX2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3RkZXJyIHNcbmxldCBwcmVycl9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJlcnJfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmVycl9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzOyBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxubGV0IHByZXJyX25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxuXG4oKiBJbnB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgaW5wdXQgKilcblxubGV0IHJlYWRfbGluZSAoKSA9IGZsdXNoIHN0ZG91dDsgaW5wdXRfbGluZSBzdGRpblxubGV0IHJlYWRfaW50ICgpID0gaW50X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2ludF9vcHQgKCkgPSBpbnRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0ICgpID0gZmxvYXRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXRfb3B0ICgpID0gZmxvYXRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcblxuKCogT3BlcmF0aW9ucyBvbiBsYXJnZSBmaWxlcyAqKVxuXG5tb2R1bGUgTGFyZ2VGaWxlID1cbiAgc3RydWN0XG4gICAgZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX291dF82NFwiXG4gICAgZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50NjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgICBleHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5fNjRcIlxuICAgIGV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX2luXzY0XCJcbiAgICBleHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgZW5kXG5cbigqIEZvcm1hdHMgKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAgPSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcbiAgID0gRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm10XG4gICAgICAgICAgICAgICAqIHN0cmluZ1xuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG5cbnR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjLCAnYykgZm9ybWF0NFxuXG5sZXQgc3RyaW5nX29mX2Zvcm1hdCAoRm9ybWF0IChfZm10LCBzdHIpKSA9IHN0clxuXG5leHRlcm5hbCBmb3JtYXRfb2Zfc3RyaW5nIDpcbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgKCBeXiApIChGb3JtYXQgKGZtdDEsIHN0cjEpKSAoRm9ybWF0IChmbXQyLCBzdHIyKSkgPVxuICBGb3JtYXQgKENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5jb25jYXRfZm10IGZtdDEgZm10MixcbiAgICAgICAgICBzdHIxIF4gXCIlLFwiIF4gc3RyMilcblxuKCogTWlzY2VsbGFuZW91cyAqKVxuXG5leHRlcm5hbCBzeXNfZXhpdCA6IGludCAtPiAnYSA9IFwiY2FtbF9zeXNfZXhpdFwiXG5cbmxldCBleGl0X2Z1bmN0aW9uID0gcmVmIGZsdXNoX2FsbFxuXG5sZXQgYXRfZXhpdCBmID1cbiAgbGV0IGcgPSAhZXhpdF9mdW5jdGlvbiBpblxuICAoKiBNUFIjNzI1MywgTVBSIzc3OTY6IG1ha2Ugc3VyZSBcImZcIiBpcyBleGVjdXRlZCBvbmx5IG9uY2UgKilcbiAgbGV0IGZfYWxyZWFkeV9yYW4gPSByZWYgZmFsc2UgaW5cbiAgZXhpdF9mdW5jdGlvbiA6PVxuICAgIChmdW4gKCkgLT4gXG4gICAgICBpZiBub3QgIWZfYWxyZWFkeV9yYW4gdGhlbiBiZWdpbiBmX2FscmVhZHlfcmFuIDo9IHRydWU7IGYoKSBlbmQ7XG4gICAgICBnKCkpXG5cbmxldCBkb19hdF9leGl0ICgpID0gKCFleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuZW5kXG5cbmluY2x1ZGUgUGVydmFzaXZlc1xuXG4oKk1PRFVMRV9BTElBU0VTKilcbm1vZHVsZSBBcmcgICAgICAgICAgPSBBcmdcbm1vZHVsZSBBcnJheSAgICAgICAgPSBBcnJheVxubW9kdWxlIEFycmF5TGFiZWxzICA9IEFycmF5TGFiZWxzXG5tb2R1bGUgQmlnYXJyYXkgICAgID0gQmlnYXJyYXlcbm1vZHVsZSBCdWZmZXIgICAgICAgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyAgICAgICAgPSBCeXRlc1xubW9kdWxlIEJ5dGVzTGFiZWxzICA9IEJ5dGVzTGFiZWxzXG5tb2R1bGUgQ2FsbGJhY2sgICAgID0gQ2FsbGJhY2tcbm1vZHVsZSBDaGFyICAgICAgICAgPSBDaGFyXG5tb2R1bGUgQ29tcGxleCAgICAgID0gQ29tcGxleFxubW9kdWxlIERpZ2VzdCAgICAgICA9IERpZ2VzdFxubW9kdWxlIEVwaGVtZXJvbiAgICA9IEVwaGVtZXJvblxubW9kdWxlIEZpbGVuYW1lICAgICA9IEZpbGVuYW1lXG5tb2R1bGUgRmxvYXQgICAgICAgID0gRmxvYXRcbm1vZHVsZSBGb3JtYXQgICAgICAgPSBGb3JtYXRcbm1vZHVsZSBHYyAgICAgICAgICAgPSBHY1xubW9kdWxlIEdlbmxleCAgICAgICA9IEdlbmxleFxubW9kdWxlIEhhc2h0YmwgICAgICA9IEhhc2h0Ymxcbm1vZHVsZSBJbnQzMiAgICAgICAgPSBJbnQzMlxubW9kdWxlIEludDY0ICAgICAgICA9IEludDY0XG5tb2R1bGUgTGF6eSAgICAgICAgID0gTGF6eVxubW9kdWxlIExleGluZyAgICAgICA9IExleGluZ1xubW9kdWxlIExpc3QgICAgICAgICA9IExpc3Rcbm1vZHVsZSBMaXN0TGFiZWxzICAgPSBMaXN0TGFiZWxzXG5tb2R1bGUgTWFwICAgICAgICAgID0gTWFwXG5tb2R1bGUgTWFyc2hhbCAgICAgID0gTWFyc2hhbFxubW9kdWxlIE1vcmVMYWJlbHMgICA9IE1vcmVMYWJlbHNcbm1vZHVsZSBOYXRpdmVpbnQgICAgPSBOYXRpdmVpbnRcbm1vZHVsZSBPYmogICAgICAgICAgPSBPYmpcbm1vZHVsZSBPbyAgICAgICAgICAgPSBPb1xubW9kdWxlIFBhcnNpbmcgICAgICA9IFBhcnNpbmdcbm1vZHVsZSBQcmludGV4YyAgICAgPSBQcmludGV4Y1xubW9kdWxlIFByaW50ZiAgICAgICA9IFByaW50ZlxubW9kdWxlIFF1ZXVlICAgICAgICA9IFF1ZXVlXG5tb2R1bGUgUmFuZG9tICAgICAgID0gUmFuZG9tXG5tb2R1bGUgU2NhbmYgICAgICAgID0gU2NhbmZcbm1vZHVsZSBTZXEgICAgICAgICAgPSBTZXFcbm1vZHVsZSBTZXQgICAgICAgICAgPSBTZXRcbm1vZHVsZSBTb3J0ICAgICAgICAgPSBTb3J0XG5tb2R1bGUgU3BhY2V0aW1lICAgID0gU3BhY2V0aW1lXG5tb2R1bGUgU3RhY2sgICAgICAgID0gU3RhY2tcbm1vZHVsZSBTdGRMYWJlbHMgICAgPSBTdGRMYWJlbHNcbm1vZHVsZSBTdHJlYW0gICAgICAgPSBTdHJlYW1cbm1vZHVsZSBTdHJpbmcgICAgICAgPSBTdHJpbmdcbm1vZHVsZSBTdHJpbmdMYWJlbHMgPSBTdHJpbmdMYWJlbHNcbm1vZHVsZSBTeXMgICAgICAgICAgPSBTeXNcbm1vZHVsZSBVY2hhciAgICAgICAgPSBVY2hhclxubW9kdWxlIFdlYWsgICAgICAgICA9IFdlYWtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGxlblxuICB8IF86OmwgLT4gbGVuZ3RoX2F1eCAobGVuICsgMSkgbFxuXG5sZXQgbGVuZ3RoIGwgPSBsZW5ndGhfYXV4IDAgbFxuXG5sZXQgY29ucyBhIGwgPSBhOjpsXG5cbmxldCBoZCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJoZFwiXG4gIHwgYTo6XyAtPiBhXG5cbmxldCB0bCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJ0bFwiXG4gIHwgXzo6bCAtPiBsXG5cbmxldCBudGggbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGZhaWx3aXRoIFwibnRoXCJcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBudGhfb3B0IGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBhcHBlbmQgPSAoQClcblxubGV0IHJlYyByZXZfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgYSA6OiBsIC0+IHJldl9hcHBlbmQgbCAoYSA6OiBsMilcblxubGV0IHJldiBsID0gcmV2X2FwcGVuZCBsIFtdXG5cbmxldCByZWMgaW5pdF90YWlscmVjX2F1eCBhY2MgaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBhY2NcbiAgZWxzZSBpbml0X3RhaWxyZWNfYXV4IChmIGkgOjogYWNjKSAoaSsxKSBuIGZcblxubGV0IHJlYyBpbml0X2F1eCBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgciA9IGYgaSBpblxuICAgIHIgOjogaW5pdF9hdXggKGkrMSkgbiBmXG5cbmxldCByZXZfaW5pdF90aHJlc2hvbGQgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBTeXMuTmF0aXZlIHwgU3lzLkJ5dGVjb2RlIC0+IDEwXzAwMFxuICAoKiBXZSBkb24ndCBrbm93biB0aGUgc2l6ZSBvZiB0aGUgc3RhY2ssIGJldHRlciBiZSBzYWZlIGFuZCBhc3N1bWUgaXQncyBzbWFsbC4gKilcbiAgfCBTeXMuT3RoZXIgXyAtPiA1MFxuXG5sZXQgaW5pdCBsZW4gZiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QuaW5pdFwiIGVsc2VcbiAgaWYgbGVuID4gcmV2X2luaXRfdGhyZXNob2xkIHRoZW4gcmV2IChpbml0X3RhaWxyZWNfYXV4IFtdIDAgbGVuIGYpXG4gIGVsc2UgaW5pdF9hdXggMCBsZW4gZlxuXG5sZXQgcmVjIGZsYXR0ZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgbDo6ciAtPiBsIEAgZmxhdHRlbiByXG5cbmxldCBjb25jYXQgPSBmbGF0dGVuXG5cbmxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgYSBpbiByIDo6IG1hcCBmIGxcblxubGV0IHJlYyBtYXBpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBpIGEgaW4gciA6OiBtYXBpIChpICsgMSkgZiBsXG5cbmxldCBtYXBpIGYgbCA9IG1hcGkgMCBmIGxcblxubGV0IHJldl9tYXAgZiBsID1cbiAgbGV0IHJlYyBybWFwX2YgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCBhOjpsIC0+IHJtYXBfZiAoZiBhIDo6IGFjY3UpIGxcbiAgaW5cbiAgcm1hcF9mIFtdIGxcblxuXG5sZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgYTsgaXRlciBmIGxcblxubGV0IHJlYyBpdGVyaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGkgYTsgaXRlcmkgKGkgKyAxKSBmIGxcblxubGV0IGl0ZXJpIGYgbCA9IGl0ZXJpIDAgZiBsXG5cbmxldCByZWMgZm9sZF9sZWZ0IGYgYWNjdSBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZm9sZF9sZWZ0IGYgKGYgYWNjdSBhKSBsXG5cbmxldCByZWMgZm9sZF9yaWdodCBmIGwgYWNjdSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGYgYSAoZm9sZF9yaWdodCBmIGwgYWNjdSlcblxubGV0IHJlYyBtYXAyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGxldCByID0gZiBhMSBhMiBpbiByIDo6IG1hcDIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubWFwMlwiXG5cbmxldCByZXZfbWFwMiBmIGwxIGwyID1cbiAgbGV0IHJlYyBybWFwMl9mIGFjY3UgbDEgbDIgPVxuICAgIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICB8IChbXSwgW10pIC0+IGFjY3VcbiAgICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcm1hcDJfZiAoZiBhMSBhMiA6OiBhY2N1KSBsMSBsMlxuICAgIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZXZfbWFwMlwiXG4gIGluXG4gIHJtYXAyX2YgW10gbDEgbDJcblxuXG5sZXQgcmVjIGl0ZXIyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gKClcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTI7IGl0ZXIyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lml0ZXIyXCJcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmb2xkX2xlZnQyIGYgKGYgYWNjdSBhMSBhMikgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfbGVmdDJcIlxuXG5sZXQgcmVjIGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyIChmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UpXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX3JpZ2h0MlwiXG5cbmxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiB0cnVlXG4gIHwgYTo6bCAtPiBwIGEgJiYgZm9yX2FsbCBwIGxcblxubGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IHAgYSB8fCBleGlzdHMgcCBsXG5cbmxldCByZWMgZm9yX2FsbDIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiB0cnVlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyICYmIGZvcl9hbGwyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvcl9hbGwyXCJcblxubGV0IHJlYyBleGlzdHMyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gZmFsc2VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgfHwgZXhpc3RzMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5leGlzdHMyXCJcblxubGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW0geCBsXG5cbmxldCByZWMgbWVtcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gYSA9PSB4IHx8IG1lbXEgeCBsXG5cbmxldCByZWMgYXNzb2MgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gYiBlbHNlIGFzc29jIHggbFxuXG5sZXQgcmVjIGFzc29jX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gU29tZSBiIGVsc2UgYXNzb2Nfb3B0IHggbFxuXG5sZXQgcmVjIGFzc3EgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gYiBlbHNlIGFzc3EgeCBsXG5cbmxldCByZWMgYXNzcV9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIFNvbWUgYiBlbHNlIGFzc3Ffb3B0IHggbFxuXG5sZXQgcmVjIG1lbV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW1fYXNzb2MgeCBsXG5cbmxldCByZWMgbWVtX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBhID09IHggfHwgbWVtX2Fzc3EgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPlxuICAgICAgaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc29jIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPiBpZiBhID09IHggdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzcSB4IGxcblxubGV0IHJlYyBmaW5kIHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiB4IGVsc2UgZmluZCBwIGxcblxubGV0IHJlYyBmaW5kX29wdCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmRfb3B0IHAgbFxuXG5sZXQgZmluZF9hbGwgcCA9XG4gIGxldCByZWMgZmluZCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjdVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBmaW5kICh4IDo6IGFjY3UpIGwgZWxzZSBmaW5kIGFjY3UgbCBpblxuICBmaW5kIFtdXG5cbmxldCBmaWx0ZXIgPSBmaW5kX2FsbFxuXG5sZXQgcGFydGl0aW9uIHAgbCA9XG4gIGxldCByZWMgcGFydCB5ZXMgbm8gPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgeWVzLCByZXYgbm8pXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHBhcnQgKHggOjogeWVzKSBubyBsIGVsc2UgcGFydCB5ZXMgKHggOjogbm8pIGwgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCByZWMgc3BsaXQgPSBmdW5jdGlvblxuICAgIFtdIC0+IChbXSwgW10pXG4gIHwgKHgseSk6OmwgLT5cbiAgICAgIGxldCAocngsIHJ5KSA9IHNwbGl0IGwgaW4gKHg6OnJ4LCB5OjpyeSlcblxubGV0IHJlYyBjb21iaW5lIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiAoYTEsIGEyKSA6OiBjb21iaW5lIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5jb21iaW5lXCJcblxuKCoqIHNvcnRpbmcgKilcblxubGV0IHJlYyBtZXJnZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gaDEgOjogbWVyZ2UgY21wIHQxIGwyXG4gICAgICBlbHNlIGgyIDo6IG1lcmdlIGNtcCBsMSB0MlxuXG5cbmxldCByZWMgY2hvcCBrIGwgPVxuICBpZiBrID0gMCB0aGVuIGwgZWxzZSBiZWdpblxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgXzo6dCAtPiBjaG9wIChrLTEpIHRcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGVuZFxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICBlbmRcbiAgICB8IG4sIGwgLT5cbiAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgbGV0IGwyID0gY2hvcCBuMSBsIGluXG4gICAgICAgbGV0IHMxID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgIGxldCBzMiA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgcmV2X21lcmdlX3JldiBzMSBzMiBbXVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IF8gLT5cbiAgICAgICBpZiBjbXAgeDEgeDIgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBiZWdpblxuICAgICAgICAgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgZW5kXG4gICAgfCBuLCBsIC0+XG4gICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgIGxldCBsMiA9IGNob3AgbjEgbCBpblxuICAgICAgIGxldCBzMSA9IHNvcnQgbjEgbCBpblxuICAgICAgIGxldCBzMiA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2UgczEgczIgW11cbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2Ugc29ydCBsZW4gbFxuXG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiBOb3RlOiBvbiBhIGxpc3Qgb2YgbGVuZ3RoIGJldHdlZW4gYWJvdXQgMTAwMDAwIChkZXBlbmRpbmcgb24gdGhlIG1pbm9yXG4gICBoZWFwIHNpemUgYW5kIHRoZSB0eXBlIG9mIHRoZSBsaXN0KSBhbmQgU3lzLm1heF9hcnJheV9zaXplLCBpdCBpc1xuICAgYWN0dWFsbHkgZmFzdGVyIHRvIHVzZSB0aGUgZm9sbG93aW5nLCBidXQgaXQgbWlnaHQgYWxzbyB1c2UgbW9yZSBtZW1vcnlcbiAgIGJlY2F1c2UgdGhlIGFyZ3VtZW50IGxpc3QgY2Fubm90IGJlIGRlYWxsb2NhdGVkIGluY3JlbWVudGFsbHkuXG5cbiAgIEFsc28sIHRoZXJlIHNlZW1zIHRvIGJlIGEgYnVnIGluIHRoaXMgY29kZSBvciBpbiB0aGVcbiAgIGltcGxlbWVudGF0aW9uIG9mIG9ial90cnVuY2F0ZS5cblxuZXh0ZXJuYWwgb2JqX3RydW5jYXRlIDogJ2EgYXJyYXkgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcblxubGV0IGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYSA9XG4gIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGFjY3UgbiBwID1cbiAgICBpZiBwIDw9IDAgdGhlbiBhY2N1IGVsc2UgYmVnaW5cbiAgICAgIGlmIHAgPSBuIHRoZW4gYmVnaW5cbiAgICAgICAgb2JqX3RydW5jYXRlIGEgcDtcbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSAobi0xMDAwKSAocC0xKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSBuIChwLTEpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBbXSAobC0xMDAwKSBsXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgQXJyYXkuc3RhYmxlX3NvcnQgY21wIGE7XG4gIGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYVxuXG4qKVxuXG5cbigqKiBzb3J0aW5nICsgcmVtb3ZpbmcgZHVwbGljYXRlcyAqKVxuXG5sZXQgc29ydF91bmlxIGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlIHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZV9yZXYgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdXG4gICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IF8gLT5cbiAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgZW5kIGVsc2UgaWYgYyA8IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgIGVuZFxuICAgIHwgbiwgbCAtPlxuICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICBsZXQgbDIgPSBjaG9wIG4xIGwgaW5cbiAgICAgICBsZXQgczEgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgbGV0IHMyID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2VfcmV2IHMxIHMyIFtdXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdXG4gICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IF8gLT5cbiAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgZW5kIGVsc2UgaWYgYyA+IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgIGVuZFxuICAgIHwgbiwgbCAtPlxuICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICBsZXQgbDIgPSBjaG9wIG4xIGwgaW5cbiAgICAgICBsZXQgczEgPSBzb3J0IG4xIGwgaW5cbiAgICAgICBsZXQgczIgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgcmV2X21lcmdlIHMxIHMyIFtdXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIHNvcnQgbGVuIGxcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aHMgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgXyA6OiBsMSwgXyA6OiBsMiAtPiBjb21wYXJlX2xlbmd0aHMgbDEgbDJcbjs7XG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhfd2l0aCBsIG4gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGlmIG4gPSAwIHRoZW4gMCBlbHNlXG4gICAgICBpZiBuID4gMCB0aGVuIC0xIGVsc2UgMVxuICB8IF8gOjogbCAtPlxuICAgIGlmIG4gPD0gMCB0aGVuIDEgZWxzZVxuICAgICAgY29tcGFyZV9sZW5ndGhfd2l0aCBsIChuLTEpXG47O1xuXG4oKiogezYgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGwgPVxuICBsZXQgcmVjIGF1eCBsICgpID0gbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBTZXEuTmlsXG4gICAgfCB4IDo6IHRhaWwgLT4gU2VxLkNvbnMgKHgsIGF1eCB0YWlsKVxuICBpblxuICBhdXggbFxuXG5sZXQgb2Zfc2VxIHNlcSA9XG4gIGxldCByZWMgZGlyZWN0IGRlcHRoIHNlcSA6IF8gbGlzdCA9XG4gICAgaWYgZGVwdGg9MFxuICAgIHRoZW5cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIHNlcVxuICAgICAgfD4gcmV2ICgqIHRhaWxyZWMgKilcbiAgICBlbHNlIG1hdGNoIHNlcSgpIHdpdGhcbiAgICAgIHwgU2VxLk5pbCAtPiBbXVxuICAgICAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT4geCA6OiBkaXJlY3QgKGRlcHRoLTEpIG5leHRcbiAgaW5cbiAgZGlyZWN0IDUwMCBzZXFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTaW1vbiBDcnVhbmVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtTZXFdOiBmdW5jdGlvbmFsIGl0ZXJhdG9ycyAqKVxuXG50eXBlICsnYSBub2RlID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZVxuXG5sZXQgZW1wdHkgKCkgPSBOaWxcblxubGV0IHJldHVybiB4ICgpID0gQ29ucyAoeCwgZW1wdHkpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zIChmIHgsIG1hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyX21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgICB8IFNvbWUgeSAtPiBDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXIgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBpZiBmIHhcbiAgICAgIHRoZW4gQ29ucyAoeCwgZmlsdGVyIGYgbmV4dClcbiAgICAgIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBmbGF0X21hcF9hcHAgZiAoZiB4KSBuZXh0ICgpXG5cbigqIHRoaXMgaXMgW2FwcGVuZCBzZXEgKGZsYXRfbWFwIGYgdGFpbCldICopXG5hbmQgZmxhdF9tYXBfYXBwIGYgc2VxIHRhaWwgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBmbGF0X21hcCBmIHRhaWwgKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIENvbnMgKHgsIGZsYXRfbWFwX2FwcCBmIG5leHQgdGFpbClcblxubGV0IGZvbGRfbGVmdCBmIGFjYyBzZXEgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyBzZXEgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgYXV4IGYgYWNjIHNlcVxuXG5sZXQgaXRlciBmIHNlcSA9XG4gIGxldCByZWMgYXV4IHNlcSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgYXV4IG5leHRcbiAgaW5cbiAgYXV4IHNlcVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBjb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgY2hyIG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJDaGFyLmNoclwiIGVsc2UgdW5zYWZlX2NociBuXG5cbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZTogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBieXRlc191bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgZXNjYXBlZCA9IGZ1bmN0aW9uXG4gIHwgJ1xcJycgLT4gXCJcXFxcJ1wiXG4gIHwgJ1xcXFwnIC0+IFwiXFxcXFxcXFxcIlxuICB8ICdcXG4nIC0+IFwiXFxcXG5cIlxuICB8ICdcXHQnIC0+IFwiXFxcXHRcIlxuICB8ICdcXHInIC0+IFwiXFxcXHJcIlxuICB8ICdcXGInIC0+IFwiXFxcXGJcIlxuICB8ICcgJyAuLiAnficgYXMgYyAtPlxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgMSBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgYztcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuICB8IGMgLT5cbiAgICAgIGxldCBuID0gY29kZSBjIGluXG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSA0IGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCAnXFxcXCc7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMSAodW5zYWZlX2NociAoNDggKyBuIC8gMTAwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMiAodW5zYWZlX2NociAoNDggKyAobiAvIDEwKSBtb2QgMTApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAzICh1bnNhZmVfY2hyICg0OCArIG4gbW9kIDEwKSk7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcblxubGV0IGxvd2VyY2FzZSBjID1cbiAgaWYgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKVxuICB8fCAoYyA+PSAnXFwxOTInICYmIGMgPD0gJ1xcMjE0JylcbiAgfHwgKGMgPj0gJ1xcMjE2JyAmJiBjIDw9ICdcXDIyMicpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgZWxzZSBjXG5cbmxldCB1cHBlcmNhc2UgYyA9XG4gIGlmIChjID49ICdhJyAmJiBjIDw9ICd6JylcbiAgfHwgKGMgPj0gJ1xcMjI0JyAmJiBjIDw9ICdcXDI0NicpXG4gIHx8IChjID49ICdcXDI0OCcgJiYgYyA8PSAnXFwyNTQnKVxuICB0aGVuIHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIGVsc2UgY1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpIGMgPVxuICBpZiAoYyA+PSAnQScgJiYgYyA8PSAnWicpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgZWxzZSBjXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgYyA9XG4gIGlmIChjID49ICdhJyAmJiBjIDw9ICd6JylcbiAgdGhlbiB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICBlbHNlIGNcblxudHlwZSB0ID0gY2hhclxuXG5sZXQgY29tcGFyZSBjMSBjMiA9IGNvZGUgYzEgLSBjb2RlIGMyXG5sZXQgZXF1YWwgKGMxOiB0KSAoYzI6IHQpID0gY29tcGFyZSBjMSBjMiA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtOYXRpdmVpbnRdOiBwcm9jZXNzb3ItbmF0aXZlIGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZzogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9uZWdcIlxuZXh0ZXJuYWwgYWRkOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hZGRcIlxuZXh0ZXJuYWwgc3ViOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9zdWJcIlxuZXh0ZXJuYWwgbXVsOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tdWxcIlxuZXh0ZXJuYWwgZGl2OiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9kaXZcIlxuZXh0ZXJuYWwgcmVtOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29yXCJcbmV4dGVybmFsIGxvZ3hvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWw6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzclwiXG5leHRlcm5hbCBvZl9pbnQ6IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludDogbmF0aXZlaW50IC0+IGludCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogbmF0aXZlaW50IC0+IGZsb2F0XG4gID0gXCJjYW1sX25hdGl2ZWludF90b19mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyOiBuYXRpdmVpbnQgLT4gaW50MzIgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgemVybyA9IDBuXG5sZXQgb25lID0gMW5cbmxldCBtaW51c19vbmUgPSAtMW5cbmxldCBzdWNjIG4gPSBhZGQgbiAxblxubGV0IHByZWQgbiA9IHN1YiBuIDFuXG5sZXQgYWJzIG4gPSBpZiBuID49IDBuIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgc2l6ZSA9IFN5cy53b3JkX3NpemVcbmxldCBtaW5faW50ID0gc2hpZnRfbGVmdCAxbiAoc2l6ZSAtIDEpXG5sZXQgbWF4X2ludCA9IHN1YiBtaW5faW50IDFuXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFuKVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZyA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmc6IHN0cmluZyAtPiBuYXRpdmVpbnQgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBuYXRpdmVpbnRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFBlcnZhc2l2ZXMuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIHN0cmluZy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2ZpbGxfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGJ5dGVzID0gXCIlYnl0ZXNfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9ibGl0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbmxldCBtYWtlIG4gYyA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgdW5zYWZlX2ZpbGwgcyAwIG4gYztcbiAgc1xuXG5sZXQgaW5pdCBuIGYgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgcyBpIChmIGkpXG4gIGRvbmU7XG4gIHNcblxubGV0IGVtcHR5ID0gY3JlYXRlIDBcblxubGV0IGNvcHkgcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgdW5zYWZlX2JsaXQgcyAwIHIgMCBsZW47XG4gIHJcblxubGV0IHRvX3N0cmluZyBiID0gdW5zYWZlX3RvX3N0cmluZyAoY29weSBiKVxubGV0IG9mX3N0cmluZyBzID0gY29weSAodW5zYWZlX29mX3N0cmluZyBzKVxuXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLnN1YiAvIEJ5dGVzLnN1YlwiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBzIG9mcyByIDAgbGVuO1xuICAgIHJcbiAgZW5kXG5cbmxldCBzdWJfc3RyaW5nIGIgb2ZzIGxlbiA9IHVuc2FmZV90b19zdHJpbmcgKHN1YiBiIG9mcyBsZW4pXG5cbigqIGFkZGl0aW9uIHdpdGggYW4gb3ZlcmZsb3cgY2hlY2sgKilcbmxldCAoKyspIGEgYiA9XG4gIGxldCBjID0gYSArIGIgaW5cbiAgbWF0Y2ggYSA8IDAsIGIgPCAwLCBjIDwgMCB3aXRoXG4gIHwgdHJ1ZSAsIHRydWUgLCBmYWxzZVxuICB8IGZhbHNlLCBmYWxzZSwgdHJ1ZSAgLT4gaW52YWxpZF9hcmcgXCJCeXRlcy5leHRlbmRcIiAoKiBvdmVyZmxvdyAqKVxuICB8IF8gLT4gY1xuXG5sZXQgZXh0ZW5kIHMgbGVmdCByaWdodCA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyArKyBsZWZ0ICsrIHJpZ2h0IGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICBsZXQgKHNyY29mZiwgZHN0b2ZmKSA9IGlmIGxlZnQgPCAwIHRoZW4gLWxlZnQsIDAgZWxzZSAwLCBsZWZ0IGluXG4gIGxldCBjcHlsZW4gPSBtaW4gKGxlbmd0aCBzIC0gc3Jjb2ZmKSAobGVuIC0gZHN0b2ZmKSBpblxuICBpZiBjcHlsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgcyBzcmNvZmYgciBkc3RvZmYgY3B5bGVuO1xuICByXG5cbmxldCBmaWxsIHMgb2ZzIGxlbiBjID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuZmlsbCAvIEJ5dGVzLmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIHMgb2ZzIGxlbiBjXG5cbmxldCBibGl0IHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCeXRlcy5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbmxldCBibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gc3RyaW5nX2xlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5ibGl0IC8gQnl0ZXMuYmxpdF9zdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9ibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJCeXRlcy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGVtcHR5XG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpblxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKGNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG5sZXQgY2F0IHMxIHMyID1cbiAgbGV0IGwxID0gbGVuZ3RoIHMxIGluXG4gIGxldCBsMiA9IGxlbmd0aCBzMiBpblxuICBsZXQgciA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgdW5zYWZlX2JsaXQgczEgMCByIDAgbDE7XG4gIHVuc2FmZV9ibGl0IHMyIDAgciBsMSBsMjtcbiAgclxuXG5cbmV4dGVybmFsIGNoYXJfY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBjaGFyX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaSkgZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgbGV0IGogPSByZWYgKGxlbiAtIDEpIGluXG4gIHdoaWxlICFqID49ICFpICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWopIGRvXG4gICAgZGVjciBqXG4gIGRvbmU7XG4gIGlmICFqID49ICFpIHRoZW5cbiAgICBzdWIgcyAhaSAoIWogLSAhaSArIDEpXG4gIGVsc2VcbiAgICBlbXB0eVxuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgbiA6PSAhbiArXG4gICAgICAobWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gMlxuICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgfCBfIC0+IDQpXG4gIGRvbmU7XG4gIGlmICFuID0gbGVuZ3RoIHMgdGhlbiBjb3B5IHMgZWxzZSBiZWdpblxuICAgIGxldCBzJyA9IGNyZWF0ZSAhbiBpblxuICAgIG4gOj0gMDtcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICBiZWdpbiBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgfCAoJyAnIC4uICd+JykgYXMgYyAtPiB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgYyAtPlxuICAgICAgICAgIGxldCBhID0gY2hhcl9jb2RlIGMgaW5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSAvIDEwMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyAoYSAvIDEwKSBtb2QgMTApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSBtb2QgMTApKTtcbiAgICAgIGVuZDtcbiAgICAgIGluY3IgblxuICAgIGRvbmU7XG4gICAgcydcbiAgZW5kXG5cbmxldCBtYXAgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwaSBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbmxldCBhcHBseTEgZiBzID1cbiAgaWYgbGVuZ3RoIHMgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjb3B5IHMgaW5cbiAgICB1bnNhZmVfc2V0IHIgMCAoZih1bnNhZmVfZ2V0IHMgMCkpO1xuICAgIHJcbiAgZW5kXG5cbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiIGVsc2VcbiAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG50eXBlIHQgPSBieXRlc1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gUGVydmFzaXZlcy5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9ieXRlc19lcXVhbFwiXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID0gbWFwIENoYXIudXBwZXJjYXNlIHNcbmxldCBsb3dlcmNhc2UgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZSBzXG5cbmxldCBjYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2Ugc1xubGV0IHVuY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlIHNcblxuKCoqIHs2IEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGxldCBidWYgPSByZWYgKG1ha2UgMjU2ICdcXDAwMCcpIGluXG4gIGxldCByZXNpemUgKCkgPVxuICAgICgqIHJlc2l6ZSAqKVxuICAgIGxldCBuZXdfbGVuID0gbWluICgyICogbGVuZ3RoICFidWYpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgIGlmIGxlbmd0aCAhYnVmID0gbmV3X2xlbiB0aGVuIGZhaWx3aXRoIFwiQnl0ZXMub2Zfc2VxOiBjYW5ub3QgZ3JvdyBieXRlc1wiO1xuICAgIGxldCBuZXdfYnVmID0gbWFrZSBuZXdfbGVuICdcXDAwMCcgaW5cbiAgICBibGl0ICFidWYgMCBuZXdfYnVmIDAgIW47XG4gICAgYnVmIDo9IG5ld19idWZcbiAgaW5cbiAgU2VxLml0ZXJcbiAgICAoZnVuIGMgLT5cbiAgICAgICBpZiAhbiA9IGxlbmd0aCAhYnVmIHRoZW4gcmVzaXplKCk7XG4gICAgICAgc2V0ICFidWYgIW4gYztcbiAgICAgICBpbmNyIG4pXG4gICAgaTtcbiAgc3ViICFidWYgMCAhblxuXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBHYWxsaXVtLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFN0cmluZyBvcGVyYXRpb25zLCBiYXNlZCBvbiBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIGJ5dGVzLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5tb2R1bGUgQiA9IEJ5dGVzXG5cbmxldCBidHMgPSBCLnVuc2FmZV90b19zdHJpbmdcbmxldCBib3MgPSBCLnVuc2FmZV9vZl9zdHJpbmdcblxubGV0IG1ha2UgbiBjID1cbiAgQi5tYWtlIG4gYyB8PiBidHNcbmxldCBpbml0IG4gZiA9XG4gIEIuaW5pdCBuIGYgfD4gYnRzXG5sZXQgY29weSBzID1cbiAgQi5jb3B5IChib3MgcykgfD4gYnRzXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIEIuc3ViIChib3Mgcykgb2ZzIGxlbiB8PiBidHNcbmxldCBmaWxsID1cbiAgQi5maWxsXG5sZXQgYmxpdCA9XG4gIEIuYmxpdF9zdHJpbmdcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBcIlwiXG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpbiBidHMgQEBcbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChCLmNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlciBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyaSBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxubGV0IG1hcCBmIHMgPVxuICBCLm1hcCBmIChib3MgcykgfD4gYnRzXG5sZXQgbWFwaSBmIHMgPVxuICBCLm1hcGkgZiAoYm9zIHMpIHw+IGJ0c1xuXG4oKiBCZXdhcmU6IHdlIGNhbm5vdCB1c2UgQi50cmltIG9yIEIuZXNjYXBlIGJlY2F1c2UgdGhleSBhbHdheXMgbWFrZSBhXG4gICBjb3B5LCBidXQgU3RyaW5nLm1saSBzcGVsbHMgb3V0IHNvbWUgY2FzZXMgd2hlcmUgd2UgYXJlIG5vdCBhbGxvd2VkXG4gICB0byBtYWtlIGEgY29weS4gKilcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBpZiBzID0gXCJcIiB0aGVuIHNcbiAgZWxzZSBpZiBpc19zcGFjZSAodW5zYWZlX2dldCBzIDApIHx8IGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgKGxlbmd0aCBzIC0gMSkpXG4gICAgdGhlbiBidHMgKEIudHJpbSAoYm9zIHMpKVxuICBlbHNlIHNcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCByZWMgZXNjYXBlX2lmX25lZWRlZCBzIG4gaSA9XG4gICAgaWYgaSA+PSBuIHRoZW4gcyBlbHNlXG4gICAgICBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXDAwMCcuLidcXDAzMScgfCAnXFwxMjcnLi4gJ1xcMjU1JyAtPiBidHMgKEIuZXNjYXBlZCAoYm9zIHMpKVxuICAgICAgfCBfIC0+IGVzY2FwZV9pZl9uZWVkZWQgcyBuIChpKzEpXG4gIGluXG4gIGVzY2FwZV9pZl9uZWVkZWQgcyAobGVuZ3RoIHMpIDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICAgIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCIgZWxzZVxuICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9XG4gIEIudXBwZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPVxuICBCLmxvd2VyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi51bmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBQZXJ2YXNpdmVzLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zdHJpbmdfZXF1YWxcIlxuXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPVxuICBCLnVwcGVyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZSBzID1cbiAgQi5sb3dlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplIHMgPVxuICBCLmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemUgcyA9XG4gIEIudW5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5cbigqKiB7NiBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IGJvcyBzIHw+IEIudG9fc2VxXG5cbmxldCB0b19zZXFpIHMgPSBib3MgcyB8PiBCLnRvX3NlcWlcblxubGV0IG9mX3NlcSBnID0gQi5vZl9zZXEgZyB8PiBidHNcblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNZXJnaW5nIGFuZCBzb3J0aW5nICopXG5cbm9wZW4gQXJyYXlcblxubGV0IHJlYyBtZXJnZSBvcmRlciBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGgxIDo6IHQxIC0+XG4gICAgICBtYXRjaCBsMiB3aXRoXG4gICAgICAgIFtdIC0+IGwxXG4gICAgICB8IGgyIDo6IHQyIC0+XG4gICAgICAgICAgaWYgb3JkZXIgaDEgaDJcbiAgICAgICAgICB0aGVuIGgxIDo6IG1lcmdlIG9yZGVyIHQxIGwyXG4gICAgICAgICAgZWxzZSBoMiA6OiBtZXJnZSBvcmRlciBsMSB0MlxuXG5sZXQgbGlzdCBvcmRlciBsID1cbiAgbGV0IHJlYyBpbml0bGlzdCA9IGZ1bmN0aW9uXG4gICAgICBbXSAtPiBbXVxuICAgIHwgW2VdIC0+IFtbZV1dXG4gICAgfCBlMTo6ZTI6OnJlc3QgLT5cbiAgICAgICAgKGlmIG9yZGVyIGUxIGUyIHRoZW4gW2UxO2UyXSBlbHNlIFtlMjtlMV0pIDo6IGluaXRsaXN0IHJlc3QgaW5cbiAgbGV0IHJlYyBtZXJnZTIgPSBmdW5jdGlvblxuICAgICAgbDE6OmwyOjpyZXN0IC0+IG1lcmdlIG9yZGVyIGwxIGwyIDo6IG1lcmdlMiByZXN0XG4gICAgfCB4IC0+IHggaW5cbiAgbGV0IHJlYyBtZXJnZWFsbCA9IGZ1bmN0aW9uXG4gICAgICBbXSAtPiBbXVxuICAgIHwgW2xdIC0+IGxcbiAgICB8IGxsaXN0IC0+IG1lcmdlYWxsIChtZXJnZTIgbGxpc3QpIGluXG4gIG1lcmdlYWxsKGluaXRsaXN0IGwpXG5cbmxldCBzd2FwIGFyciBpIGogPVxuICBsZXQgdG1wID0gdW5zYWZlX2dldCBhcnIgaSBpblxuICB1bnNhZmVfc2V0IGFyciBpICh1bnNhZmVfZ2V0IGFyciBqKTtcbiAgdW5zYWZlX3NldCBhcnIgaiB0bXBcblxuKCogVGhlcmUgaXMgYSBrbm93biBwZXJmb3JtYW5jZSBidWcgaW4gdGhlIGNvZGUgYmVsb3cuICBJZiB5b3UgZmluZFxuICAgaXQsIGRvbid0IGJvdGhlciByZXBvcnRpbmcgaXQuICBZb3UncmUgbm90IHN1cHBvc2VkIHRvIHVzZSB0aGlzXG4gICBtb2R1bGUgYW55d2F5LiAqKVxubGV0IGFycmF5IGNtcCBhcnIgPVxuICBsZXQgcmVjIHFzb3J0IGxvIGhpID1cbiAgICBpZiBoaSAtIGxvID49IDYgdGhlbiBiZWdpblxuICAgICAgbGV0IG1pZCA9IChsbyArIGhpKSBsc3IgMSBpblxuICAgICAgKCogU2VsZWN0IG1lZGlhbiB2YWx1ZSBmcm9tIGFtb25nIExPLCBNSUQsIGFuZCBISS4gUmVhcnJhbmdlXG4gICAgICAgICBMTyBhbmQgSEkgc28gdGhlIHRocmVlIHZhbHVlcyBhcmUgc29ydGVkLiBUaGlzIGxvd2VycyB0aGVcbiAgICAgICAgIHByb2JhYmlsaXR5IG9mIHBpY2tpbmcgYSBwYXRob2xvZ2ljYWwgcGl2b3QuICBJdCBhbHNvXG4gICAgICAgICBhdm9pZHMgZXh0cmEgY29tcGFyaXNvbnMgb24gaSBhbmQgaiBpbiB0aGUgdHdvIHRpZ2h0IFwid2hpbGVcIlxuICAgICAgICAgbG9vcHMgYmVsb3cuICopXG4gICAgICBpZiBjbXAgKHVuc2FmZV9nZXQgYXJyIG1pZCkgKHVuc2FmZV9nZXQgYXJyIGxvKSB0aGVuIHN3YXAgYXJyIG1pZCBsbztcbiAgICAgIGlmIGNtcCAodW5zYWZlX2dldCBhcnIgaGkpICh1bnNhZmVfZ2V0IGFyciBtaWQpIHRoZW4gYmVnaW5cbiAgICAgICAgc3dhcCBhcnIgbWlkIGhpO1xuICAgICAgICBpZiBjbXAgKHVuc2FmZV9nZXQgYXJyIG1pZCkgKHVuc2FmZV9nZXQgYXJyIGxvKSB0aGVuIHN3YXAgYXJyIG1pZCBsb1xuICAgICAgZW5kO1xuICAgICAgbGV0IHBpdm90ID0gdW5zYWZlX2dldCBhcnIgbWlkIGluXG4gICAgICBsZXQgaSA9IHJlZiAobG8gKyAxKSBhbmQgaiA9IHJlZiAoaGkgLSAxKSBpblxuICAgICAgaWYgbm90IChjbXAgcGl2b3QgKHVuc2FmZV9nZXQgYXJyIGhpKSlcbiAgICAgICAgIHx8IG5vdCAoY21wICh1bnNhZmVfZ2V0IGFyciBsbykgcGl2b3QpXG4gICAgICB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiU29ydC5hcnJheVwiKTtcbiAgICAgIHdoaWxlICFpIDwgIWogZG9cbiAgICAgICAgd2hpbGUgbm90IChjbXAgcGl2b3QgKHVuc2FmZV9nZXQgYXJyICFpKSkgZG8gaW5jciBpIGRvbmU7XG4gICAgICAgIHdoaWxlIG5vdCAoY21wICh1bnNhZmVfZ2V0IGFyciAhaikgcGl2b3QpIGRvIGRlY3IgaiBkb25lO1xuICAgICAgICBpZiAhaSA8ICFqIHRoZW4gc3dhcCBhcnIgIWkgIWo7XG4gICAgICAgIGluY3IgaTsgZGVjciBqXG4gICAgICBkb25lO1xuICAgICAgKCogUmVjdXJzaW9uIG9uIHNtYWxsZXIgaGFsZiwgdGFpbC1jYWxsIG9uIGxhcmdlciBoYWxmICopXG4gICAgICBpZiAhaiAtIGxvIDw9IGhpIC0gIWkgdGhlbiBiZWdpblxuICAgICAgICBxc29ydCBsbyAhajsgcXNvcnQgIWkgaGlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHFzb3J0ICFpIGhpOyBxc29ydCBsbyAhalxuICAgICAgZW5kXG4gICAgZW5kIGluXG4gIHFzb3J0IDAgKEFycmF5Lmxlbmd0aCBhcnIgLSAxKTtcbiAgKCogRmluaXNoIHNvcnRpbmcgYnkgaW5zZXJ0aW9uIHNvcnQgKilcbiAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnIgLSAxIGRvXG4gICAgbGV0IHZhbF9pID0gKHVuc2FmZV9nZXQgYXJyIGkpIGluXG4gICAgaWYgbm90IChjbXAgKHVuc2FmZV9nZXQgYXJyIChpIC0gMSkpIHZhbF9pKSB0aGVuIGJlZ2luXG4gICAgICB1bnNhZmVfc2V0IGFyciBpICh1bnNhZmVfZ2V0IGFyciAoaSAtIDEpKTtcbiAgICAgIGxldCBqID0gcmVmIChpIC0gMSkgaW5cbiAgICAgIHdoaWxlICFqID49IDEgJiYgbm90IChjbXAgKHVuc2FmZV9nZXQgYXJyICghaiAtIDEpKSB2YWxfaSkgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgIWogKHVuc2FmZV9nZXQgYXJyICghaiAtIDEpKTtcbiAgICAgICAgZGVjciBqXG4gICAgICBkb25lO1xuICAgICAgdW5zYWZlX3NldCBhcnIgIWogdmFsX2lcbiAgICBlbmRcbiAgZG9uZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGV4dGVybl9mbGFncyA9XG4gICAgTm9fc2hhcmluZ1xuICB8IENsb3N1cmVzXG4gIHwgQ29tcGF0XzMyXG4oKiBub3RlOiB0aGlzIHR5cGUgZGVmaW5pdGlvbiBpcyB1c2VkIGluICdieXRlcnVuL2RlYnVnZ2VyLmMnICopXG5cbmV4dGVybmFsIHRvX2NoYW5uZWw6IG91dF9jaGFubmVsIC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVcIlxuZXh0ZXJuYWwgdG9fYnl0ZXM6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGJ5dGVzXG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzXCJcbmV4dGVybmFsIHRvX3N0cmluZzogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gc3RyaW5nXG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB0b19idWZmZXJfdW5zYWZlOlxuICAgICAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBpbnRcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXCJcblxubGV0IHRvX2J1ZmZlciBidWZmIG9mcyBsZW4gdiBmbGFncyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC50b19idWZmZXI6IHN1YnN0cmluZyBvdXQgb2YgYm91bmRzXCJcbiAgZWxzZSB0b19idWZmZXJfdW5zYWZlIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzXG5cbigqIFRoZSBmdW5jdGlvbnMgYmVsb3cgdXNlIGJ5dGUgc2VxdWVuY2VzIGFzIGlucHV0LCBuZXZlciB1c2luZyBhbnlcbiAgIG11dGF0aW9uLiBJdCBtYWtlcyBzZW5zZSB0byB1c2Ugbm9uLW11dGF0ZWQgW2J5dGVzXSByYXRoZXIgdGhhblxuICAgW3N0cmluZ10sIGJlY2F1c2Ugd2UgcmVhbGx5IHdvcmsgd2l0aCBzZXF1ZW5jZXMgb2YgYnl0ZXMsIG5vdFxuICAgYSB0ZXh0IHJlcHJlc2VudGF0aW9uLlxuKilcblxuZXh0ZXJuYWwgZnJvbV9jaGFubmVsOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIGZyb21fYnl0ZXNfdW5zYWZlOiBieXRlcyAtPiBpbnQgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlc1wiXG5leHRlcm5hbCBkYXRhX3NpemVfdW5zYWZlOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX21hcnNoYWxfZGF0YV9zaXplXCJcblxubGV0IGhlYWRlcl9zaXplID0gMjBcbmxldCBkYXRhX3NpemUgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZGF0YV9zaXplXCJcbiAgZWxzZSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzXG5sZXQgdG90YWxfc2l6ZSBidWZmIG9mcyA9IGhlYWRlcl9zaXplICsgZGF0YV9zaXplIGJ1ZmYgb2ZzXG5cbmxldCBmcm9tX2J5dGVzIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IGxlbiA9IGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnMgaW5cbiAgICBpZiBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIChoZWFkZXJfc2l6ZSArIGxlbilcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgICBlbHNlIGZyb21fYnl0ZXNfdW5zYWZlIGJ1ZmYgb2ZzXG4gIGVuZFxuXG5sZXQgZnJvbV9zdHJpbmcgYnVmZiBvZnMgPVxuICAoKiBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGlzIHNhZmUgaGVyZSwgYXMgdGhlIHByb2R1Y2VkIGJ5dGVcbiAgICAgc2VxdWVuY2UgaXMgbmV2ZXIgbXV0YXRlZCAqKVxuICBmcm9tX2J5dGVzIChCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGJ1ZmYpIG9mc1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBPcGVyYXRpb25zIG9uIGludGVybmFsIHJlcHJlc2VudGF0aW9ucyBvZiB2YWx1ZXMgKilcblxudHlwZSB0XG5cbmV4dGVybmFsIHJlcHIgOiAnYSAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgb2JqIDogdCAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG1hZ2ljIDogJ2EgLT4gJ2IgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBpc19pbnQgOiB0IC0+IGJvb2wgPSBcIiVvYmpfaXNfaW50XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGlzX2Jsb2NrIGEgPSBub3QgKGlzX2ludCBhKVxuZXh0ZXJuYWwgdGFnIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3RhZ1wiXG5leHRlcm5hbCBzZXRfdGFnIDogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfc2V0X3RhZ1wiXG5leHRlcm5hbCBzaXplIDogdCAtPiBpbnQgPSBcIiVvYmpfc2l6ZVwiXG5leHRlcm5hbCByZWFjaGFibGVfd29yZHMgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzXCJcbmV4dGVybmFsIGZpZWxkIDogdCAtPiBpbnQgLT4gdCA9IFwiJW9ial9maWVsZFwiXG5leHRlcm5hbCBzZXRfZmllbGQgOiB0IC0+IGludCAtPiB0IC0+IHVuaXQgPSBcIiVvYmpfc2V0X2ZpZWxkXCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRhcnJheV9nZXRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9zZXQgOlxuICAgIGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcImNhbWxfZmxvYXRhcnJheV9zZXRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gZG91YmxlX2ZpZWxkIHggaSA9IGZsb2F0YXJyYXlfZ2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGlcbmxldCBbQGlubGluZSBhbHdheXNdIHNldF9kb3VibGVfZmllbGQgeCBpIHYgPVxuICBmbG9hdGFycmF5X3NldCAob2JqIHggOiBmbG9hdGFycmF5KSBpIHZcbmV4dGVybmFsIG5ld19ibG9jayA6IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9vYmpfYmxvY2tcIlxuZXh0ZXJuYWwgZHVwIDogdCAtPiB0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5leHRlcm5hbCBhZGRfb2Zmc2V0IDogdCAtPiBJbnQzMi50IC0+IHQgPSBcImNhbWxfb2JqX2FkZF9vZmZzZXRcIlxuXG5sZXQgbWFyc2hhbCAob2JqIDogdCkgPVxuICBNYXJzaGFsLnRvX2J5dGVzIG9iaiBbXVxubGV0IHVubWFyc2hhbCBzdHIgcG9zID1cbiAgKE1hcnNoYWwuZnJvbV9ieXRlcyBzdHIgcG9zLCBwb3MgKyBNYXJzaGFsLnRvdGFsX3NpemUgc3RyIHBvcylcblxubGV0IGZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWcgPSAwXG5sZXQgbGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMjQ1XG5cbmxldCBsYXp5X3RhZyA9IDI0NlxubGV0IGNsb3N1cmVfdGFnID0gMjQ3XG5sZXQgb2JqZWN0X3RhZyA9IDI0OFxubGV0IGluZml4X3RhZyA9IDI0OVxubGV0IGZvcndhcmRfdGFnID0gMjUwXG5cbmxldCBub19zY2FuX3RhZyA9IDI1MVxuXG5sZXQgYWJzdHJhY3RfdGFnID0gMjUxXG5sZXQgc3RyaW5nX3RhZyA9IDI1MlxubGV0IGRvdWJsZV90YWcgPSAyNTNcbmxldCBkb3VibGVfYXJyYXlfdGFnID0gMjU0XG5sZXQgY3VzdG9tX3RhZyA9IDI1NVxubGV0IGZpbmFsX3RhZyA9IGN1c3RvbV90YWdcblxuXG5sZXQgaW50X3RhZyA9IDEwMDBcbmxldCBvdXRfb2ZfaGVhcF90YWcgPSAxMDAxXG5sZXQgdW5hbGlnbmVkX3RhZyA9IDEwMDJcblxubGV0IGV4dGVuc2lvbl9jb25zdHJ1Y3RvciB4ID1cbiAgbGV0IHggPSByZXByIHggaW5cbiAgbGV0IHNsb3QgPVxuICAgIGlmIChpc19ibG9jayB4KSAmJiAodGFnIHgpIDw+IG9iamVjdF90YWcgJiYgKHNpemUgeCkgPj0gMSB0aGVuIGZpZWxkIHggMFxuICAgIGVsc2UgeFxuICBpblxuICBsZXQgbmFtZSA9XG4gICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuICBpblxuICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogZXh0ZW5zaW9uX2NvbnN0cnVjdG9yKVxuICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxubGV0IFtAaW5saW5lIGFsd2F5c10gZXh0ZW5zaW9uX25hbWUgKHNsb3QgOiBleHRlbnNpb25fY29uc3RydWN0b3IpID1cbiAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMCkgOiBzdHJpbmcpXG5cbmxldCBbQGlubGluZSBhbHdheXNdIGV4dGVuc2lvbl9pZCAoc2xvdCA6IGV4dGVuc2lvbl9jb25zdHJ1Y3RvcikgPVxuICAob2JqIChmaWVsZCAocmVwciBzbG90KSAxKSA6IGludClcblxubW9kdWxlIEVwaGVtZXJvbiA9IHN0cnVjdFxuICB0eXBlIG9ial90ID0gdFxuXG4gIHR5cGUgdCAoKiogZXBoZW1lcm9uICopXG5cbiAgZXh0ZXJuYWwgY3JlYXRlOiBpbnQgLT4gdCA9IFwiY2FtbF9lcGhlX2NyZWF0ZVwiXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gMlxuXG4gIGV4dGVybmFsIGdldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlcIlxuICBleHRlcm5hbCBnZXRfa2V5X2NvcHk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlfY29weVwiXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgZXh0ZXJuYWwgdW5zZXRfa2V5OiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgZXh0ZXJuYWwgYmxpdF9rZXkgOiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgID0gXCJjYW1sX2VwaGVfYmxpdF9rZXlcIlxuXG4gIGV4dGVybmFsIGdldF9kYXRhOiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhXCJcbiAgZXh0ZXJuYWwgZ2V0X2RhdGFfY29weTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XCJcbiAgZXh0ZXJuYWwgc2V0X2RhdGE6IHQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9kYXRhXCJcbiAgZXh0ZXJuYWwgdW5zZXRfZGF0YTogdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfZGF0YVwiXG4gIGV4dGVybmFsIGNoZWNrX2RhdGE6IHQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2RhdGFcIlxuICBleHRlcm5hbCBibGl0X2RhdGEgOiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX2JsaXRfZGF0YVwiXG5cblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgIE5pY29sYXMgT2plZGEgQmFyLCBMZXhpRmkgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIG5lZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgYWRkIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCBzdWIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsIG11bCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgZGl2IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCByZW0gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFicyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxubGV0IGluZmluaXR5ID0gUGVydmFzaXZlcy5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFBlcnZhc2l2ZXMubmVnX2luZmluaXR5XG5sZXQgbmFuID0gUGVydmFzaXZlcy5uYW5cbmxldCBwaSA9IDB4MS45MjFmYjU0NDQyZDE4cCsxXG5sZXQgbWF4X2Zsb2F0ID0gUGVydmFzaXZlcy5tYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBQZXJ2YXNpdmVzLm1pbl9mbG9hdFxubGV0IGVwc2lsb24gPSBQZXJ2YXNpdmVzLmVwc2lsb25fZmxvYXRcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmdfb3B0ID0gUGVydmFzaXZlcy5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fc3RyaW5nID0gUGVydmFzaXZlcy5zdHJpbmdfb2ZfZmxvYXRcbnR5cGUgZnBjbGFzcyA9IFBlcnZhc2l2ZXMuZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcG93IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxudHlwZSB0ID0gZmxvYXRcbmV4dGVybmFsIGNvbXBhcmUgOiBmbG9hdCAtPiBmbG9hdCAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmxldCBlcXVhbCB4IHkgPSBjb21wYXJlIHggeSA9IDBcbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiBpbnQgLT4gZmxvYXQgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG4gIHR5cGUgdCA9IGZsb2F0YXJyYXlcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCBsZW5ndGggOiB0IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIGNyZWF0ZV9mbG9hdDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG5sZXQgbWFrZV9mbG9hdCA9IGNyZWF0ZV9mbG9hdFxuXG5tb2R1bGUgRmxvYXRhcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gZmxvYXRhcnJheSA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IGZsb2F0YXJyYXkgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5lbmRcblxubGV0IGluaXQgbCBmID1cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2VcbiAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRcIlxuICAoKiBTZWUgIzY1NzUuIFdlIGNvdWxkIGFsc28gY2hlY2sgZm9yIG1heGltdW0gYXJyYXkgc2l6ZSwgYnV0IHRoaXMgZGVwZW5kc1xuICAgICBvbiB3aGV0aGVyIHdlIGNyZWF0ZSBhIGZsb2F0IGFycmF5IG9yIGEgcmVndWxhciBvbmUuLi4gKilcbiAgZWxzZVxuICAgbGV0IHJlcyA9IGNyZWF0ZSBsIChmIDApIGluXG4gICBmb3IgaSA9IDEgdG8gcHJlZCBsIGRvXG4gICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgIGRvbmU7XG4gICByZXNcblxubGV0IG1ha2VfbWF0cml4IHN4IHN5IGluaXQgPVxuICBsZXQgcmVzID0gY3JlYXRlIHN4IFt8fF0gaW5cbiAgZm9yIHggPSAwIHRvIHByZWQgc3ggZG9cbiAgICB1bnNhZmVfc2V0IHJlcyB4IChjcmVhdGUgc3kgaW5pdClcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBjcmVhdGVfbWF0cml4ID0gbWFrZV9tYXRyaXhcblxubGV0IGNvcHkgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW4gaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgdW5zYWZlX3N1YiBhIDAgbFxuXG5sZXQgYXBwZW5kIGExIGEyID1cbiAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gIGlmIGwxID0gMCB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsZW5ndGggYTIgPSAwIHRoZW4gdW5zYWZlX3N1YiBhMSAwIGwxXG4gIGVsc2UgYXBwZW5kX3ByaW0gYTEgYTJcblxubGV0IHN1YiBhIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LnN1YlwiXG4gIGVsc2UgdW5zYWZlX3N1YiBhIG9mcyBsZW5cblxubGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZpbGxcIlxuICBlbHNlIGZvciBpID0gb2ZzIHRvIG9mcyArIGxlbiAtIDEgZG8gdW5zYWZlX3NldCBhIGkgdiBkb25lXG5cbmxldCBibGl0IGExIG9mczEgYTIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggYTEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIGEyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuXG5cbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgaXRlcjIgZiBhIGIgPVxuICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbmxldCBtYXAgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcDIgZiBhIGIgPVxuICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2UgYmVnaW5cbiAgICBpZiBsYSA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIChmICh1bnNhZmVfZ2V0IGEgMCkgKHVuc2FmZV9nZXQgYiAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcbiAgZW5kXG5cbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IG1hcGkgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYgMCAodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHRvX2xpc3QgYSA9XG4gIGxldCByZWMgdG9saXN0IGkgcmVzID1cbiAgICBpZiBpIDwgMCB0aGVuIHJlcyBlbHNlIHRvbGlzdCAoaSAtIDEpICh1bnNhZmVfZ2V0IGEgaSA6OiByZXMpIGluXG4gIHRvbGlzdCAobGVuZ3RoIGEgLSAxKSBbXVxuXG4oKiBDYW5ub3QgdXNlIExpc3QubGVuZ3RoIGhlcmUgYmVjYXVzZSB0aGUgTGlzdCBtb2R1bGUgZGVwZW5kcyBvbiBBcnJheS4gKilcbmxldCByZWMgbGlzdF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjdVxuICB8IF86OnQgLT4gbGlzdF9sZW5ndGggKHN1Y2MgYWNjdSkgdFxuXG5sZXQgb2ZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgYSA9IGNyZWF0ZSAobGlzdF9sZW5ndGggMCBsKSBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGkrMSkgdGwgaW5cbiAgICAgIGZpbGwgMSB0bFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW1xIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHggPT0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG5sZXQgc29ydCBjbXAgYSA9XG4gIGxldCBtYXhzb24gbCBpID1cbiAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICF4XG4gICAgZW5kIGVsc2VcbiAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgdGhlbiBpMzErMVxuICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICBpblxuICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgIGJ1YmJsZWRvd24gbCBqXG4gIGluXG4gIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgZG9uZTtcbiAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuXG5sZXQgY3V0b2ZmID0gNVxubGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICBlbmRcbiAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgaW5cbiAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgZGVjciBqO1xuICAgICAgZG9uZTtcbiAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICBkb25lO1xuICBpblxuICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgbGV0IHQgPSBtYWtlIGwyIChnZXQgYSAwKSBpblxuICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICBlbmRcblxuXG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCoqIHs2IEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgb2ZfcmV2X2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGxlbiA9IGxpc3RfbGVuZ3RoIDAgbCBpblxuICAgICAgbGV0IGEgPSBjcmVhdGUgbGVuIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgICAgaW5cbiAgICAgIGZpbGwgKGxlbi0yKSB0bFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgb2ZfcmV2X2xpc3QgbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDMyXTogMzItYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDMyIC0+IGludCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl90b19mbG9hdFwiIFwiY2FtbF9pbnQzMl90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgemVybyA9IDBsXG5sZXQgb25lID0gMWxcbmxldCBtaW51c19vbmUgPSAtMWxcbmxldCBzdWNjIG4gPSBhZGQgbiAxbFxubGV0IHByZWQgbiA9IHN1YiBuIDFsXG5sZXQgYWJzIG4gPSBpZiBuID49IDBsIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDBsXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZsXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFsKVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBpbnQzMlxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gUGVydmFzaXZlcy5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHBhcnNpbmcgZW5naW5lICopXG5cbm9wZW4gTGV4aW5nXG5cbigqIEludGVybmFsIGludGVyZmFjZSB0byB0aGUgcGFyc2luZyBlbmdpbmUgKilcblxudHlwZSBwYXJzZXJfZW52ID1cbiAgeyBtdXRhYmxlIHNfc3RhY2sgOiBpbnQgYXJyYXk7ICAgICAgICAoKiBTdGF0ZXMgKilcbiAgICBtdXRhYmxlIHZfc3RhY2sgOiBPYmoudCBhcnJheTsgICAgICAoKiBTZW1hbnRpYyBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0X3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICgqIFN0YXJ0IHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3ltYl9lbmRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgICAoKiBFbmQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzdGFja3NpemUgOiBpbnQ7ICAgICAgICAgICAgKCogU2l6ZSBvZiB0aGUgc3RhY2tzICopXG4gICAgbXV0YWJsZSBzdGFja2Jhc2UgOiBpbnQ7ICAgICAgICAgICAgKCogQmFzZSBzcCBmb3IgY3VycmVudCBwYXJzZSAqKVxuICAgIG11dGFibGUgY3Vycl9jaGFyIDogaW50OyAgICAgICAgICAgICgqIExhc3QgdG9rZW4gcmVhZCAqKVxuICAgIG11dGFibGUgbHZhbCA6IE9iai50OyAgICAgICAgICAgICAgICgqIEl0cyBzZW1hbnRpYyBhdHRyaWJ1dGUgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnQgOiBwb3NpdGlvbjsgICAgICAoKiBTdGFydCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCopXG4gICAgbXV0YWJsZSBzeW1iX2VuZCA6IHBvc2l0aW9uOyAgICAgICAgKCogRW5kIHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sICopXG4gICAgbXV0YWJsZSBhc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogVGhlIHN0YWNrIHBvaW50ZXIgZm9yIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHJ1bGVfbGVuIDogaW50OyAgICAgICAgICAgICAoKiBOdW1iZXIgb2YgcmhzIGl0ZW1zIGluIHRoZSBydWxlICopXG4gICAgbXV0YWJsZSBydWxlX251bWJlciA6IGludDsgICAgICAgICAgKCogUnVsZSBudW1iZXIgdG8gcmVkdWNlIGJ5ICopXG4gICAgbXV0YWJsZSBzcCA6IGludDsgICAgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3AgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgc3RhdGUgOiBpbnQ7ICAgICAgICAgICAgICAgICgqIFNhdmVkIHN0YXRlIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIGVycmZsYWcgOiBpbnQgfSAgICAgICAgICAgICAoKiBTYXZlZCBlcnJvciBmbGFnIGZvciBwYXJzZV9lbmdpbmUgKilcblxudHlwZSBwYXJzZV90YWJsZXMgPVxuICB7IGFjdGlvbnMgOiAocGFyc2VyX2VudiAtPiBPYmoudCkgYXJyYXk7XG4gICAgdHJhbnNsX2NvbnN0IDogaW50IGFycmF5O1xuICAgIHRyYW5zbF9ibG9jayA6IGludCBhcnJheTtcbiAgICBsaHMgOiBzdHJpbmc7XG4gICAgbGVuIDogc3RyaW5nO1xuICAgIGRlZnJlZCA6IHN0cmluZztcbiAgICBkZ290byA6IHN0cmluZztcbiAgICBzaW5kZXggOiBzdHJpbmc7XG4gICAgcmluZGV4IDogc3RyaW5nO1xuICAgIGdpbmRleCA6IHN0cmluZztcbiAgICB0YWJsZXNpemUgOiBpbnQ7XG4gICAgdGFibGUgOiBzdHJpbmc7XG4gICAgY2hlY2sgOiBzdHJpbmc7XG4gICAgZXJyb3JfZnVuY3Rpb24gOiBzdHJpbmcgLT4gdW5pdDtcbiAgICBuYW1lc19jb25zdCA6IHN0cmluZztcbiAgICBuYW1lc19ibG9jayA6IHN0cmluZyB9XG5cbmV4Y2VwdGlvbiBZWWV4aXQgb2YgT2JqLnRcbmV4Y2VwdGlvbiBQYXJzZV9lcnJvclxuXG50eXBlIHBhcnNlcl9pbnB1dCA9XG4gICAgU3RhcnRcbiAgfCBUb2tlbl9yZWFkXG4gIHwgU3RhY2tzX2dyb3duXzFcbiAgfCBTdGFja3NfZ3Jvd25fMlxuICB8IFNlbWFudGljX2FjdGlvbl9jb21wdXRlZFxuICB8IEVycm9yX2RldGVjdGVkXG5cbnR5cGUgcGFyc2VyX291dHB1dCA9XG4gICAgUmVhZF90b2tlblxuICB8IFJhaXNlX3BhcnNlX2Vycm9yXG4gIHwgR3Jvd19zdGFja3NfMVxuICB8IEdyb3dfc3RhY2tzXzJcbiAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvblxuICB8IENhbGxfZXJyb3JfZnVuY3Rpb25cblxuKCogdG8gYXZvaWQgd2FybmluZ3MgKilcbmxldCBfID0gW1JlYWRfdG9rZW47IFJhaXNlX3BhcnNlX2Vycm9yOyBHcm93X3N0YWNrc18xOyBHcm93X3N0YWNrc18yO1xuICAgICAgICAgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb247IENhbGxfZXJyb3JfZnVuY3Rpb25dXG5cbmV4dGVybmFsIHBhcnNlX2VuZ2luZSA6XG4gICAgcGFyc2VfdGFibGVzIC0+IHBhcnNlcl9lbnYgLT4gcGFyc2VyX2lucHV0IC0+IE9iai50IC0+IHBhcnNlcl9vdXRwdXRcbiAgICA9IFwiY2FtbF9wYXJzZV9lbmdpbmVcIlxuXG5leHRlcm5hbCBzZXRfdHJhY2U6IGJvb2wgLT4gYm9vbFxuICAgID0gXCJjYW1sX3NldF9wYXJzZXJfdHJhY2VcIlxuXG5sZXQgZW52ID1cbiAgeyBzX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgMDtcbiAgICB2X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgKE9iai5yZXByICgpKTtcbiAgICBzeW1iX3N0YXJ0X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN0YWNrc2l6ZSA9IDEwMDtcbiAgICBzdGFja2Jhc2UgPSAwO1xuICAgIGN1cnJfY2hhciA9IDA7XG4gICAgbHZhbCA9IE9iai5yZXByICgpO1xuICAgIHN5bWJfc3RhcnQgPSBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmQgPSBkdW1teV9wb3M7XG4gICAgYXNwID0gMDtcbiAgICBydWxlX2xlbiA9IDA7XG4gICAgcnVsZV9udW1iZXIgPSAwO1xuICAgIHNwID0gMDtcbiAgICBzdGF0ZSA9IDA7XG4gICAgZXJyZmxhZyA9IDAgfVxuXG5sZXQgZ3Jvd19zdGFja3MoKSA9XG4gIGxldCBvbGRzaXplID0gZW52LnN0YWNrc2l6ZSBpblxuICBsZXQgbmV3c2l6ZSA9IG9sZHNpemUgKiAyIGluXG4gIGxldCBuZXdfcyA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAwXG4gIGFuZCBuZXdfdiA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAoT2JqLnJlcHIgKCkpXG4gIGFuZCBuZXdfc3RhcnQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zXG4gIGFuZCBuZXdfZW5kID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3BvcyBpblxuICAgIEFycmF5LmJsaXQgZW52LnNfc3RhY2sgMCBuZXdfcyAwIG9sZHNpemU7XG4gICAgZW52LnNfc3RhY2sgPC0gbmV3X3M7XG4gICAgQXJyYXkuYmxpdCBlbnYudl9zdGFjayAwIG5ld192IDAgb2xkc2l6ZTtcbiAgICBlbnYudl9zdGFjayA8LSBuZXdfdjtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX3N0YXJ0X3N0YWNrIDAgbmV3X3N0YXJ0IDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9zdGFydF9zdGFjayA8LSBuZXdfc3RhcnQ7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9lbmRfc3RhY2sgMCBuZXdfZW5kIDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9lbmRfc3RhY2sgPC0gbmV3X2VuZDtcbiAgICBlbnYuc3RhY2tzaXplIDwtIG5ld3NpemVcblxubGV0IGNsZWFyX3BhcnNlcigpID1cbiAgQXJyYXkuZmlsbCBlbnYudl9zdGFjayAwIGVudi5zdGFja3NpemUgKE9iai5yZXByICgpKTtcbiAgZW52Lmx2YWwgPC0gT2JqLnJlcHIgKClcblxubGV0IGN1cnJlbnRfbG9va2FoZWFkX2Z1biA9IHJlZiAoZnVuIChfIDogT2JqLnQpIC0+IGZhbHNlKVxuXG5sZXQgeXlwYXJzZSB0YWJsZXMgc3RhcnQgbGV4ZXIgbGV4YnVmID1cbiAgbGV0IHJlYyBsb29wIGNtZCBhcmcgPVxuICAgIG1hdGNoIHBhcnNlX2VuZ2luZSB0YWJsZXMgZW52IGNtZCBhcmcgd2l0aFxuICAgICAgUmVhZF90b2tlbiAtPlxuICAgICAgICBsZXQgdCA9IE9iai5yZXByKGxleGVyIGxleGJ1ZikgaW5cbiAgICAgICAgZW52LnN5bWJfc3RhcnQgPC0gbGV4YnVmLmxleF9zdGFydF9wO1xuICAgICAgICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gICAgICAgIGxvb3AgVG9rZW5fcmVhZCB0XG4gICAgfCBSYWlzZV9wYXJzZV9lcnJvciAtPlxuICAgICAgICByYWlzZSBQYXJzZV9lcnJvclxuICAgIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb24gLT5cbiAgICAgICAgbGV0IChhY3Rpb24sIHZhbHVlKSA9XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICAoU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkLCB0YWJsZXMuYWN0aW9ucy4oZW52LnJ1bGVfbnVtYmVyKSBlbnYpXG4gICAgICAgICAgd2l0aCBQYXJzZV9lcnJvciAtPlxuICAgICAgICAgICAgKEVycm9yX2RldGVjdGVkLCBPYmoucmVwciAoKSkgaW5cbiAgICAgICAgbG9vcCBhY3Rpb24gdmFsdWVcbiAgICB8IEdyb3dfc3RhY2tzXzEgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMSAoT2JqLnJlcHIgKCkpXG4gICAgfCBHcm93X3N0YWNrc18yIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzIgKE9iai5yZXByICgpKVxuICAgIHwgQ2FsbF9lcnJvcl9mdW5jdGlvbiAtPlxuICAgICAgICB0YWJsZXMuZXJyb3JfZnVuY3Rpb24gXCJzeW50YXggZXJyb3JcIjtcbiAgICAgICAgbG9vcCBFcnJvcl9kZXRlY3RlZCAoT2JqLnJlcHIgKCkpIGluXG4gIGxldCBpbml0X2FzcCA9IGVudi5hc3BcbiAgYW5kIGluaXRfc3AgPSBlbnYuc3BcbiAgYW5kIGluaXRfc3RhY2tiYXNlID0gZW52LnN0YWNrYmFzZVxuICBhbmQgaW5pdF9zdGF0ZSA9IGVudi5zdGF0ZVxuICBhbmQgaW5pdF9jdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyXG4gIGFuZCBpbml0X2x2YWwgPSBlbnYubHZhbFxuICBhbmQgaW5pdF9lcnJmbGFnID0gZW52LmVycmZsYWcgaW5cbiAgZW52LnN0YWNrYmFzZSA8LSBlbnYuc3AgKyAxO1xuICBlbnYuY3Vycl9jaGFyIDwtIHN0YXJ0O1xuICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gIHRyeVxuICAgIGxvb3AgU3RhcnQgKE9iai5yZXByICgpKVxuICB3aXRoIGV4biAtPlxuICAgIGxldCBjdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyIGluXG4gICAgZW52LmFzcCA8LSBpbml0X2FzcDtcbiAgICBlbnYuc3AgPC0gaW5pdF9zcDtcbiAgICBlbnYuc3RhY2tiYXNlIDwtIGluaXRfc3RhY2tiYXNlO1xuICAgIGVudi5zdGF0ZSA8LSBpbml0X3N0YXRlO1xuICAgIGVudi5jdXJyX2NoYXIgPC0gaW5pdF9jdXJyX2NoYXI7XG4gICAgZW52Lmx2YWwgPC0gaW5pdF9sdmFsO1xuICAgIGVudi5lcnJmbGFnIDwtIGluaXRfZXJyZmxhZztcbiAgICBtYXRjaCBleG4gd2l0aFxuICAgICAgWVlleGl0IHYgLT5cbiAgICAgICAgT2JqLm1hZ2ljIHZcbiAgICB8IF8gLT5cbiAgICAgICAgY3VycmVudF9sb29rYWhlYWRfZnVuIDo9XG4gICAgICAgICAgKGZ1biB0b2sgLT5cbiAgICAgICAgICAgIGlmIE9iai5pc19ibG9jayB0b2tcbiAgICAgICAgICAgIHRoZW4gdGFibGVzLnRyYW5zbF9ibG9jay4oT2JqLnRhZyB0b2spID0gY3Vycl9jaGFyXG4gICAgICAgICAgICBlbHNlIHRhYmxlcy50cmFuc2xfY29uc3QuKE9iai5tYWdpYyB0b2spID0gY3Vycl9jaGFyKTtcbiAgICAgICAgcmFpc2UgZXhuXG5cbmxldCBwZWVrX3ZhbCBlbnYgbiA9XG4gIE9iai5tYWdpYyBlbnYudl9zdGFjay4oZW52LmFzcCAtIG4pXG5cbmxldCBzeW1ib2xfc3RhcnRfcG9zICgpID1cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPD0gMCB0aGVuIGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgc3QgPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgbGV0IGVuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBpZiBzdCA8PiBlbiB0aGVuIHN0IGVsc2UgbG9vcCAoaSAtIDEpXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgZW52LnJ1bGVfbGVuXG5cbmxldCBzeW1ib2xfZW5kX3BvcyAoKSA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbmxldCByaHNfc3RhcnRfcG9zIG4gPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcbmxldCByaHNfZW5kX3BvcyBuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxuXG5sZXQgc3ltYm9sX3N0YXJ0ICgpID0gKHN5bWJvbF9zdGFydF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgc3ltYm9sX2VuZCAoKSA9IChzeW1ib2xfZW5kX3BvcyAoKSkucG9zX2NudW1cbmxldCByaHNfc3RhcnQgbiA9IChyaHNfc3RhcnRfcG9zIG4pLnBvc19jbnVtXG5sZXQgcmhzX2VuZCBuID0gKHJoc19lbmRfcG9zIG4pLnBvc19jbnVtXG5cbmxldCBpc19jdXJyZW50X2xvb2thaGVhZCB0b2sgPVxuICAoIWN1cnJlbnRfbG9va2FoZWFkX2Z1bikoT2JqLnJlcHIgdG9rKVxuXG5sZXQgcGFyc2VfZXJyb3IgKF8gOiBzdHJpbmcpID0gKClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUgZWx0XG4gICAgdHlwZSB0XG4gICAgdmFsIGVtcHR5OiB0XG4gICAgdmFsIGlzX2VtcHR5OiB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiBlbHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGFkZDogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCBzaW5nbGV0b246IGVsdCAtPiB0XG4gICAgdmFsIHJlbW92ZTogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCB1bmlvbjogdCAtPiB0IC0+IHRcbiAgICB2YWwgaW50ZXI6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGRpZmY6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIHN1YnNldDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGVsdCAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgICB2YWwgbWFwOiAoZWx0IC0+IGVsdCkgLT4gdCAtPiB0XG4gICAgdmFsIGZvbGQ6IChlbHQgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgICB2YWwgZm9yX2FsbDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBmaWx0ZXI6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHQgKiB0XG4gICAgdmFsIGNhcmRpbmFsOiB0IC0+IGludFxuICAgIHZhbCBlbGVtZW50czogdCAtPiBlbHQgbGlzdFxuICAgIHZhbCBtaW5fZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtaW5fZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG1heF9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1heF9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiB0IC0+IGVsdFxuICAgIHZhbCBjaG9vc2Vfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGVsdCAtPiB0IC0+IHQgKiBib29sICogdFxuICAgIHZhbCBmaW5kOiBlbHQgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9vcHQ6IGVsdCAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG9mX2xpc3Q6IGVsdCBsaXN0IC0+IHRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBlbHQgLT4gdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgdG9fc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IGVsdCBTZXEudCAtPiB0IC0+IHRcbiAgICB2YWwgb2Zfc2VxIDogZWx0IFNlcS50IC0+IHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID1cbiAgc3RydWN0XG4gICAgdHlwZSBlbHQgPSBPcmQudFxuICAgIHR5cGUgdCA9IEVtcHR5IHwgTm9kZSBvZiB7bDp0OyB2OmVsdDsgcjp0OyBoOmludH1cblxuICAgICgqIFNldHMgYXJlIHJlcHJlc2VudGVkIGJ5IGJhbGFuY2VkIGJpbmFyeSB0cmVlcyAodGhlIGhlaWdodHMgb2YgdGhlXG4gICAgICAgY2hpbGRyZW4gZGlmZmVyIGJ5IGF0IG1vc3QgMiAqKVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICAgIGwgYW5kIHIgbXVzdCBiZSBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gICAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgICBsZXQgYmFsIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgICBsZXQgcmVjIGFkZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHQgZWxzZVxuICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0IGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0IGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHNpbmdsZXRvbiB4ID0gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgdiBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBlbGVtZW50cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBlbGVtZW50LlxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fZWxlbWVudCB4IGwpIHYgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgKGFkZF9tYXhfZWxlbWVudCB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9lbGVtZW50IHYgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfZWxlbWVudCB2IGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgcj1scjsgaD1saH0sIE5vZGV7bD1ybDsgdj1ydjsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IHJsKSBydiByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiByXG5cbiAgICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuXG4gICAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHQgbFxuXG4gICAgbGV0IHJlYyBtaW5fZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0X29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdCByXG5cbiAgICBsZXQgcmVjIG1heF9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHRfb3B0IHJcblxuICAgICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIEFzc3VtZSB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gYmFsIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGpvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIFNwbGl0dGluZy4gIHNwbGl0IHggcyByZXR1cm5zIGEgdHJpcGxlIChsLCBwcmVzZW50LCByKSB3aGVyZVxuICAgICAgICAtIGwgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlIDwgeFxuICAgICAgICAtIHIgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlID4geFxuICAgICAgICAtIHByZXNlbnQgaXMgZmFsc2UgaWYgcyBjb250YWlucyBubyBlbGVtZW50IGVxdWFsIHRvIHgsXG4gICAgICAgICAgb3IgdHJ1ZSBpZiBzIGNvbnRhaW5zIGFuIGVsZW1lbnQgZXF1YWwgdG8geC4gKilcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBmYWxzZSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIHRydWUsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGxyLCBwcmVzLCBycilcblxuICAgICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0gYXMgdCkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluXG4gICAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluXG4gICAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdDIpIC0+IHQyXG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjE7IGg9aDF9LCBOb2Rle2w9bDI7IHY9djI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMSB0aGVuIGFkZCB2MiBzMSBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDIsIF8sIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBoMSA9IDEgdGhlbiBhZGQgdjEgczIgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwxLCBfLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAoXywgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMilcblxuICAgIGxldCByZWMgZGlmZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChkaWZmIGwxIGwyKSB2MSAoZGlmZiByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpXG5cbiAgICB0eXBlIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBlbHQgKiB0ICogZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIHIsIGUpKVxuXG4gICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICB8IChNb3JlKHYxLCByMSwgZTEpLCBNb3JlKHYyLCByMiwgZTIpKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG5cbiAgICBsZXQgY29tcGFyZSBzMSBzMiA9XG4gICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHMxIEVuZCkgKGNvbnNfZW51bSBzMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgczEgczIgPVxuICAgICAgY29tcGFyZSBzMSBzMiA9IDBcblxuICAgIGxldCByZWMgc3Vic2V0IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgRW1wdHksIF8gLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IF8sIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bD1sMTsgdj12MTsgcj1yMX0sIChOb2RlIHtsPWwyOyB2PXYyOyByPXIyfSBhcyB0MikgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IGwxIGwyICYmIHN1YnNldCByMSByMlxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPWwxOyB2PXYxOyByPUVtcHR5OyBoPTB9KSBsMiAmJiBzdWJzZXQgcjEgdDJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9RW1wdHk7IHY9djE7IHI9cjE7IGg9MH0pIHIyICYmIHN1YnNldCBsMSB0MlxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGl0ZXIgZiBsOyBmIHY7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIGZvbGQgZiBzIGFjY3UgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBmb2xkIGYgciAoZiB2IChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2IHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9KSBhcyB0IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2IHRoZW5cbiAgICAgICAgICAgIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gdCBlbHNlIGpvaW4gbCcgdiByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdlxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IHJmKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZXtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZWxlbWVudHNfYXV4ICh2IDo6IGVsZW1lbnRzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBlbGVtZW50cyBzID1cbiAgICAgIGVsZW1lbnRzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2VsdFxuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fZWx0X29wdFxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB2XG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSB2XG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHRyeV9qb2luIGwgdiByID1cbiAgICAgICgqIFtqb2luIGwgdiByXSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiAoZWxlbWVudHMgb2YgbCA8IHYgPFxuICAgICAgICAgZWxlbWVudHMgb2Ygcik7IHVzZSBbdHJ5X2pvaW4gbCB2IHJdIHdoZW4gdGhpcyBwcm9wZXJ0eSBtYXlcbiAgICAgICAgIG5vdCBob2xkLCBidXQgeW91IGhvcGUgaXQgZG9lcyBob2xkIGluIHRoZSBjb21tb24gY2FzZSAqKVxuICAgICAgaWYgKGwgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSAobWF4X2VsdCBsKSB2IDwgMClcbiAgICAgICYmIChyID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgdiAobWluX2VsdCByKSA8IDApXG4gICAgICB0aGVuIGpvaW4gbCB2IHJcbiAgICAgIGVsc2UgdW5pb24gbCAoYWRkIHYgcilcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgIGlmIGwgPT0gbCcgJiYgdiA9PSB2JyAmJiByID09IHInIHRoZW4gdFxuICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuXG4gICAgbGV0IG9mX3NvcnRlZF9saXN0IGwgPVxuICAgICAgbGV0IHJlYyBzdWIgbiBsID1cbiAgICAgICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgICAgIHwgMCwgbCAtPiBFbXB0eSwgbFxuICAgICAgICB8IDEsIHgwIDo6IGwgLT4gTm9kZSB7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfSwgbFxuICAgICAgICB8IDIsIHgwIDo6IHgxIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7IHI9RW1wdHk7IGg9Mn0sIGxcbiAgICAgICAgfCAzLCB4MCA6OiB4MSA6OiB4MiA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxO1xuICAgICAgICAgICAgICAgICByPU5vZGV7bD1FbXB0eTsgdj14Mjsgcj1FbXB0eTsgaD0xfTsgaD0yfSwgbFxuICAgICAgICB8IG4sIGwgLT5cbiAgICAgICAgICBsZXQgbmwgPSBuIC8gMiBpblxuICAgICAgICAgIGxldCBsZWZ0LCBsID0gc3ViIG5sIGwgaW5cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgbWlkIDo6IGwgLT5cbiAgICAgICAgICAgIGxldCByaWdodCwgbCA9IHN1YiAobiAtIG5sIC0gMSkgbCBpblxuICAgICAgICAgICAgY3JlYXRlIGxlZnQgbWlkIHJpZ2h0LCBsXG4gICAgICBpblxuICAgICAgZnN0IChzdWIgKExpc3QubGVuZ3RoIGwpIGwpXG5cbiAgICBsZXQgb2ZfbGlzdCBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBlbXB0eVxuICAgICAgfCBbeDBdIC0+IHNpbmdsZXRvbiB4MFxuICAgICAgfCBbeDA7IHgxXSAtPiBhZGQgeDEgKHNpbmdsZXRvbiB4MClcbiAgICAgIHwgW3gwOyB4MTsgeDJdIC0+IGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDNdIC0+IGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDM7IHg0XSAtPiBhZGQgeDQgKGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKSlcbiAgICAgIHwgXyAtPiBvZl9zb3J0ZWRfbGlzdCAoTGlzdC5zb3J0X3VuaXEgT3JkLmNvbXBhcmUgbClcblxuICAgIGxldCBhZGRfc2VxIGkgbSA9XG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gcyB4IC0+IGFkZCB4IHMpIG0gaVxuXG4gICAgbGV0IG9mX3NlcSBpID0gYWRkX3NlcSBpIGVtcHR5XG5cbiAgICBsZXQgcmVjIHNlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKHgsIHQsIHJlc3QpIC0+IFNlcS5Db25zICh4LCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBjID0gc2VxX29mX2VudW1fIChjb25zX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IHMgPVxuICAgICAgbGV0IHJlYyBhdXggbG93IHMgYyA9IG1hdGNoIHMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyByOyB2OyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IHMgRW5kKVxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSArJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBpc19lbXB0eTogJ2EgdCAtPiBib29sXG4gICAgdmFsIG1lbTogIGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAgICAgKGtleSAtPiAnYSBvcHRpb24gLT4gJ2Igb3B0aW9uIC0+ICdjIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgcGFydGl0aW9uOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAqICdhIHRcbiAgICB2YWwgY2FyZGluYWw6ICdhIHQgLT4gaW50XG4gICAgdmFsIGJpbmRpbmdzOiAnYSB0IC0+IChrZXkgKiAnYSkgbGlzdFxuICAgIHZhbCBtaW5fYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1pbl9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXhfYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1heF9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBjaG9vc2U6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBjaG9vc2Vfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIHNwbGl0OiBrZXkgLT4gJ2EgdCAtPiAnYSB0ICogJ2Egb3B0aW9uICogJ2EgdFxuICAgIHZhbCBmaW5kOiBrZXkgLT4gJ2EgdCAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDoga2V5IC0+ICdhIHQgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXA6ICgnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIG1hcGk6IChrZXkgLT4gJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBrZXkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID0gc3RydWN0XG5cbiAgICB0eXBlIGtleSA9IE9yZC50XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIG9mIHtsOidhIHQ7IHY6a2V5OyBkOidhOyByOidhIHQ7IGg6aW50fVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgbGV0IGNyZWF0ZSBsIHggZCByID1cbiAgICAgIGxldCBobCA9IGhlaWdodCBsIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IHNpbmdsZXRvbiB4IGQgPSBOb2Rle2w9RW1wdHk7IHY9eDsgZDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgbGV0IGJhbCBsIHggZCByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiBsZCAoY3JlYXRlIGxyIHggZCByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgZD1scmQ7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyBkPXJsZDsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgYWRkIHggZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGRhdGEgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCBkYXRhIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGRcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGRcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfSAtPiBtaW5fYmluZGluZyBsXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0tPiBtaW5fYmluZGluZ19vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmcgclxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nX29wdCByXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiYWwgKHJlbW92ZV9taW5fYmluZGluZyBsKSB2IGQgclxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCAoTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpbiBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyB1cGRhdGUgeCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBFbXB0eVxuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgICAgICBlbmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gbWVyZ2UgbCByXG4gICAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVuZCBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHVwZGF0ZSB4IGYgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSB1cGRhdGUgeCBmIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaXRlciBmIGw7IGYgdiBkOyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgbWFwaSBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcGkgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXBpIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgZm9sZCBmIG0gYWNjdSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGZvbGQgZiByIChmIHYgZCAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgayBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBrZXlzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGtleS5cblxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2JpbmRpbmcgayB4IGwpIHYgZCByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgZCAoYWRkX21heF9iaW5kaW5nIGsgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgZCByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9iaW5kaW5nIHYgZCByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9iaW5kaW5nIHYgZCBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHI7IGg9bGh9LCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IGxkIChqb2luIGxyIHYgZCByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IGQgcmwpIHJ2IHJkIHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IGQgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGpvaW4gdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgY29uY2F0X29yX2pvaW4gdDEgdiBkIHQyID1cbiAgICAgIG1hdGNoIGQgd2l0aFxuICAgICAgfCBTb21lIGQgLT4gam9pbiB0MSB2IGQgdDJcbiAgICAgIHwgTm9uZSAtPiBjb25jYXQgdDEgdDJcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBOb25lLCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIFNvbWUgZCwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiBkIHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBkIGxyLCBwcmVzLCBycilcblxuICAgIGxldCByZWMgbWVyZ2UgZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSwgXykgd2hlbiBoMSA+PSBoZWlnaHQgczIgLT5cbiAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjEgKGYgdjEgKFNvbWUgZDEpIGQyKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgKF8sIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjJ9KSAtPlxuICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MiAoZiB2MiBkMSAoU29tZSBkMikpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCBfIC0+XG4gICAgICAgICAgYXNzZXJ0IGZhbHNlXG5cbiAgICBsZXQgcmVjIHVuaW9uIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgfCAoRW1wdHksIHMpIHwgKHMsIEVtcHR5KSAtPiBzXG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSwgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZkXG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IGQgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiBkIHJmKVxuXG4gICAgdHlwZSAnYSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2Yga2V5ICogJ2EgKiAnYSB0ICogJ2EgZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIG0gZSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCBkLCByLCBlKSlcblxuICAgIGxldCBjb21wYXJlIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBjb21wYXJlX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgZXF1YWxfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiB0cnVlXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IGZhbHNlXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gZmFsc2VcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgT3JkLmNvbXBhcmUgdjEgdjIgPSAwICYmIGNtcCBkMSBkMiAmJlxuICAgICAgICAgICAgZXF1YWxfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBlcXVhbF9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGJpbmRpbmdzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiaW5kaW5nc19hdXggKCh2LCBkKSA6OiBiaW5kaW5nc19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgYmluZGluZ3MgcyA9XG4gICAgICBiaW5kaW5nc19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9iaW5kaW5nXG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9iaW5kaW5nX29wdFxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBtIChrLHYpIC0+IGFkZCBrIHYgbSkgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoayx2LHQscmVzdCkgLT4gU2VxLkNvbnMgKChrLHYpLCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBtID1cbiAgICAgIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIG0gRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IGlzX2VtcHR5IHMgPSAocy5jID0gW10pXG5cbmxldCBsZW5ndGggcyA9IHMubGVuXG5cbmxldCBpdGVyIGYgcyA9IExpc3QuaXRlciBmIHMuY1xuXG5sZXQgZm9sZCBmIGFjYyBzID0gTGlzdC5mb2xkX2xlZnQgZiBhY2Mgcy5jXG5cbigqKiB7NiBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IExpc3QudG9fc2VxIHMuY1xuXG5sZXQgYWRkX3NlcSBxIGkgPSBTZXEuaXRlciAoZnVuIHggLT4gcHVzaCB4IHEpIGlcblxubGV0IG9mX3NlcSBnID1cbiAgbGV0IHMgPSBjcmVhdGUoKSBpblxuICBhZGRfc2VxIHMgZztcbiAgc1xuXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgdG9wID1cbiAgcGVla1xuXG5sZXQgdGFrZSBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSAtPlxuICAgIGNsZWFyIHE7XG4gICAgY29udGVudFxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCAtIDE7XG4gICAgcS5maXJzdCA8LSBuZXh0O1xuICAgIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezYgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG5cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSW50ZXJuYWxzIG9mIGZvcmNpbmcgbGF6eSB2YWx1ZXMuICopXG5cbmV4Y2VwdGlvbiBVbmRlZmluZWRcblxubGV0IHJhaXNlX3VuZGVmaW5lZCA9IE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgVW5kZWZpbmVkKVxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICB0cnlcbiAgICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICAgICgqIGRvIHNldF9maWVsZCBCRUZPUkUgc2V0X3RhZyAqKVxuICAgIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCAoT2JqLnJlcHIgcmVzdWx0KTtcbiAgICBPYmouc2V0X3RhZyAoT2JqLnJlcHIgYmxrKSBPYmouZm9yd2FyZF90YWc7XG4gICAgcmVzdWx0XG4gIHdpdGggZSAtPlxuICAgIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCAoT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBlKSk7XG4gICAgcmFpc2UgZVxuXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV92YWxfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICAoKiBkbyBzZXRfZmllbGQgQkVGT1JFIHNldF90YWcgKilcbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIChPYmoucmVwciByZXN1bHQpO1xuICBPYmouc2V0X3RhZyAoT2JqLnJlcHIgYmxrKSAoT2JqLmZvcndhcmRfdGFnKTtcbiAgcmVzdWx0XG5cblxuKCogW2ZvcmNlXSBpcyBub3QgdXNlZCwgc2luY2UgW0xhenkuZm9yY2VdIGlzIGRlY2xhcmVkIGFzIGEgcHJpbWl0aXZlXG4gICB3aG9zZSBjb2RlIGlubGluZXMgdGhlIHRhZyB0ZXN0cyBvZiBpdHMgYXJndW1lbnQuICBUaGlzIGZ1bmN0aW9uIGlzXG4gICBoZXJlIGZvciB0aGUgc2FrZSBvZiBjb21wbGV0ZW5lc3MsIGFuZCBmb3IgZGVidWdnaW5nIHB1cnBvc2UuICopXG5cbmxldCBmb3JjZSAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV9sYXp5X2Jsb2NrIGx6dlxuXG5cbmxldCBmb3JjZV92YWwgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfdmFsX2xhenlfYmxvY2sgbHp2XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbTGF6eV06IGRlZmVycmVkIGNvbXB1dGF0aW9ucyAqKVxuXG5cbigqXG4gICBXQVJOSU5HOiBzb21lIHB1cnBsZSBtYWdpYyBpcyBnb2luZyBvbiBoZXJlLiAgRG8gbm90IHRha2UgdGhpcyBmaWxlXG4gICBhcyBhbiBleGFtcGxlIG9mIGhvdyB0byBwcm9ncmFtIGluIE9DYW1sLlxuKilcblxuXG4oKiBXZSBtYWtlIHVzZSBvZiB0d28gc3BlY2lhbCB0YWdzIHByb3ZpZGVkIGJ5IHRoZSBydW50aW1lOlxuICAgW2xhenlfdGFnXSBhbmQgW2ZvcndhcmRfdGFnXS5cblxuICAgQSB2YWx1ZSBvZiB0eXBlIFsnYSBMYXp5LnRdIGNhbiBiZSBvbmUgb2YgdGhyZWUgdGhpbmdzOlxuICAgMS4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2xhenlfdGFnXS4gIEl0cyBmaWVsZCBpcyBhIGNsb3N1cmUgb2ZcbiAgICAgIHR5cGUgW3VuaXQgLT4gJ2FdIHRoYXQgY29tcHV0ZXMgdGhlIHZhbHVlLlxuICAgMi4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2ZvcndhcmRfdGFnXS4gIEl0cyBmaWVsZCBpcyB0aGUgdmFsdWVcbiAgICAgIG9mIHR5cGUgWydhXSB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIDMuIEFueXRoaW5nIGVsc2UgZXhjZXB0IGEgZmxvYXQuICBUaGlzIGhhcyB0eXBlIFsnYV0gYW5kIGlzIHRoZSB2YWx1ZVxuICAgICAgdGhhdCB3YXMgY29tcHV0ZWQuXG4gICBFeGNlcHRpb25zIGFyZSBzdG9yZWQgaW4gZm9ybWF0ICgxKS5cbiAgIFRoZSBHQyB3aWxsIG1hZ2ljYWxseSBjaGFuZ2UgdGhpbmdzIGZyb20gKDIpIHRvICgzKSBhY2NvcmRpbmcgdG8gaXRzXG4gICBmYW5jeS5cblxuICAgSWYgT0NhbWwgd2FzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgLWZsYXQtZmxvYXQtYXJyYXkgb3B0aW9uICh3aGljaCBpc1xuICAgY3VycmVudGx5IHRoZSBkZWZhdWx0KSwgdGhlIGZvbGxvd2luZyBpcyBhbHNvIHRydWU6XG4gICBXZSBjYW5ub3QgdXNlIHJlcHJlc2VudGF0aW9uICgzKSBmb3IgYSBbZmxvYXQgTGF6eS50XSBiZWNhdXNlXG4gICBbY2FtbF9tYWtlX2FycmF5XSBhc3N1bWVzIHRoYXQgb25seSBhIFtmbG9hdF0gdmFsdWUgY2FuIGhhdmUgdGFnXG4gICBbRG91YmxlX3RhZ10uXG5cbiAgIFdlIGhhdmUgdG8gdXNlIHRoZSBidWlsdC1pbiB0eXBlIGNvbnN0cnVjdG9yIFtsYXp5X3RdIHRvXG4gICBsZXQgdGhlIGNvbXBpbGVyIGltcGxlbWVudCB0aGUgc3BlY2lhbCB0eXBpbmcgYW5kIGNvbXBpbGF0aW9uXG4gICBydWxlcyBmb3IgdGhlIFtsYXp5XSBrZXl3b3JkLlxuKilcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90XG5cbmV4Y2VwdGlvbiBVbmRlZmluZWQgPSBDYW1saW50ZXJuYWxMYXp5LlVuZGVmaW5lZFxuXG5leHRlcm5hbCBtYWtlX2ZvcndhcmQgOiAnYSAtPiAnYSBsYXp5X3QgPSBcImNhbWxfbGF6eV9tYWtlX2ZvcndhcmRcIlxuXG5leHRlcm5hbCBmb3JjZSA6ICdhIHQgLT4gJ2EgPSBcIiVsYXp5X2ZvcmNlXCJcblxuKCogbGV0IGZvcmNlID0gZm9yY2UgKilcblxubGV0IGZvcmNlX3ZhbCA9IENhbWxpbnRlcm5hbExhenkuZm9yY2VfdmFsXG5cbmxldCBmcm9tX2Z1biAoZiA6IHVuaXQgLT4gJ2FyZykgPVxuICBsZXQgeCA9IE9iai5uZXdfYmxvY2sgT2JqLmxhenlfdGFnIDEgaW5cbiAgT2JqLnNldF9maWVsZCB4IDAgKE9iai5yZXByIGYpO1xuICAoT2JqLm9iaiB4IDogJ2FyZyB0KVxuXG5cbmxldCBmcm9tX3ZhbCAodiA6ICdhcmcpID1cbiAgbGV0IHQgPSBPYmoudGFnIChPYmoucmVwciB2KSBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHx8IHQgPSBPYmoubGF6eV90YWcgfHwgdCA9IE9iai5kb3VibGVfdGFnIHRoZW4gYmVnaW5cbiAgICBtYWtlX2ZvcndhcmQgdlxuICBlbmQgZWxzZSBiZWdpblxuICAgIChPYmoubWFnaWMgdiA6ICdhcmcgdClcbiAgZW5kXG5cblxubGV0IGlzX3ZhbCAobCA6ICdhcmcgdCkgPSBPYmoudGFnIChPYmoucmVwciBsKSA8PiBPYmoubGF6eV90YWdcblxubGV0IGxhenlfZnJvbV9mdW4gPSBmcm9tX2Z1blxuXG5sZXQgbGF6eV9mcm9tX3ZhbCA9IGZyb21fdmFsXG5cbmxldCBsYXp5X2lzX3ZhbCA9IGlzX3ZhbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBEYW5pZWwgZGUgUmF1Z2xhdWRyZSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAnYSBjZWxsIG9wdGlvblxuYW5kICdhIGNlbGwgPSB7IG11dGFibGUgY291bnQgOiBpbnQ7IG11dGFibGUgZGF0YSA6ICdhIGRhdGEgfVxuYW5kICdhIGRhdGEgPVxuICAgIFNlbXB0eVxuICB8IFNjb25zIG9mICdhICogJ2EgZGF0YVxuICB8IFNhcHAgb2YgJ2EgZGF0YSAqICdhIGRhdGFcbiAgfCBTbGF6eSBvZiAnYSBkYXRhIExhenkudFxuICB8IFNnZW4gb2YgJ2EgZ2VuXG4gIHwgU2J1ZmZpbyA6IGJ1ZmZpbyAtPiBjaGFyIGRhdGFcbmFuZCAnYSBnZW4gPSB7IG11dGFibGUgY3VyciA6ICdhIG9wdGlvbiBvcHRpb247IGZ1bmMgOiBpbnQgLT4gJ2Egb3B0aW9uIH1cbmFuZCBidWZmaW8gPVxuICB7IGljIDogaW5fY2hhbm5lbDsgYnVmZiA6IGJ5dGVzOyBtdXRhYmxlIGxlbiA6IGludDsgbXV0YWJsZSBpbmQgOiBpbnQgfVxuXG5leGNlcHRpb24gRmFpbHVyZVxuZXhjZXB0aW9uIEVycm9yIG9mIHN0cmluZ1xuXG5sZXQgY291bnQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gMFxuICB8IFNvbWUgeyBjb3VudCB9IC0+IGNvdW50XG5sZXQgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBTZW1wdHlcbiAgfCBTb21lIHsgZGF0YSB9IC0+IGRhdGFcblxubGV0IGZpbGxfYnVmZiBiID1cbiAgYi5sZW4gPC0gaW5wdXQgYi5pYyBiLmJ1ZmYgMCAoQnl0ZXMubGVuZ3RoIGIuYnVmZik7IGIuaW5kIDwtIDBcblxuXG5sZXQgcmVjIGdldF9kYXRhIDogdHlwZSB2LiBpbnQgLT4gdiBkYXRhIC0+IHYgZGF0YSA9IGZ1biBjb3VudCBkIC0+IG1hdGNoIGQgd2l0aFxuICgqIFJldHVybnMgZWl0aGVyIFNlbXB0eSBvciBTY29ucyhhLCBfKSBldmVuIHdoZW4gZCBpcyBhIGdlbmVyYXRvclxuICAgIG9yIGEgYnVmZmVyLiBJbiB0aG9zZSBjYXNlcywgdGhlIGl0ZW0gYSBpcyBzZWVuIGFzIGV4dHJhY3RlZCBmcm9tXG4gdGhlIGdlbmVyYXRvci9idWZmZXIuXG4gVGhlIGNvdW50IHBhcmFtZXRlciBpcyB1c2VkIGZvciBjYWxsaW5nIGBTZ2VuLWZ1bmN0aW9ucycuICAqKVxuICAgU2VtcHR5IHwgU2NvbnMgKF8sIF8pIC0+IGRcbiB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgY291bnQgZDEgd2l0aFxuICAgICAgIFNjb25zIChhLCBkMTEpIC0+IFNjb25zIChhLCBTYXBwIChkMTEsIGQyKSlcbiAgICAgfCBTZW1wdHkgLT4gZ2V0X2RhdGEgY291bnQgZDJcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNnZW4ge2N1cnIgPSBTb21lIE5vbmV9IC0+IFNlbXB0eVxuIHwgU2dlbiAoe2N1cnIgPSBTb21lKFNvbWUgYSl9IGFzIGcpIC0+XG4gICAgIGcuY3VyciA8LSBOb25lOyBTY29ucyhhLCBkKVxuIHwgU2dlbiBnIC0+XG4gICAgIGJlZ2luIG1hdGNoIGcuZnVuYyBjb3VudCB3aXRoXG4gICAgICAgTm9uZSAtPiBnLmN1cnIgPC0gU29tZShOb25lKTsgU2VtcHR5XG4gICAgIHwgU29tZSBhIC0+IFNjb25zKGEsIGQpXG4gICAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgZW5kXG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIFNlbXB0eSBlbHNlXG4gICAgICAgbGV0IHIgPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZCBpblxuICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICAgIGIuaW5kIDwtIHN1Y2MgYi5pbmQ7IFNjb25zKHIsIGQpXG4gfCBTbGF6eSBmIC0+IGdldF9kYXRhIGNvdW50IChMYXp5LmZvcmNlIGYpXG5cblxubGV0IHJlYyBwZWVrX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB2IG9wdGlvbiA9IGZ1biBzIC0+XG4gKCogY29uc3VsdCB0aGUgZmlyc3QgaXRlbSBvZiBzICopXG4gbWF0Y2ggcy5kYXRhIHdpdGhcbiAgIFNlbXB0eSAtPiBOb25lXG4gfCBTY29ucyAoYSwgXykgLT4gU29tZSBhXG4gfCBTYXBwIChfLCBfKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBzLmNvdW50IHMuZGF0YSB3aXRoXG4gICAgICAgU2NvbnMoYSwgXykgYXMgZCAtPiBzLmRhdGEgPC0gZDsgU29tZSBhXG4gICAgIHwgU2VtcHR5IC0+IE5vbmVcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNsYXp5IGYgLT4gcy5kYXRhIDwtIChMYXp5LmZvcmNlIGYpOyBwZWVrX2RhdGEgc1xuIHwgU2dlbiB7Y3VyciA9IFNvbWUgYX0gLT4gYVxuIHwgU2dlbiBnIC0+IGxldCB4ID0gZy5mdW5jIHMuY291bnQgaW4gZy5jdXJyIDwtIFNvbWUgeDsgeFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBiZWdpbiBzLmRhdGEgPC0gU2VtcHR5OyBOb25lIGVuZFxuICAgICBlbHNlIFNvbWUgKEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kKVxuXG5cbmxldCBwZWVrID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHMgLT4gcGVla19kYXRhIHNcblxuXG5sZXQgcmVjIGp1bmtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHVuaXQgPSBmdW4gcyAtPlxuICBtYXRjaCBzLmRhdGEgd2l0aFxuICAgIFNjb25zIChfLCBkKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBzLmRhdGEgPC0gZFxuICB8IFNnZW4gKHtjdXJyID0gU29tZSBffSBhcyBnKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBnLmN1cnIgPC0gTm9uZVxuICB8IFNidWZmaW8gYiAtPlxuICAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgIGlmIGIubGVuID09IDAgdGhlbiBzLmRhdGEgPC0gU2VtcHR5XG4gICAgICBlbHNlIChzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBiLmluZCA8LSBzdWNjIGIuaW5kKVxuICB8IF8gLT5cbiAgICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgICAgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIF8gLT4ganVua19kYXRhIHNcblxuXG5sZXQganVuayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZGF0YSAtPiBqdW5rX2RhdGEgZGF0YVxuXG5sZXQgcmVjIG5nZXRfZGF0YSBuIHMgPVxuICBpZiBuIDw9IDAgdGhlbiBbXSwgcy5kYXRhLCAwXG4gIGVsc2VcbiAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICBTb21lIGEgLT5cbiAgICAgICAganVua19kYXRhIHM7XG4gICAgICAgIGxldCAoYWwsIGQsIGspID0gbmdldF9kYXRhIChwcmVkIG4pIHMgaW4gYSA6OiBhbCwgU2NvbnMgKGEsIGQpLCBzdWNjIGtcbiAgICB8IE5vbmUgLT4gW10sIHMuZGF0YSwgMFxuXG5cbmxldCBucGVla19kYXRhIG4gcyA9XG4gIGxldCAoYWwsIGQsIGxlbikgPSBuZ2V0X2RhdGEgbiBzIGluXG4gIHMuY291bnQgPC0gKHMuY291bnQgLSBsZW4pO1xuICBzLmRhdGEgPC0gZDtcbiAgYWxcblxuXG5sZXQgbnBlZWsgbiA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgZCAtPiBucGVla19kYXRhIG4gZFxuXG5sZXQgbmV4dCBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIGEgLT4ganVuayBzOyBhXG4gIHwgTm9uZSAtPiByYWlzZSBGYWlsdXJlXG5cblxubGV0IGVtcHR5IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgXyAtPiByYWlzZSBGYWlsdXJlXG4gIHwgTm9uZSAtPiAoKVxuXG5cbmxldCBpdGVyIGYgc3RybSA9XG4gIGxldCByZWMgZG9fcmVjICgpID1cbiAgICBtYXRjaCBwZWVrIHN0cm0gd2l0aFxuICAgICAgU29tZSBhIC0+IGp1bmsgc3RybTsgaWdub3JlKGYgYSk7IGRvX3JlYyAoKVxuICAgIHwgTm9uZSAtPiAoKVxuICBpblxuICBkb19yZWMgKClcblxuXG4oKiBTdHJlYW0gYnVpbGRpbmcgZnVuY3Rpb25zICopXG5cbmxldCBmcm9tIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTZ2VuIHtjdXJyID0gTm9uZTsgZnVuYyA9IGZ9fVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gTGlzdC5mb2xkX3JpZ2h0IChmdW4geCBsIC0+IFNjb25zICh4LCBsKSkgbCBTZW1wdHl9XG5cblxubGV0IG9mX3N0cmluZyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICAoKiBXZSBjYW5ub3QgdXNlIHRoZSBpbmRleCBwYXNzZWQgYnkgdGhlIFtmcm9tXSBmdW5jdGlvbiBkaXJlY3RseVxuICAgICAgIGJlY2F1c2UgaXQgcmV0dXJucyB0aGUgY3VycmVudCBzdHJlYW0gY291bnQsIHdpdGggYWJzb2x1dGVseSBub1xuICAgICAgIGd1YXJhbnRlZSB0aGF0IGl0IHdpbGwgc3RhcnQgZnJvbSAwLiBGb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2VcbiAgICAgICBvZiBbU3RyZWFtLmljb25zICdjJyAoU3RyZWFtLmZyb21fc3RyaW5nIFwiYWJcIildLCB0aGUgZmlyc3RcbiAgICAgICBhY2Nlc3MgdG8gdGhlIHN0cmluZyB3aWxsIGJlIG1hZGUgd2l0aCBjb3VudCBbMV0gYWxyZWFkeS5cbiAgICAqKVxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IFN0cmluZy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgcy5bY10pXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9ieXRlcyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBCeXRlcy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgKEJ5dGVzLmdldCBzIGMpKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfY2hhbm5lbCBpYyA9XG4gIFNvbWUge2NvdW50ID0gMDtcbiAgICAgICAgZGF0YSA9IFNidWZmaW8ge2ljID0gaWM7IGJ1ZmYgPSBCeXRlcy5jcmVhdGUgNDA5NjsgbGVuID0gMDsgaW5kID0gMH19XG5cblxuKCogU3RyZWFtIGV4cHJlc3Npb25zIGJ1aWxkZXJzICopXG5cbmxldCBpYXBwIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNhcHAgKGRhdGEgaSwgZGF0YSBzKX1cbmxldCBpY29ucyBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgZGF0YSBzKX1cbmxldCBpc2luZyBpID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIFNlbXB0eSl9XG5cbmxldCBsYXBwIGYgcyA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNhcHAgKGRhdGEgKGYgKCkpLCBkYXRhIHMpKSl9XG5cbmxldCBsY29ucyBmIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgZGF0YSBzKSkpfVxubGV0IGxzaW5nIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgU2VtcHR5KSkpfVxuXG5sZXQgc2VtcHR5ID0gTm9uZVxubGV0IHNsYXp5IGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShkYXRhIChmICgpKSkpfVxuXG4oKiBGb3IgZGVidWdnaW5nIHVzZSAqKVxuXG5sZXQgcmVjIGR1bXAgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgdCAtPiB1bml0ID0gZnVuIGYgcyAtPlxuICBwcmludF9zdHJpbmcgXCJ7Y291bnQgPSBcIjtcbiAgcHJpbnRfaW50IChjb3VudCBzKTtcbiAgcHJpbnRfc3RyaW5nIFwiOyBkYXRhID0gXCI7XG4gIGR1bXBfZGF0YSBmIChkYXRhIHMpO1xuICBwcmludF9zdHJpbmcgXCJ9XCI7XG4gIHByaW50X25ld2xpbmUgKClcbmFuZCBkdW1wX2RhdGEgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgZGF0YSAtPiB1bml0ID0gZnVuIGYgLT5cbiAgZnVuY3Rpb25cbiAgICBTZW1wdHkgLT4gcHJpbnRfc3RyaW5nIFwiU2VtcHR5XCJcbiAgfCBTY29ucyAoYSwgZCkgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNjb25zIChcIjtcbiAgICAgIGYgYTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2FwcCAoXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMjtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNsYXp5IF8gLT4gcHJpbnRfc3RyaW5nIFwiU2xhenlcIlxuICB8IFNnZW4gXyAtPiBwcmludF9zdHJpbmcgXCJTZ2VuXCJcbiAgfCBTYnVmZmlvIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2J1ZmZpb1wiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICBQaWVycmUgV2VpcyBhbmQgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4dGVuc2libGUgYnVmZmVycyAqKVxuXG50eXBlIHQgPVxuIHttdXRhYmxlIGJ1ZmZlciA6IGJ5dGVzO1xuICBtdXRhYmxlIHBvc2l0aW9uIDogaW50O1xuICBtdXRhYmxlIGxlbmd0aCA6IGludDtcbiAgaW5pdGlhbF9idWZmZXIgOiBieXRlc31cblxubGV0IGNyZWF0ZSBuID1cbiBsZXQgbiA9IGlmIG4gPCAxIHRoZW4gMSBlbHNlIG4gaW5cbiBsZXQgbiA9IGlmIG4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBTeXMubWF4X3N0cmluZ19sZW5ndGggZWxzZSBuIGluXG4gbGV0IHMgPSBCeXRlcy5jcmVhdGUgbiBpblxuIHtidWZmZXIgPSBzOyBwb3NpdGlvbiA9IDA7IGxlbmd0aCA9IG47IGluaXRpYWxfYnVmZmVyID0gc31cblxubGV0IGNvbnRlbnRzIGIgPSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxubGV0IHRvX2J5dGVzIGIgPSBCeXRlcy5zdWIgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBzdWIgYiBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGIucG9zaXRpb24gLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5zdWJcIlxuICBlbHNlIEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgb2ZzIGxlblxuXG5cbmxldCBibGl0IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IHNyY29mZiA8IDAgfHwgc3Jjb2ZmID4gc3JjLnBvc2l0aW9uIC0gbGVuXG4gICAgICAgICAgICAgfHwgZHN0b2ZmIDwgMCB8fCBkc3RvZmYgPiAoQnl0ZXMubGVuZ3RoIGRzdCkgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5ibGl0XCJcbiAgZWxzZVxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0IHNyYy5idWZmZXIgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuXG5cblxubGV0IG50aCBiIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID49IGIucG9zaXRpb24gdGhlblxuICAgaW52YWxpZF9hcmcgXCJCdWZmZXIubnRoXCJcbiAgZWxzZSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIG9mc1xuXG5cbmxldCBsZW5ndGggYiA9IGIucG9zaXRpb25cblxubGV0IGNsZWFyIGIgPSBiLnBvc2l0aW9uIDwtIDBcblxubGV0IHJlc2V0IGIgPVxuICBiLnBvc2l0aW9uIDwtIDA7IGIuYnVmZmVyIDwtIGIuaW5pdGlhbF9idWZmZXI7XG4gIGIubGVuZ3RoIDwtIEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlclxuXG5sZXQgcmVzaXplIGIgbW9yZSA9XG4gIGxldCBsZW4gPSBiLmxlbmd0aCBpblxuICBsZXQgbmV3X2xlbiA9IHJlZiBsZW4gaW5cbiAgd2hpbGUgYi5wb3NpdGlvbiArIG1vcmUgPiAhbmV3X2xlbiBkbyBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiBkb25lO1xuICBpZiAhbmV3X2xlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgaWYgYi5wb3NpdGlvbiArIG1vcmUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgdGhlbiBuZXdfbGVuIDo9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIGVsc2UgZmFpbHdpdGggXCJCdWZmZXIuYWRkOiBjYW5ub3QgZ3JvdyBidWZmZXJcIlxuICBlbmQ7XG4gIGxldCBuZXdfYnVmZmVyID0gQnl0ZXMuY3JlYXRlICFuZXdfbGVuIGluXG4gICgqIFBSIzYxNDg6IGxldCdzIGtlZXAgdXNpbmcgW2JsaXRdIHJhdGhlciB0aGFuIFt1bnNhZmVfYmxpdF0gaW5cbiAgICAgdGhpcyB0cmlja3kgZnVuY3Rpb24gdGhhdCBpcyBzbG93IGFueXdheS4gKilcbiAgQnl0ZXMuYmxpdCBiLmJ1ZmZlciAwIG5ld19idWZmZXIgMCBiLnBvc2l0aW9uO1xuICBiLmJ1ZmZlciA8LSBuZXdfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSAhbmV3X2xlblxuXG5sZXQgYWRkX2NoYXIgYiBjID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciBwb3MgYztcbiAgYi5wb3NpdGlvbiA8LSBwb3MgKyAxXG5cbiBsZXQgYWRkX3V0Zl84X3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4MDA3RiAtPlxuICAgICBhZGRfY2hhciBiIChDaGFyLnVuc2FmZV9jaHIgdSlcbiB8IHUgd2hlbiB1IDw9IDB4MDdGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4QzAgbG9yICh1IGxzciA2KSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMyA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMztcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEUwIGxvciAodSBsc3IgMTIpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDNcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhGMCBsb3IgKHUgbHNyIDE4KSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgMTIpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMilcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMylcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuIGxldCBhZGRfdXRmXzE2YmVfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKHUgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAodSBsYW5kIDB4RkYpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICBsZXQgaGkgPSAweEQ4MDAgbG9yICh1JyBsc3IgMTApIGluXG4gICAgIGxldCBsbyA9IDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpIGluXG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsYW5kIDB4RkYpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gbGV0IGFkZF91dGZfMTZsZV91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAodSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAodSBsc3IgOCkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgIGxldCBoaSA9IDB4RDgwMCBsb3IgKHUnIGxzciAxMCkgaW5cbiAgICAgbGV0IGxvID0gMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikgaW5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAoaGkgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsc3IgOCkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBhZGRfc3Vic3RyaW5nIGIgcyBvZmZzZXQgbGVuID1cbiAgaWYgb2Zmc2V0IDwgMCB8fCBsZW4gPCAwIHx8IG9mZnNldCA+IFN0cmluZy5sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9zdWJzdHJpbmcvYWRkX3N1YmJ5dGVzXCI7XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy5ibGl0X3N0cmluZyBzIG9mZnNldCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9zdWJieXRlcyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGFkZF9zdWJzdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKSBvZmZzZXQgbGVuXG5cbmxldCBhZGRfc3RyaW5nIGIgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLmJsaXRfc3RyaW5nIHMgMCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9ieXRlcyBiIHMgPSBhZGRfc3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcylcblxubGV0IGFkZF9idWZmZXIgYiBicyA9XG4gIGFkZF9zdWJieXRlcyBiIGJzLmJ1ZmZlciAwIGJzLnBvc2l0aW9uXG5cbigqIHJlYWQgdXAgdG8gW2xlbl0gYnl0ZXMgZnJvbSBbaWNdIGludG8gW2JdLiAqKVxubGV0IHJlYyBhZGRfY2hhbm5lbF9yZWMgYiBpYyBsZW4gPVxuICBpZiBsZW4gPiAwIHRoZW4gKFxuICAgIGxldCBuID0gaW5wdXQgaWMgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW4gaW5cbiAgICBiLnBvc2l0aW9uIDwtIGIucG9zaXRpb24gKyBuO1xuICAgIGlmIG4gPSAwIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICBlbHNlIGFkZF9jaGFubmVsX3JlYyBiIGljIChsZW4tbikgICAoKiBuIDw9IGxlbiAqKVxuICApXG5cbmxldCBhZGRfY2hhbm5lbCBiIGljIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gICAoKiBQUiM1MDA0ICopXG4gICAgaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX2NoYW5uZWxcIjtcbiAgaWYgYi5wb3NpdGlvbiArIGxlbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBhZGRfY2hhbm5lbF9yZWMgYiBpYyBsZW5cblxubGV0IG91dHB1dF9idWZmZXIgb2MgYiA9XG4gIG91dHB1dCBvYyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IGNsb3NpbmcgPSBmdW5jdGlvblxuICB8ICcoJyAtPiAnKSdcbiAgfCAneycgLT4gJ30nXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuKCogb3BlbmluZyBhbmQgY2xvc2luZzogb3BlbiBhbmQgY2xvc2UgY2hhcmFjdGVycywgdHlwaWNhbGx5ICggYW5kIClcbiAgIGs6IGJhbGFuY2Ugb2Ygb3BlbmluZyBhbmQgY2xvc2luZyBjaGFyc1xuICAgczogdGhlIHN0cmluZyB3aGVyZSB3ZSBhcmUgc2VhcmNoaW5nXG4gICBzdGFydDogdGhlIGluZGV4IHdoZXJlIHdlIHN0YXJ0IHRoZSBzZWFyY2guICopXG5sZXQgYWR2YW5jZV90b19jbG9zaW5nIG9wZW5pbmcgY2xvc2luZyBrIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgayBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICAgIGlmIHMuW2ldID0gb3BlbmluZyB0aGVuIGFkdmFuY2UgKGsgKyAxKSAoaSArIDEpIGxpbSBlbHNlXG4gICAgaWYgcy5baV0gPSBjbG9zaW5nIHRoZW5cbiAgICAgIGlmIGsgPSAwIHRoZW4gaSBlbHNlIGFkdmFuY2UgKGsgLSAxKSAoaSArIDEpIGxpbVxuICAgIGVsc2UgYWR2YW5jZSBrIChpICsgMSkgbGltIGluXG4gIGFkdmFuY2UgayBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG5sZXQgYWR2YW5jZV90b19ub25fYWxwaGEgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiBsaW0gZWxzZVxuICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyB8ICdfJyAtPiBhZHZhbmNlIChpICsgMSkgbGltXG4gICAgfCBfIC0+IGkgaW5cbiAgYWR2YW5jZSBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG4oKiBXZSBhcmUganVzdCBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGlkZW50IGluIHMsIHN0YXJ0aW5nIGF0IHN0YXJ0LiAqKVxubGV0IGZpbmRfaWRlbnQgcyBzdGFydCBsaW0gPVxuICBpZiBzdGFydCA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBtYXRjaCBzLltzdGFydF0gd2l0aFxuICAoKiBQYXJlbnRoZXNpemVkIGlkZW50ID8gKilcbiAgfCAnKCcgfCAneycgYXMgYyAtPlxuICAgICBsZXQgbmV3X3N0YXJ0ID0gc3RhcnQgKyAxIGluXG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19jbG9zaW5nIGMgKGNsb3NpbmcgYykgMCBzIG5ld19zdGFydCBpblxuICAgICBTdHJpbmcuc3ViIHMgbmV3X3N0YXJ0IChzdG9wIC0gc3RhcnQgLSAxKSwgc3RvcCArIDFcbiAgKCogUmVndWxhciBpZGVudCAqKVxuICB8IF8gLT5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIChzdGFydCArIDEpIGluXG4gICAgIFN0cmluZy5zdWIgcyBzdGFydCAoc3RvcCAtIHN0YXJ0KSwgc3RvcFxuXG4oKiBTdWJzdGl0dXRlICRpZGVudCwgJChpZGVudCksIG9yICR7aWRlbnR9IGluIHMsXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBmdW5jdGlvbiBtYXBwaW5nIGYuICopXG5sZXQgYWRkX3N1YnN0aXR1dGUgYiBmIHMgPVxuICBsZXQgbGltID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgc3Vic3QgcHJldmlvdXMgaSA9XG4gICAgaWYgaSA8IGxpbSB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICckJyBhcyBjdXJyZW50IHdoZW4gcHJldmlvdXMgPSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICckJyAtPlxuICAgICAgICAgbGV0IGogPSBpICsgMSBpblxuICAgICAgICAgbGV0IGlkZW50LCBuZXh0X2kgPSBmaW5kX2lkZW50IHMgaiBsaW0gaW5cbiAgICAgICAgIGFkZF9zdHJpbmcgYiAoZiBpZGVudCk7XG4gICAgICAgICBzdWJzdCAnICcgbmV4dF9pXG4gICAgICB8IGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9PSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgJ1xcXFwnO1xuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJ1xcXFwnIGFzIGN1cnJlbnQgLT5cbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgICAgfCBjdXJyZW50IC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICBlbmQgZWxzZVxuICAgIGlmIHByZXZpb3VzID0gJ1xcXFwnIHRoZW4gYWRkX2NoYXIgYiBwcmV2aW91cyBpblxuICBzdWJzdCAnICcgMFxuXG5sZXQgdHJ1bmNhdGUgYiBsZW4gPVxuICAgIGlmIGxlbiA8IDAgfHwgbGVuID4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJCdWZmZXIudHJ1bmNhdGVcIlxuICAgIGVsc2VcbiAgICAgIGIucG9zaXRpb24gPC0gbGVuXG5cbigqKiB7NiBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLmdldCBiLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMuZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgYWRkX3NlcSBiIHNlcSA9IFNlcS5pdGVyIChhZGRfY2hhciBiKSBzZXFcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IGIgPSBjcmVhdGUgMzIgaW5cbiAgYWRkX3NlcSBiIGk7XG4gIGJcblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBYYXZpZXIgTGVyb3kgYW5kIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxubGV0IGtmcHJpbnRmIGsgbyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gbyBhY2MgLT4gb3V0cHV0X2FjYyBvIGFjYzsgayBvKSBvIEVuZF9vZl9hY2MgZm10XG5sZXQga2JwcmludGYgayBiIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBiIGFjYyAtPiBidWZwdXRfYWNjIGIgYWNjOyBrIGIpIGIgRW5kX29mX2FjYyBmbXRcbmxldCBpa2ZwcmludGYgayBvYyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIG9jIGZtdFxuXG5sZXQgZnByaW50ZiBvYyBmbXQgPSBrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgYnByaW50ZiBiIGZtdCA9IGticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IGlmcHJpbnRmIG9jIGZtdCA9IGlrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3Rkb3V0IGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBzdGRlcnIgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGsnICgpIGFjYyA9XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgICBzdHJwdXRfYWNjIGJ1ZiBhY2M7XG4gICAgayAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgaycgKCkgRW5kX29mX2FjYyBmbXRcblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUga2V5ID0gc3RyaW5nXG50eXBlIGRvYyA9IHN0cmluZ1xudHlwZSB1c2FnZV9tc2cgPSBzdHJpbmdcbnR5cGUgYW5vbl9mdW4gPSAoc3RyaW5nIC0+IHVuaXQpXG5cbnR5cGUgc3BlYyA9XG4gIHwgVW5pdCBvZiAodW5pdCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB1bml0IGFyZ3VtZW50ICopXG4gIHwgQm9vbCBvZiAoYm9vbCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGJvb2wgYXJndW1lbnQgKilcbiAgfCBTZXQgb2YgYm9vbCByZWYgICAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0cnVlICopXG4gIHwgQ2xlYXIgb2YgYm9vbCByZWYgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gZmFsc2UgKilcbiAgfCBTdHJpbmcgb2YgKHN0cmluZyAtPiB1bml0KSAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgU2V0X3N0cmluZyBvZiBzdHJpbmcgcmVmICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IEludCBvZiAoaW50IC0+IHVuaXQpICAgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYW4gaW50IGFyZ3VtZW50ICopXG4gIHwgU2V0X2ludCBvZiBpbnQgcmVmICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGludCBhcmd1bWVudCAqKVxuICB8IEZsb2F0IG9mIChmbG9hdCAtPiB1bml0KSAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFNldF9mbG9hdCBvZiBmbG9hdCByZWYgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFR1cGxlIG9mIHNwZWMgbGlzdCAgICAgICAgICgqIFRha2Ugc2V2ZXJhbCBhcmd1bWVudHMgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWMgbGlzdCAqKVxuICB8IFN5bWJvbCBvZiBzdHJpbmcgbGlzdCAqIChzdHJpbmcgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUYWtlIG9uZSBvZiB0aGUgc3ltYm9scyBhcyBhcmd1bWVudCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBzeW1ib2wuICopXG4gIHwgUmVzdCBvZiAoc3RyaW5nIC0+IHVuaXQpICAgKCogU3RvcCBpbnRlcnByZXRpbmcga2V5d29yZHMgYW5kIGNhbGwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aCBlYWNoIHJlbWFpbmluZyBhcmd1bWVudCAqKVxuICB8IEV4cGFuZCBvZiAoc3RyaW5nIC0+IHN0cmluZyBhcnJheSkgKCogSWYgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW1wiLWZvb1wiOyBcImFyZ1wiXSBAIHJlc3RdIHdoZXJlIFwiZm9vXCIgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWQgYXMgW0V4cGFuZCBmXSwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyBbZiBcImFyZ1wiIEAgcmVzdF0gYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQuIE9ubHkgYWxsb3dlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXS4gKilcblxuZXhjZXB0aW9uIEJhZCBvZiBzdHJpbmdcbmV4Y2VwdGlvbiBIZWxwIG9mIHN0cmluZ1xuXG50eXBlIGVycm9yID1cbiAgfCBVbmtub3duIG9mIHN0cmluZ1xuICB8IFdyb25nIG9mIHN0cmluZyAqIHN0cmluZyAqIHN0cmluZyAgKCogb3B0aW9uLCBhY3R1YWwsIGV4cGVjdGVkICopXG4gIHwgTWlzc2luZyBvZiBzdHJpbmdcbiAgfCBNZXNzYWdlIG9mIHN0cmluZ1xuXG5leGNlcHRpb24gU3RvcCBvZiBlcnJvciAoKiB1c2VkIGludGVybmFsbHkgKilcblxub3BlbiBQcmludGZcblxubGV0IHJlYyBhc3NvYzMgeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKHkxLCB5MiwgXykgOjogXyB3aGVuIHkxID0geCAtPiB5MlxuICB8IF8gOjogdCAtPiBhc3NvYzMgeCB0XG5cblxubGV0IHNwbGl0IHMgPVxuICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc9JyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIFN0cmluZy5zdWIgcyAwIGksIFN0cmluZy5zdWIgcyAoaSsxKSAobGVuLShpKzEpKVxuXG5cbmxldCBtYWtlX3N5bWxpc3QgcHJlZml4IHNlcCBzdWZmaXggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiPG5vbmU+XCJcbiAgfCBoOjp0IC0+IChMaXN0LmZvbGRfbGVmdCAoZnVuIHggeSAtPiB4IF4gc2VwIF4geSkgKHByZWZpeCBeIGgpIHQpIF4gc3VmZml4XG5cblxubGV0IHByaW50X3NwZWMgYnVmIChrZXksIHNwZWMsIGRvYykgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRvYyA+IDAgdGhlblxuICAgIG1hdGNoIHNwZWMgd2l0aFxuICAgIHwgU3ltYm9sIChsLCBfKSAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXMlc1xcblwiIGtleSAobWFrZV9zeW1saXN0IFwie1wiIFwifFwiIFwifVwiIGwpIGRvY1xuICAgIHwgXyAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXNcXG5cIiBrZXkgZG9jXG5cblxubGV0IGhlbHBfYWN0aW9uICgpID0gcmFpc2UgKFN0b3AgKFVua25vd24gXCItaGVscFwiKSlcblxubGV0IGFkZF9oZWxwIHNwZWNsaXN0ID1cbiAgbGV0IGFkZDEgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItaGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGFuZCBhZGQyID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi0taGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGluXG4gIHNwZWNsaXN0IEAgKGFkZDEgQCBhZGQyKVxuXG5cbmxldCB1c2FnZV9iIGJ1ZiBzcGVjbGlzdCBlcnJtc2cgPVxuICBicHJpbnRmIGJ1ZiBcIiVzXFxuXCIgZXJybXNnO1xuICBMaXN0Lml0ZXIgKHByaW50X3NwZWMgYnVmKSAoYWRkX2hlbHAgc3BlY2xpc3QpXG5cblxubGV0IHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIHVzYWdlX2IgYiBzcGVjbGlzdCBlcnJtc2c7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IHVzYWdlIHNwZWNsaXN0IGVycm1zZyA9XG4gIGVwcmludGYgXCIlc1wiICh1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnKVxuXG5cbmxldCBjdXJyZW50ID0gcmVmIDBcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGJvb2xfb2Zfc3RyaW5nIHgpXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBhbGxvd19leHBhbmQgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgbGV0IGluaXRwb3MgPSAhY3VycmVudCBpblxuICBsZXQgY29udmVydF9lcnJvciBlcnJvciA9XG4gICAgKCogY29udmVydCBhbiBpbnRlcm5hbCBlcnJvciB0byBhIEJhZC9IZWxwIGV4Y2VwdGlvblxuICAgICAgICpvciogYWRkIHRoZSBwcm9ncmFtIG5hbWUgYXMgYSBwcmVmaXggYW5kIHRoZSB1c2FnZSBtZXNzYWdlIGFzIGEgc3VmZml4XG4gICAgICAgdG8gYW4gdXNlci1yYWlzZWQgQmFkIGV4Y2VwdGlvbi5cbiAgICAqKVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgICBsZXQgcHJvZ25hbWUgPSBpZiBpbml0cG9zIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oaW5pdHBvcykgZWxzZSBcIig/KVwiIGluXG4gICAgYmVnaW4gbWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgfCBVbmtub3duIFwiLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIFwiLS1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHVua25vd24gb3B0aW9uICclcycuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBNaXNzaW5nIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogb3B0aW9uICclcycgbmVlZHMgYW4gYXJndW1lbnQuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBXcm9uZyAob3B0LCBhcmcsIGV4cGVjdGVkKSAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB3cm9uZyBhcmd1bWVudCAnJXMnOyBvcHRpb24gJyVzJyBleHBlY3RzICVzLlxcblwiXG4gICAgICAgICAgICAgICAgICBwcm9nbmFtZSBhcmcgb3B0IGV4cGVjdGVkXG4gICAgICB8IE1lc3NhZ2UgcyAtPiAoKiB1c2VyIGVycm9yIG1lc3NhZ2UgKilcbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogJXMuXFxuXCIgcHJvZ25hbWUgc1xuICAgIGVuZDtcbiAgICB1c2FnZV9iIGIgIXNwZWNsaXN0IGVycm1zZztcbiAgICBpZiBlcnJvciA9IFVua25vd24gXCItaGVscFwiIHx8IGVycm9yID0gVW5rbm93biBcIi0taGVscFwiXG4gICAgdGhlbiBIZWxwIChCdWZmZXIuY29udGVudHMgYilcbiAgICBlbHNlIEJhZCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gIGluXG4gIGluY3IgY3VycmVudDtcbiAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSBkb1xuICAgIGJlZ2luIHRyeVxuICAgICAgbGV0IHMgPSAhYXJndi4oIWN1cnJlbnQpIGluXG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHMgPj0gMSAmJiBzLlswXSA9ICctJyB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBhY3Rpb24sIGZvbGxvdyA9XG4gICAgICAgICAgdHJ5IGFzc29jMyBzICFzcGVjbGlzdCwgTm9uZVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQga2V5d29yZCwgYXJnID0gc3BsaXQgcyBpblxuICAgICAgICAgICAgYXNzb2MzIGtleXdvcmQgIXNwZWNsaXN0LCBTb21lIGFyZ1xuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IHJhaXNlIChTdG9wIChVbmtub3duIHMpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbm9fYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwibm8gYXJndW1lbnRcIikpKSBpblxuICAgICAgICBsZXQgZ2V0X2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgaWYgIWN1cnJlbnQgKyAxIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICBlbHNlIHJhaXNlIChTdG9wIChNaXNzaW5nIHMpKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gYXJnXG4gICAgICAgIGluXG4gICAgICAgIGxldCBjb25zdW1lX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gaW5jciBjdXJyZW50XG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlYyB0cmVhdF9hY3Rpb24gPSBmdW5jdGlvblxuICAgICAgICB8IFVuaXQgZiAtPiBmICgpO1xuICAgICAgICB8IEJvb2wgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGJvb2xfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgYm9vbGVhblwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgcyAtPiBmIHNcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldCByIC0+IG5vX2FyZyAoKTsgciA6PSB0cnVlO1xuICAgICAgICB8IENsZWFyIHIgLT4gbm9fYXJnICgpOyByIDo9IGZhbHNlO1xuICAgICAgICB8IFN0cmluZyBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTeW1ib2wgKHN5bWIsIGYpIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgaWYgTGlzdC5tZW0gYXJnIHN5bWIgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJvbmUgb2Y6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIChtYWtlX3N5bWxpc3QgXCJcIiBcIiBcIiBcIlwiIHN5bWIpKSkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBTZXRfc3RyaW5nIHIgLT5cbiAgICAgICAgICAgIHIgOj0gZ2V0X2FyZyAoKTtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEludCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2ludCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgRmxvYXQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2Zsb2F0IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFR1cGxlIHNwZWNzIC0+XG4gICAgICAgICAgICBMaXN0Lml0ZXIgdHJlYXRfYWN0aW9uIHNwZWNzO1xuICAgICAgICB8IFJlc3QgZiAtPlxuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSAtIDEgZG9cbiAgICAgICAgICAgICAgZiAhYXJndi4oIWN1cnJlbnQgKyAxKTtcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICB8IEV4cGFuZCBmIC0+XG4gICAgICAgICAgICBpZiBub3QgYWxsb3dfZXhwYW5kIHRoZW5cbiAgICAgICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJBcmcuRXhwYW5kIGlzIGlzIG9ubHkgYWxsb3dlZCB3aXRoIEFyZy5wYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY1wiKTtcbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBsZXQgbmV3YXJnID0gZiBhcmcgaW5cbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IEFycmF5LnN1YiAhYXJndiAwICghY3VycmVudCArIDEpXG4gICAgICAgICAgICBhbmQgYWZ0ZXIgPSBBcnJheS5zdWIgIWFyZ3YgKCFjdXJyZW50ICsgMSkgKChBcnJheS5sZW5ndGggIWFyZ3YpIC0gIWN1cnJlbnQgLSAxKSBpblxuICAgICAgICAgICAgYXJndjo9IEFycmF5LmNvbmNhdCBbYmVmb3JlO25ld2FyZzthZnRlcl07XG4gICAgICAgIGluXG4gICAgICAgIHRyZWF0X2FjdGlvbiBhY3Rpb24gZW5kXG4gICAgICBlbHNlIGFub25mdW4gc1xuICAgIHdpdGggfCBCYWQgbSAtPiByYWlzZSAoY29udmVydF9lcnJvciAoTWVzc2FnZSBtKSk7XG4gICAgICAgICB8IFN0b3AgZSAtPiByYWlzZSAoY29udmVydF9lcnJvciBlKTtcbiAgICBlbmQ7XG4gICAgaW5jciBjdXJyZW50XG4gIGRvbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCB0cnVlIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZ1xuXG5sZXQgcGFyc2VfYXJndl9keW5hbWljID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGZhbHNlIGN1cnJlbnQgKHJlZiBhcmd2KSBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZ1xuXG5cbmxldCBwYXJzZV9hcmd2ID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYXJndl9keW5hbWljIH5jdXJyZW50OmN1cnJlbnQgYXJndiAocmVmIHNwZWNsaXN0KSBhbm9uZnVuIGVycm1zZ1xuXG5cbmxldCBwYXJzZSBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndiBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBwYXJzZV9keW5hbWljIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2X2R5bmFtaWMgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxubGV0IHBhcnNlX2V4cGFuZCBsIGYgbXNnID1cbiAgdHJ5XG4gICAgbGV0IGFyZ3YgPSByZWYgU3lzLmFyZ3YgaW5cbiAgICBsZXQgc3BlYyA9IHJlZiBsIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgKCFjdXJyZW50KSBpblxuICAgIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBzZWNvbmRfd29yZCBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgbiA9XG4gICAgaWYgbiA+PSBsZW4gdGhlbiBsZW5cbiAgICBlbHNlIGlmIHMuW25dID0gJyAnIHRoZW4gbG9vcCAobisxKVxuICAgIGVsc2UgblxuICBpblxuICBtYXRjaCBTdHJpbmcuaW5kZXggcyAnXFx0JyB3aXRoXG4gIHwgbiAtPiBsb29wIChuKzEpXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggU3RyaW5nLmluZGV4IHMgJyAnIHdpdGhcbiAgICAgIHwgbiAtPiBsb29wIChuKzEpXG4gICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gbGVuXG4gICAgICBlbmRcblxuXG5sZXQgbWF4X2FyZ19sZW4gY3VyIChrd2QsIHNwZWMsIGRvYykgPVxuICBtYXRjaCBzcGVjIHdpdGhcbiAgfCBTeW1ib2wgXyAtPiBtYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZClcbiAgfCBfIC0+IG1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkICsgc2Vjb25kX3dvcmQgZG9jKVxuXG5cbmxldCByZXBsYWNlX2xlYWRpbmdfdGFiIHMgPVxuICBsZXQgc2VlbiA9IHJlZiBmYWxzZSBpblxuICBTdHJpbmcubWFwIChmdW5jdGlvbiAnXFx0JyB3aGVuIG5vdCAhc2VlbiAtPiBzZWVuIDo9IHRydWU7ICcgJyB8IGMgLT4gYykgc1xuXG5sZXQgYWRkX3BhZGRpbmcgbGVuIGtzZCA9XG4gIG1hdGNoIGtzZCB3aXRoXG4gIHwgKF8sIF8sIFwiXCIpIC0+XG4gICAgICAoKiBEbyBub3QgcGFkIHVuZG9jdW1lbnRlZCBvcHRpb25zLCBzbyB0aGF0IHRoZXkgc3RpbGwgZG9uJ3Qgc2hvdyB1cCB3aGVuXG4gICAgICAgKiBydW4gdGhyb3VnaCBbdXNhZ2VdIG9yIFtwYXJzZV0uICopXG4gICAgICBrc2RcbiAgfCAoa3dkLCAoU3ltYm9sIF8gYXMgc3BlYyksIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSAoKG1heCAwIChsZW4gLSBjdXRjb2wpKSArIDMpICcgJyBpblxuICAgICAgKGt3ZCwgc3BlYywgXCJcXG5cIiBeIHNwYWNlcyBeIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICB8IChrd2QsIHNwZWMsIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBrd2RfbGVuID0gU3RyaW5nLmxlbmd0aCBrd2QgaW5cbiAgICAgIGxldCBkaWZmID0gbGVuIC0ga3dkX2xlbiAtIGN1dGNvbCBpblxuICAgICAgaWYgZGlmZiA8PSAwIHRoZW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSBkaWZmICcgJyBpblxuICAgICAgICBsZXQgcHJlZml4ID0gU3RyaW5nLnN1YiAocmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpIDAgY3V0Y29sIGluXG4gICAgICAgIGxldCBzdWZmaXggPSBTdHJpbmcuc3ViIG1zZyBjdXRjb2wgKFN0cmluZy5sZW5ndGggbXNnIC0gY3V0Y29sKSBpblxuICAgICAgICAoa3dkLCBzcGVjLCBwcmVmaXggXiBzcGFjZXMgXiBzdWZmaXgpXG5cblxubGV0IGFsaWduID8obGltaXQ9bWF4X2ludCkgc3BlY2xpc3QgPVxuICBsZXQgY29tcGxldGVkID0gYWRkX2hlbHAgc3BlY2xpc3QgaW5cbiAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IG1heF9hcmdfbGVuIDAgY29tcGxldGVkIGluXG4gIGxldCBsZW4gPSBtaW4gbGVuIGxpbWl0IGluXG4gIExpc3QubWFwIChhZGRfcGFkZGluZyBsZW4pIGNvbXBsZXRlZFxuXG5sZXQgdHJpbV9jciBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBsZW4gPiAwICYmIFN0cmluZy5nZXQgcyAobGVuIC0gMSkgPSAnXFxyJyB0aGVuXG4gICAgU3RyaW5nLnN1YiBzIDAgKGxlbiAtIDEpXG4gIGVsc2VcbiAgICBzXG5cbmxldCByZWFkX2F1eCB0cmltIHNlcCBmaWxlID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgbGV0IHdvcmRzID0gcmVmIFtdIGluXG4gIGxldCBzdGFzaCAoKSA9XG4gICAgbGV0IHdvcmQgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gICAgbGV0IHdvcmQgPSBpZiB0cmltIHRoZW4gdHJpbV9jciB3b3JkIGVsc2Ugd29yZCBpblxuICAgIHdvcmRzIDo9IHdvcmQgOjogIXdvcmRzO1xuICAgIEJ1ZmZlci5jbGVhciBidWZcbiAgaW5cbiAgYmVnaW5cbiAgICB0cnkgd2hpbGUgdHJ1ZSBkb1xuICAgICAgICBsZXQgYyA9IGlucHV0X2NoYXIgaWMgaW5cbiAgICAgICAgaWYgYyA9IHNlcCB0aGVuIHN0YXNoICgpIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gICAgICBkb25lXG4gICAgd2l0aCBFbmRfb2ZfZmlsZSAtPiAoKVxuICBlbmQ7XG4gIGlmIEJ1ZmZlci5sZW5ndGggYnVmID4gMCB0aGVuIHN0YXNoICgpO1xuICBjbG9zZV9pbiBpYztcbiAgQXJyYXkub2ZfbGlzdCAoTGlzdC5yZXYgIXdvcmRzKVxuXG5sZXQgcmVhZF9hcmcgPSByZWFkX2F1eCB0cnVlICdcXG4nXG5cbmxldCByZWFkX2FyZzAgPSByZWFkX2F1eCBmYWxzZSAnXFx4MDAnXG5cbmxldCB3cml0ZV9hdXggc2VwIGZpbGUgYXJncyA9XG4gIGxldCBvYyA9IG9wZW5fb3V0X2JpbiBmaWxlIGluXG4gIEFycmF5Lml0ZXIgKGZ1biBzIC0+IGZwcmludGYgb2MgXCIlcyVjXCIgcyBzZXApIGFyZ3M7XG4gIGNsb3NlX291dCBvY1xuXG5sZXQgd3JpdGVfYXJnID0gd3JpdGVfYXV4ICdcXG4nXG5cbmxldCB3cml0ZV9hcmcwID0gd3JpdGVfYXV4ICdcXHgwMCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBzdGF0ID0ge1xuICBtaW5vcl93b3JkcyA6IGZsb2F0O1xuICBwcm9tb3RlZF93b3JkcyA6IGZsb2F0O1xuICBtYWpvcl93b3JkcyA6IGZsb2F0O1xuICBtaW5vcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgbWFqb3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIGhlYXBfd29yZHMgOiBpbnQ7XG4gIGhlYXBfY2h1bmtzIDogaW50O1xuICBsaXZlX3dvcmRzIDogaW50O1xuICBsaXZlX2Jsb2NrcyA6IGludDtcbiAgZnJlZV93b3JkcyA6IGludDtcbiAgZnJlZV9ibG9ja3MgOiBpbnQ7XG4gIGxhcmdlc3RfZnJlZSA6IGludDtcbiAgZnJhZ21lbnRzIDogaW50O1xuICBjb21wYWN0aW9ucyA6IGludDtcbiAgdG9wX2hlYXBfd29yZHMgOiBpbnQ7XG4gIHN0YWNrX3NpemUgOiBpbnQ7XG59XG5cbnR5cGUgY29udHJvbCA9IHtcbiAgbXV0YWJsZSBtaW5vcl9oZWFwX3NpemUgOiBpbnQ7XG4gIG11dGFibGUgbWFqb3JfaGVhcF9pbmNyZW1lbnQgOiBpbnQ7XG4gIG11dGFibGUgc3BhY2Vfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgdmVyYm9zZSA6IGludDtcbiAgbXV0YWJsZSBtYXhfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgc3RhY2tfbGltaXQgOiBpbnQ7XG4gIG11dGFibGUgYWxsb2NhdGlvbl9wb2xpY3kgOiBpbnQ7XG4gIHdpbmRvd19zaXplIDogaW50O1xufVxuXG5leHRlcm5hbCBzdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3N0YXRcIlxuZXh0ZXJuYWwgcXVpY2tfc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19xdWlja19zdGF0XCJcbmV4dGVybmFsIGNvdW50ZXJzIDogdW5pdCAtPiAoZmxvYXQgKiBmbG9hdCAqIGZsb2F0KSA9IFwiY2FtbF9nY19jb3VudGVyc1wiXG5leHRlcm5hbCBtaW5vcl93b3JkcyA6IHVuaXQgLT4gKGZsb2F0IFtAdW5ib3hlZF0pXG4gID0gXCJjYW1sX2djX21pbm9yX3dvcmRzXCIgXCJjYW1sX2djX21pbm9yX3dvcmRzX3VuYm94ZWRcIlxuZXh0ZXJuYWwgZ2V0IDogdW5pdCAtPiBjb250cm9sID0gXCJjYW1sX2djX2dldFwiXG5leHRlcm5hbCBzZXQgOiBjb250cm9sIC0+IHVuaXQgPSBcImNhbWxfZ2Nfc2V0XCJcbmV4dGVybmFsIG1pbm9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21pbm9yXCJcbmV4dGVybmFsIG1ham9yX3NsaWNlIDogaW50IC0+IGludCA9IFwiY2FtbF9nY19tYWpvcl9zbGljZVwiXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBmdWxsX21ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2Z1bGxfbWFqb3JcIlxuZXh0ZXJuYWwgY29tcGFjdCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19jb21wYWN0aW9uXCJcbmV4dGVybmFsIGdldF9taW5vcl9mcmVlIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21pbm9yX2ZyZWVcIlxuZXh0ZXJuYWwgZ2V0X2J1Y2tldCA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2J1Y2tldFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBnZXRfY3JlZGl0IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2NyZWRpdFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBodWdlX2ZhbGxiYWNrX2NvdW50IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudFwiXG5cbm9wZW4gUHJpbnRmXG5cbmxldCBwcmludF9zdGF0IGMgPVxuICBsZXQgc3QgPSBzdGF0ICgpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0Lm1pbm9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJtYWpvcl9jb2xsZWN0aW9uczogJWRcXG5cIiBzdC5tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiY29tcGFjdGlvbnM6ICAgICAgICVkXFxuXCIgc3QuY29tcGFjdGlvbnM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDEgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJS4wZlwiIHN0Lm1pbm9yX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5taW5vcl93b3JkcztcbiAgZnByaW50ZiBjIFwicHJvbW90ZWRfd29yZHM6ICUqLjBmXFxuXCIgbDEgc3QucHJvbW90ZWRfd29yZHM7XG4gIGZwcmludGYgYyBcIm1ham9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1ham9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwyID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiVkXCIgc3QudG9wX2hlYXBfd29yZHMpIGluXG4gIGZwcmludGYgYyBcInRvcF9oZWFwX3dvcmRzOiAlKmRcXG5cIiBsMiBzdC50b3BfaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwiaGVhcF93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmhlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImxpdmVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5saXZlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJmcmVlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuZnJlZV93b3JkcztcbiAgZnByaW50ZiBjIFwibGFyZ2VzdF9mcmVlOiAgICUqZFxcblwiIGwyIHN0Lmxhcmdlc3RfZnJlZTtcbiAgZnByaW50ZiBjIFwiZnJhZ21lbnRzOiAgICAgICUqZFxcblwiIGwyIHN0LmZyYWdtZW50cztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGZwcmludGYgYyBcImxpdmVfYmxvY2tzOiAlZFxcblwiIHN0LmxpdmVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJmcmVlX2Jsb2NrczogJWRcXG5cIiBzdC5mcmVlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiaGVhcF9jaHVua3M6ICVkXFxuXCIgc3QuaGVhcF9jaHVua3NcblxuXG5sZXQgYWxsb2NhdGVkX2J5dGVzICgpID1cbiAgbGV0IChtaSwgcHJvLCBtYSkgPSBjb3VudGVycyAoKSBpblxuICAobWkgKy4gbWEgLS4gcHJvKSAqLiBmbG9hdF9vZl9pbnQgKFN5cy53b3JkX3NpemUgLyA4KVxuXG5cbmV4dGVybmFsIGZpbmFsaXNlIDogKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVnaXN0ZXJcIlxuZXh0ZXJuYWwgZmluYWxpc2VfbGFzdCA6ICh1bml0IC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPVxuICBcImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZmluYWxpc2VfcmVsZWFzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWxlYXNlXCJcblxuXG50eXBlIGFsYXJtID0gYm9vbCByZWZcbnR5cGUgYWxhcm1fcmVjID0ge2FjdGl2ZSA6IGFsYXJtOyBmIDogdW5pdCAtPiB1bml0fVxuXG5sZXQgcmVjIGNhbGxfYWxhcm0gYXJlYyA9XG4gIGlmICEoYXJlYy5hY3RpdmUpIHRoZW4gYmVnaW5cbiAgICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gICAgYXJlYy5mICgpO1xuICBlbmRcblxuXG5sZXQgY3JlYXRlX2FsYXJtIGYgPVxuICBsZXQgYXJlYyA9IHsgYWN0aXZlID0gcmVmIHRydWU7IGYgPSBmIH0gaW5cbiAgZmluYWxpc2UgY2FsbF9hbGFybSBhcmVjO1xuICBhcmVjLmFjdGl2ZVxuXG5cbmxldCBkZWxldGVfYWxhcm0gYSA9IGEgOj0gZmFsc2VcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTWVzc2FnZSBkaWdlc3QgKE1ENSkgKilcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlID0gU3RyaW5nLmNvbXBhcmVcbmxldCBlcXVhbCA9IFN0cmluZy5lcXVhbFxuXG5leHRlcm5hbCB1bnNhZmVfc3RyaW5nOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9zdHJpbmdcIlxuZXh0ZXJuYWwgY2hhbm5lbDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfY2hhblwiXG5cbmxldCBzdHJpbmcgc3RyID1cbiAgdW5zYWZlX3N0cmluZyBzdHIgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbmxldCBieXRlcyBiID0gc3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpXG5cbmxldCBzdWJzdHJpbmcgc3RyIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gU3RyaW5nLmxlbmd0aCBzdHIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9zdHJpbmcgc3RyIG9mcyBsZW5cblxubGV0IHN1YmJ5dGVzIGIgb2ZzIGxlbiA9IHN1YnN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKSBvZnMgbGVuXG5cbmxldCBmaWxlIGZpbGVuYW1lID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZW5hbWUgaW5cbiAgbWF0Y2ggY2hhbm5lbCBpYyAoLTEpIHdpdGhcbiAgICB8IGQgLT4gY2xvc2VfaW4gaWM7IGRcbiAgICB8IGV4Y2VwdGlvbiBlIC0+IGNsb3NlX2luIGljOyByYWlzZSBlXG5cbmxldCBvdXRwdXQgY2hhbiBkaWdlc3QgPVxuICBvdXRwdXRfc3RyaW5nIGNoYW4gZGlnZXN0XG5cbmxldCBpbnB1dCBjaGFuID0gcmVhbGx5X2lucHV0X3N0cmluZyBjaGFuIDE2XG5cbmxldCBjaGFyX2hleCBuID1cbiAgQ2hhci51bnNhZmVfY2hyIChuICsgaWYgbiA8IDEwIHRoZW4gQ2hhci5jb2RlICcwJyBlbHNlIChDaGFyLmNvZGUgJ2EnIC0gMTApKVxuXG5sZXQgdG9faGV4IGQgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGQgPD4gMTYgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC50b19oZXhcIjtcbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAzMiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBsZXQgeCA9IENoYXIuY29kZSBkLltpXSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIpIChjaGFyX2hleCAoeCBsc3IgNCkpO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIrMSkgKGNoYXJfaGV4ICh4IGxhbmQgMHgwZikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuXG5sZXQgZnJvbV9oZXggcyA9XG4gIGlmIFN0cmluZy5sZW5ndGggcyA8PiAzMiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LmZyb21faGV4XCI7XG4gIGxldCBkaWdpdCBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcwJy4uJzknIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICcwJ1xuICAgIHwgJ0EnLi4nRicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ0EnICsgMTBcbiAgICB8ICdhJy4uJ2YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdhJyArIDEwXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRGlnZXN0LmZyb21faGV4XCIpXG4gIGluXG4gIGxldCBieXRlIGkgPSBkaWdpdCBzLltpXSBsc2wgNCArIGRpZ2l0IHMuW2krMV0gaW5cbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAxNiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBCeXRlcy5zZXQgcmVzdWx0IGkgKENoYXIuY2hyIChieXRlICgyICogaSkpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICBUaGlzIGlzIGEgbGFnZ2VkLUZpYm9uYWNjaSBGKDU1LCAyNCwgKykgd2l0aCBhIG1vZGlmaWVkIGFkZGl0aW9uXG4gICBmdW5jdGlvbiB0byBlbmhhbmNlIHRoZSBtaXhpbmcgb2YgYml0cy5cbiAgIElmIHdlIHVzZSBub3JtYWwgYWRkaXRpb24sIHRoZSBsb3ctb3JkZXIgYml0IGZhaWxzIHRlc3RzIDEgYW5kIDdcbiAgIG9mIHRoZSBEaWVoYXJkIHRlc3Qgc3VpdGUsIGFuZCBiaXRzIDEgYW5kIDIgYWxzbyBmYWlsIHRlc3QgNy5cbiAgIElmIHdlIHVzZSBtdWx0aXBsaWNhdGlvbiBhcyBzdWdnZXN0ZWQgYnkgTWFyc2FnbGlhLCBpdCBkb2Vzbid0IGZhcmVcbiAgIG11Y2ggYmV0dGVyLlxuICAgQnkgbWl4aW5nIHRoZSBiaXRzIG9mIG9uZSBvZiB0aGUgbnVtYmVycyBiZWZvcmUgYWRkaXRpb24gKFhPUiB0aGVcbiAgIDUgaGlnaC1vcmRlciBiaXRzIGludG8gdGhlIGxvdy1vcmRlciBiaXRzKSwgd2UgZ2V0IGEgZ2VuZXJhdG9yIHRoYXRcbiAgIHBhc3NlcyBhbGwgdGhlIERpZWhhcmQgdGVzdHMuXG4qKVxuXG5leHRlcm5hbCByYW5kb21fc2VlZDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG5cbiAgdHlwZSB0ID0geyBzdCA6IGludCBhcnJheTsgbXV0YWJsZSBpZHggOiBpbnQgfVxuXG4gIGxldCBuZXdfc3RhdGUgKCkgPSB7IHN0ID0gQXJyYXkubWFrZSA1NSAwOyBpZHggPSAwIH1cbiAgbGV0IGFzc2lnbiBzdDEgc3QyID1cbiAgICBBcnJheS5ibGl0IHN0Mi5zdCAwIHN0MS5zdCAwIDU1O1xuICAgIHN0MS5pZHggPC0gc3QyLmlkeFxuXG5cbiAgbGV0IGZ1bGxfaW5pdCBzIHNlZWQgPVxuICAgIGxldCBjb21iaW5lIGFjY3UgeCA9IERpZ2VzdC5zdHJpbmcgKGFjY3UgXiBzdHJpbmdfb2ZfaW50IHgpIGluXG4gICAgbGV0IGV4dHJhY3QgZCA9XG4gICAgICBDaGFyLmNvZGUgZC5bMF0gKyAoQ2hhci5jb2RlIGQuWzFdIGxzbCA4KSArIChDaGFyLmNvZGUgZC5bMl0gbHNsIDE2KVxuICAgICAgKyAoQ2hhci5jb2RlIGQuWzNdIGxzbCAyNClcbiAgICBpblxuICAgIGxldCBzZWVkID0gaWYgQXJyYXkubGVuZ3RoIHNlZWQgPSAwIHRoZW4gW3wgMCB8XSBlbHNlIHNlZWQgaW5cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBzZWVkIGluXG4gICAgZm9yIGkgPSAwIHRvIDU0IGRvXG4gICAgICBzLnN0LihpKSA8LSBpO1xuICAgIGRvbmU7XG4gICAgbGV0IGFjY3UgPSByZWYgXCJ4XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgKyBtYXggNTUgbCBkb1xuICAgICAgbGV0IGogPSBpIG1vZCA1NSBpblxuICAgICAgbGV0IGsgPSBpIG1vZCBsIGluXG4gICAgICBhY2N1IDo9IGNvbWJpbmUgIWFjY3Ugc2VlZC4oayk7XG4gICAgICBzLnN0LihqKSA8LSAocy5zdC4oaikgbHhvciBleHRyYWN0ICFhY2N1KSBsYW5kIDB4M0ZGRkZGRkY7ICAoKiBQUiM1NTc1ICopXG4gICAgZG9uZTtcbiAgICBzLmlkeCA8LSAwXG5cblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgZnVsbF9pbml0IHJlc3VsdCBzZWVkO1xuICAgIHJlc3VsdFxuXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID0gbWFrZSAocmFuZG9tX3NlZWQgKCkpXG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGFzc2lnbiByZXN1bHQgcztcbiAgICByZXN1bHRcblxuXG4gICgqIFJldHVybnMgMzAgcmFuZG9tIGJpdHMgYXMgYW4gaW50ZWdlciAwIDw9IHggPCAxMDczNzQxODI0ICopXG4gIGxldCBiaXRzIHMgPVxuICAgIHMuaWR4IDwtIChzLmlkeCArIDEpIG1vZCA1NTtcbiAgICBsZXQgY3VydmFsID0gcy5zdC4ocy5pZHgpIGluXG4gICAgbGV0IG5ld3ZhbCA9IHMuc3QuKChzLmlkeCArIDI0KSBtb2QgNTUpXG4gICAgICAgICAgICAgICAgICsgKGN1cnZhbCBseG9yICgoY3VydmFsIGxzciAyNSkgbGFuZCAweDFGKSkgaW5cbiAgICBsZXQgbmV3dmFsMzAgPSBuZXd2YWwgbGFuZCAweDNGRkZGRkZGIGluICAoKiBQUiM1NTc1ICopXG4gICAgcy5zdC4ocy5pZHgpIDwtIG5ld3ZhbDMwO1xuICAgIG5ld3ZhbDMwXG5cblxuICBsZXQgcmVjIGludGF1eCBzIG4gPVxuICAgIGxldCByID0gYml0cyBzIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiAweDNGRkZGRkZGIC0gbiArIDEgdGhlbiBpbnRhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiAweDNGRkZGRkZGIHx8IGJvdW5kIDw9IDBcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludFwiXG4gICAgZWxzZSBpbnRhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQzMmF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDMyLm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDMyLnNoaWZ0X2xlZnQgKEludDMyLm9mX2ludCAoYml0cyBzIGxhbmQgMSkpIDMwIGluXG4gICAgbGV0IHIgPSBJbnQzMi5sb2dvciBiMSBiMiBpblxuICAgIGxldCB2ID0gSW50MzIucmVtIHIgbiBpblxuICAgIGlmIEludDMyLnN1YiByIHYgPiBJbnQzMi5hZGQgKEludDMyLnN1YiBJbnQzMi5tYXhfaW50IG4pIDFsXG4gICAgdGhlbiBpbnQzMmF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50MzIgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDMyXCJcbiAgICBlbHNlIGludDMyYXV4IHMgYm91bmRcblxuXG4gIGxldCByZWMgaW50NjRhdXggcyBuID1cbiAgICBsZXQgYjEgPSBJbnQ2NC5vZl9pbnQgKGJpdHMgcykgaW5cbiAgICBsZXQgYjIgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcykpIDMwIGluXG4gICAgbGV0IGIzID0gSW50NjQuc2hpZnRfbGVmdCAoSW50NjQub2ZfaW50IChiaXRzIHMgbGFuZCA3KSkgNjAgaW5cbiAgICBsZXQgciA9IEludDY0LmxvZ29yIGIxIChJbnQ2NC5sb2dvciBiMiBiMykgaW5cbiAgICBsZXQgdiA9IEludDY0LnJlbSByIG4gaW5cbiAgICBpZiBJbnQ2NC5zdWIgciB2ID4gSW50NjQuYWRkIChJbnQ2NC5zdWIgSW50NjQubWF4X2ludCBuKSAxTFxuICAgIHRoZW4gaW50NjRhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDY0IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBMXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQ2NFwiXG4gICAgZWxzZSBpbnQ2NGF1eCBzIGJvdW5kXG5cblxuICBsZXQgbmF0aXZlaW50ID1cbiAgICBpZiBOYXRpdmVpbnQuc2l6ZSA9IDMyXG4gICAgdGhlbiBmdW4gcyBib3VuZCAtPiBOYXRpdmVpbnQub2ZfaW50MzIgKGludDMyIHMgKE5hdGl2ZWludC50b19pbnQzMiBib3VuZCkpXG4gICAgZWxzZSBmdW4gcyBib3VuZCAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGludDY0IHMgKEludDY0Lm9mX25hdGl2ZWludCBib3VuZCkpXG5cblxuICAoKiBSZXR1cm5zIGEgZmxvYXQgMCA8PSB4IDw9IDEgd2l0aCBhdCBtb3N0IDYwIGJpdHMgb2YgcHJlY2lzaW9uLiAqKVxuICBsZXQgcmF3ZmxvYXQgcyA9XG4gICAgbGV0IHNjYWxlID0gMTA3Mzc0MTgyNC4wICAoKiAyXjMwICopXG4gICAgYW5kIHIxID0gUGVydmFzaXZlcy5mbG9hdCAoYml0cyBzKVxuICAgIGFuZCByMiA9IFBlcnZhc2l2ZXMuZmxvYXQgKGJpdHMgcylcbiAgICBpbiAocjEgLy4gc2NhbGUgKy4gcjIpIC8uIHNjYWxlXG5cblxuICBsZXQgZmxvYXQgcyBib3VuZCA9IHJhd2Zsb2F0IHMgKi4gYm91bmRcblxuICBsZXQgYm9vbCBzID0gKGJpdHMgcyBsYW5kIDEgPSAwKVxuXG5lbmRcblxuKCogVGhpcyBpcyB0aGUgc3RhdGUgeW91IGdldCB3aXRoIFtpbml0IDI3MTgyODE4XSBhbmQgdGhlbiBhcHBseWluZ1xuICAgdGhlIFwibGFuZCAweDNGRkZGRkZGXCIgZmlsdGVyIHRvIHRoZW0uICBTZWUgIzU1NzUsICM1NzkzLCAjNTk3Ny4gKilcbmxldCBkZWZhdWx0ID0ge1xuICBTdGF0ZS5zdCA9IFt8XG4gICAgICAweDNhZTI1MjJiOyAweDFkOGQ0NjM0OyAweDE1YjRmYWQwOyAweDE4YjE0YWNlOyAweDEyZjhhM2M0OyAweDNiMDg2YzQ3O1xuICAgICAgMHgxNmQ0NjdkNjsgMHgxMDFkOTFjNzsgMHgzMjFkZjE3NzsgMHgwMTc2YzE5MzsgMHgxZmY3MmJmMTsgMHgxZTg4OTEwOTtcbiAgICAgIDB4MGI0NjRiMTg7IDB4MmI4NmI5N2M7IDB4MDg5MWRhNDg7IDB4MDMxMzc0NjM7IDB4MDg1YWM1YTE7IDB4MTVkNjFmMmY7XG4gICAgICAweDNiY2VkMzU5OyAweDI5YzFjMTMyOyAweDNhODY3NjZlOyAweDM2NmQ4Yzg2OyAweDFmNWI2MjIyOyAweDNjZTFiNTlmO1xuICAgICAgMHgyZWJmNzhlMTsgMHgyN2NkMWI4NjsgMHgyNThmM2RjMzsgMHgzODlhODE5NDsgMHgwMmU0YzQ0YzsgMHgxOGM0M2Y3ZDtcbiAgICAgIDB4MGY2ZTUzNGY7IDB4MWU3ZGYzNTk7IDB4MDU1ZDBiN2U7IDB4MTBlODRlN2U7IDB4MTI2MTk4ZTQ7IDB4MGU3NzIyY2I7XG4gICAgICAweDFjYmVkZTI4OyAweDMzOTFiOTY0OyAweDNkNDBlOTJhOyAweDBjNTk5MzNkOyAweDBiOGNkMGI3OyAweDI0ZWZmZjFjO1xuICAgICAgMHgyODAzZmRhYTsgMHgwOGViYzcyZTsgMHgwZjUyMmUzMjsgMHgwNTM5OGVkYzsgMHgyMTQ0YTA0YzsgMHgwYWVmM2NiZDtcbiAgICAgIDB4MDFhZDQ3MTk7IDB4MzViOTNjZDY7IDB4MmE1NTlkNGY7IDB4MWU2ZmQ3Njg7IDB4MjZlMjdmMzY7IDB4MTg2ZjE4YzM7XG4gICAgICAweDJmYmY5NjdhO1xuICAgIHxdO1xuICBTdGF0ZS5pZHggPSAwO1xufVxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgZGVmYXVsdFxubGV0IGludCBib3VuZCA9IFN0YXRlLmludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50MzIgYm91bmQgPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IGJvdW5kXG5sZXQgbmF0aXZlaW50IGJvdW5kID0gU3RhdGUubmF0aXZlaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IGRlZmF1bHQgYm91bmRcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgc2NhbGVcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCBkZWZhdWx0XG5cbmxldCBmdWxsX2luaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IHNlZWRcbmxldCBpbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCgpKVxuXG4oKiBNYW5pcHVsYXRpbmcgdGhlIGN1cnJlbnQgc3RhdGUuICopXG5cbmxldCBnZXRfc3RhdGUgKCkgPSBTdGF0ZS5jb3B5IGRlZmF1bHRcbmxldCBzZXRfc3RhdGUgcyA9IFN0YXRlLmFzc2lnbiBkZWZhdWx0IHNcblxuKCoqKioqKioqKioqKioqKioqKioqXG5cbigqIFRlc3QgZnVuY3Rpb25zLiAgTm90IGluY2x1ZGVkIGluIHRoZSBsaWJyYXJ5LlxuICAgVGhlIFtjaGlzcXVhcmVdIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBuID4gMTByLlxuICAgSXQgcmV0dXJucyBhIHRyaXBsZSAobG93LCBhY3R1YWwsIGhpZ2gpLlxuICAgSWYgbG93IDw9IGFjdHVhbCA8PSBoaWdoLCB0aGUgW2ddIGZ1bmN0aW9uIHBhc3NlZCB0aGUgdGVzdCxcbiAgIG90aGVyd2lzZSBpdCBmYWlsZWQuXG5cbiAgU29tZSByZXN1bHRzOlxuXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDUwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI5OTc5MjY0MzsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAxNDE0MjEzNjsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMjQ7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAwOyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMjQ7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDE0MTQyMTM2OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMjk5NzkyNjQzOyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbi0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTk3LjUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4OS43NDAwMDAwMDAwMDUyMzg3LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDQ4NTguNTc4NjQzNzYyNjksIDUwNDUuNSwgNTE0MS40MjEzNTYyMzczMSlcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9XG4oOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTQ0LjgwNTk5OTk5OTk4MjMwNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDE5LjE5NzQ0MDAwMDAwMzU1LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU5LjMxNzc2MDAwMDAwNTM2LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDM5Ljk4NDYzOTk5OTk5NTEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU0LjM4MjA3OTk5OTk5NTc3LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDkwLjA5NjAwMDAwMDAwNSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDc2Ljc4NzIwMDAwMDAwNjEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjE3NjAwMDAwMDAwNjc1MjEsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4yMTYwMDAwMDAwMDAzNDkyLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODAuNjIyMDAwMDAwMDAzMDI2OCwgMTIwLilcblxuKilcblxuKCogUmV0dXJuIHRoZSBzdW0gb2YgdGhlIHNxdWFyZXMgb2YgdltpMCxpMVsgKilcbmxldCByZWMgc3Vtc3EgdiBpMCBpMSA9XG4gIGlmIGkwID49IGkxIHRoZW4gMC4wXG4gIGVsc2UgaWYgaTEgPSBpMCArIDEgdGhlbiBQZXJ2YXNpdmVzLmZsb2F0IHYuKGkwKSAqLiBQZXJ2YXNpdmVzLmZsb2F0IHYuKGkwKVxuICBlbHNlIHN1bXNxIHYgaTAgKChpMCtpMSkvMikgKy4gc3Vtc3EgdiAoKGkwK2kxKS8yKSBpMVxuXG5cbmxldCBjaGlzcXVhcmUgZyBuIHIgPVxuICBpZiBuIDw9IDEwICogciB0aGVuIGludmFsaWRfYXJnIFwiY2hpc3F1YXJlXCI7XG4gIGxldCBmID0gQXJyYXkubWFrZSByIDAgaW5cbiAgZm9yIGkgPSAxIHRvIG4gZG9cbiAgICBsZXQgdCA9IGcgciBpblxuICAgIGYuKHQpIDwtIGYuKHQpICsgMVxuICBkb25lO1xuICBsZXQgdCA9IHN1bXNxIGYgMCByXG4gIGFuZCByID0gUGVydmFzaXZlcy5mbG9hdCByXG4gIGFuZCBuID0gUGVydmFzaXZlcy5mbG9hdCBuIGluXG4gIGxldCBzciA9IDIuMCAqLiBzcXJ0IHIgaW5cbiAgKHIgLS4gc3IsICAgKHIgKi4gdCAvLiBuKSAtLiBuLCAgIHIgKy4gc3IpXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBsaW5lYXIgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb20gbnVtYmVycy5cbiopXG5sZXQgc3QgPSByZWYgMFxubGV0IGluaXRfZGlmZiByID0gc3QgOj0gaW50IHJcbmxldCBkaWZmIHIgPVxuICBsZXQgeDEgPSAhc3RcbiAgYW5kIHgyID0gaW50IHJcbiAgaW5cbiAgc3QgOj0geDI7XG4gIGlmIHgxID49IHgyIHRoZW5cbiAgICB4MSAtIHgyXG4gIGVsc2VcbiAgICByICsgeDEgLSB4MlxuXG5cbmxldCBzdDEgPSByZWYgMFxuYW5kIHN0MiA9IHJlZiAwXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBxdWFkcmF0aWMgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb21cbiAgIG51bWJlcnMuXG4qKVxubGV0IGluaXRfZGlmZjIgciA9IHN0MSA6PSBpbnQgcjsgc3QyIDo9IGludCByXG5sZXQgZGlmZjIgciA9XG4gIGxldCB4MSA9ICFzdDFcbiAgYW5kIHgyID0gIXN0MlxuICBhbmQgeDMgPSBpbnQgclxuICBpblxuICBzdDEgOj0geDI7XG4gIHN0MiA6PSB4MztcbiAgKHgzIC0geDIgLSB4MiArIHgxICsgMipyKSBtb2QgclxuXG5cbioqKioqKioqKioqKioqKioqKioqKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBIYXNoIHRhYmxlcyAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG9sZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaF91bml2X3BhcmFtXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbigqIFdlIGRvIGR5bmFtaWMgaGFzaGluZywgYW5kIHJlc2l6ZSB0aGUgdGFibGUgYW5kIHJlaGFzaCB0aGUgZWxlbWVudHNcbiAgIHdoZW4gYnVja2V0cyBiZWNvbWUgdG9vIGxvbmcuICopXG5cbnR5cGUgKCdhLCAnYikgdCA9XG4gIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICBtdXRhYmxlIGRhdGE6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgbXV0YWJsZSBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gIH1cblxuYW5kICgnYSwgJ2IpIGJ1Y2tldGxpc3QgPVxuICAgIEVtcHR5XG4gIHwgQ29ucyBvZiB7IG11dGFibGUga2V5OiAnYTtcbiAgICAgICAgICAgICAgbXV0YWJsZSBkYXRhOiAnYjtcbiAgICAgICAgICAgICAgbXV0YWJsZSBuZXh0OiAoJ2EsICdiKSBidWNrZXRsaXN0IH1cblxuKCogVGhlIHNpZ24gb2YgaW5pdGlhbF9zaXplIGVuY29kZXMgdGhlIGZhY3QgdGhhdCBhIHRyYXZlcnNhbCBpc1xuICAgb25nb2luZyBvciBub3QuXG5cbiAgIFRoaXMgZGlzYWJsZXMgdGhlIGVmZmljaWVudCBpbiBwbGFjZSBpbXBsZW1lbnRhdGlvbiBvZiByZXNpemluZy5cbiopXG5cbmxldCBvbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIHx8IGguaW5pdGlhbF9zaXplIDwgMFxuXG5sZXQgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgaC5pbml0aWFsX3NpemUgPC0gLSBoLmluaXRpYWxfc2l6ZVxuXG4oKiBUbyBwaWNrIHJhbmRvbSBzZWVkcyBpZiByZXF1ZXN0ZWQgKilcblxubGV0IHJhbmRvbWl6ZWRfZGVmYXVsdCA9XG4gIGxldCBwYXJhbXMgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJDQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPiBcIlwiIGluXG4gIFN0cmluZy5jb250YWlucyBwYXJhbXMgJ1InXG5cbmxldCByYW5kb21pemVkID0gcmVmIHJhbmRvbWl6ZWRfZGVmYXVsdFxuXG5sZXQgcmFuZG9taXplICgpID0gcmFuZG9taXplZCA6PSB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9ICFyYW5kb21pemVkXG5cbmxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbigqIENyZWF0aW5nIGEgZnJlc2gsIGVtcHR5IHRhYmxlICopXG5cbmxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICBpZiB4ID49IG4gdGhlbiB4XG4gIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG5sZXQgY3JlYXRlID8ocmFuZG9tID0gIXJhbmRvbWl6ZWQpIGluaXRpYWxfc2l6ZSA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG5sZXQgY2xlYXIgaCA9XG4gIGguc2l6ZSA8LSAwO1xuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgZG9uZVxuXG5sZXQgcmVzZXQgaCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICAgIHx8IGxlbiA9IGFicyBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgY2xlYXIgaFxuICBlbHNlIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgKGFicyBoLmluaXRpYWxfc2l6ZSkgRW1wdHlcbiAgZW5kXG5cbmxldCBjb3B5X2J1Y2tldGxpc3QgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IEVtcHR5XG4gIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgbGV0IHJlYyBsb29wIHByZWMgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IENvbnMgcHJlYyAtPiAgcHJlYy5uZXh0IDwtIHJcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGxvb3AgciBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICBsb29wIHIgbmV4dDtcbiAgICAgIHJcblxubGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5tYXAgY29weV9idWNrZXRsaXN0IGguZGF0YSB9XG5cbmxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG5sZXQgcmVzaXplIGluZGV4ZnVuIGggPVxuICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IG5kYXRhX3RhaWwgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IGlucGxhY2UgPSBub3QgKG9uZ29pbmdfdHJhdmVyc2FsIGgpIGluXG4gICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAgICAoKiBzbyB0aGF0IGluZGV4ZnVuIHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGFzIGNlbGwgLT5cbiAgICAgICAgICBsZXQgY2VsbCA9XG4gICAgICAgICAgICBpZiBpbnBsYWNlIHRoZW4gY2VsbFxuICAgICAgICAgICAgZWxzZSBDb25zIHtrZXk7IGRhdGE7IG5leHQgPSBFbXB0eX1cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBuaWR4ID0gaW5kZXhmdW4gaCBrZXkgaW5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBuZGF0YV90YWlsLihuaWR4KSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBuZGF0YS4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gY2VsbDtcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgbmRhdGFfdGFpbC4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG5leHRcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBpbnBsYWNlIHRoZW5cbiAgICAgIGZvciBpID0gMCB0byBuc2l6ZSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggbmRhdGFfdGFpbC4oaSkgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBFbXB0eVxuICAgICAgZG9uZTtcbiAgZW5kXG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSAzXG4gIHRoZW4gKHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcbiAgZWxzZSAob2xkX2hhc2hfcGFyYW0gMTAgMTAwIGtleSkgbW9kIChBcnJheS5sZW5ndGggaC5kYXRhKVxuXG5sZXQgYWRkIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbmxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICAoKVxuICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgIGVuZFxuICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbmxldCByZW1vdmUgaCBrZXkgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG5sZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG5sZXQgZmluZCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxubGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgTm9uZVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG5sZXQgZmluZF9vcHQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG5sZXQgZmluZF9hbGwgaCBrZXkgPVxuICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgW11cbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gZGF0YSA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbmxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gIGVuZFxuXG5sZXQgbWVtIGgga2V5ID1cbiAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgY29tcGFyZSBrIGtleSA9IDAgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCBpdGVyIGYgaCA9XG4gIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+XG4gICAgICAgICgpXG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZiBrZXkgZGF0YTsgZG9fYnVja2V0IG5leHQgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gRW1wdHlcbiAgICAgIGVuZFxuICB8IChDb25zICh7a2V5OyBkYXRhOyBuZXh0fSBhcyBjKSkgYXMgc2xvdCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZiBrZXkgZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgbmV4dFxuICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gc2xvdFxuICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBzbG90XG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGMuZGF0YSA8LSBkYXRhO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgc2xvdCBuZXh0XG4gICAgICBlbmRcblxubGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICBsZXQgZCA9IGguZGF0YSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBFbXB0eSBoLmRhdGEuKGkpXG4gICAgZG9uZVxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IGZvbGQgZiBoIGluaXQgPVxuICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgIG1hdGNoIGIgd2l0aFxuICAgICAgRW1wdHkgLT5cbiAgICAgICAgYWNjdVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGRvX2J1Y2tldCBuZXh0IChmIGtleSBkYXRhIGFjY3UpIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgICFhY2N1XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG50eXBlIHN0YXRpc3RpY3MgPSB7XG4gIG51bV9iaW5kaW5nczogaW50O1xuICBudW1fYnVja2V0czogaW50O1xuICBtYXhfYnVja2V0X2xlbmd0aDogaW50O1xuICBidWNrZXRfaGlzdG9ncmFtOiBpbnQgYXJyYXlcbn1cblxubGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFjY3VcbiAgfCBDb25ze25leHR9IC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSBuZXh0XG5cbmxldCBzdGF0cyBoID1cbiAgbGV0IG1ibCA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgQXJyYXkuaXRlclxuICAgIChmdW4gYiAtPlxuICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgaC5kYXRhO1xuICB7IG51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuKCoqIHs2IEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSB0YmwgPVxuICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgaW5cbiAgYXV4IDAgRW1wdHlcblxubGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbmxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbmxldCBhZGRfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG5sZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gIHJlcGxhY2Vfc2VxIHRibCBpO1xuICB0YmxcblxuKCogRnVuY3RvcmlhbCBpbnRlcmZhY2UgKilcblxubW9kdWxlIHR5cGUgSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnYSB0XG4gICAgdmFsIGNyZWF0ZSA6ID9yYW5kb206Ym9vbCAtPiBpbnQgLT4gJ2EgdFxuICAgIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICAgIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbCA6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyIDogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQgOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlU2VlZGVkKEg6IFNlZWRlZEhhc2hlZFR5cGUpOiAoU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIHR5cGUga2V5ID0gSC50XG4gICAgdHlwZSAnYSBoYXNodGJsID0gKGtleSwgJ2EpIHRcbiAgICB0eXBlICdhIHQgPSAnYSBoYXNodGJsXG4gICAgbGV0IGNyZWF0ZSA9IGNyZWF0ZVxuICAgIGxldCBjbGVhciA9IGNsZWFyXG4gICAgbGV0IHJlc2V0ID0gcmVzZXRcbiAgICBsZXQgY29weSA9IGNvcHlcblxuICAgIGxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAgICAgKEguaGFzaCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBhZGQgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG4gICAgbGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgKClcbiAgICAgIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGJlZ2luXG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBbXVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhPWQ7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gZCA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxuICAgIGxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gICAgICBlbmRcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgICAgIEguZXF1YWwgayBrZXkgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IGl0ZXIgPSBpdGVyXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSA9IGZpbHRlcl9tYXBfaW5wbGFjZVxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgc3RhdHMgPSBzdGF0c1xuICAgIGxldCB0b19zZXEgPSB0b19zZXFcbiAgICBsZXQgdG9fc2VxX2tleXMgPSB0b19zZXFfa2V5c1xuICAgIGxldCB0b19zZXFfdmFsdWVzID0gdG9fc2VxX3ZhbHVlc1xuICAgIGxldCBhZGRfc2VxID0gYWRkX3NlcVxuICAgIGxldCByZXBsYWNlX3NlcSA9IHJlcGxhY2Vfc2VxXG4gICAgbGV0IG9mX3NlcSA9IG9mX3NlcVxuICBlbmRcblxubW9kdWxlIE1ha2UoSDogSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogV2VhayBhcnJheSBvcGVyYXRpb25zICopXG5cbnR5cGUgJ2EgdFxuXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdCA9IFwiY2FtbF93ZWFrX2NyZWF0ZVwiXG5cbigqKiBudW1iZXIgb2YgYWRkaXRpb25hbCB2YWx1ZXMgaW4gYSB3ZWFrIHBvaW50ZXIgKilcbmxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcblxubGV0IGxlbmd0aCB4ID0gT2JqLnNpemUoT2JqLnJlcHIgeCkgLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG5leHRlcm5hbCBzZXQgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gLT4gdW5pdCA9IFwiY2FtbF93ZWFrX3NldFwiXG5leHRlcm5hbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRcIlxuZXh0ZXJuYWwgZ2V0X2NvcHkgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRfY29weVwiXG5leHRlcm5hbCBjaGVjayA6ICdhIHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfd2Vha19jaGVja1wiXG5leHRlcm5hbCBibGl0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfd2Vha19ibGl0XCJcbigqIGJsaXQ6IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gKilcblxubGV0IGZpbGwgYXIgb2ZzIGxlbiB4ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhclxuICB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiV2Vhay5maWxsXCIpXG4gIGVsc2UgYmVnaW5cbiAgICBmb3IgaSA9IG9mcyB0byAob2ZzICsgbGVuIC0gMSkgZG9cbiAgICAgIHNldCBhciBpIHhcbiAgICBkb25lXG4gIGVuZFxuXG5cbigqKiBXZWFrIGhhc2ggdGFibGVzICopXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBkYXRhXG4gIHR5cGUgdFxuICB2YWwgY3JlYXRlIDogaW50IC0+IHRcbiAgdmFsIGNsZWFyIDogdCAtPiB1bml0XG4gIHZhbCBtZXJnZSA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBhZGQgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIGZpbmQgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgZmluZF9vcHQgOiB0IC0+IGRhdGEgLT4gZGF0YSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogdCAtPiBkYXRhIC0+IGRhdGEgbGlzdFxuICB2YWwgbWVtIDogdCAtPiBkYXRhIC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoZGF0YSAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgdmFsIGZvbGQgOiAoZGF0YSAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICB2YWwgY291bnQgOiB0IC0+IGludFxuICB2YWwgc3RhdHMgOiB0IC0+IGludCAqIGludCAqIGludCAqIGludCAqIGludCAqIGludFxuZW5kXG5cbm1vZHVsZSBNYWtlIChIIDogSGFzaHRibC5IYXNoZWRUeXBlKSA6IChTIHdpdGggdHlwZSBkYXRhID0gSC50KSA9IHN0cnVjdFxuXG4gIHR5cGUgJ2Egd2Vha190ID0gJ2EgdFxuICBsZXQgd2Vha19jcmVhdGUgPSBjcmVhdGVcbiAgbGV0IGVtcHR5YnVja2V0ID0gd2Vha19jcmVhdGUgMFxuXG4gIHR5cGUgZGF0YSA9IEgudFxuXG4gIHR5cGUgdCA9IHtcbiAgICBtdXRhYmxlIHRhYmxlIDogZGF0YSB3ZWFrX3QgYXJyYXk7XG4gICAgbXV0YWJsZSBoYXNoZXMgOiBpbnQgYXJyYXkgYXJyYXk7XG4gICAgbXV0YWJsZSBsaW1pdCA6IGludDsgICAgICAgICAgICAgICAoKiBidWNrZXQgc2l6ZSBsaW1pdCAqKVxuICAgIG11dGFibGUgb3ZlcnNpemUgOiBpbnQ7ICAgICAgICAgICAgKCogbnVtYmVyIG9mIG92ZXJzaXplIGJ1Y2tldHMgKilcbiAgICBtdXRhYmxlIHJvdmVyIDogaW50OyAgICAgICAgICAgICAgICgqIGZvciBpbnRlcm5hbCBib29ra2VlcGluZyAqKVxuICB9XG5cbiAgbGV0IGdldF9pbmRleCB0IGggPSAoaCBsYW5kIG1heF9pbnQpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cbiAgbGV0IGxpbWl0ID0gN1xuICBsZXQgb3Zlcl9saW1pdCA9IDJcblxuICBsZXQgY3JlYXRlIHN6ID1cbiAgICBsZXQgc3ogPSBpZiBzeiA8IDcgdGhlbiA3IGVsc2Ugc3ogaW5cbiAgICBsZXQgc3ogPSBpZiBzeiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gU3lzLm1heF9hcnJheV9sZW5ndGggZWxzZSBzeiBpblxuICAgIHtcbiAgICAgIHRhYmxlID0gQXJyYXkubWFrZSBzeiBlbXB0eWJ1Y2tldDtcbiAgICAgIGhhc2hlcyA9IEFycmF5Lm1ha2Ugc3ogW3wgfF07XG4gICAgICBsaW1pdCA9IGxpbWl0O1xuICAgICAgb3ZlcnNpemUgPSAwO1xuICAgICAgcm92ZXIgPSAwO1xuICAgIH1cblxuICBsZXQgY2xlYXIgdCA9XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgICAgdC50YWJsZS4oaSkgPC0gZW1wdHlidWNrZXQ7XG4gICAgICB0Lmhhc2hlcy4oaSkgPC0gW3wgfF07XG4gICAgZG9uZTtcbiAgICB0LmxpbWl0IDwtIGxpbWl0O1xuICAgIHQub3ZlcnNpemUgPC0gMFxuXG5cbiAgbGV0IGZvbGQgZiB0IGluaXQgPVxuICAgIGxldCByZWMgZm9sZF9idWNrZXQgaSBiIGFjY3UgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIChmIHYgYWNjdSlcbiAgICAgIHwgTm9uZSAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIGFjY3VcbiAgICBpblxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGZvbGRfYnVja2V0IDApIHQudGFibGUgaW5pdFxuXG5cbiAgbGV0IGl0ZXIgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmIHY7IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICAgIHwgTm9uZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgaXRlcl93ZWFrIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGogYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggY2hlY2sgYiBpIHdpdGhcbiAgICAgIHwgdHJ1ZSAtPiBmIGIgdC5oYXNoZXMuKGopIGk7IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgICAgfCBmYWxzZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXJpIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgcmVjIGNvdW50X2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgIGNvdW50X2J1Y2tldCAoaSsxKSBiIChhY2N1ICsgKGlmIGNoZWNrIGIgaSB0aGVuIDEgZWxzZSAwKSlcblxuXG4gIGxldCBjb3VudCB0ID1cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChjb3VudF9idWNrZXQgMCkgdC50YWJsZSAwXG5cblxuICBsZXQgbmV4dF9zeiBuID0gbWluICgzICogbiAvIDIgKyAzKSBTeXMubWF4X2FycmF5X2xlbmd0aFxuICBsZXQgcHJldl9zeiBuID0gKChuIC0gMykgKiAyICsgMikgLyAzXG5cbiAgbGV0IHRlc3Rfc2hyaW5rX2J1Y2tldCB0ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4odC5yb3ZlcikgaW5cbiAgICBsZXQgaGJ1Y2tldCA9IHQuaGFzaGVzLih0LnJvdmVyKSBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHByZXZfbGVuID0gcHJldl9zeiBsZW4gaW5cbiAgICBsZXQgbGl2ZSA9IGNvdW50X2J1Y2tldCAwIGJ1Y2tldCAwIGluXG4gICAgaWYgbGl2ZSA8PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgcmVjIGxvb3AgaSBqID1cbiAgICAgICAgaWYgaiA+PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICAgICAgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBsb29wIChpICsgMSkgalxuICAgICAgICAgIGVsc2UgaWYgY2hlY2sgYnVja2V0IGogdGhlbiBiZWdpblxuICAgICAgICAgICAgYmxpdCBidWNrZXQgaiBidWNrZXQgaSAxO1xuICAgICAgICAgICAgaGJ1Y2tldC4oaSkgPC0gaGJ1Y2tldC4oaik7XG4gICAgICAgICAgICBsb29wIChpICsgMSkgKGogLSAxKTtcbiAgICAgICAgICBlbmQgZWxzZSBsb29wIGkgKGogLSAxKTtcbiAgICAgICAgZW5kO1xuICAgICAgaW5cbiAgICAgIGxvb3AgMCAobGVuZ3RoIGJ1Y2tldCAtIDEpO1xuICAgICAgaWYgcHJldl9sZW4gPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgdC50YWJsZS4odC5yb3ZlcikgPC0gZW1wdHlidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLih0LnJvdmVyKSA8LSBbfCB8XTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIE9iai50cnVuY2F0ZSAoT2JqLnJlcHIgYnVja2V0KSAocHJldl9sZW4gKyBhZGRpdGlvbmFsX3ZhbHVlcyk7XG4gICAgICAgIE9iai50cnVuY2F0ZSAoT2JqLnJlcHIgaGJ1Y2tldCkgcHJldl9sZW47XG4gICAgICBlbmQ7XG4gICAgICBpZiBsZW4gPiB0LmxpbWl0ICYmIHByZXZfbGVuIDw9IHQubGltaXQgdGhlbiB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgLSAxO1xuICAgIGVuZDtcbiAgICB0LnJvdmVyIDwtICh0LnJvdmVyICsgMSkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuXG4gIGxldCByZWMgcmVzaXplIHQgPVxuICAgIGxldCBvbGRsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBuZXdsZW4gPSBuZXh0X3N6IG9sZGxlbiBpblxuICAgIGlmIG5ld2xlbiA+IG9sZGxlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgbmV3dCA9IGNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgIGxldCBhZGRfd2VhayBvYiBvaCBvaSA9XG4gICAgICAgIGxldCBzZXR0ZXIgbmIgbmkgXyA9IGJsaXQgb2Igb2kgbmIgbmkgMSBpblxuICAgICAgICBsZXQgaCA9IG9oLihvaSkgaW5cbiAgICAgICAgYWRkX2F1eCBuZXd0IHNldHRlciBOb25lIGggKGdldF9pbmRleCBuZXd0IGgpO1xuICAgICAgaW5cbiAgICAgIGl0ZXJfd2VhayBhZGRfd2VhayB0O1xuICAgICAgdC50YWJsZSA8LSBuZXd0LnRhYmxlO1xuICAgICAgdC5oYXNoZXMgPC0gbmV3dC5oYXNoZXM7XG4gICAgICB0LmxpbWl0IDwtIG5ld3QubGltaXQ7XG4gICAgICB0Lm92ZXJzaXplIDwtIG5ld3Qub3ZlcnNpemU7XG4gICAgICB0LnJvdmVyIDwtIHQucm92ZXIgbW9kIEFycmF5Lmxlbmd0aCBuZXd0LnRhYmxlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICB0LmxpbWl0IDwtIG1heF9pbnQ7ICAgICAgICAgICAgICgqIG1heGltdW0gc2l6ZSBhbHJlYWR5IHJlYWNoZWQgKilcbiAgICAgIHQub3ZlcnNpemUgPC0gMDtcbiAgICBlbmRcblxuICBhbmQgYWRkX2F1eCB0IHNldHRlciBkIGggaW5kZXggPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5ld3N6ID1cbiAgICAgICAgICBtaW4gKDMgKiBzeiAvIDIgKyAzKSAoU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlcylcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbmV3c3ogPD0gc3ogdGhlbiBmYWlsd2l0aCBcIldlYWsuTWFrZTogaGFzaCBidWNrZXQgY2Fubm90IGdyb3cgbW9yZVwiO1xuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgbmV3c3ogaW5cbiAgICAgICAgbGV0IG5ld2hhc2hlcyA9IEFycmF5Lm1ha2UgbmV3c3ogMCBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHN6O1xuICAgICAgICBBcnJheS5ibGl0IGhhc2hlcyAwIG5ld2hhc2hlcyAwIHN6O1xuICAgICAgICBzZXR0ZXIgbmV3YnVja2V0IHN6IGQ7XG4gICAgICAgIG5ld2hhc2hlcy4oc3opIDwtIGg7XG4gICAgICAgIHQudGFibGUuKGluZGV4KSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLihpbmRleCkgPC0gbmV3aGFzaGVzO1xuICAgICAgICBpZiBzeiA8PSB0LmxpbWl0ICYmIG5ld3N6ID4gdC5saW1pdCB0aGVuIGJlZ2luXG4gICAgICAgICAgdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplICsgMTtcbiAgICAgICAgICBmb3IgX2kgPSAwIHRvIG92ZXJfbGltaXQgZG8gdGVzdF9zaHJpbmtfYnVja2V0IHQgZG9uZTtcbiAgICAgICAgZW5kO1xuICAgICAgICBpZiB0Lm92ZXJzaXplID4gQXJyYXkubGVuZ3RoIHQudGFibGUgLyBvdmVyX2xpbWl0IHRoZW4gcmVzaXplIHQ7XG4gICAgICBlbmQgZWxzZSBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGJlZ2luXG4gICAgICAgIGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0dGVyIGJ1Y2tldCBpIGQ7XG4gICAgICAgIGhhc2hlcy4oaSkgPC0gaDtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGFkZCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggKGdldF9pbmRleCB0IGgpXG5cblxuICBsZXQgZmluZF9vciB0IGQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmQgaCBpbmRleFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgbWVyZ2UgdCBkID1cbiAgICBmaW5kX29yIHQgZCAoZnVuIGggaW5kZXggLT4gYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIGluZGV4OyBkKVxuXG5cbiAgbGV0IGZpbmQgdCBkID0gZmluZF9vciB0IGQgKGZ1biBfaCBfaW5kZXggLT4gcmFpc2UgTm90X2ZvdW5kKVxuXG4gIGxldCBmaW5kX29wdCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBOb25lXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGZpbmRfc2hhZG93IHQgZCBpZmZvdW5kIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkIC0+IGlmZm91bmQgYnVja2V0IGlcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCByZW1vdmUgdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gdyBpIC0+IHNldCB3IGkgTm9uZSkgKClcblxuXG4gIGxldCBtZW0gdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gX3cgX2kgLT4gdHJ1ZSkgZmFsc2VcblxuXG4gIGxldCBmaW5kX2FsbCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpIGFjY3UgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGFjY3VcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gbG9vcCAoaSArIDEpICh2IDo6IGFjY3UpXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSkgYWNjdVxuICAgIGluXG4gICAgbG9vcCAwIFtdXG5cblxuICBsZXQgc3RhdHMgdCA9XG4gICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGxlbnMgPSBBcnJheS5tYXAgbGVuZ3RoIHQudGFibGUgaW5cbiAgICBBcnJheS5zb3J0IGNvbXBhcmUgbGVucztcbiAgICBsZXQgdG90bGVuID0gQXJyYXkuZm9sZF9sZWZ0ICggKyApIDAgbGVucyBpblxuICAgIChsZW4sIGNvdW50IHQsIHRvdGxlbiwgbGVucy4oMCksIGxlbnMuKGxlbi8yKSwgbGVucy4obGVuLTEpKVxuXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBIHByZXR0eS1wcmludGluZyBmYWNpbGl0eSBhbmQgZGVmaW5pdGlvbiBvZiBmb3JtYXR0ZXJzIGZvciAncGFyYWxsZWwnXG4gICAoaS5lLiB1bnJlbGF0ZWQgb3IgaW5kZXBlbmRlbnQpIHByZXR0eS1wcmludGluZyBvbiBtdWx0aXBsZSBvdXQgY2hhbm5lbHMuICopXG5cbigqXG4gICBUaGUgcHJldHR5LXByaW50aW5nIGVuZ2luZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4qKVxuXG4oKiBBIGRldm90ZWQgdHlwZSBmb3Igc2l6ZXMgdG8gYXZvaWQgY29uZnVzaW9uXG4gICBiZXR3ZWVuIHNpemVzIGFuZCBtZXJlIGludGVnZXJzLiAqKVxudHlwZSBzaXplXG5cbmV4dGVybmFsIHNpemVfb2ZfaW50IDogaW50IC0+IHNpemUgPSBcIiVpZGVudGl0eVwiXG5cbmV4dGVybmFsIGludF9vZl9zaXplIDogc2l6ZSAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyBib3hlcyBkZWZpbml0aW9uOlxuICAgYSBwcmV0dHktcHJpbnRpbmcgYm94IGlzIGVpdGhlclxuICAgLSBoYm94OiBob3Jpem9udGFsIGJveCAobm8gbGluZSBzcGxpdHRpbmcpXG4gICAtIHZib3g6IHZlcnRpY2FsIGJveCAoZXZlcnkgYnJlYWsgaGludCBzcGxpdHMgdGhlIGxpbmUpXG4gICAtIGh2Ym94OiBob3Jpem9udGFsL3ZlcnRpY2FsIGJveFxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgYm94IGlmIGl0IGZpdHMgb25cbiAgICAgIHRoZSBjdXJyZW50IGxpbmUsIG90aGVyd2lzZSB0aGUgYm94IGJlaGF2ZXMgYXMgYSB2ZXJ0aWNhbCBib3gpXG4gICAtIGhvdmJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveFxuICAgICAodGhlIGJveCBpcyBjb21wYWN0aW5nIG1hdGVyaWFsLCBwcmludGluZyBhcyBtdWNoIG1hdGVyaWFsIGFzIHBvc3NpYmxlXG4gICAgICBvbiBldmVyeSBsaW5lcylcbiAgIC0gYm94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94IHdpdGggZW5oYW5jZWQgYm94IHN0cnVjdHVyZVxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgb3IgdmVydGljYWwgYm94IGJ1dCBicmVhayBoaW50cyBzcGxpdFxuICAgICAgdGhlIGxpbmUgaWYgc3BsaXR0aW5nIHdvdWxkIG1vdmUgdG8gdGhlIGxlZnQpXG4qKVxudHlwZSBib3hfdHlwZSA9IENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5ibG9ja190eXBlID1cbiAgfCBQcF9oYm94IHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0c1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgdG9rZW5zIGRlZmluaXRpb246XG4gICBhcmUgZWl0aGVyIHRleHQgdG8gcHJpbnQgb3IgcHJldHR5IHByaW50aW5nXG4gICBlbGVtZW50cyB0aGF0IGRyaXZlIGluZGVudGF0aW9uIGFuZCBsaW5lIHNwbGl0dGluZy4gKilcbnR5cGUgcHBfdG9rZW4gPVxuICB8IFBwX3RleHQgb2Ygc3RyaW5nICAgICAgICAgICgqIG5vcm1hbCB0ZXh0ICopXG4gIHwgUHBfYnJlYWsgb2YgaW50ICogaW50ICAgICAgKCogY29tcGxldGUgYnJlYWsgKilcbiAgfCBQcF90YnJlYWsgb2YgaW50ICogaW50ICAgICAoKiBnbyB0byBuZXh0IHRhYnVsYXRpb24gKilcbiAgfCBQcF9zdGFiICAgICAgICAgICAgICAgICAgICAoKiBzZXQgYSB0YWJ1bGF0aW9uICopXG4gIHwgUHBfYmVnaW4gb2YgaW50ICogYm94X3R5cGUgKCogYmVnaW5uaW5nIG9mIGEgYm94ICopXG4gIHwgUHBfZW5kICAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgYm94ICopXG4gIHwgUHBfdGJlZ2luIG9mIHRib3ggICAgICAgICAgKCogYmVnaW5uaW5nIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF90ZW5kICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX25ld2xpbmUgICAgICAgICAgICAgICAgICgqIHRvIGZvcmNlIGEgbmV3bGluZSBpbnNpZGUgYSBib3ggKilcbiAgfCBQcF9pZl9uZXdsaW5lICAgICAgICAgICAgICAoKiB0byBkbyBzb21ldGhpbmcgb25seSBpZiB0aGlzIHZlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIGhhcyBiZWVuIGJyb2tlbiAqKVxuICB8IFBwX29wZW5fdGFnIG9mIHRhZyAgICAgICAgICgqIG9wZW5pbmcgYSB0YWcgbmFtZSAqKVxuICB8IFBwX2Nsb3NlX3RhZyAgICAgICAgICAgICAgICgqIGNsb3NpbmcgdGhlIG1vc3QgcmVjZW50bHkgb3BlbiB0YWcgKilcblxuYW5kIHRhZyA9IHN0cmluZ1xuXG5hbmQgdGJveCA9IFBwX3Rib3ggb2YgaW50IGxpc3QgcmVmICAoKiBUYWJ1bGF0aW9uIGJveCAqKVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uOlxuICAgcHJldHR5LXByaW50aW5nIG1hdGVyaWFsIGlzIG5vdCB3cml0dGVuIGluIHRoZSBvdXRwdXQgYXMgc29vbiBhcyBlbWl0dGVkO1xuICAgaW5zdGVhZCwgdGhlIG1hdGVyaWFsIGlzIHNpbXBseSByZWNvcmRlZCBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsXG4gICB1bnRpbCB0aGUgZW5jbG9zaW5nIGJveCBoYXMgYSBrbm93biBjb21wdXRlZCBzaXplIGFuZCBwcm9wZXIgc3BsaXR0aW5nXG4gICBkZWNpc2lvbnMgY2FuIGJlIG1hZGUuXG5cbiAgIFRvIGRlZmluZSB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsIHdlIGZpcnN0IGRlZmluZSBwb2x5bW9ycGhpYyBxdWV1ZXMsXG4gICB0aGVuIHByZXR0eS1wcmludGVyIHF1ZXVlIGVsZW1lbnRzLlxuKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlOiBwb2x5bW9ycGhpYyBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSAnYSBxdWV1ZV9lbGVtID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mIHtcbiAgICAgIGhlYWQgOiAnYTtcbiAgICAgIG11dGFibGUgdGFpbCA6ICdhIHF1ZXVlX2VsZW07XG4gICAgfVxuXG5cbnR5cGUgJ2EgcXVldWUgPSB7XG4gIG11dGFibGUgaW5zZXJ0IDogJ2EgcXVldWVfZWxlbTtcbiAgbXV0YWJsZSBib2R5IDogJ2EgcXVldWVfZWxlbTtcbn1cblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWU6IHF1ZXVlIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBjb250YWlucyBmb3JtYXR0aW5nIGVsZW1lbnRzIHRvIGJlIHByaW50ZWQuXG4gICBFYWNoIGZvcm1hdHRpbmcgZWxlbWVudCBpcyBhIHR1cGxlIChzaXplLCB0b2tlbiwgbGVuZ3RoKSwgd2hlcmVcbiAgIC0gbGVuZ3RoIGlzIHRoZSBkZWNsYXJlZCBsZW5ndGggb2YgdGhlIHRva2VuLFxuICAgLSBzaXplIGlzIGVmZmVjdGl2ZSBzaXplIG9mIHRoZSB0b2tlbiB3aGVuIGl0IGlzIHByaW50ZWRcbiAgICAgKHNpemUgaXMgc2V0IHdoZW4gdGhlIHNpemUgb2YgdGhlIGJveCBpcyBrbm93biwgc28gdGhhdCBzaXplIG9mIGJyZWFrXG4gICAgICBoaW50cyBhcmUgZGVmaW5pdGl2ZSkuICopXG50eXBlIHBwX3F1ZXVlX2VsZW0gPSB7XG4gIG11dGFibGUgZWxlbV9zaXplIDogc2l6ZTtcbiAgdG9rZW4gOiBwcF90b2tlbjtcbiAgbGVuZ3RoIDogaW50O1xufVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9xdWV1ZSA9IHBwX3F1ZXVlX2VsZW0gcXVldWVcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2s6IHNjYW5uaW5nIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZWxlbWVudCBpcyAobGVmdF90b3RhbCwgcXVldWUgZWxlbWVudCkgd2hlcmUgbGVmdF90b3RhbFxuICAgaXMgdGhlIHZhbHVlIG9mIHBwX2xlZnRfdG90YWwgd2hlbiB0aGUgZWxlbWVudCBoYXMgYmVlbiBlbnF1ZXVlZC4gKilcbnR5cGUgcHBfc2Nhbl9lbGVtID0gU2Nhbl9lbGVtIG9mIGludCAqIHBwX3F1ZXVlX2VsZW1cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrIGRlZmluaXRpb24uICopXG50eXBlIHBwX3NjYW5fc3RhY2sgPSBwcF9zY2FuX2VsZW0gbGlzdFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazpcbiAgIHRoZSBmb3JtYXR0aW5nIHN0YWNrIGNvbnRhaW5zIHRoZSBkZXNjcmlwdGlvbiBvZiBhbGwgdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgIGJveGVzOyB0aGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjayBpcyB1c2VkIHRvIHNwbGl0IHRoZSBsaW5lc1xuICAgd2hpbGUgcHJpbnRpbmcgdG9rZW5zLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazogZm9ybWF0dGluZyBzdGFjayBlbGVtZW50IGRlZmluaXRpb24uXG4gICBFYWNoIHN0YWNrIGVsZW1lbnQgZGVzY3JpYmVzIGEgcHJldHR5LXByaW50aW5nIGJveC4gKilcbnR5cGUgcHBfZm9ybWF0X2VsZW0gPSBGb3JtYXRfZWxlbSBvZiBib3hfdHlwZSAqIGludFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjayBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9mb3JtYXRfc3RhY2sgPSBwcF9mb3JtYXRfZWxlbSBsaXN0XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzZW1hbnRpY3MgdGFnIHN0YWNrIGRlZmluaXRpb24uICopXG50eXBlIHBwX3RhZ19zdGFjayA9IHRhZyBsaXN0XG5cbigqIFRoZSBmb3JtYXR0ZXIgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZm9ybWF0dGVyIHZhbHVlIGlzIGEgcHJldHR5LXByaW50ZXIgaW5zdGFuY2Ugd2l0aCBhbGwgaXRzXG4gICBtYWNoaW5lcnkuICopXG50eXBlIGZvcm1hdHRlciA9IHtcbiAgKCogVGhlIHZhcmlvdXMgc3RhY2tzLiAqKVxuICBtdXRhYmxlIHBwX3NjYW5fc3RhY2sgOiBwcF9zY2FuX3N0YWNrO1xuICBtdXRhYmxlIHBwX2Zvcm1hdF9zdGFjayA6IHBwX2Zvcm1hdF9zdGFjaztcbiAgbXV0YWJsZSBwcF90Ym94X3N0YWNrIDogdGJveCBsaXN0O1xuICBtdXRhYmxlIHBwX3RhZ19zdGFjayA6IHBwX3RhZ19zdGFjaztcbiAgbXV0YWJsZSBwcF9tYXJrX3N0YWNrIDogcHBfdGFnX3N0YWNrO1xuICAoKiBWYWx1ZSBvZiByaWdodCBtYXJnaW4uICopXG4gIG11dGFibGUgcHBfbWFyZ2luIDogaW50O1xuICAoKiBNaW5pbWFsIHNwYWNlIGxlZnQgYmVmb3JlIG1hcmdpbiwgd2hlbiBvcGVuaW5nIGEgYm94LiAqKVxuICBtdXRhYmxlIHBwX21pbl9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBNYXhpbXVtIHZhbHVlIG9mIGluZGVudGF0aW9uOlxuICAgICBubyBib3ggY2FuIGJlIG9wZW5lZCBmdXJ0aGVyLiAqKVxuICBtdXRhYmxlIHBwX21heF9pbmRlbnQgOiBpbnQ7XG4gICgqIFNwYWNlIHJlbWFpbmluZyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxuICBtdXRhYmxlIHBwX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIEN1cnJlbnQgdmFsdWUgb2YgaW5kZW50YXRpb24uICopXG4gIG11dGFibGUgcHBfY3VycmVudF9pbmRlbnQgOiBpbnQ7XG4gICgqIFRydWUgd2hlbiB0aGUgbGluZSBoYXMgYmVlbiBicm9rZW4gYnkgdGhlIHByZXR0eS1wcmludGVyLiAqKVxuICBtdXRhYmxlIHBwX2lzX25ld19saW5lIDogYm9vbDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGFscmVhZHkgcHJpbnRlZC4gKilcbiAgbXV0YWJsZSBwcF9sZWZ0X3RvdGFsIDogaW50O1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgZXZlciBwdXQgaW4gcXVldWUuICopXG4gIG11dGFibGUgcHBfcmlnaHRfdG90YWwgOiBpbnQ7XG4gICgqIEN1cnJlbnQgbnVtYmVyIG9mIG9wZW4gYm94ZXMuICopXG4gIG11dGFibGUgcHBfY3Vycl9kZXB0aCA6IGludDtcbiAgKCogTWF4aW11bSBudW1iZXIgb2YgYm94ZXMgd2hpY2ggY2FuIGJlIHNpbXVsdGFuZW91c2x5IG9wZW4uICopXG4gIG11dGFibGUgcHBfbWF4X2JveGVzIDogaW50O1xuICAoKiBFbGxpcHNpcyBzdHJpbmcuICopXG4gIG11dGFibGUgcHBfZWxsaXBzaXMgOiBzdHJpbmc7XG4gICgqIE91dHB1dCBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgKCogRmx1c2hpbmcgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgYnJlYWsgaGludHMgc3BhY2VzLiAqKVxuICBtdXRhYmxlIHBwX291dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG4gICgqIEFyZSB0YWdzIHByaW50ZWQgPyAqKVxuICBtdXRhYmxlIHBwX3ByaW50X3RhZ3MgOiBib29sO1xuICAoKiBBcmUgdGFncyBtYXJrZWQgPyAqKVxuICBtdXRhYmxlIHBwX21hcmtfdGFncyA6IGJvb2w7XG4gICgqIEZpbmQgb3BlbmluZyBhbmQgY2xvc2luZyBtYXJrZXJzIG9mIHRhZ3MuICopXG4gIG11dGFibGUgcHBfbWFya19vcGVuX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfbWFya19jbG9zZV90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX3ByaW50X29wZW5fdGFnIDogdGFnIC0+IHVuaXQ7XG4gIG11dGFibGUgcHBfcHJpbnRfY2xvc2VfdGFnIDogdGFnIC0+IHVuaXQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwcF9xdWV1ZSA6IHBwX3F1ZXVlO1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgc3BlY2lmaWMgdGFnIGhhbmRsaW5nIGZ1bmN0aW9ucy4gKilcbnR5cGUgZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fdGFnIDogdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3RhZyA6IHRhZyAtPiB1bml0O1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb25zIHRvIG91dHB1dCBtYXRlcmlhbC4gKilcbnR5cGUgZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPSB7XG4gIG91dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICBvdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICBvdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gIG91dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbn1cblxuXG4oKlxuXG4gIEF1eGlsaWFyaWVzIGFuZCBiYXNpYyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIFF1ZXVlcyBhdXhpbGlhcmllcy4gKilcblxubGV0IG1ha2VfcXVldWUgKCkgPSB7IGluc2VydCA9IE5pbDsgYm9keSA9IE5pbDsgfVxuXG5sZXQgY2xlYXJfcXVldWUgcSA9IHEuaW5zZXJ0IDwtIE5pbDsgcS5ib2R5IDwtIE5pbFxuXG5sZXQgYWRkX3F1ZXVlIHggcSA9XG4gIGxldCBjID0gQ29ucyB7IGhlYWQgPSB4OyB0YWlsID0gTmlsOyB9IGluXG4gIG1hdGNoIHEgd2l0aFxuICB8IHsgaW5zZXJ0ID0gQ29ucyBjZWxsOyBib2R5ID0gXzsgfSAtPlxuICAgIHEuaW5zZXJ0IDwtIGM7IGNlbGwudGFpbCA8LSBjXG4gICgqIEludmFyaWFudDogd2hlbiBpbnNlcnQgaXMgTmlsIGJvZHkgc2hvdWxkIGJlIE5pbC4gKilcbiAgfCB7IGluc2VydCA9IE5pbDsgYm9keSA9IF87IH0gLT5cbiAgICBxLmluc2VydCA8LSBjOyBxLmJvZHkgPC0gY1xuXG5cbmV4Y2VwdGlvbiBFbXB0eV9xdWV1ZVxuXG5sZXQgcGVla19xdWV1ZSA9IGZ1bmN0aW9uXG4gIHwgeyBib2R5ID0gQ29ucyB7IGhlYWQgPSB4OyB0YWlsID0gXzsgfTsgXyB9IC0+IHhcbiAgfCB7IGJvZHkgPSBOaWw7IGluc2VydCA9IF87IH0gLT4gcmFpc2UgRW1wdHlfcXVldWVcblxuXG5sZXQgdGFrZV9xdWV1ZSA9IGZ1bmN0aW9uXG4gIHwgeyBib2R5ID0gQ29ucyB7IGhlYWQgPSB4OyB0YWlsID0gdGw7IH07IF8gfSBhcyBxIC0+XG4gICAgcS5ib2R5IDwtIHRsO1xuICAgIGlmIHRsID0gTmlsIHRoZW4gcS5pbnNlcnQgPC0gTmlsOyAoKiBNYWludGFpbiB0aGUgaW52YXJpYW50LiAqKVxuICAgIHhcbiAgfCB7IGJvZHkgPSBOaWw7IGluc2VydCA9IF87IH0gLT4gcmFpc2UgRW1wdHlfcXVldWVcblxuXG4oKiBFbnRlciBhIHRva2VuIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9lbnF1ZXVlIHN0YXRlICh7IGxlbmd0aCA9IGxlbjsgX30gYXMgdG9rZW4pID1cbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gc3RhdGUucHBfcmlnaHRfdG90YWwgKyBsZW47XG4gIGFkZF9xdWV1ZSB0b2tlbiBzdGF0ZS5wcF9xdWV1ZVxuXG5cbmxldCBwcF9jbGVhcl9xdWV1ZSBzdGF0ZSA9XG4gIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gMTsgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gMTtcbiAgY2xlYXJfcXVldWUgc3RhdGUucHBfcXVldWVcblxuXG4oKiBQcF9pbmZpbml0eTogbGFyZ2UgdmFsdWUgZm9yIGRlZmF1bHQgdG9rZW5zIHNpemUuXG5cbiAgIFBwX2luZmluaXR5IGlzIGRvY3VtZW50ZWQgYXMgYmVpbmcgZ3JlYXRlciB0aGFuIDFlMTA7IHRvIGF2b2lkXG4gICBjb25mdXNpb24gYWJvdXQgdGhlIHdvcmQgJ2dyZWF0ZXInLCB3ZSBjaG9vc2UgcHBfaW5maW5pdHkgZ3JlYXRlclxuICAgdGhhbiAxZTEwICsgMTsgZm9yIGNvcnJlY3QgaGFuZGxpbmcgb2YgdGVzdHMgaW4gdGhlIGFsZ29yaXRobSxcbiAgIHBwX2luZmluaXR5IG11c3QgYmUgZXZlbiBvbmUgbW9yZSB0aGFuIDFlMTAgKyAxOyBsZXQncyBzdGFuZCBvbiB0aGVcbiAgIHNhZmUgc2lkZSBieSBjaG9vc2luZyAxLmUxMCsxMC5cblxuICAgUHBfaW5maW5pdHkgY291bGQgcHJvYmFibHkgYmUgMTA3Mzc0MTgyMyB0aGF0IGlzIDJeMzAgLSAxLCB0aGF0IGlzXG4gICB0aGUgbWluaW1hbCB1cHBlciBib3VuZCBmb3IgaW50ZWdlcnM7IG5vdyB0aGF0IG1heF9pbnQgaXMgZGVmaW5lZCxcbiAgIHRoaXMgbGltaXQgY291bGQgYWxzbyBiZSBkZWZpbmVkIGFzIG1heF9pbnQgLSAxLlxuXG4gICBIb3dldmVyLCBiZWZvcmUgc2V0dGluZyBwcF9pbmZpbml0eSB0byBzb21ldGhpbmcgYXJvdW5kIG1heF9pbnQsIHdlXG4gICBtdXN0IGNhcmVmdWxseSBkb3VibGUtY2hlY2sgYWxsIHRoZSBpbnRlZ2VyIGFyaXRobWV0aWMgb3BlcmF0aW9uc1xuICAgdGhhdCBpbnZvbHZlIHBwX2luZmluaXR5LCBzaW5jZSBhbnkgb3ZlcmZsb3cgd291bGQgd3JlY2sgaGF2b2MgdGhlXG4gICBwcmV0dHktcHJpbnRpbmcgYWxnb3JpdGhtJ3MgaW52YXJpYW50cy4gR2l2ZW4gdGhhdCB0aGlzIGFyaXRobWV0aWNcbiAgIGNvcnJlY3RuZXNzIGNoZWNrIGlzIGRpZmZpY3VsdCBhbmQgZXJyb3IgcHJvbmUgYW5kIGdpdmVuIHRoYXQgMWUxMFxuICAgKyAxIGlzIGluIHByYWN0aWNlIGxhcmdlIGVub3VnaCwgdGhlcmUgaXMgbm8gbmVlZCB0byBhdHRlbXB0IHRvIHNldFxuICAgcHBfaW5maW5pdHkgdG8gdGhlIHRoZW9yZXRpY2FsbHkgbWF4aW11bSBsaW1pdC4gSXQgaXMgbm90IHdvcnRoIHRoZVxuICAgYnVyZGVuICEgKilcbmxldCBwcF9pbmZpbml0eSA9IDEwMDAwMDAwMTBcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBmb3IgdGhlIGZvcm1hdHRlci4gKilcbmxldCBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHMgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIHMgMCAoU3RyaW5nLmxlbmd0aCBzKVxuYW5kIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlID0gc3RhdGUucHBfb3V0X25ld2xpbmUgKClcbmFuZCBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfc3BhY2VzIG5cbmFuZCBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfaW5kZW50IG5cblxuKCogVG8gZm9ybWF0IGEgYnJlYWssIGluZGVudGluZyBhIG5ldyBsaW5lLiAqKVxubGV0IGJyZWFrX25ld19saW5lIHN0YXRlIG9mZnNldCB3aWR0aCA9XG4gIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSB0cnVlO1xuICBsZXQgaW5kZW50ID0gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZzZXQgaW5cbiAgKCogRG9uJ3QgaW5kZW50IG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LiAqKVxuICBsZXQgcmVhbF9pbmRlbnQgPSBtaW4gc3RhdGUucHBfbWF4X2luZGVudCBpbmRlbnQgaW5cbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gcmVhbF9pbmRlbnQ7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgc3RhdGUucHBfY3VycmVudF9pbmRlbnRcblxuXG4oKiBUbyBmb3JjZSBhIGxpbmUgYnJlYWsgaW5zaWRlIGEgYm94OiBubyBvZmZzZXQgaXMgYWRkZWQuICopXG5sZXQgYnJlYWtfbGluZSBzdGF0ZSB3aWR0aCA9IGJyZWFrX25ld19saW5lIHN0YXRlIDAgd2lkdGhcblxuKCogVG8gZm9ybWF0IGEgYnJlYWsgdGhhdCBmaXRzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgYnJlYWtfc2FtZV9saW5lIHN0YXRlIHdpZHRoID1cbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gd2lkdGg7XG4gIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgd2lkdGhcblxuXG4oKiBUbyBpbmRlbnQgbm8gbW9yZSB0aGFuIHBwX21heF9pbmRlbnQsIGlmIG9uZSB0cmllcyB0byBvcGVuIGEgYm94XG4gICBiZXlvbmQgcHBfbWF4X2luZGVudCwgdGhlbiB0aGUgYm94IGlzIHJlamVjdGVkIG9uIHRoZSBsZWZ0XG4gICBieSBzaW11bGF0aW5nIGEgYnJlYWsuICopXG5sZXQgcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSA9XG4gIG1hdGNoIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gIHwgRm9ybWF0X2VsZW0gKGJsX3R5LCB3aWR0aCkgOjogXyAtPlxuICAgIGlmIHdpZHRoID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuXG4gICAgICAobWF0Y2ggYmxfdHkgd2l0aFxuICAgICAgIHwgUHBfZml0cyAtPiAoKSB8IFBwX2hib3ggLT4gKClcbiAgICAgICB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCAtPlxuICAgICAgICAgYnJlYWtfbGluZSBzdGF0ZSB3aWR0aClcbiAgfCBbXSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZVxuXG5cbigqIFRvIHNraXAgYSB0b2tlbiwgaWYgdGhlIHByZXZpb3VzIGxpbmUgaGFzIGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3NraXBfdG9rZW4gc3RhdGUgPVxuICAoKiBXaGVuIGNhbGxpbmcgcHBfc2tpcF90b2tlbiB0aGUgcXVldWUgY2Fubm90IGJlIGVtcHR5LiAqKVxuICBtYXRjaCB0YWtlX3F1ZXVlIHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCB7IGVsZW1fc2l6ZSA9IHNpemU7IGxlbmd0aCA9IGxlbjsgdG9rZW4gPSBfOyB9IC0+XG4gICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIC0gbGVuO1xuICAgIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCArIGludF9vZl9zaXplIHNpemVcblxuXG4oKlxuXG4gIFRoZSBtYWluIHByZXR0eSBwcmludGluZyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEZvcm1hdHRpbmcgYSB0b2tlbiB3aXRoIGEgZ2l2ZW4gc2l6ZS4gKilcbmxldCBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSA9IGZ1bmN0aW9uXG5cbiAgfCBQcF90ZXh0IHMgLT5cbiAgICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBzaXplO1xuICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgcztcbiAgICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSBmYWxzZVxuXG4gIHwgUHBfYmVnaW4gKG9mZiwgdHkpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBpZiBpbnNlcnRpb25fcG9pbnQgPiBzdGF0ZS5wcF9tYXhfaW5kZW50IHRoZW5cbiAgICAgICgqIGNhbiBub3Qgb3BlbiBhIGJveCByaWdodCB0aGVyZS4gKilcbiAgICAgIGJlZ2luIHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgZW5kO1xuICAgIGxldCBvZmZzZXQgPSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gb2ZmIGluXG4gICAgbGV0IGJsX3R5cGUgPVxuICAgICAgYmVnaW4gbWF0Y2ggdHkgd2l0aFxuICAgICAgfCBQcF92Ym94IC0+IFBwX3Zib3hcbiAgICAgIHwgUHBfaGJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0cyAtPlxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIHR5IGVsc2UgUHBfZml0c1xuICAgICAgZW5kIGluXG4gICAgc3RhdGUucHBfZm9ybWF0X3N0YWNrIDwtXG4gICAgICBGb3JtYXRfZWxlbSAoYmxfdHlwZSwgb2Zmc2V0KSA6OiBzdGF0ZS5wcF9mb3JtYXRfc3RhY2tcblxuICB8IFBwX2VuZCAtPlxuICAgIGJlZ2luIG1hdGNoIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBfIDo6IGxzIC0+IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayA8LSBsc1xuICAgIHwgW10gLT4gKCkgKCogTm8gbW9yZSBib3ggdG8gY2xvc2UuICopXG4gICAgZW5kXG5cbiAgfCBQcF90YmVnaW4gKFBwX3Rib3ggXyBhcyB0Ym94KSAtPlxuICAgIHN0YXRlLnBwX3Rib3hfc3RhY2sgPC0gdGJveCA6OiBzdGF0ZS5wcF90Ym94X3N0YWNrXG5cbiAgfCBQcF90ZW5kIC0+XG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBfIDo6IGxzIC0+IHN0YXRlLnBwX3Rib3hfc3RhY2sgPC0gbHNcbiAgICB8IFtdIC0+ICgpICgqIE5vIG1vcmUgdGFidWxhdGlvbiBib3ggdG8gY2xvc2UuICopXG4gICAgZW5kXG5cbiAgfCBQcF9zdGFiIC0+XG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBQcF90Ym94IHRhYnMgOjogXyAtPlxuICAgICAgbGV0IHJlYyBhZGRfdGFiIG4gPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+IFtuXVxuICAgICAgICB8IHggOjogbCBhcyBscyAtPiBpZiBuIDwgeCB0aGVuIG4gOjogbHMgZWxzZSB4IDo6IGFkZF90YWIgbiBsIGluXG4gICAgICB0YWJzIDo9IGFkZF90YWIgKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQpICF0YWJzXG4gICAgfCBbXSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIGVuZFxuXG4gIHwgUHBfdGJyZWFrIChuLCBvZmYpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBiZWdpbiBtYXRjaCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IFBwX3Rib3ggdGFicyA6OiBfIC0+XG4gICAgICBsZXQgcmVjIGZpbmQgbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgeCA6OiBsIC0+IGlmIHggPj0gbiB0aGVuIHggZWxzZSBmaW5kIG4gbFxuICAgICAgICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZCBpblxuICAgICAgbGV0IHRhYiA9XG4gICAgICAgIG1hdGNoICF0YWJzIHdpdGhcbiAgICAgICAgfCB4IDo6IF8gLT5cbiAgICAgICAgICBiZWdpblxuICAgICAgICAgICAgdHJ5IGZpbmQgaW5zZXJ0aW9uX3BvaW50ICF0YWJzIHdpdGhcbiAgICAgICAgICAgIHwgTm90X2ZvdW5kIC0+IHhcbiAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGluc2VydGlvbl9wb2ludCBpblxuICAgICAgbGV0IG9mZnNldCA9IHRhYiAtIGluc2VydGlvbl9wb2ludCBpblxuICAgICAgaWYgb2Zmc2V0ID49IDBcbiAgICAgIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIChvZmZzZXQgKyBuKVxuICAgICAgZWxzZSBicmVha19uZXdfbGluZSBzdGF0ZSAodGFiICsgb2ZmKSBzdGF0ZS5wcF9tYXJnaW5cbiAgICB8IFtdIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgZW5kXG5cbiAgfCBQcF9uZXdsaW5lIC0+XG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IEZvcm1hdF9lbGVtIChfLCB3aWR0aCkgOjogXyAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG4gICAgfCBbXSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSAoKiBObyBvcGVuIGJveC4gKilcbiAgICBlbmRcblxuICB8IFBwX2lmX25ld2xpbmUgLT5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCAhPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgdGhlbiBwcF9za2lwX3Rva2VuIHN0YXRlXG5cbiAgfCBQcF9icmVhayAobiwgb2ZmKSAtPlxuICAgIGJlZ2luIG1hdGNoIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBGb3JtYXRfZWxlbSAodHksIHdpZHRoKSA6OiBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCB0eSB3aXRoXG4gICAgICB8IFBwX2hvdmJveCAtPlxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIG9mZiB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBuXG4gICAgICB8IFBwX2JveCAtPlxuICAgICAgICAoKiBIYXZlIHRoZSBsaW5lIGp1c3QgYmVlbiBicm9rZW4gaGVyZSA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2lzX25ld19saW5lIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIG4gZWxzZVxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBvZmYgd2lkdGggZWxzZVxuICAgICAgICAoKiBicmVhayB0aGUgbGluZSBoZXJlIGxlYWRzIHRvIG5ldyBpbmRlbnRhdGlvbiA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ID4gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBvZmYgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgblxuICAgICAgfCBQcF9odmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBvZmYgd2lkdGhcbiAgICAgIHwgUHBfZml0cyAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgblxuICAgICAgfCBQcF92Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIG9mZiB3aWR0aFxuICAgICAgfCBQcF9oYm94IC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBuXG4gICAgICBlbmRcbiAgICB8IFtdIC0+ICgpICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIGVuZFxuXG4gICB8IFBwX29wZW5fdGFnIHRhZ19uYW1lIC0+XG4gICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICBzdGF0ZS5wcF9tYXJrX3N0YWNrIDwtIHRhZ19uYW1lIDo6IHN0YXRlLnBwX21hcmtfc3RhY2tcblxuICAgfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfbWFya19zdGFjayB3aXRoXG4gICAgIHwgdGFnX25hbWUgOjogdGFncyAtPlxuICAgICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyB0YWdfbmFtZSBpblxuICAgICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICAgIHN0YXRlLnBwX21hcmtfc3RhY2sgPC0gdGFnc1xuICAgICB8IFtdIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgICBlbmRcblxuXG4oKiBQcmludCBpZiB0b2tlbiBzaXplIGlzIGtub3duIGVsc2UgcHJpbnRpbmcgaXMgZGVsYXllZC5cbiAgIFNpemUgaXMga25vd24gd2hlbiBub3QgbmVnYXRpdmUuXG4gICBQcmludGluZyBpcyBkZWxheWVkIHdoZW4gdGhlIHRleHQgd2FpdGluZyBpbiB0aGUgcXVldWUgcmVxdWlyZXNcbiAgIG1vcmUgcm9vbSB0byBmb3JtYXQgdGhhbiBleGlzdHMgb24gdGhlIGN1cnJlbnQgbGluZS5cblxuICAgTm90ZTogW2FkdmFuY2VfbG9vcF0gbXVzdCBiZSB0YWlsIHJlY3Vyc2l2ZSB0byBwcmV2ZW50IHN0YWNrIG92ZXJmbG93cy4gKilcbmxldCByZWMgYWR2YW5jZV9sb29wIHN0YXRlID1cbiAgbWF0Y2ggcGVla19xdWV1ZSBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwge2VsZW1fc2l6ZSA9IHNpemU7IHRva2VuID0gdG9rOyBsZW5ndGggPSBsZW59IC0+XG4gICAgbGV0IHNpemUgPSBpbnRfb2Zfc2l6ZSBzaXplIGluXG4gICAgaWYgbm90XG4gICAgICAgICAoc2l6ZSA8IDAgJiZcbiAgICAgICAgICAoc3RhdGUucHBfcmlnaHRfdG90YWwgLSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwgc3RhdGUucHBfc3BhY2VfbGVmdCkpXG4gICAgdGhlbiBiZWdpblxuICAgICAgaWdub3JlICh0YWtlX3F1ZXVlIHN0YXRlLnBwX3F1ZXVlKTtcbiAgICAgIGZvcm1hdF9wcF90b2tlbiBzdGF0ZSAoaWYgc2l6ZSA8IDAgdGhlbiBwcF9pbmZpbml0eSBlbHNlIHNpemUpIHRvaztcbiAgICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gbGVuICsgc3RhdGUucHBfbGVmdF90b3RhbDtcbiAgICAgIGFkdmFuY2VfbG9vcCBzdGF0ZVxuICAgIGVuZFxuXG5cbmxldCBhZHZhbmNlX2xlZnQgc3RhdGUgPVxuICB0cnkgYWR2YW5jZV9sb29wIHN0YXRlIHdpdGhcbiAgfCBFbXB0eV9xdWV1ZSAtPiAoKVxuXG5cbigqIFRvIGVucXVldWUgYSB0b2tlbiA6IHRyeSB0byBhZHZhbmNlLiAqKVxubGV0IGVucXVldWVfYWR2YW5jZSBzdGF0ZSB0b2sgPSBwcF9lbnF1ZXVlIHN0YXRlIHRvazsgYWR2YW5jZV9sZWZ0IHN0YXRlXG5cbigqIEJ1aWxkaW5nIHByZXR0eS1wcmludGVyIHF1ZXVlIGVsZW1lbnRzLiAqKVxubGV0IG1ha2VfcXVldWVfZWxlbSBzaXplIHRvayBsZW4gPVxuICB7IGVsZW1fc2l6ZSA9IHNpemU7IHRva2VuID0gdG9rOyBsZW5ndGggPSBsZW47IH1cblxuXG4oKiBUbyBlbnF1ZXVlIHN0cmluZ3MuICopXG5sZXQgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzID1cbiAgbGV0IGxlbiA9IGludF9vZl9zaXplIHNpemUgaW5cbiAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIChtYWtlX3F1ZXVlX2VsZW0gc2l6ZSAoUHBfdGV4dCBzKSBsZW4pXG5cblxubGV0IGVucXVldWVfc3RyaW5nIHN0YXRlIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIChzaXplX29mX2ludCBsZW4pIHNcblxuXG4oKiBSb3V0aW5lcyBmb3Igc2NhbiBzdGFja1xuICAgZGV0ZXJtaW5lIHNpemUgb2YgYm94ZXMuICopXG5cbigqIFRoZSBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxubGV0IHNjYW5fc3RhY2tfYm90dG9tID1cbiAgbGV0IHFfZWxlbSA9IG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgKC0xKSkgKFBwX3RleHQgXCJcIikgMCBpblxuICBbU2Nhbl9lbGVtICgtMSwgcV9lbGVtKV1cblxuXG4oKiBDbGVhcmluZyB0aGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG5sZXQgY2xlYXJfc2Nhbl9zdGFjayBzdGF0ZSA9IHN0YXRlLnBwX3NjYW5fc3RhY2sgPC0gc2Nhbl9zdGFja19ib3R0b21cblxuKCogU2V0dGluZyB0aGUgc2l6ZSBvZiBib3hlcyBvbiBzY2FuIHN0YWNrOlxuICAgaWYgdHkgPSB0cnVlIHRoZW4gc2l6ZSBvZiBicmVhayBpcyBzZXQgZWxzZSBzaXplIG9mIGJveCBpcyBzZXQ7XG4gICBpbiBlYWNoIGNhc2UgcHBfc2Nhbl9zdGFjayBpcyBwb3BwZWQuXG5cbiAgIE5vdGU6XG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHNjYW4gc3RhY2sgaXMgZXhoYXVzdGl2ZSwgc2luY2Ugc2Nhbl9zdGFjayBpcyBuZXZlclxuICAgZW1wdHkuXG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHRva2VuIGluIHNjYW4gc3RhY2sgaXMgYWxzbyBleGhhdXN0aXZlLFxuICAgc2luY2Ugc2Nhbl9wdXNoIGlzIHVzZWQgb24gYnJlYWtzIGFuZCBvcGVuaW5nIG9mIGJveGVzLiAqKVxubGV0IHNldF9zaXplIHN0YXRlIHR5ID1cbiAgbWF0Y2ggc3RhdGUucHBfc2Nhbl9zdGFjayB3aXRoXG4gIHwgU2Nhbl9lbGVtXG4gICAgICAobGVmdF90b3QsXG4gICAgICAgKHsgZWxlbV9zaXplID0gc2l6ZTsgdG9rZW4gPSB0b2s7IGxlbmd0aCA9IF87IH0gYXMgcXVldWVfZWxlbSkpIDo6IHQgLT5cbiAgICBsZXQgc2l6ZSA9IGludF9vZl9zaXplIHNpemUgaW5cbiAgICAoKiB0ZXN0IGlmIHNjYW4gc3RhY2sgY29udGFpbnMgYW55IGRhdGEgdGhhdCBpcyBub3Qgb2Jzb2xldGUuICopXG4gICAgaWYgbGVmdF90b3QgPCBzdGF0ZS5wcF9sZWZ0X3RvdGFsIHRoZW4gY2xlYXJfc2Nhbl9zdGFjayBzdGF0ZSBlbHNlXG4gICAgICBiZWdpbiBtYXRjaCB0b2sgd2l0aFxuICAgICAgfCBQcF9icmVhayAoXywgXykgfCBQcF90YnJlYWsgKF8sIF8pIC0+XG4gICAgICAgIGlmIHR5IHRoZW5cbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLmVsZW1fc2l6ZSA8LSBzaXplX29mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBzdGF0ZS5wcF9zY2FuX3N0YWNrIDwtIHRcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX2JlZ2luIChfLCBfKSAtPlxuICAgICAgICBpZiBub3QgdHkgdGhlblxuICAgICAgICBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uZWxlbV9zaXplIDwtIHNpemVfb2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIHN0YXRlLnBwX3NjYW5fc3RhY2sgPC0gdFxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfdGV4dCBfIHwgUHBfc3RhYiB8IFBwX3RiZWdpbiBfIHwgUHBfdGVuZCB8IFBwX2VuZFxuICAgICAgfCBQcF9uZXdsaW5lIHwgUHBfaWZfbmV3bGluZVxuICAgICAgfCBQcF9vcGVuX3RhZyBfIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgICAgICgpICgqIHNjYW5fcHVzaCBpcyBvbmx5IHVzZWQgZm9yIGJyZWFrcyBhbmQgYm94ZXMuICopXG4gICAgICBlbmRcbiAgfCBbXSAtPiAoKSAoKiBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxuXG5cbigqIFB1c2ggYSB0b2tlbiBvbiBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay5cbiAgIElmIGIgaXMgdHJ1ZSBzZXRfc2l6ZSBpcyBjYWxsZWQuICopXG5sZXQgc2Nhbl9wdXNoIHN0YXRlIGIgdG9rID1cbiAgcHBfZW5xdWV1ZSBzdGF0ZSB0b2s7XG4gIGlmIGIgdGhlbiBzZXRfc2l6ZSBzdGF0ZSB0cnVlO1xuICBzdGF0ZS5wcF9zY2FuX3N0YWNrIDwtXG4gICAgU2Nhbl9lbGVtIChzdGF0ZS5wcF9yaWdodF90b3RhbCwgdG9rKSA6OiBzdGF0ZS5wcF9zY2FuX3N0YWNrXG5cblxuKCogVG8gb3BlbiBhIG5ldyBib3ggOlxuICAgdGhlIHVzZXIgbWF5IHNldCB0aGUgZGVwdGggYm91bmQgcHBfbWF4X2JveGVzXG4gICBhbnkgdGV4dCBuZXN0ZWQgZGVlcGVyIGlzIHByaW50ZWQgYXMgdGhlIGVsbGlwc2lzIHN0cmluZy4gKilcbmxldCBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IGJyX3R5ID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPVxuICAgICAgbWFrZV9xdWV1ZV9lbGVtXG4gICAgICAgIChzaXplX29mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkpXG4gICAgICAgIChQcF9iZWdpbiAoaW5kZW50LCBicl90eSkpXG4gICAgICAgIDAgaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgZmFsc2UgZWxlbSBlbHNlXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRoZSBib3ggd2hpY2ggaXMgYWx3YXlzIG9wZW4uICopXG5sZXQgcHBfb3Blbl9zeXNfYm94IHN0YXRlID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaG92Ym94XG5cbigqIENsb3NlIGEgYm94LCBzZXR0aW5nIHNpemVzIG9mIGl0cyBzdWIgYm94ZXMuICopXG5sZXQgcHBfY2xvc2VfYm94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGJlZ2luXG4gICAgICBwcF9lbnF1ZXVlIHN0YXRlXG4gICAgICAgIHsgZWxlbV9zaXplID0gc2l6ZV9vZl9pbnQgMDsgdG9rZW4gPSBQcF9lbmQ7IGxlbmd0aCA9IDA7IH07XG4gICAgICBzZXRfc2l6ZSBzdGF0ZSB0cnVlOyBzZXRfc2l6ZSBzdGF0ZSBmYWxzZVxuICAgIGVuZDtcbiAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxO1xuICBlbmRcblxuXG4oKiBPcGVuIGEgdGFnLCBwdXNoaW5nIGl0IG9uIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfb3Blbl90YWcgc3RhdGUgdGFnX25hbWUgPVxuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgYmVnaW5cbiAgICBzdGF0ZS5wcF90YWdfc3RhY2sgPC0gdGFnX25hbWUgOjogc3RhdGUucHBfdGFnX3N0YWNrO1xuICAgIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIHRhZ19uYW1lXG4gIGVuZDtcbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHtcbiAgICAgIGVsZW1fc2l6ZSA9IHNpemVfb2ZfaW50IDA7XG4gICAgICB0b2tlbiA9IFBwX29wZW5fdGFnIHRhZ19uYW1lO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICB9XG5cblxuKCogQ2xvc2UgYSB0YWcsIHBvcHBpbmcgaXQgZnJvbSB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7XG4gICAgICBlbGVtX3NpemUgPSBzaXplX29mX2ludCAwO1xuICAgICAgdG9rZW4gPSBQcF9jbG9zZV90YWc7XG4gICAgICBsZW5ndGggPSAwO1xuICAgIH07XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICBiZWdpblxuICAgIG1hdGNoIHN0YXRlLnBwX3RhZ19zdGFjayB3aXRoXG4gICAgfCB0YWdfbmFtZSA6OiB0YWdzIC0+XG4gICAgICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgdGFnX25hbWU7XG4gICAgICBzdGF0ZS5wcF90YWdfc3RhY2sgPC0gdGFnc1xuICAgIHwgXyAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgZW5kXG5cblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBtYXJrX29wZW5fdGFnID0gc3RhdGUucHBfbWFya19vcGVuX3RhZztcbiAgbWFya19jbG9zZV90YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl90YWcgPSBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZztcbiAgcHJpbnRfY2xvc2VfdGFnID0gc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnO1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fdGFnID0gbW90O1xuICAgICBtYXJrX2Nsb3NlX3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl90YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3RhZyA9IHBjdDtcbiAgfSA9XG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gbW90O1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBtY3Q7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHBvdDtcbiAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIDwtIHBjdFxuXG5cbigqIEluaXRpYWxpemUgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfcmluaXQgc3RhdGUgPVxuICBwcF9jbGVhcl9xdWV1ZSBzdGF0ZTtcbiAgY2xlYXJfc2Nhbl9zdGFjayBzdGF0ZTtcbiAgc3RhdGUucHBfZm9ybWF0X3N0YWNrIDwtIFtdO1xuICBzdGF0ZS5wcF90Ym94X3N0YWNrIDwtIFtdO1xuICBzdGF0ZS5wcF90YWdfc3RhY2sgPC0gW107XG4gIHN0YXRlLnBwX21hcmtfc3RhY2sgPC0gW107XG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIDA7XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gMDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW47XG4gIHBwX29wZW5fc3lzX2JveCBzdGF0ZVxuXG5sZXQgY2xlYXJfdGFnX3N0YWNrIHN0YXRlID1cbiAgTGlzdC5pdGVyXG4gICAgKGZ1biBfIC0+IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSlcbiAgICBzdGF0ZS5wcF90YWdfc3RhY2tcblxuXG4oKiBGbHVzaGluZyBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBiID1cbiAgY2xlYXJfdGFnX3N0YWNrIHN0YXRlO1xuICB3aGlsZSBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSBkb1xuICAgIHBwX2Nsb3NlX2JveCBzdGF0ZSAoKVxuICBkb25lO1xuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBwcF9pbmZpbml0eTtcbiAgYWR2YW5jZV9sZWZ0IHN0YXRlO1xuICBpZiBiIHRoZW4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHBwX3Jpbml0IHN0YXRlXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBmb3JtYXQgdmFsdWVzIGFuZCB1c2UgYm94ZXMuXG5cbiopXG5cbigqIFRvIGZvcm1hdCBhIHN0cmluZy4gKilcbmxldCBwcF9wcmludF9hc19zaXplIHN0YXRlIHNpemUgcyA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHNcblxuXG5sZXQgcHBfcHJpbnRfYXMgc3RhdGUgaXNpemUgcyA9XG4gIHBwX3ByaW50X2FzX3NpemUgc3RhdGUgKHNpemVfb2ZfaW50IGlzaXplKSBzXG5cblxubGV0IHBwX3ByaW50X3N0cmluZyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG5cbigqIFRvIGZvcm1hdCBhbiBpbnRlZ2VyLiAqKVxubGV0IHBwX3ByaW50X2ludCBzdGF0ZSBpID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfaW50IGkpXG5cbigqIFRvIGZvcm1hdCBhIGZsb2F0LiAqKVxubGV0IHBwX3ByaW50X2Zsb2F0IHN0YXRlIGYgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9mbG9hdCBmKVxuXG4oKiBUbyBmb3JtYXQgYSBib29sZWFuLiAqKVxubGV0IHBwX3ByaW50X2Jvb2wgc3RhdGUgYiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Jvb2wgYilcblxuKCogVG8gZm9ybWF0IGEgY2hhci4gKilcbmxldCBwcF9wcmludF9jaGFyIHN0YXRlIGMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAxIChTdHJpbmcubWFrZSAxIGMpXG5cblxuKCogT3BlbmluZyBib3hlcy4gKilcbmxldCBwcF9vcGVuX2hib3ggc3RhdGUgKCkgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9oYm94XG5hbmQgcHBfb3Blbl92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfdmJveFxuXG5hbmQgcHBfb3Blbl9odmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2h2Ym94XG5hbmQgcHBfb3Blbl9ob3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ob3Zib3hcbmFuZCBwcF9vcGVuX2JveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2JveFxuXG5cbigqIFByaW50aW5nIHF1ZXVlZCB0ZXh0LlxuXG4gICBbcHBfcHJpbnRfZmx1c2hdIHByaW50cyBhbGwgcGVuZGluZyBpdGVtcyBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYW5kXG4gICB0aGVuIGZsdXNoZXMgdGhlIGxvdyBsZXZlbCBvdXRwdXQgZGV2aWNlIG9mIHRoZSBmb3JtYXR0ZXIgdG8gYWN0dWFsbHlcbiAgIGRpc3BsYXkgcHJpbnRpbmcgbWF0ZXJpYWwuXG5cbiAgIFtwcF9wcmludF9uZXdsaW5lXSBiZWhhdmVzIGFzIFtwcF9wcmludF9mbHVzaF0gYWZ0ZXIgcHJpbnRpbmcgYW4gYWRkaXRpb25hbFxuICAgbmV3IGxpbmUuICopXG5sZXQgcHBfcHJpbnRfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIHRydWU7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuYW5kIHBwX3ByaW50X2ZsdXNoIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgZmFsc2U7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuXG5cbigqIFRvIGdldCBhIG5ld2xpbmUgd2hlbiBvbmUgZG9lcyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3VycmVudCBib3guICopXG5sZXQgcHBfZm9yY2VfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSAobWFrZV9xdWV1ZV9lbGVtIChzaXplX29mX2ludCAwKSBQcF9uZXdsaW5lIDApXG5cblxuKCogVG8gZm9ybWF0IHNvbWV0aGluZywgb25seSBpbiBjYXNlIHRoZSBsaW5lIGhhcyBqdXN0IGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3ByaW50X2lmX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgKG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgUHBfaWZfbmV3bGluZSAwKVxuXG5cbigqIFByaW50aW5nIGJyZWFrIGhpbnRzOlxuICAgQSBicmVhayBoaW50IGluZGljYXRlcyB3aGVyZSBhIGJveCBtYXkgYmUgYnJva2VuLlxuICAgSWYgbGluZSBpcyBicm9rZW4gdGhlbiBvZmZzZXQgaXMgYWRkZWQgdG8gdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICBib3ggZWxzZSAodGhlIHZhbHVlIG9mKSB3aWR0aCBibGFua3MgYXJlIHByaW50ZWQuICopXG5sZXQgcHBfcHJpbnRfYnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPVxuICAgICAgbWFrZV9xdWV1ZV9lbGVtXG4gICAgICAgIChzaXplX29mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkpXG4gICAgICAgIChQcF9icmVhayAod2lkdGgsIG9mZnNldCkpXG4gICAgICAgIHdpZHRoIGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIHRydWUgZWxlbVxuXG5cbigqIFByaW50IGEgc3BhY2UgOlxuICAgYSBzcGFjZSBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgYSBzaW5nbGUgc3BhY2UgaWYgdGhlIGJyZWFrIGRvZXMgbm90XG4gICBzcGxpdCB0aGUgbGluZTtcbiAgIGEgY3V0IGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBub3RoaW5nIGlmIHRoZSBicmVhayBkb2VzIG5vdCBzcGxpdCB0aGVcbiAgIGxpbmUuICopXG5sZXQgcHBfcHJpbnRfc3BhY2Ugc3RhdGUgKCkgPSBwcF9wcmludF9icmVhayBzdGF0ZSAxIDBcbmFuZCBwcF9wcmludF9jdXQgc3RhdGUgKCkgPSBwcF9wcmludF9icmVhayBzdGF0ZSAwIDBcblxuXG4oKiBUYWJ1bGF0aW9uIGJveGVzLiAqKVxubGV0IHBwX29wZW5fdGJveCBzdGF0ZSAoKSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID1cbiAgICAgIG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgKFBwX3RiZWdpbiAoUHBfdGJveCAocmVmIFtdKSkpIDAgaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqIENsb3NlIGEgdGFidWxhdGlvbiBib3guICopXG5sZXQgcHBfY2xvc2VfdGJveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgICBsZXQgZWxlbSA9IG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgUHBfdGVuZCAwIGluXG4gICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtO1xuICAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxXG4gIGVuZFxuXG5cbigqIFByaW50IGEgdGFidWxhdGlvbiBicmVhay4gKilcbmxldCBwcF9wcmludF90YnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPVxuICAgICAgbWFrZV9xdWV1ZV9lbGVtXG4gICAgICAgIChzaXplX29mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkpXG4gICAgICAgIChQcF90YnJlYWsgKHdpZHRoLCBvZmZzZXQpKVxuICAgICAgICB3aWR0aCBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG5sZXQgcHBfcHJpbnRfdGFiIHN0YXRlICgpID0gcHBfcHJpbnRfdGJyZWFrIHN0YXRlIDAgMFxuXG5sZXQgcHBfc2V0X3RhYiBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID1cbiAgICAgIG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgUHBfc3RhYiAwIGluXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW1cblxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gY29udHJvbCB0aGUgcHJldHR5LXByaW50ZXJzXG5cbiopXG5cbigqIFNldF9tYXhfYm94ZXMuICopXG5sZXQgcHBfc2V0X21heF9ib3hlcyBzdGF0ZSBuID0gaWYgbiA+IDEgdGhlbiBzdGF0ZS5wcF9tYXhfYm94ZXMgPC0gblxuXG4oKiBUbyBrbm93IHRoZSBjdXJyZW50IG1heGltdW0gbnVtYmVyIG9mIGJveGVzIGFsbG93ZWQuICopXG5sZXQgcHBfZ2V0X21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG5sZXQgcHBfb3Zlcl9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbigqIEVsbGlwc2lzLiAqKVxubGV0IHBwX3NldF9lbGxpcHNpc190ZXh0IHN0YXRlIHMgPSBzdGF0ZS5wcF9lbGxpcHNpcyA8LSBzXG5hbmQgcHBfZ2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRvIHNldCB0aGUgbWFyZ2luIG9mIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX2xpbWl0IG4gPVxuICBpZiBuIDwgcHBfaW5maW5pdHkgdGhlbiBuIGVsc2UgcHJlZCBwcF9pbmZpbml0eVxuXG5cbigqIEludGVybmFsIHByZXR0eS1wcmludGVyIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgbiA9XG4gIGlmIG4gPj0gMSB0aGVuXG4gICAgbGV0IG4gPSBwcF9saW1pdCBuIGluXG4gICAgc3RhdGUucHBfbWluX3NwYWNlX2xlZnQgPC0gbjtcbiAgICBzdGF0ZS5wcF9tYXhfaW5kZW50IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3Jpbml0IHN0YXRlXG5cblxuKCogSW5pdGlhbGx5LCB3ZSBoYXZlIDpcbiAgIHBwX21heF9pbmRlbnQgPSBwcF9tYXJnaW4gLSBwcF9taW5fc3BhY2VfbGVmdCwgYW5kXG4gICBwcF9zcGFjZV9sZWZ0ID0gcHBfbWFyZ2luLiAqKVxubGV0IHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG4gPVxuICBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgKHN0YXRlLnBwX21hcmdpbiAtIG4pXG5cblxubGV0IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2luZGVudFxuXG5sZXQgcHBfc2V0X21hcmdpbiBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9tYXJnaW4gPC0gbjtcbiAgICBsZXQgbmV3X21heF9pbmRlbnQgPVxuICAgICAgKCogVHJ5IHRvIG1haW50YWluIG1heF9pbmRlbnQgdG8gaXRzIGFjdHVhbCB2YWx1ZS4gKilcbiAgICAgIGlmIHN0YXRlLnBwX21heF9pbmRlbnQgPD0gc3RhdGUucHBfbWFyZ2luXG4gICAgICB0aGVuIHN0YXRlLnBwX21heF9pbmRlbnQgZWxzZVxuICAgICAgKCogSWYgcG9zc2libGUgbWFpbnRhaW4gcHBfbWluX3NwYWNlX2xlZnQgdG8gaXRzIGFjdHVhbCB2YWx1ZSxcbiAgICAgICAgIGlmIHRoaXMgbGVhZHMgdG8gYSB0b28gc21hbGwgbWF4X2luZGVudCwgdGFrZSBoYWxmIG9mIHRoZVxuICAgICAgICAgbmV3IG1hcmdpbiwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDEuICopXG4gICAgICAgbWF4IChtYXggKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0KVxuICAgICAgICAgICAgICAgIChzdGF0ZS5wcF9tYXJnaW4gLyAyKSkgMSBpblxuICAgICgqIFJlYnVpbGQgaW52YXJpYW50cy4gKilcbiAgICBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuZXdfbWF4X2luZGVudFxuXG5cbmxldCBwcF9nZXRfbWFyZ2luIHN0YXRlICgpID0gc3RhdGUucHBfbWFyZ2luXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUge1xuICAgICAgb3V0X3N0cmluZyA9IGY7XG4gICAgICBvdXRfZmx1c2ggPSBnO1xuICAgICAgb3V0X25ld2xpbmUgPSBoO1xuICAgICAgb3V0X3NwYWNlcyA9IGk7XG4gICAgICBvdXRfaW5kZW50ID0gajtcbiAgICB9ID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGpcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgb3V0X3N0cmluZyA9IHN0YXRlLnBwX291dF9zdHJpbmc7XG4gIG91dF9mbHVzaCA9IHN0YXRlLnBwX291dF9mbHVzaDtcbiAgb3V0X25ld2xpbmUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZTtcbiAgb3V0X3NwYWNlcyA9IHN0YXRlLnBwX291dF9zcGFjZXM7XG4gIG91dF9pbmRlbnQgPSBzdGF0ZS5wcF9vdXRfaW5kZW50O1xufVxuXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgc3RyaW5nIG91dHB1dCBhbmQgZmx1c2ggZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSBmIGcgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7IHN0YXRlLnBwX291dF9mbHVzaCA8LSBnXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoKVxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9uZXdsaW5lIHN0YXRlICgpID0gc3RhdGUucHBfb3V0X3N0cmluZyBcIlxcblwiIDAgIDFcblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IHNwYWNlcy4gKilcbmxldCBibGFua19saW5lID0gU3RyaW5nLm1ha2UgODAgJyAnXG5sZXQgcmVjIGRpc3BsYXlfYmxhbmtzIHN0YXRlIG4gPVxuICBpZiBuID4gMCB0aGVuXG4gIGlmIG4gPD0gODAgdGhlbiBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCBuIGVsc2VcbiAgYmVnaW5cbiAgICBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCA4MDtcbiAgICBkaXNwbGF5X2JsYW5rcyBzdGF0ZSAobiAtIDgwKVxuICBlbmRcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfaW5kZW50ID0gZGlzcGxheV9ibGFua3NcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zIGFzIHByaW50aW5nIHRvIGEgZ2l2ZW5cbiAgIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgc3RhdGUgb2MgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIG91dHB1dF9zdWJzdHJpbmcgb2M7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSAoZnVuICgpIC0+IGZsdXNoIG9jKTtcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGRpc3BsYXlfYmxhbmtzIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHN0YXRlXG5cbigqXG5cbiAgRGVmaW5pbmcgc3BlY2lmaWMgZm9ybWF0dGVyc1xuXG4qKVxuXG5sZXQgZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnIHMgPSBcIjxcIiBeIHMgXiBcIj5cIlxubGV0IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWcgcyA9IFwiPC9cIiBeIHMgXiBcIj5cIlxuXG5sZXQgZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyA9IGlnbm9yZVxubGV0IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnID0gaWdub3JlXG5cbigqIEJ1aWxkaW5nIGEgZm9ybWF0dGVyIGdpdmVuIGl0cyBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLlxuICAgT3RoZXIgZmllbGRzIGdldCByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWVzLiAqKVxubGV0IHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgaiA9XG4gICgqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBmb3JtYXR0ZXIgY29udGFpbnMgYSBkdW1teSBib3guICopXG4gIGxldCBwcF9xdWV1ZSA9IG1ha2VfcXVldWUgKCkgaW5cbiAgbGV0IHN5c190b2sgPVxuICAgIG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgKC0xKSkgKFBwX2JlZ2luICgwLCBQcF9ob3Zib3gpKSAwIGluXG4gIGFkZF9xdWV1ZSBzeXNfdG9rIHBwX3F1ZXVlO1xuICBsZXQgc3lzX3NjYW5fc3RhY2sgPVxuICAgIFNjYW5fZWxlbSAoMSwgc3lzX3RvaykgOjogc2Nhbl9zdGFja19ib3R0b20gaW5cbiAgbGV0IHBwX21hcmdpbiA9IDc4XG4gIGFuZCBwcF9taW5fc3BhY2VfbGVmdCA9IDEwIGluXG4gIHtcbiAgICBwcF9zY2FuX3N0YWNrID0gc3lzX3NjYW5fc3RhY2s7XG4gICAgcHBfZm9ybWF0X3N0YWNrID0gW107XG4gICAgcHBfdGJveF9zdGFjayA9IFtdO1xuICAgIHBwX3RhZ19zdGFjayA9IFtdO1xuICAgIHBwX21hcmtfc3RhY2sgPSBbXTtcbiAgICBwcF9tYXJnaW4gPSBwcF9tYXJnaW47XG4gICAgcHBfbWluX3NwYWNlX2xlZnQgPSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbjtcbiAgICBwcF9jdXJyZW50X2luZGVudCA9IDA7XG4gICAgcHBfaXNfbmV3X2xpbmUgPSB0cnVlO1xuICAgIHBwX2xlZnRfdG90YWwgPSAxO1xuICAgIHBwX3JpZ2h0X3RvdGFsID0gMTtcbiAgICBwcF9jdXJyX2RlcHRoID0gMTtcbiAgICBwcF9tYXhfYm94ZXMgPSBtYXhfaW50O1xuICAgIHBwX2VsbGlwc2lzID0gXCIuXCI7XG4gICAgcHBfb3V0X3N0cmluZyA9IGY7XG4gICAgcHBfb3V0X2ZsdXNoID0gZztcbiAgICBwcF9vdXRfbmV3bGluZSA9IGg7XG4gICAgcHBfb3V0X3NwYWNlcyA9IGk7XG4gICAgcHBfb3V0X2luZGVudCA9IGo7XG4gICAgcHBfcHJpbnRfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfb3Blbl90YWcgPSBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWc7XG4gICAgcHBfbWFya19jbG9zZV90YWcgPSBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnO1xuICAgIHBwX3ByaW50X29wZW5fdGFnID0gZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZztcbiAgICBwcF9wcmludF9jbG9zZV90YWcgPSBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZztcbiAgICBwcF9xdWV1ZSA9IHBwX3F1ZXVlO1xuICB9XG5cblxuKCogQnVpbGQgYSBmb3JtYXR0ZXIgb3V0IG9mIGl0cyBvdXQgZnVuY3Rpb25zLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIG91dF9mdW5zID1cbiAgcHBfbWFrZV9mb3JtYXR0ZXJcbiAgICBvdXRfZnVucy5vdXRfc3RyaW5nXG4gICAgb3V0X2Z1bnMub3V0X2ZsdXNoXG4gICAgb3V0X2Z1bnMub3V0X25ld2xpbmVcbiAgICBvdXRfZnVucy5vdXRfc3BhY2VzXG4gICAgb3V0X2Z1bnMub3V0X2luZGVudFxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd2l0aCBkZWZhdWx0IGZ1bmN0aW9ucyB0byBvdXRwdXQgc3BhY2VzLFxuICBpbmRlbnRhdGlvbiwgYW5kIG5ldyBsaW5lcy4gKilcbmxldCBtYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBsZXQgcHBmID0gcHBfbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoIGlnbm9yZSBpZ25vcmUgaWdub3JlIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgcHBmXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9mb3JtYXR0ZXIgKG91dHB1dF9zdWJzdHJpbmcgb2MpIChmdW4gKCkgLT4gZmx1c2ggb2MpXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW0J1ZmZlci50XSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgPVxuICBtYWtlX2Zvcm1hdHRlciAoQnVmZmVyLmFkZF9zdWJzdHJpbmcgYikgaWdub3JlXG5cblxuKCogQWxsb2NhdGluZyBidWZmZXIgZm9yIHByZXR0eS1wcmludGluZyBwdXJwb3Nlcy5cbiAgIERlZmF1bHQgYnVmZmVyIHNpemUgaXMgcHBfYnVmZmVyX3NpemUgb3IgNTEyLlxuKilcbmxldCBwcF9idWZmZXJfc2l6ZSA9IDUxMlxubGV0IHBwX21ha2VfYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZVxuXG4oKiBUaGUgc3RhbmRhcmQgKHNoYXJlZCkgYnVmZmVyLiAqKVxubGV0IHN0ZGJ1ZiA9IHBwX21ha2VfYnVmZmVyICgpXG5cbigqIFByZWRlZmluZWQgZm9ybWF0dGVycyBzdGFuZGFyZCBmb3JtYXR0ZXIgdG8gcHJpbnRcbiAgIHRvIFtQZXJ2YXNpdmVzLnN0ZG91dF0sIFtQZXJ2YXNpdmVzLnN0ZGVycl0sIGFuZCB7IXN0ZGJ1Zn0uICopXG5sZXQgc3RkX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBQZXJ2YXNpdmVzLnN0ZG91dFxuYW5kIGVycl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgUGVydmFzaXZlcy5zdGRlcnJcbmFuZCBzdHJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX2J1ZmZlciBzdGRidWZcblxuXG4oKiBbZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmXSBmbHVzaGVzIGZvcm1hdHRlciBbcHBmXSxcbiAgIHRoZW4gcmV0dXJucyB0aGUgY29udGVudHMgb2YgYnVmZmVyIFtidWZdIHRoYXQgaXMgcmVzZXQuXG4gICBGb3JtYXR0ZXIgW3BwZl0gaXMgc3VwcG9zZWQgdG8gcHJpbnQgdG8gYnVmZmVyIFtidWZdLCBvdGhlcndpc2UgdGhpc1xuICAgZnVuY3Rpb24gaXMgbm90IHJlYWxseSB1c2VmdWwuICopXG5sZXQgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmID1cbiAgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlO1xuICBsZXQgcyA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgQnVmZmVyLnJlc2V0IGJ1ZjtcbiAgc1xuXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID0gZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtQZXJ2YXNpdmVzLnN0ZG91dF0pLlxuXG4qKVxuXG5sZXQgb3Blbl9oYm94ID0gcHBfb3Blbl9oYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3Zib3ggPSBwcF9vcGVuX3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faHZib3ggPSBwcF9vcGVuX2h2Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2hvdmJveCA9IHBwX29wZW5faG92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2JveCA9IHBwX29wZW5fYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV9ib3ggPSBwcF9jbG9zZV9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdGFnID0gcHBfb3Blbl90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3RhZyA9IHBwX2Nsb3NlX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYXMgPSBwcF9wcmludF9hcyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3RyaW5nID0gcHBfcHJpbnRfc3RyaW5nIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pbnQgPSBwcF9wcmludF9pbnQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Zsb2F0ID0gcHBfcHJpbnRfZmxvYXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2NoYXIgPSBwcF9wcmludF9jaGFyIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9ib29sID0gcHBfcHJpbnRfYm9vbCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYnJlYWsgPSBwcF9wcmludF9icmVhayBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY3V0ID0gcHBfcHJpbnRfY3V0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zcGFjZSA9IHBwX3ByaW50X3NwYWNlIHN0ZF9mb3JtYXR0ZXJcbmFuZCBmb3JjZV9uZXdsaW5lID0gcHBfZm9yY2VfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmx1c2ggPSBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfbmV3bGluZSA9IHBwX3ByaW50X25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2lmX25ld2xpbmUgPSBwcF9wcmludF9pZl9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIG9wZW5fdGJveCA9IHBwX29wZW5fdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGJveCA9IHBwX2Nsb3NlX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RicmVhayA9IHBwX3ByaW50X3RicmVhayBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfdGFiID0gcHBfc2V0X3RhYiBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGFiID0gcHBfcHJpbnRfdGFiIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXJnaW4gPSBwcF9zZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2luZGVudCA9IHBwX3NldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfYm94ZXMgPSBwcF9zZXRfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2JveGVzID0gcHBfZ2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgb3Zlcl9tYXhfYm94ZXMgPSBwcF9vdmVyX21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZWxsaXBzaXNfdGV4dCA9IHBwX3NldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZWxsaXBzaXNfdGV4dCA9IHBwX2dldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfcHJpbnRfdGFncyA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfcHJpbnRfdGFncyA9XG4gIHBwX2dldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfbWFya190YWdzID1cbiAgcHBfc2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmtfdGFncyA9XG4gIHBwX2dldF9tYXJrX3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF90YWdzID1cbiAgcHBfc2V0X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuXG5cbigqIENvbnZlbmllbmNlIGZ1bmN0aW9ucyAqKVxuXG4oKiBUbyBmb3JtYXQgYSBsaXN0ICopXG5sZXQgcmVjIHBwX3ByaW50X2xpc3QgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIHBwX3YgcHBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAoKVxuICB8IFt2XSAtPiBwcF92IHBwZiB2XG4gIHwgdiA6OiB2cyAtPlxuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF9wcmludF9saXN0IH5wcF9zZXAgcHBfdiBwcGYgdnNcblxuKCogVG8gZm9ybWF0IGZyZWUtZmxvd2luZyB0ZXh0ICopXG5sZXQgcHBfcHJpbnRfdGV4dCBwcGYgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGxlZnQgPSByZWYgMCBpblxuICBsZXQgcmlnaHQgPSByZWYgMCBpblxuICBsZXQgZmx1c2ggKCkgPVxuICAgIHBwX3ByaW50X3N0cmluZyBwcGYgKFN0cmluZy5zdWIgcyAhbGVmdCAoIXJpZ2h0IC0gIWxlZnQpKTtcbiAgICBpbmNyIHJpZ2h0OyBsZWZ0IDo9ICFyaWdodDtcbiAgaW5cbiAgd2hpbGUgKCFyaWdodCA8PiBsZW4pIGRvXG4gICAgbWF0Y2ggcy5bIXJpZ2h0XSB3aXRoXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGZsdXNoICgpO1xuICAgICAgICBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgZmx1c2ggKCk7IHBwX3ByaW50X3NwYWNlIHBwZiAoKVxuICAgICAgKCogdGhlcmUgaXMgbm8gc3BlY2lmaWMgc3VwcG9ydCBmb3IgJ1xcdCdcbiAgICAgICAgIGFzIGl0IGlzIHVuY2xlYXIgd2hhdCBhIHJpZ2h0IHNlbWFudGljcyB3b3VsZCBiZSAqKVxuICAgICAgfCBfIC0+IGluY3IgcmlnaHRcbiAgZG9uZTtcbiAgaWYgIWxlZnQgPD4gbGVuIHRoZW4gZmx1c2ggKClcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfdGFnIHBwZiAoKVxuICB8IEJyZWFrIChfLCB3aWR0aCwgb2Zmc2V0KSAgLT4gcHBfcHJpbnRfYnJlYWsgcHBmIHdpZHRoIG9mZnNldFxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfZmx1c2ggcHBmICgpXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfcHJpbnRfbmV3bGluZSBwcGYgKClcbiAgfCBNYWdpY19zaXplIChfLCBfKSAgICAgICAgIC0+ICgpXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCdcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICclJ1xuICB8IFNjYW5faW5kaWMgYyAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnOyBwcF9wcmludF9jaGFyIHBwZiBjXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5vdXRwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKHNpemVfb2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoc2l6ZV9vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3RhZyBwcGYgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJylcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBmIHBwZjtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYuYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChzaXplX29mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKHNpemVfb2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19kZWxheSAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoc2l6ZV9vZl9pbnQgc2l6ZSkgKGYgKCkpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl90YWcgcHBmIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZiAoKSk7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKlxuXG4gIERlZmluaW5nIFtmcHJpbnRmXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtmcHJpbnRmXS5cblxuKilcblxubGV0IGtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIHBwZiBhY2MgLT4gb3V0cHV0X2FjYyBwcGYgYWNjOyBrIHBwZilcbiAgICBwcGYgRW5kX29mX2FjYyBmbXRcblxuYW5kIGlrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIHBwZiBmbXRcblxubGV0IGZwcmludGYgcHBmID0ga2ZwcmludGYgaWdub3JlIHBwZlxubGV0IGlmcHJpbnRmIHBwZiA9IGlrZnByaW50ZiBpZ25vcmUgcHBmXG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkX2Zvcm1hdHRlciBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgZXJyX2Zvcm1hdHRlciBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgKCkgYWNjID1cbiAgICBzdHJwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayAoKSBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxubGV0IGthc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGIgPSBwcF9tYWtlX2J1ZmZlciAoKSBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIHBwZiBhY2MgPVxuICAgIG91dHB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIHBwZiBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBhc3ByaW50ZiBmbXQgPSBrYXNwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG4oKiBPdXRwdXQgZXZlcnl0aGluZyBsZWZ0IGluIHRoZSBwcmV0dHkgcHJpbnRlciBxdWV1ZSBhdCBlbmQgb2YgZXhlY3V0aW9uLiAqKVxubGV0ICgpID0gYXRfZXhpdCBwcmludF9mbHVzaFxuXG5cbigqXG5cbiAgRGVwcmVjYXRlZCBzdHVmZi5cblxuKilcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGVcbiAgICB+b3V0OmYgfmZsdXNoOmcgfm5ld2xpbmU6aCB+c3BhY2VzOmkgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGlcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoLFxuICAgc3RhdGUucHBfb3V0X25ld2xpbmUsIHN0YXRlLnBwX291dF9zcGFjZXMpXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5cbigqIERlcHJlY2F0ZWQgOiBlcnJvciBwcm9uZSBmdW5jdGlvbiwgZG8gbm90IHVzZSBpdC5cbiAgIFRoaXMgZnVuY3Rpb24gaXMgbmVpdGhlciBjb21wb3NpdGlvbmFsIG5vciBpbmNyZW1lbnRhbCwgc2luY2UgaXQgZmx1c2hlc1xuICAgdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGF0IGVhY2ggY2FsbC5cbiAgIFRvIGdldCB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5LCBkZWZpbmUgYSBmb3JtYXR0ZXIgb2YgeW91ciBvd24gd3JpdGluZyB0b1xuICAgdGhlIGJ1ZmZlciBhcmd1bWVudCwgYXMgaW5cbiAgIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJcbiAgIHRoZW4gdXNlIHshZnByaW50ZiBwcGZ9IGFzIHVzdWFsLiAqKVxubGV0IGJwcmludGYgYiAoRm9ybWF0IChmbXQsIF8pIDogKCdhLCBmb3JtYXR0ZXIsIHVuaXQpIGZvcm1hdCkgPVxuICBsZXQgayBwcGYgYWNjID0gb3V0cHV0X2FjYyBwcGYgYWNjOyBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2UgaW5cbiAgbWFrZV9wcmludGYgayAoZm9ybWF0dGVyX29mX2J1ZmZlciBiKSBFbmRfb2ZfYWNjIGZtdFxuXG5cbigqIERlcHJlY2F0ZWQgOiBhbGlhcyBmb3Iga3NwcmludGYuICopXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBhbGlhcyB0byBhdm9pZCB3YXJuaW5nIGZvciBhbWJpZ3VpdHkgYmV0d2VlblxuICAgUGVydmFzaXZlcy5mb3JtYXQ2XG4gICBhbmQgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcblxuICAgKHRoZSBmb3JtZXIgaXMgaW4gZmFjdCBhbiBhbGlhcyBmb3IgdGhlIGxhdHRlcixcbiAgICBidXQgdGhlIGFtYmlndWl0eSB3YXJuaW5nIGRvZXNuJ3QgY2FyZSlcbiopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIFBlcnZhc2l2ZXMuZm9ybWF0NlxuXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FubmVycy4gKilcblxuKCogU2Nhbm5pbmcgYnVmZmVycy4gKilcbm1vZHVsZSB0eXBlIFNDQU5OSU5HID0gc2lnXG5cbiAgdHlwZSBpbl9jaGFubmVsXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdmFsIHN0ZGluIDogaW5fY2hhbm5lbFxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbUGVydmFzaXZlcy5zdGRpbl0uXG4gICAgIFtzdGRpYl0gaXMgZXF1aXZhbGVudCB0byBbU2Nhbm5pbmcuZnJvbV9jaGFubmVsIFBlcnZhc2l2ZXMuc3RkaW5dLiAqKVxuXG4gIHZhbCBzdGRpYiA6IGluX2NoYW5uZWxcbiAgKCogQW4gYWxpYXMgZm9yIFtTY2FuZi5zdGRpbl0sIHRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tXG4gICAgIFtQZXJ2YXNpdmVzLnN0ZGluXS4gKilcblxuICB2YWwgbmV4dF9jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5uZXh0X2NoYXIgaWJdIGFkdmFuY2UgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3Rlci5cbiAgICAgSWYgbm8gbW9yZSBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYSBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXSBtYXJrIHRoZSBjdXJyZW50X2NoYXIgYXMgYWxyZWFkeVxuICAgICBzY2FubmVkLiAqKVxuXG4gIHZhbCBwZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLnBlZWtfY2hhciBpYl0gcmV0dXJucyB0aGUgY3VycmVudCBjaGFyIGF2YWlsYWJsZSBpblxuICAgICB0aGUgYnVmZmVyIG9yIHJlYWRzIG9uZSBpZiBuZWNlc3NhcnkgKHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzXG4gICAgIGFscmVhZHkgc2Nhbm5lZCkuXG4gICAgIElmIG5vIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhbiBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgY2hlY2tlZF9wZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogU2FtZSBhcyBbU2Nhbm5pbmcucGVla19jaGFyXSBhYm92ZSBidXQgYWx3YXlzIHJldHVybnMgYSB2YWxpZCBjaGFyIG9yXG4gICAgIGZhaWxzOiBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG51bGwgY2hhciB3aGVuIHRoZSByZWFkaW5nIG1ldGhvZCBvZiB0aGVcbiAgICAgaW5wdXQgYnVmZmVyIGhhcyByZWFjaGVkIGFuIGVuZCBvZiBmaWxlLCB0aGUgZnVuY3Rpb24gcmFpc2VzIGV4Y2VwdGlvblxuICAgICBbRW5kX29mX2ZpbGVdLiAqKVxuXG4gIHZhbCBzdG9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gY2hhciAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnN0b3JlX2NoYXIgbGltIGliIGNdIGFkZHMgW2NdIHRvIHRoZSB0b2tlbiBidWZmZXJcbiAgICAgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlciBbaWJdLiBJdCBhbHNvIGFkdmFuY2VzIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIgYW5kIHJldHVybnMgW2xpbSAtIDFdLCBpbmRpY2F0aW5nIHRoZSBuZXcgbGltaXQgZm9yIHRoZVxuICAgICBsZW5ndGggb2YgdGhlIGN1cnJlbnQgdG9rZW4uICopXG5cbiAgdmFsIHNraXBfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc2tpcF9jaGFyIGxpbSBpYl0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuICopXG5cbiAgdmFsIGlnbm9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5pZ25vcmVfY2hhciBpYiBsaW1dIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGFuZFxuICAgICBkZWNyZW1lbnRzIHRoZSBsaW1pdC4gKilcblxuICB2YWwgdG9rZW4gOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcudG9rZW4gaWJdIHJldHVybnMgdGhlIHN0cmluZyBzdG9yZWQgaW50byB0aGUgdG9rZW5cbiAgICAgYnVmZmVyIG9mIHRoZSBzY2FubmluZyBidWZmZXI6IGl0IHJldHVybnMgdGhlIHRva2VuIG1hdGNoZWQgYnkgdGhlXG4gICAgIGZvcm1hdC4gKilcblxuICB2YWwgcmVzZXRfdG9rZW4gOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLnJlc2V0X3Rva2VuIGliXSByZXNldHMgdGhlIHRva2VuIGJ1ZmZlciBvZlxuICAgICB0aGUgZ2l2ZW4gc2Nhbm5pbmcgYnVmZmVyLiAqKVxuXG4gIHZhbCBjaGFyX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmNoYXJfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbGluZV9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5saW5lX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbmV3IGxpbmVcbiAgICAgY2hhcmFjdGVycyByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIHRva2VuX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnRva2VuX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgdG9rZW5zIHJlYWRcbiAgICAgc28gZmFyIGZyb20gW2liXS4gKilcblxuICB2YWwgZW9mIDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lb2YgaWJdIHJldHVybnMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgZW5kX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIgKGlmIG5vIGNoYXIgaGFzIGV2ZXIgYmVlbiByZWFkLCBhbiBhdHRlbXB0IHRvXG4gICAgIHJlYWQgb25lIGlzIHBlcmZvcm1lZCkuICopXG5cbiAgdmFsIGJlZ2lubmluZ19vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuYmVnaW5uaW5nX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgYmVnaW5uaW5nIG9mIGlucHV0XG4gICAgIGNvbmRpdGlvbiBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBuYW1lX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLm5hbWVfb2ZfaW5wdXQgaWJdIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNoYXJhY3RlclxuICAgICBzb3VyY2UgZm9yIGlucHV0IGJ1ZmZlciBbaWJdLiAqKVxuXG4gIHZhbCBvcGVuX2luIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIG9wZW5faW5fYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZSA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGVfYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fc3RyaW5nIDogc3RyaW5nIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZnVuY3Rpb24gOiAodW5pdCAtPiBjaGFyKSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2NoYW5uZWwgOiBQZXJ2YXNpdmVzLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuXG4gIHZhbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdFxuXG4gIHZhbCBtZW1vX2Zyb21fY2hhbm5lbCA6IFBlcnZhc2l2ZXMuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG4gICgqIE9ic29sZXRlLiAqKVxuXG5lbmRcblxuXG5tb2R1bGUgU2Nhbm5pbmcgOiBTQ0FOTklORyA9IHN0cnVjdFxuXG4gICgqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FuZi4gKilcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbF9uYW1lID1cbiAgICB8IEZyb21fY2hhbm5lbCBvZiBQZXJ2YXNpdmVzLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZmlsZSBvZiBmaWxlX25hbWUgKiBQZXJ2YXNpdmVzLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZnVuY3Rpb25cbiAgICB8IEZyb21fc3RyaW5nXG5cblxuICB0eXBlIGluX2NoYW5uZWwgPSB7XG4gICAgbXV0YWJsZSBpY19lb2YgOiBib29sO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyIDogY2hhcjtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jaGFyX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfbGluZV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX3Rva2VuX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfZ2V0X25leHRfY2hhciA6IHVuaXQgLT4gY2hhcjtcbiAgICBpY190b2tlbl9idWZmZXIgOiBCdWZmZXIudDtcbiAgICBpY19pbnB1dF9uYW1lIDogaW5fY2hhbm5lbF9uYW1lO1xuICB9XG5cblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgbGV0IG51bGxfY2hhciA9ICdcXDAwMCdcblxuICAoKiBSZWFkcyBhIG5ldyBjaGFyYWN0ZXIgZnJvbSBpbnB1dCBidWZmZXIuXG4gICAgIE5leHRfY2hhciBuZXZlciBmYWlscywgZXZlbiBpbiBjYXNlIG9mIGVuZCBvZiBpbnB1dDpcbiAgICAgaXQgdGhlbiBzaW1wbHkgc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uLiAqKVxuICBsZXQgbmV4dF9jaGFyIGliID1cbiAgICB0cnlcbiAgICAgIGxldCBjID0gaWIuaWNfZ2V0X25leHRfY2hhciAoKSBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gdHJ1ZTtcbiAgICAgIGliLmljX2NoYXJfY291bnQgPC0gc3VjYyBpYi5pY19jaGFyX2NvdW50O1xuICAgICAgaWYgYyA9ICdcXG4nIHRoZW4gaWIuaWNfbGluZV9jb3VudCA8LSBzdWNjIGliLmljX2xpbmVfY291bnQ7XG4gICAgICBjIHdpdGhcbiAgICB8IEVuZF9vZl9maWxlIC0+XG4gICAgICBsZXQgYyA9IG51bGxfY2hhciBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2U7XG4gICAgICBpYi5pY19lb2YgPC0gdHJ1ZTtcbiAgICAgIGNcblxuXG4gIGxldCBwZWVrX2NoYXIgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY3VycmVudF9jaGFyXG4gICAgZWxzZSBuZXh0X2NoYXIgaWJcblxuXG4gICgqIFJldHVybnMgYSB2YWxpZCBjdXJyZW50IGNoYXIgZm9yIHRoZSBpbnB1dCBidWZmZXIuIEluIHBhcnRpY3VsYXJcbiAgICAgbm8gaXJyZWxldmFudCBudWxsIGNoYXJhY3RlciAoYXMgc2V0IGJ5IFtuZXh0X2NoYXJdIGluIGNhc2Ugb2YgZW5kXG4gICAgIG9mIGlucHV0KSBpcyByZXR1cm5lZCwgc2luY2UgW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlblxuICAgICBbbmV4dF9jaGFyXSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24gd2hpbGUgdHJ5aW5nIHRvIHJlYWQgYVxuICAgICBuZXcgY2hhcmFjdGVyLiAqKVxuICBsZXQgY2hlY2tlZF9wZWVrX2NoYXIgaWIgPVxuICAgIGxldCBjID0gcGVla19jaGFyIGliIGluXG4gICAgaWYgaWIuaWNfZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICAgY1xuXG5cbiAgbGV0IGVuZF9vZl9pbnB1dCBpYiA9XG4gICAgaWdub3JlIChwZWVrX2NoYXIgaWIpO1xuICAgIGliLmljX2VvZlxuXG5cbiAgbGV0IGVvZiBpYiA9IGliLmljX2VvZlxuXG4gIGxldCBiZWdpbm5pbmdfb2ZfaW5wdXQgaWIgPSBpYi5pY19jaGFyX2NvdW50ID0gMFxuXG4gIGxldCBuYW1lX29mX2lucHV0IGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBfaWMgLT4gXCJ1bm5hbWVkIFBlcnZhc2l2ZXMgaW5wdXQgY2hhbm5lbFwiXG4gICAgfCBGcm9tX2ZpbGUgKGZuYW1lLCBfaWMpIC0+IGZuYW1lXG4gICAgfCBGcm9tX2Z1bmN0aW9uIC0+IFwidW5uYW1lZCBmdW5jdGlvblwiXG4gICAgfCBGcm9tX3N0cmluZyAtPiBcInVubmFtZWQgY2hhcmFjdGVyIHN0cmluZ1wiXG5cblxuICBsZXQgY2hhcl9jb3VudCBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jaGFyX2NvdW50IC0gMVxuICAgIGVsc2UgaWIuaWNfY2hhcl9jb3VudFxuXG5cbiAgbGV0IGxpbmVfY291bnQgaWIgPSBpYi5pY19saW5lX2NvdW50XG5cbiAgbGV0IHJlc2V0X3Rva2VuIGliID0gQnVmZmVyLnJlc2V0IGliLmljX3Rva2VuX2J1ZmZlclxuXG4gIGxldCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiA9IGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZVxuXG4gIGxldCB0b2tlbiBpYiA9XG4gICAgbGV0IHRva2VuX2J1ZmZlciA9IGliLmljX3Rva2VuX2J1ZmZlciBpblxuICAgIGxldCB0b2sgPSBCdWZmZXIuY29udGVudHMgdG9rZW5fYnVmZmVyIGluXG4gICAgQnVmZmVyLmNsZWFyIHRva2VuX2J1ZmZlcjtcbiAgICBpYi5pY190b2tlbl9jb3VudCA8LSBzdWNjIGliLmljX3Rva2VuX2NvdW50O1xuICAgIHRva1xuXG5cbiAgbGV0IHRva2VuX2NvdW50IGliID0gaWIuaWNfdG9rZW5fY291bnRcblxuICBsZXQgc2tpcF9jaGFyIHdpZHRoIGliID1cbiAgICBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjtcbiAgICB3aWR0aFxuXG5cbiAgbGV0IGlnbm9yZV9jaGFyIHdpZHRoIGliID0gc2tpcF9jaGFyICh3aWR0aCAtIDEpIGliXG5cbiAgbGV0IHN0b3JlX2NoYXIgd2lkdGggaWIgYyA9XG4gICAgQnVmZmVyLmFkZF9jaGFyIGliLmljX3Rva2VuX2J1ZmZlciBjO1xuICAgIGlnbm9yZV9jaGFyIHdpZHRoIGliXG5cblxuICBsZXQgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSA9IDEwMjRcblxuICBsZXQgY3JlYXRlIGluYW1lIG5leHQgPSB7XG4gICAgaWNfZW9mID0gZmFsc2U7XG4gICAgaWNfY3VycmVudF9jaGFyID0gbnVsbF9jaGFyO1xuICAgIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA9IGZhbHNlO1xuICAgIGljX2NoYXJfY291bnQgPSAwO1xuICAgIGljX2xpbmVfY291bnQgPSAwO1xuICAgIGljX3Rva2VuX2NvdW50ID0gMDtcbiAgICBpY19nZXRfbmV4dF9jaGFyID0gbmV4dDtcbiAgICBpY190b2tlbl9idWZmZXIgPSBCdWZmZXIuY3JlYXRlIGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemU7XG4gICAgaWNfaW5wdXRfbmFtZSA9IGluYW1lO1xuICB9XG5cblxuICBsZXQgZnJvbV9zdHJpbmcgcyA9XG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA+PSBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlXG4gICAgICBsZXQgYyA9IHMuWyFpXSBpblxuICAgICAgaW5jciBpO1xuICAgICAgYyBpblxuICAgIGNyZWF0ZSBGcm9tX3N0cmluZyBuZXh0XG5cblxuICBsZXQgZnJvbV9mdW5jdGlvbiA9IGNyZWF0ZSBGcm9tX2Z1bmN0aW9uXG5cbiAgKCogU2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsLiAqKVxuXG4gICgqIFBvc2l0aW9uIG9mIHRoZSBwcm9ibGVtOlxuXG4gICAgIFdlIGNhbm5vdCBwcmV2ZW50IHRoZSBzY2FubmluZyBtZWNoYW5pc20gdG8gdXNlIG9uZSBsb29rYWhlYWQgY2hhcmFjdGVyLFxuICAgICBpZiBuZWVkZWQgYnkgdGhlIHNlbWFudGljcyBvZiB0aGUgZm9ybWF0IHN0cmluZyBzcGVjaWZpY2F0aW9ucyAoZS5nLiBhXG4gICAgIHRyYWlsaW5nICdza2lwIHNwYWNlJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBmb3JtYXQgc3RyaW5nKTsgaW4gdGhpcyBjYXNlLFxuICAgICB0aGUgbWFuZGF0b3J5IGxvb2thaGVhZCBjaGFyYWN0ZXIgaXMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgaW5wdXQgYW5kIG5vdFxuICAgICB1c2VkIHRvIHJldHVybiB0aGUgdG9rZW4gcmVhZC4gSXQgaXMgdGh1cyBtYW5kYXRvcnkgdG8gYmUgYWJsZSB0byBzdG9yZVxuICAgICBhbiB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBzb21ld2hlcmUgdG8gZ2V0IGl0IGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgb2YgdGhlIG5leHQgc2Nhbi5cblxuICAgICBUbyBjaXJjdW12ZW50IHRoaXMgcHJvYmxlbSwgYWxsIHRoZSBzY2FubmluZyBmdW5jdGlvbnMgZ2V0IGEgbG93IGxldmVsXG4gICAgIGlucHV0IGJ1ZmZlciBhcmd1bWVudCB3aGVyZSB0aGV5IHN0b3JlIHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyIHdoZW5cbiAgICAgbmVlZGVkOyBhZGRpdGlvbmFsbHksIHRoZSBpbnB1dCBidWZmZXIgaXMgdGhlIG9ubHkgc291cmNlIG9mIGNoYXJhY3RlciBvZlxuICAgICBhIHNjYW5uZXIuIFRoZSBbc2NhbmJ1Zl0gaW5wdXQgYnVmZmVycyBhcmUgZGVmaW5lZCBpbiBtb2R1bGUgeyFTY2FubmluZ30uXG5cbiAgICAgTm93IHdlIHVuZGVyc3RhbmQgdGhhdCBpdCBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRoYXQgcmVsYXRlZCBhbmRcbiAgICAgc3VjY2Vzc2l2ZSBjYWxscyB0byBzY2FubmVycyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBzYW1lIGlucHV0IGJ1ZmZlci5cbiAgICAgSW4gZWZmZWN0LCBpZiBhIHNjYW5uZXIgW3NjYW4xXSBpcyByZWFkaW5nIGZyb20gW2liMV0gYW5kIHN0b3JlcyBhblxuICAgICB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBbYzFdIGludG8gaXRzIGlucHV0IGJ1ZmZlciBbaWIxXSwgdGhlblxuICAgICBhbm90aGVyIHNjYW5uZXIgW3NjYW4yXSBub3QgcmVhZGluZyBmcm9tIHRoZSBzYW1lIGJ1ZmZlciBbaWIxXSB3aWxsIG1pc3NcbiAgICAgdGhlIGNoYXJhY3RlciBbYzFdLCBzZWVtaW5nbHkgdmFuaXNoZWQgaW4gdGhlIGFpciBmcm9tIHRoZSBwb2ludCBvZiB2aWV3XG4gICAgIG9mIFtzY2FuMl0uXG5cbiAgICAgVGhpcyBtZWNoYW5pc20gd29ya3MgcGVyZmVjdGx5IHRvIHJlYWQgZnJvbSBzdHJpbmdzLCBmcm9tIGZpbGVzLCBhbmQgZnJvbVxuICAgICBmdW5jdGlvbnMsIHNpbmNlIGluIHRob3NlIGNhc2VzLCBhbGxvY2F0aW5nIHR3byBidWZmZXJzIHJlYWRpbmcgZnJvbSB0aGVcbiAgICAgc2FtZSBzb3VyY2UgaXMgdW5uYXR1cmFsLlxuXG4gICAgIFN0aWxsLCB0aGVyZSBpcyBhIGRpZmZpY3VsdHkgaW4gdGhlIGNhc2Ugb2Ygc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dFxuICAgICBjaGFubmVsLiBJbiBlZmZlY3QsIHdoZW4gc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsIFtpY10sIHRoaXMgY2hhbm5lbFxuICAgICBtYXkgbm90IGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB3aXRoaW4gdGhpcyBsaWJyYXJ5LiBIZW5jZSwgaXQgbWF5IGJlXG4gICAgIHNoYXJlZCAodHdvIGZ1bmN0aW9ucyBvZiB0aGUgdXNlcidzIHByb2dyYW0gbWF5IHN1Y2Nlc3NpdmVseSByZWFkIGZyb21cbiAgICAgW2ljXSkuIFRoaXMgaXMgaGlnaGx5IGVycm9yIHByb25lIHNpbmNlLCBvbmUgb2YgdGhlIGZ1bmN0aW9uIG1heSBzZWVrIHRoZVxuICAgICBpbnB1dCBjaGFubmVsLCB3aGlsZSB0aGUgb3RoZXIgZnVuY3Rpb24gaGFzIHN0aWxsIGFuIHVudXNlZCBsb29rYWhlYWRcbiAgICAgY2hhcmFjdGVyIGluIGl0cyBpbnB1dCBidWZmZXIuIEluIGNvbmNsdXNpb24sIHlvdSBzaG91bGQgbmV2ZXIgbWl4IGRpcmVjdFxuICAgICBsb3cgbGV2ZWwgcmVhZGluZyBhbmQgaGlnaCBsZXZlbCBzY2FubmluZyBmcm9tIHRoZSBzYW1lIGlucHV0IGNoYW5uZWwuXG5cbiAgKilcblxuICAoKiBQZXJmb3JtIGJ1ZmZlcml6ZWQgaW5wdXQgdG8gaW1wcm92ZSBlZmZpY2llbmN5LiAqKVxuICBsZXQgZmlsZV9idWZmZXJfc2l6ZSA9IHJlZiAxMDI0XG5cbiAgKCogVGhlIHNjYW5uZXIgY2xvc2VzIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dC4gKilcbiAgbGV0IHNjYW5fY2xvc2VfYXRfZW5kIGljID0gUGVydmFzaXZlcy5jbG9zZV9pbiBpYzsgcmFpc2UgRW5kX29mX2ZpbGVcblxuICAoKiBUaGUgc2Nhbm5lciBkb2VzIG5vdCBjbG9zZSB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IGp1c3QgcmFpc2VzIFtFbmRfb2ZfZmlsZV0uICopXG4gIGxldCBzY2FuX3JhaXNlX2F0X2VuZCBfaWMgPSByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gIGxldCBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgaW5hbWUgaWMgPVxuICAgIGxldCBsZW4gPSAhZmlsZV9idWZmZXJfc2l6ZSBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsaW0gPSByZWYgMCBpblxuICAgIGxldCBlb2YgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA8ICFsaW0gdGhlbiBiZWdpbiBsZXQgYyA9IEJ5dGVzLmdldCBidWYgIWkgaW4gaW5jciBpOyBjIGVuZCBlbHNlXG4gICAgICBpZiAhZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZSBiZWdpblxuICAgICAgICBsaW0gOj0gaW5wdXQgaWMgYnVmIDAgbGVuO1xuICAgICAgICBpZiAhbGltID0gMCB0aGVuIGJlZ2luIGVvZiA6PSB0cnVlOyBzY2FuX2Nsb3NlX2ljIGljIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgaSA6PSAxO1xuICAgICAgICAgIEJ5dGVzLmdldCBidWYgMFxuICAgICAgICBlbmRcbiAgICAgIGVuZCBpblxuICAgIGNyZWF0ZSBpbmFtZSBuZXh0XG5cblxuICBsZXQgZnJvbV9pY19jbG9zZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fY2xvc2VfYXRfZW5kXG4gIGxldCBmcm9tX2ljX3JhaXNlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbUGVydmFzaXZlcy5zdGRpbl0uXG4gICAgIE9uZSBjb3VsZCB0cnkgdG8gZGVmaW5lIFtzdGRpYl0gYXMgYSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBhIGNoYXJhY3RlclxuICAgICBhdCBhIHRpbWUgKG5vIGJ1ZmZlcml6YXRpb24gYXQgYWxsKSwgYnV0IHVuZm9ydHVuYXRlbHkgdGhlIHRvcC1sZXZlbFxuICAgICBpbnRlcmFjdGlvbiB3b3VsZCBiZSB3cm9uZy4gVGhpcyBpcyBkdWUgdG8gc29tZSBraW5kIG9mXG4gICAgICdyYWNlIGNvbmRpdGlvbicgd2hlbiByZWFkaW5nIGZyb20gW1BlcnZhc2l2ZXMuc3RkaW5dLFxuICAgICBzaW5jZSB0aGUgaW50ZXJhY3RpdmUgY29tcGlsZXIgYW5kIFtTY2FuZi5zY2FuZl0gd2lsbCBzaW11bHRhbmVvdXNseVxuICAgICByZWFkIHRoZSBtYXRlcmlhbCB0aGV5IG5lZWQgZnJvbSBbUGVydmFzaXZlcy5zdGRpbl07IHRoZW4sIGNvbmZ1c2lvblxuICAgICB3aWxsIHJlc3VsdCBmcm9tIHdoYXQgc2hvdWxkIGJlIHJlYWQgYnkgdGhlIHRvcC1sZXZlbCBhbmQgd2hhdCBzaG91bGQgYmVcbiAgICAgcmVhZCBieSBbU2NhbmYuc2NhbmZdLlxuICAgICBUaGlzIGlzIGV2ZW4gbW9yZSBjb21wbGljYXRlZCBieSB0aGUgb25lIGNoYXJhY3RlciBsb29rYWhlYWQgdGhhdFxuICAgICBbU2NhbmYuc2NhbmZdIGlzIHNvbWV0aW1lcyBvYmxpZ2VkIHRvIG1haW50YWluOiB0aGUgbG9va2FoZWFkIGNoYXJhY3RlclxuICAgICB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgdGhlIG5leHQgW1NjYW5mLnNjYW5mXSBlbnRyeSwgc2VlbWluZ2x5IGNvbWluZyBmcm9tXG4gICAgIG5vd2hlcmUuXG4gICAgIEFsc28gbm8gW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlbiByZWFkaW5nIGZyb20gc3RkaW46IGlmIG5vdCBlbm91Z2hcbiAgICAgY2hhcmFjdGVycyBoYXZlIGJlZW4gcmVhZCwgd2Ugc2ltcGx5IGFzayB0byByZWFkIG1vcmUuICopXG4gIGxldCBzdGRpbiA9XG4gICAgZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuICAgICAgKEZyb21fZmlsZSAoXCItXCIsIFBlcnZhc2l2ZXMuc3RkaW4pKSBQZXJ2YXNpdmVzLnN0ZGluXG5cblxuICBsZXQgc3RkaWIgPSBzdGRpblxuXG4gIGxldCBvcGVuX2luX2ZpbGUgb3Blbl9pbiBmbmFtZSA9XG4gICAgbWF0Y2ggZm5hbWUgd2l0aFxuICAgIHwgXCItXCIgLT4gc3RkaW5cbiAgICB8IGZuYW1lIC0+XG4gICAgICBsZXQgaWMgPSBvcGVuX2luIGZuYW1lIGluXG4gICAgICBmcm9tX2ljX2Nsb3NlX2F0X2VuZCAoRnJvbV9maWxlIChmbmFtZSwgaWMpKSBpY1xuXG5cbiAgbGV0IG9wZW5faW4gPSBvcGVuX2luX2ZpbGUgUGVydmFzaXZlcy5vcGVuX2luXG4gIGxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fZmlsZSBQZXJ2YXNpdmVzLm9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fZmlsZSA9IG9wZW5faW5cbiAgbGV0IGZyb21fZmlsZV9iaW4gPSBvcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2NoYW5uZWwgaWMgPVxuICAgIGZyb21faWNfcmFpc2VfYXRfZW5kIChGcm9tX2NoYW5uZWwgaWMpIGljXG5cblxuICBsZXQgY2xvc2VfaW4gaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIGljIC0+XG4gICAgICBQZXJ2YXNpdmVzLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2ZpbGUgKF9mbmFtZSwgaWMpIC0+IFBlcnZhc2l2ZXMuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZnVuY3Rpb24gfCBGcm9tX3N0cmluZyAtPiAoKVxuXG5cbiAgKCpcbiAgICAgT2Jzb2xldGU6IGEgbWVtbyBbZnJvbV9jaGFubmVsXSB2ZXJzaW9uIHRvIGJ1aWxkIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdXG4gICAgIHNjYW5uaW5nIGJ1ZmZlciBvdXQgb2YgYSBbUGVydmFzaXZlcy5pbl9jaGFubmVsXS5cbiAgICAgVGhpcyBmdW5jdGlvbiB3YXMgdXNlZCB0byB0cnkgdG8gcHJlc2VydmUgdGhlIHNjYW5uaW5nXG4gICAgIHNlbWFudGljcyBmb3IgdGhlIChub3cgb2Jzb2xldGUpIGZ1bmN0aW9uIFtmc2NhbmZdLlxuICAgICBHaXZlbiB0aGF0IGFsbCBzY2FubmVyIG11c3QgcmVhZCBmcm9tIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIHNjYW5uaW5nXG4gICAgIGJ1ZmZlciwgW2ZzY2FuZl0gbXVzdCByZWFkIGZyb20gb25lIVxuICAgICBNb3JlIHByZWNpc2VseSwgZ2l2ZW4gW2ljXSwgYWxsIHN1Y2Nlc3NpdmUgY2FsbHMgW2ZzY2FuZiBpY10gbXVzdCByZWFkXG4gICAgIGZyb20gdGhlIHNhbWUgc2Nhbm5pbmcgYnVmZmVyLlxuICAgICBUaGlzIG9ibGlnZWQgdGhpcyBsaWJyYXJ5IHRvIGFsbG9jYXRlZCBzY2FubmluZyBidWZmZXJzIHRoYXQgd2VyZVxuICAgICBub3QgcHJvcGVybHkgZ2FyYmFnZSBjb2xsZWN0YWJsZSwgaGVuY2UgbGVhZGluZyB0byBtZW1vcnkgbGVha3MuXG4gICAgIElmIHlvdSBuZWVkIHRvIHJlYWQgZnJvbSBhIFtQZXJ2YXNpdmVzLmluX2NoYW5uZWxdIGlucHV0IGNoYW5uZWxcbiAgICAgW2ljXSwgc2ltcGx5IGRlZmluZSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBmb3JtYXR0ZWQgaW5wdXQgY2hhbm5lbCBhcyBpblxuICAgICBbbGV0IGliID0gU2Nhbm5pbmcuZnJvbV9jaGFubmVsIGljXSwgdGhlbiB1c2UgW1NjYW5mLmJzY2FuZiBpYl0gYXMgdXN1YWwuXG4gICopXG4gIGxldCBtZW1vX2Zyb21faWMgPVxuICAgIGxldCBtZW1vID0gcmVmIFtdIGluXG4gICAgKGZ1biBzY2FuX2Nsb3NlX2ljIGljIC0+XG4gICAgIHRyeSBMaXN0LmFzc3EgaWMgIW1lbW8gd2l0aFxuICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgIGxldCBpYiA9XG4gICAgICAgICBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgKEZyb21fY2hhbm5lbCBpYykgaWMgaW5cbiAgICAgICBtZW1vIDo9IChpYywgaWIpIDo6ICFtZW1vO1xuICAgICAgIGliKVxuXG5cbiAgKCogT2Jzb2xldGU6IHNlZSB7IW1lbW9fZnJvbV9pY30gYWJvdmUuICopXG4gIGxldCBtZW1vX2Zyb21fY2hhbm5lbCA9IG1lbW9fZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG5lbmRcblxuXG4oKiBGb3JtYXR0ZWQgaW5wdXQgZnVuY3Rpb25zLiAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgc2Nhbm5lciA9XG4gICAgICgnYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgJ2IsICdjLCAnYSAtPiAnZCwgJ2QpIGZvcm1hdDYgLT4gJ2NcblxuXG4oKiBSZXBvcnRpbmcgZXJyb3JzLiAqKVxuZXhjZXB0aW9uIFNjYW5fZmFpbHVyZSBvZiBzdHJpbmdcblxubGV0IGJhZF9pbnB1dCBzID0gcmFpc2UgKFNjYW5fZmFpbHVyZSBzKVxuXG5sZXQgYmFkX2lucHV0X2VzY2FwZSBjID1cbiAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImlsbGVnYWwgZXNjYXBlIGNoYXJhY3RlciAlQ1wiIGMpXG5cblxubGV0IGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICB0aGUgc3BlY2lmaWVkIGxlbmd0aCB3YXMgdG9vIHNob3J0IGZvciB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHByZW1hdHVyZSBlbmQgb2YgZmlsZSBvY2N1cnJlZCBiZWZvcmUgZW5kIG9mIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJubyBkb3Qgb3IgZXhwb25lbnQgcGFydCBmb3VuZCBpbiBmbG9hdCB0b2tlblwiXG5cblxubGV0IGJhZF9oZXhfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJub3QgYSB2YWxpZCBmbG9hdCBpbiBoZXhhZGVjaW1hbCBub3RhdGlvblwiXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSA9XG4gIFByaW50Zi5zcHJpbnRmIFwibG9va2luZyBmb3IgJUMsIGZvdW5kICVDXCIgYyBjaVxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaSA9XG4gIGJhZF9pbnB1dCAoY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpKVxuXG5cbmxldCByZWMgc2tpcF93aGl0ZXMgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlbiBiZWdpblxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+XG4gICAgICBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgc2tpcF93aGl0ZXMgaWJcbiAgICB8IF8gLT4gKClcbiAgZW5kXG5cblxuKCogQ2hlY2tpbmcgdGhhdCBbY10gaXMgaW5kZWVkIGluIHRoZSBpbnB1dCwgdGhlbiBza2lwcyBpdC5cbiAgIEluIHRoaXMgY2FzZSwgdGhlIGNoYXJhY3RlciBbY10gaGFzIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlXG4gICBmb3JtYXQgYXMgYmVpbmcgbWFuZGF0b3J5IGluIHRoZSBpbnB1dDsgaGVuY2Ugd2Ugc2hvdWxkIGZhaWwgd2l0aFxuICAgW0VuZF9vZl9maWxlXSBpbiBjYXNlIG9mIGVuZF9vZl9pbnB1dC5cbiAgIChSZW1lbWJlciB0aGF0IFtTY2FuX2ZhaWx1cmVdIGlzIHJhaXNlZCBvbmx5IHdoZW4gKHdlIGNhbiBwcm92ZSBieVxuICAgZXZpZGVuY2UpIHRoYXQgdGhlIGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBmb3JtYXQgc3RyaW5nIGdpdmVuLiBXZSBtdXN0XG4gICB0aHVzIGRpZmZlcmVudGlhdGUgW0VuZF9vZl9maWxlXSBhcyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBpbnB1dCwgYW5kXG4gICBbU2Nhbl9mYWlsdXJlXSB3aGljaCBpcyBkdWUgdG8gcHJvdmFibHkgd3JvbmcgaW5wdXQuIEkgYW0gbm90IHN1cmUgdGhpcyBpc1xuICAgd29ydGggdGhlIGJ1cmRlbjogaXQgaXMgY29tcGxleCBhbmQgc29tZWhvdyBzdWJsaW1pbmFsOyBzaG91bGQgYmUgY2xlYXJlclxuICAgdG8gZmFpbCB3aXRoIFNjYW5fZmFpbHVyZSBcIk5vdCBlbm91Z2ggaW5wdXQgdG8gY29tcGxldGUgc2Nhbm5pbmdcIiEpXG5cbiAgIFRoYXQncyB3aHksIHdhaXRpbmcgZm9yIGEgYmV0dGVyIHNvbHV0aW9uLCB3ZSB1c2UgY2hlY2tlZF9wZWVrX2NoYXIgaGVyZS5cbiAgIFdlIGFyZSBhbHNvIGNhcmVmdWwgdG8gdHJlYXQgXCJcXHJcXG5cIiBpbiB0aGUgaW5wdXQgYXMgYW4gZW5kIG9mIGxpbmUgbWFya2VyOlxuICAgaXQgYWx3YXlzIG1hdGNoZXMgYSAnXFxuJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBpbnB1dCBmb3JtYXQgc3RyaW5nLiAqKVxubGV0IHJlYyBjaGVja19jaGFyIGliIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnICcgLT4gc2tpcF93aGl0ZXMgaWJcbiAgfCAnXFxuJyAtPiBjaGVja19uZXdsaW5lIGliXG4gIHwgYyAtPiBjaGVja190aGlzX2NoYXIgaWIgY1xuXG5hbmQgY2hlY2tfdGhpc19jaGFyIGliIGMgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBjaSA9IGMgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiBlbHNlXG4gIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cbmFuZCBjaGVja19uZXdsaW5lIGliID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggY2kgd2l0aFxuICB8ICdcXG4nIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gIHwgJ1xccicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IGNoZWNrX3RoaXNfY2hhciBpYiAnXFxuJ1xuICB8IF8gLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXG4nIGNpXG5cblxuKCogRXh0cmFjdGluZyB0b2tlbnMgZnJvbSB0aGUgb3V0cHV0IHRva2VuIGJ1ZmZlci4gKilcblxubGV0IHRva2VuX2NoYXIgaWIgPSAoU2Nhbm5pbmcudG9rZW4gaWIpLlswXVxuXG5sZXQgdG9rZW5fc3RyaW5nID0gU2Nhbm5pbmcudG9rZW5cblxubGV0IHRva2VuX2Jvb2wgaWIgPVxuICBtYXRjaCBTY2FubmluZy50b2tlbiBpYiB3aXRoXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IHMgLT4gYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImludmFsaWQgYm9vbGVhbiAnJXMnXCIgcylcblxuXG4oKiBUaGUgdHlwZSBvZiBpbnRlZ2VyIGNvbnZlcnNpb25zLiAqKVxudHlwZSBpbnRlZ2VyX2NvbnZlcnNpb24gPVxuICB8IEJfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBiaW5hcnkgY29udmVyc2lvbiAqKVxuICB8IERfY29udmVyc2lvbiAoKiBTaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgSV9jb252ZXJzaW9uICgqIFNpZ25lZCBpbnRlZ2VyIGNvbnZlcnNpb24gKilcbiAgfCBPX2NvbnZlcnNpb24gKCogVW5zaWduZWQgb2N0YWwgY29udmVyc2lvbiAqKVxuICB8IFVfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBYX2NvbnZlcnNpb24gKCogVW5zaWduZWQgaGV4YWRlY2ltYWwgY29udmVyc2lvbiAqKVxuXG5cbmxldCBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ2InIC0+IEJfY29udmVyc2lvblxuICB8ICdkJyAtPiBEX2NvbnZlcnNpb25cbiAgfCAnaScgLT4gSV9jb252ZXJzaW9uXG4gIHwgJ28nIC0+IE9fY29udmVyc2lvblxuICB8ICd1JyAtPiBVX2NvbnZlcnNpb25cbiAgfCAneCcgfCAnWCcgLT4gWF9jb252ZXJzaW9uXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuXG4oKiBFeHRyYWN0IGFuIGludGVnZXIgbGl0ZXJhbCB0b2tlbi5cbiAgIFNpbmNlIHRoZSBmdW5jdGlvbnMgUGVydmFzaXZlcy4qaW50Kl9vZl9zdHJpbmcgZG8gbm90IGFjY2VwdCBhIGxlYWRpbmcgKyxcbiAgIHdlIHNraXAgaXQgaWYgbmVjZXNzYXJ5LiAqKVxubGV0IHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIgPVxuICBsZXQgdG9rID1cbiAgICBtYXRjaCBjb252IHdpdGhcbiAgICB8IERfY29udmVyc2lvbiB8IElfY29udmVyc2lvbiAtPiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgVV9jb252ZXJzaW9uIC0+IFwiMHVcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBPX2NvbnZlcnNpb24gLT4gXCIwb1wiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFhfY29udmVyc2lvbiAtPiBcIjB4XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgQl9jb252ZXJzaW9uIC0+IFwiMGJcIiBeIFNjYW5uaW5nLnRva2VuIGliIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCB0b2sgaW5cbiAgaWYgbCA9IDAgfHwgdG9rLlswXSA8PiAnKycgdGhlbiB0b2sgZWxzZSBTdHJpbmcuc3ViIHRvayAxIChsIC0gMSlcblxuXG4oKiBBbGwgdGhlIGZ1bmN0aW9ucyB0aGF0IGNvbnZlcnQgYSBzdHJpbmcgdG8gYSBudW1iZXIgcmFpc2UgdGhlIGV4Y2VwdGlvblxuICAgRmFpbHVyZSB3aGVuIHRoZSBjb252ZXJzaW9uIGlzIG5vdCBwb3NzaWJsZS5cbiAgIFRoaXMgZXhjZXB0aW9uIGlzIHRoZW4gdHJhcHBlZCBpbiBba3NjYW5mXS4gKilcbmxldCB0b2tlbl9pbnQgY29udiBpYiA9IGludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbmxldCB0b2tlbl9mbG9hdCBpYiA9IGZsb2F0X29mX3N0cmluZyAoU2Nhbm5pbmcudG9rZW4gaWIpXG5cbigqIFRvIHNjYW4gbmF0aXZlIGludHMsIGludDMyIGFuZCBpbnQ2NCBpbnRlZ2Vycy5cbiAgIFdlIGNhbm5vdCBhY2Nlc3MgdG8gY29udmVyc2lvbnMgdG8vZnJvbSBzdHJpbmdzIGZvciB0aG9zZSB0eXBlcyxcbiAgIE5hdGl2ZWludC5vZl9zdHJpbmcsIEludDMyLm9mX3N0cmluZywgYW5kIEludDY0Lm9mX3N0cmluZyxcbiAgIHNpbmNlIHRob3NlIG1vZHVsZXMgYXJlIG5vdCBhdmFpbGFibGUgdG8gW1NjYW5mXS5cbiAgIEhvd2V2ZXIsIHdlIGNhbiBiaW5kIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmcgcHJpbWl0aXZlcyB0aGF0IGFyZVxuICAgYXZhaWxhYmxlIGluIHRoZSBydW50aW1lLiAqKVxuZXh0ZXJuYWwgbmF0aXZlaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDMyX29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQ2NF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxuXG5sZXQgdG9rZW5fbmF0aXZlaW50IGNvbnYgaWIgPSBuYXRpdmVpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDMyIGNvbnYgaWIgPSBpbnQzMl9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50NjQgY29udiBpYiA9IGludDY0X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxuKCogU2Nhbm5pbmcgbnVtYmVycy4gKilcblxuKCogRGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzdXBwb3NlIHRoYXQgb25lIGNoYXJhY3RlciBoYXMgYmVlbiBjaGVja2VkIGFuZFxuICAgaXMgYXZhaWxhYmxlLCBzaW5jZSB0aGV5IHJldHVybiBhdCBlbmQgb2YgZmlsZSB3aXRoIHRoZSBjdXJyZW50bHkgZm91bmRcbiAgIHRva2VuIHNlbGVjdGVkLlxuXG4gICBQdXQgaXQgaW4gYW5vdGhlciB3YXksIHRoZSBkaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHNjYW4gZm9yIGEgcG9zc2libHlcbiAgIGVtcHR5IHNlcXVlbmNlIG9mIGRpZ2l0cywgKGhlbmNlLCBhIHN1Y2Nlc3NmdWwgc2Nhbm5pbmcgZnJvbSBvbmUgb2YgdGhvc2VcbiAgIGZ1bmN0aW9ucyBkb2VzIG5vdCBpbXBseSB0aGF0IHRoZSB0b2tlbiBpcyBhIHdlbGwtZm9ybWVkIG51bWJlcjogdG8gZ2V0IGFcbiAgIHRydWUgbnVtYmVyLCBpdCBpcyBtYW5kYXRvcnkgdG8gY2hlY2sgdGhhdCBhdCBsZWFzdCBvbmUgdmFsaWQgZGlnaXQgaXNcbiAgIGF2YWlsYWJsZSBiZWZvcmUgY2FsbGluZyBvbmUgb2YgdGhlIGRpZ2l0IHNjYW5uaW5nIGZ1bmN0aW9ucykuICopXG5cbigqIFRoZSBkZWNpbWFsIGNhc2UgaXMgdHJlYXRlZCBlc3BlY2lhbGx5IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuICopXG5sZXQgcmVjIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgJ18nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXMgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGVjaW1hbCBkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgZGVjaW1hbCBkaWdpdFwiIGMpXG5cblxuKCogVG8gc2NhbiBudW1iZXJzIGZyb20gb3RoZXIgYmFzZXMsIHdlIHVzZSBhIHByZWRpY2F0ZSBhcmd1bWVudCB0b1xuICAgc2NhbiBkaWdpdHMuICopXG5sZXQgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9kaWdpdHMgd2lkdGggaWIgPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8IGMgd2hlbiBkaWdpdHAgYyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgJ18nIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8IF8gLT4gd2lkdGggaW5cbiAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9kaWdpdF9wbHVzIGJhc2lzIGRpZ2l0cCB3aWR0aCBpYiA9XG4gICgqIEVuc3VyZSB3ZSBoYXZlIGdvdCBlbm91Z2ggd2lkdGggbGVmdCxcbiAgICAgYW5kIHJlYWQgYXQgbGVhc3Qgb25lIGRpZ2l0LiAqKVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGRpZ2l0cCBjIHRoZW5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliXG4gIGVsc2VcbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIHZhbGlkICVzIGRpZ2l0XCIgYyBiYXNpcylcblxuXG5sZXQgaXNfYmluYXJ5X2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzEnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fYmluYXJ5X2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImJpbmFyeVwiIGlzX2JpbmFyeV9kaWdpdFxuXG5sZXQgaXNfb2N0YWxfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnNycgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9vY3RhbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJvY3RhbFwiIGlzX29jdGFsX2RpZ2l0XG5cbmxldCBpc19oZXhhX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9oZXhhZGVjaW1hbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJoZXhhZGVjaW1hbFwiIGlzX2hleGFfZGlnaXRcblxuKCogU2NhbiBhIGRlY2ltYWwgaW50ZWdlci4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50ID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXNcblxubGV0IHNjYW5fc2lnbiB3aWR0aCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJysnIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8ICctJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW4gYW4gdW5zaWduZWQgaW50ZWdlciB0aGF0IGNvdWxkIGJlIGdpdmVuIGluIGFueSAoY29tbW9uKSBiYXNpcy5cbiAgIElmIGRpZ2l0cyBhcmUgcHJlZml4ZWQgYnkgb25lIG9mIDB4LCAwWCwgMG8sIG9yIDBiLCB0aGUgbnVtYmVyIGlzXG4gICBhc3N1bWVkIHRvIGJlIHdyaXR0ZW4gcmVzcGVjdGl2ZWx5IGluIGhleGFkZWNpbWFsLCBoZXhhZGVjaW1hbCxcbiAgIG9jdGFsLCBvciBiaW5hcnkuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgYmVnaW4gbWF0Y2ggYyB3aXRoXG4gICAgfCAneCcgfCAnWCcgLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdvJyAtPiBzY2FuX29jdGFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ2InIC0+IHNjYW5fYmluYXJ5X2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgXyAtPiBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBlbmRcbiAgfCBfIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9pbnRfY29udmVyc2lvbiBjb252IHdpZHRoIGliID1cbiAgbWF0Y2ggY29udiB3aXRoXG4gIHwgQl9jb252ZXJzaW9uIC0+IHNjYW5fYmluYXJ5X2ludCB3aWR0aCBpYlxuICB8IERfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgSV9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliXG4gIHwgT19jb252ZXJzaW9uIC0+IHNjYW5fb2N0YWxfaW50IHdpZHRoIGliXG4gIHwgVV9jb252ZXJzaW9uIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBYX2NvbnZlcnNpb24gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FubmluZyBmbG9hdGluZyBwb2ludCBudW1iZXJzLiAqKVxuXG4oKiBGcmFjdGlvbmFsIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIEV4cCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJ2UnIHwgJ0UnIGFzIGMgLT5cbiAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIFNjYW4gdGhlIGludGVnZXIgcGFydCBvZiBhIGZsb2F0aW5nIHBvaW50IG51bWJlciwgKG5vdCB1c2luZyB0aGVcbiAgIE9DYW1sIGxleGljYWwgY29udmVudGlvbiBzaW5jZSB0aGUgaW50ZWdlciBwYXJ0IGNhbiBiZSBlbXB0eSk6XG4gICBhbiBvcHRpb25hbCBzaWduLCBmb2xsb3dlZCBieSBhIHBvc3NpYmx5IGVtcHR5IHNlcXVlbmNlIG9mIGRlY2ltYWxcbiAgIGRpZ2l0cyAoZS5nLiAtLjEpLiAqKVxubGV0IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG5cblxuKCpcbiAgIEZvciB0aGUgdGltZSBiZWluZyB3ZSBoYXZlIChhcyBmb3VuZCBpbiBzY2FuZi5tbGkpOlxuICAgdGhlIGZpZWxkIHdpZHRoIGlzIGNvbXBvc2VkIG9mIGFuIG9wdGlvbmFsIGludGVnZXIgbGl0ZXJhbFxuICAgaW5kaWNhdGluZyB0aGUgbWF4aW1hbCB3aWR0aCBvZiB0aGUgdG9rZW4gdG8gcmVhZC5cbiAgIFVuZm9ydHVuYXRlbHksIHRoZSB0eXBlLWNoZWNrZXIgbGV0IHRoZSB1c2VyIHdyaXRlIGFuIG9wdGlvbmFsIHByZWNpc2lvbixcbiAgIHNpbmNlIHRoaXMgaXMgdmFsaWQgZm9yIHByaW50ZiBmb3JtYXQgc3RyaW5ncy5cblxuICAgVGh1cywgdGhlIG5leHQgc3RlcCBmb3IgU2NhbmYgaXMgdG8gc3VwcG9ydCBhIGZ1bGwgd2lkdGggYW5kIHByZWNpc2lvblxuICAgaW5kaWNhdGlvbiwgbW9yZSBvciBsZXNzIHNpbWlsYXIgdG8gdGhlIG9uZSBmb3IgcHJpbnRmLCBwb3NzaWJseSBleHRlbmRlZFxuICAgdG8gdGhlIHNwZWNpZmljYXRpb24gb2YgYSBbbWF4LCBtaW5dIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWRcbiAgIGZvciBzdHJpbmdzLiBTb21ldGhpbmcgbGlrZSB0aGUgZm9sbG93aW5nIHNwZWMgZm9yIHNjYW5mLm1saTpcblxuICAgVGhlIG9wdGlvbmFsIFt3aWR0aF0gaXMgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsXG4gICB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC4gRm9yIGluc3RhbmNlLCBbJTZkXSByZWFkcyBhbiBpbnRlZ2VyLFxuICAgaGF2aW5nIGF0IG1vc3QgNiBjaGFyYWN0ZXJzLlxuXG4gICBUaGUgb3B0aW9uYWwgW3ByZWNpc2lvbl0gaXMgYSBkb3QgWy5dIGZvbGxvd2VkIGJ5IGFuIGludGVnZXI6XG5cbiAgIC0gaW4gdGhlIGZsb2F0aW5nIHBvaW50IG51bWJlciBjb252ZXJzaW9ucyAoWyVmXSwgWyVlXSwgWyVnXSwgWyVGXSwgWyVFXSxcbiAgIGFuZCBbJUZdIGNvbnZlcnNpb25zLCB0aGUgW3ByZWNpc2lvbl0gaW5kaWNhdGVzIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuICAgZGlnaXRzIHRoYXQgbWF5IGZvbGxvdyB0aGUgZGVjaW1hbCBwb2ludC4gRm9yIGluc3RhbmNlLCBbJS40Zl0gcmVhZHMgYVxuICAgW2Zsb2F0XSB3aXRoIGF0IG1vc3QgNCBmcmFjdGlvbmFsIGRpZ2l0cyxcblxuICAgLSBpbiB0aGUgc3RyaW5nIGNvbnZlcnNpb25zIChbJXNdLCBbJVNdLCBbJVxcWyByYW5nZSBcXF1dKSwgYW5kIGluIHRoZVxuICAgaW50ZWdlciBudW1iZXIgY29udmVyc2lvbnMgKFslaV0sIFslZF0sIFsldV0sIFsleF0sIFslb10sIGFuZCB0aGVpclxuICAgW2ludDMyXSwgW2ludDY0XSwgYW5kIFtuYXRpdmVfaW50XSBjb3JyZXNwb25kZW50KSwgdGhlIFtwcmVjaXNpb25dXG4gICBpbmRpY2F0ZXMgdGhlIHJlcXVpcmVkIG1pbmltdW0gd2lkdGggb2YgdGhlIHRva2VuIHJlYWQsXG5cbiAgIC0gb24gYWxsIG90aGVyIGNvbnZlcnNpb25zLCB0aGUgd2lkdGggYW5kIHByZWNpc2lvbiBzcGVjaWZ5IHRoZSBbbWF4LCBtaW5dXG4gICByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLlxuKilcbmxldCBzY2FuX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIpIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cbiAgfCBfIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cblxuXG5sZXQgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgZXJyb3Igc3RyID1cbiAgbGV0IGxvd2VyY2FzZSBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICdBJyAuLiAnWicgLT5cbiAgICAgIGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICsgaW50X29mX2NoYXIgJ2EnKVxuICAgIHwgXyAtPiBjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGggPSByZWYgd2lkdGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGxvd2VyY2FzZSBjIDw+IGxvd2VyY2FzZSBzdHIuW2ldIHRoZW4gZXJyb3IgKCk7XG4gICAgaWYgIXdpZHRoID0gMCB0aGVuIGVycm9yICgpO1xuICAgIHdpZHRoIDo9IFNjYW5uaW5nLnN0b3JlX2NoYXIgIXdpZHRoIGliIGM7XG4gIGRvbmU7XG4gICF3aWR0aFxuXG5cbmxldCBzY2FuX2hleF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBsZXQgd2lkdGggPSBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwieFwiIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgICAgKVxuICAgICAgICAgIHwgXyAtPiB3aWR0aCBpblxuICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgICB8IF8gLT4gd2lkdGhcbiAgKVxuICB8ICduJyB8ICdOJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcImFuXCJcbiAgfCAnaScgfCAnSScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJuZmluaXR5XCJcbiAgfCBfIC0+IGJhZF9oZXhfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgKCogVGhlIGVmZmVjdGl2ZSB3aWR0aCBhdmFpbGFibGUgZm9yIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgaXNcbiAgICAgICB0aGUgbWluaW11bSBvZiBkZWNsYXJlZCBwcmVjaXNpb24gYW5kIHdpZHRoIGxlZnQuICopXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAoKiBBZnRlciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHdpdGggW3ByZWNpc2lvbl0gcHJvdmlzaW9uYWwgd2lkdGgsXG4gICAgICAgW3dpZHRoX3ByZWNpc2lvbl0gaXMgbGVmdC4gKilcbiAgICBsZXQgd2lkdGhfcHJlY2lzaW9uID0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliIGluXG4gICAgKCogSGVuY2UsIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgdG9vayBleGFjdGx5XG4gICAgICAgW3ByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbl0gY2hhcnMuICopXG4gICAgbGV0IGZyYWNfd2lkdGggPSBwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb24gaW5cbiAgICAoKiBBbmQgbmV3IHByb3Zpc2lvbmFsIHdpZHRoIGlzIFt3aWR0aCAtIHdpZHRoX3ByZWNpc2lvbi4gKilcbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIGZyYWNfd2lkdGggaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCAnZScgfCAnRScgLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICB8ICd4JyB8ICdYJyBhcyBjIC0+IChcbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgKVxuICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gYmFkX2Zsb2F0ICgpIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICB8IF8gLT4gd2lkdGhcbiAgICApXG4gICAgfCBfIC0+XG4gICAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbiAgKVxuICB8ICcxJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4oKiBTcGVjaWFsIGNhc2Ugb2YgbmFuIGFuZCBpbmZpbml0eTpcbiAgfCAnaScgLT5cbiAgfCAnbicgLT5cbiopXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG4oKiBTY2FuIGEgcmVndWxhciBzdHJpbmc6XG4gICBzdG9wcyB3aGVuIGVuY291bnRlcmluZyBhIHNwYWNlLCBpZiBubyBzY2FubmluZyBpbmRpY2F0aW9uIGhhcyBiZWVuIGdpdmVuO1xuICAgb3RoZXJ3aXNlLCBzdG9wcyB3aGVuIGVuY291bnRlcmluZyB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2Nhbm5pbmdcbiAgIGluZGljYXRpb24gW3N0cF0uXG4gICBJdCBhbHNvIHN0b3BzIGF0IGVuZCBvZiBmaWxlIG9yIHdoZW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaGFzXG4gICBiZWVuIHJlYWQuICopXG5sZXQgc2Nhbl9zdHJpbmcgc3RwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBsb29wIHdpZHRoID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBtYXRjaCBzdHAgd2l0aFxuICAgICAgfCBTb21lIGMnIHdoZW4gYyA9IGMnIC0+IFNjYW5uaW5nLnNraXBfY2hhciB3aWR0aCBpYlxuICAgICAgfCBTb21lIF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpblxuICBsb29wIHdpZHRoXG5cblxuKCogU2NhbiBhIGNoYXI6IHBlZWsgc3RyaWN0bHkgb25lIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQsIHdoYXRzb2V2ZXIuICopXG5sZXQgc2Nhbl9jaGFyIHdpZHRoIGliID1cbiAgKCogVGhlIGNhc2Ugd2lkdGggPSAwIGNvdWxkIG5vdCBoYXBwZW4gaGVyZSwgc2luY2UgaXQgaXMgdGVzdGVkIGJlZm9yZVxuICAgICBjYWxsaW5nIHNjYW5fY2hhciwgaW4gdGhlIG1haW4gc2Nhbm5pbmcgZnVuY3Rpb24uXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImEgY2hhcmFjdGVyXCIgZWxzZSAqKVxuICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYilcblxuXG5sZXQgY2hhcl9mb3JfYmFja3NsYXNoID0gZnVuY3Rpb25cbiAgfCAnbicgLT4gJ1xcMDEwJ1xuICB8ICdyJyAtPiAnXFwwMTMnXG4gIHwgJ2InIC0+ICdcXDAwOCdcbiAgfCAndCcgLT4gJ1xcMDA5J1xuICB8IGMgLT4gY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9IGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCdcblxubGV0IGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxMDAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzAgK1xuICAgICAxMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICAgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICBcImJhZCBjaGFyYWN0ZXIgZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlYyVjXCIgYzAgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBoZXhhZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID1cbiAgbGV0IGQgPSBpbnRfb2ZfY2hhciBjIGluXG4gICgqIENvdWxkIGFsc28gYmU6XG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnOScgdGhlbiBkIC0gaW50X29mX2NoYXIgJzAnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdGJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdBJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnZicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnYScgZWxzZSBhc3NlcnQgZmFsc2VcbiAgKilcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnYScgdGhlblxuICAgIGQgLSA4NyAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnYScgKikgZWxzZVxuICBpZiBkID49IGludF9vZl9jaGFyICdBJyB0aGVuXG4gICAgZCAtIDU1ICAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKikgZWxzZVxuICAgIGQgLSBpbnRfb2ZfY2hhciAnMCdcblxuXG5sZXQgY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxNiAqIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZiBcImJhZCBjaGFyYWN0ZXIgaGV4YWRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWNcIiBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogQ2FsbGVkIGluIHBhcnRpY3VsYXIgd2hlbiBlbmNvdW50ZXJpbmcgJ1xcXFwnIGFzIHN0YXJ0ZXIgb2YgYSBjaGFyLlxuICAgU3RvcHMgYmVmb3JlIHRoZSBjb3JyZXNwb25kaW5nICdcXCcnLiAqKVxubGV0IGNoZWNrX25leHRfY2hhciBtZXNzYWdlIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlIGVsc2VcbiAgY1xuXG5cbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgPSBjaGVja19uZXh0X2NoYXIgXCJhIENoYXJcIlxubGV0IGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBTdHJpbmdcIlxuXG5sZXQgc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYiA9XG4gIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gIHwgJ1xcXFwnIHwgJ1xcJycgfCAnXFxcIicgfCAnbicgfCAndCcgfCAnYicgfCAncicgYXMgYyAtPlxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKGNoYXJfZm9yX2JhY2tzbGFzaCBjKVxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMCA9IGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIpXG4gIHwgJ3gnIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyKVxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXRfZXNjYXBlIGNcblxuXG4oKiBTY2FuIGEgY2hhcmFjdGVyIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX2NoYXIgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gZmluZF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGNcblxuICBhbmQgZmluZF9jaGFyIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXFwnIC0+XG4gICAgICBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKSBpYilcbiAgICB8IGMgLT5cbiAgICAgIGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgYyBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgZGVsaW1pdGVkIHN0cmluZyAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxcIicgY1xuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgJ1xcXFwnIC0+IHNjYW5fYmFja3NsYXNoIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIHNjYW5fYmFja3NsYXNoIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxyJyAtPiBza2lwX25ld2xpbmUgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIpXG5cbiAgYW5kIHNraXBfbmV3bGluZSB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgJ1xccicpXG5cbiAgYW5kIHNraXBfc3BhY2VzIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnICcgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3Agd2lkdGggaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGJvb2xlYW4gKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2Jvb2wgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGxldCBtID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICd0JyAtPiA0XG4gICAgfCAnZicgLT4gNVxuICAgIHwgYyAtPlxuICAgICAgYmFkX2lucHV0XG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcInRoZSBjaGFyYWN0ZXIgJUMgY2Fubm90IHN0YXJ0IGEgYm9vbGVhblwiIGMpIGluXG4gIHNjYW5fc3RyaW5nIE5vbmUgbSBpYlxuXG5cbigqIFNjYW4gYSBzdHJpbmcgY29udGFpbmluZyBlbGVtZW50cyBpbiBjaGFyX3NldCBhbmQgdGVybWluYXRlZCBieSBzY2FuX2luZGljXG4gICBpZiBwcm92aWRlZC4gKilcbmxldCBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IHNjYW5faW5kaWMgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fY2hhcnMgaSBzdHAgPVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgaSA+IDAgJiYgbm90IChTY2FubmluZy5lb2YgaWIpICYmXG4gICAgICAgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyAmJlxuICAgICAgIGludF9vZl9jaGFyIGMgPD4gc3RwIHRoZW5cbiAgICAgIGxldCBfID0gU2Nhbm5pbmcuc3RvcmVfY2hhciBtYXhfaW50IGliIGMgaW5cbiAgICAgIHNjYW5fY2hhcnMgKGkgLSAxKSBzdHAgaW5cbiAgbWF0Y2ggc2Nhbl9pbmRpYyB3aXRoXG4gIHwgTm9uZSAtPiBzY2FuX2NoYXJzIHdpZHRoICgtMSk7XG4gIHwgU29tZSBjIC0+XG4gICAgc2Nhbl9jaGFycyB3aWR0aCAoaW50X29mX2NoYXIgYyk7XG4gICAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW5cbiAgICAgIGxldCBjaSA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgICAgaWYgYyA9IGNpXG4gICAgICB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gICAgICBlbHNlIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cblxuKCogVGhlIGdsb2JhbCBlcnJvciByZXBvcnQgZnVuY3Rpb24gZm9yIFtTY2FuZl0uICopXG5sZXQgc2NhbmZfYmFkX2lucHV0IGliID0gZnVuY3Rpb25cbiAgfCBTY2FuX2ZhaWx1cmUgcyB8IEZhaWx1cmUgcyAtPlxuICAgIGxldCBpID0gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYiBpblxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJzY2FuZjogYmFkIGlucHV0IGF0IGNoYXIgbnVtYmVyICVpOiAlc1wiIGkgcylcbiAgfCB4IC0+IHJhaXNlIHhcblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgYSBjb3VudGVyIGZyb20gYW4gaW5wdXQgYnVmZmVyLiAqKVxubGV0IGdldF9jb3VudGVyIGliIGNvdW50ZXIgPVxuICBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgLT4gU2Nhbm5pbmcubGluZV9jb3VudCBpYlxuICB8IENoYXJfY291bnRlciAtPiBTY2FubmluZy5jaGFyX2NvdW50IGliXG4gIHwgVG9rZW5fY291bnRlciAtPiBTY2FubmluZy50b2tlbl9jb3VudCBpYlxuXG5cbigqIENvbXB1dGUgdGhlIHdpZHRoIG9mIGEgcGFkZGluZyBvcHRpb24gKHNlZSBcIiU0MntcIiBhbmQgXCIlMTIzKFwiKS4gKilcbmxldCB3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IG1heF9pbnRcbiAgfCBTb21lIHdpZHRoIC0+IHdpZHRoXG5cblxubGV0IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nID1cbiAgaWYgZm10aW5nID0gRXNjYXBlZF9wZXJjZW50IHRoZW4gJyUnLCBcIlwiIGVsc2VcbiAgICBsZXQgc3RyID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyBpblxuICAgIGxldCBzdHAgPSBzdHIuWzFdIGluXG4gICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciAyIChTdHJpbmcubGVuZ3RoIHN0ciAtIDIpIGluXG4gICAgc3RwLCBzdWJfc3RyXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFJlYWRlciBtYW5hZ2VtZW50ICopXG5cbigqIEEgY2FsbCB0byB0YWtlX2Zvcm1hdF9yZWFkZXJzIG9uIGEgZm9ybWF0IGlzIGV2YWx1YXRlZCBpbnRvIGZ1bmN0aW9uc1xuICAgdGFraW5nIHJlYWRlcnMgYXMgYXJndW1lbnRzIGFuZCBhZ2dyZWdhdGUgdGhlbSBpbnRvIGFuIGhldGVyb2dlbmVvdXMgbGlzdCAqKVxuKCogV2hlbiBhbGwgcmVhZGVycyBhcmUgdGFrZW4sIGZpbmFsbHkgcGFzcyB0aGUgbGlzdCBvZiB0aGUgcmVhZGVycyB0byB0aGVcbiAgIGNvbnRpbnVhdGlvbiBrLiAqKVxubGV0IHJlYyB0YWtlX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgZCA9XG5mdW4gayBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdFxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfc3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQzMiAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IE5hdGl2ZWludCAoXywgXywgXywgcmVzdCkgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50NjQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbG9hdCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEJvb2wgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEN1c3RvbSAoXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgICAgLT5cbiAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKSByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgICAgICAgLT4gdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIGsgaWduIHJlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgICAgICAgIC0+IGsgTmlsXG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGZtdHR5IGNvbWluZyBmcm9tIGEgRm9ybWF0X3N1YnN0IFwiJSguLi4lKVwiLiAqKVxuYW5kIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgZm10dHkgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFJlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGlnbm9yZWQgcGFyYW1ldGVyLiAqKVxuYW5kIHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBpZ25vcmVkIC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10XG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgZm10dHkgZm10XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgc2Nhbm5pbmcgKilcblxuKCogTWFrZSBhIGdlbmVyaWMgc2Nhbm5pbmcgZnVuY3Rpb24uICopXG4oKiBTY2FuIGEgc3RyZWFtIGFjY29yZGluZyB0byBhIGZvcm1hdCBhbmQgcmVhZGVycyBvYnRhaW5lZCBieVxuICAgdGFrZV9mb3JtYXRfcmVhZGVycywgYW5kIGFnZ3JlZ2F0ZSBzY2FubmVkIHZhbHVlcyBpbnRvIGFuXG4gICBoZXRlcm9nZW5lb3VzIGxpc3QuICopXG4oKiBSZXR1cm4gdGhlIGhldGVyb2dlbmVvdXMgbGlzdCBvZiBzY2FubmVkIHZhbHVlcy4gKilcbmxldCByZWMgbWFrZV9zY2FuZiA6IHR5cGUgYSBjIGQgZSBmLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKGEsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSBzdHApIHdpZHRoIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICd7Jykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAnWycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyBOb25lIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcblxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50IGMpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDMyIGMpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9uYXRpdmVpbnQgYylcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50NjQgYylcbiAgfCBGbG9hdCAoRmxvYXRfRiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2NhbWxfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKEZsb2F0X2YgfCBGbG9hdF9wZiB8IEZsb2F0X3NmIHwgRmxvYXRfZSB8IEZsb2F0X3BlIHwgRmxvYXRfc2VcbiAgICAgICAgICAgICAgIHwgRmxvYXRfRSB8IEZsb2F0X3BFIHwgRmxvYXRfc0UgfCBGbG9hdF9nIHwgRmxvYXRfcGcgfCBGbG9hdF9zZ1xuICAgICAgICAgICAgICAgfCBGbG9hdF9HIHwgRmxvYXRfcEcgfCBGbG9hdF9zRyksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoRmxvYXRfaCB8IEZsb2F0X3BoIHwgRmxvYXRfc2ggfCBGbG9hdF9IIHwgRmxvYXRfcEggfCBGbG9hdF9zSCksXG4gICAgICAgICAgIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9oZXhfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gXyBfIGliID0gc2Nhbl9ib29sIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9ib29sXG4gIHwgQWxwaGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlYVxcXCJcIlxuICB8IFRoZXRhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJXRcXFwiXCJcbiAgfCBDdXN0b20gXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlP1xcXCIgKGN1c3RvbSBjb252ZXJ0ZXIpXCJcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBiZWdpbiBtYXRjaCByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSAtPlxuICAgICAgICBsZXQgeCA9IHJlYWRlciBpYiBpblxuICAgICAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdF9yZXN0IHJlYWRlcnNfcmVzdClcbiAgICB8IE5pbCAtPlxuICAgICAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBtaXNzaW5nIHJlYWRlclwiXG4gICAgZW5kXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIGlmIFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gICAgZWxzZSBiYWRfaW5wdXQgXCJlbmQgb2YgaW5wdXQgbm90IGZvdW5kXCJcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIHN0cjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgY2hyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgcyBmbXR0eVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChmbXQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10LCBmbXQnID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCcgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgICgqIFRPRE86IGZpbmQgYSB3YXkgdG8gYXZvaWQgcmVwYXJzaW5nIHR3aWNlICopXG5cbiAgICAgICAgKCogVE9ETzogdGhlc2UgdHlwZS1jaGVja3MgYmVsb3cgKmNhbiogZmFpbCBiZWNhdXNlIG9mIHR5cGVcbiAgICAgICAgICAgYW1iaWd1aXR5IGluIHByZXNlbmNlIG9mIGlnbm9yZWQtcmVhZGVyczogXCIlX3IlZFwiIGFuZCBcIiVkJV9yXCJcbiAgICAgICAgICAgYXJlIHR5cGVkIGluIHRoZSBzYW1lIHdheS5cblxuICAgICAgICAgICAjIFNjYW5mLnNzY2FuZiBcIlxcXCIlX3IlZFxcXCIzXCIgXCIlKCVkJV9yJSlcIiBpZ25vcmVcbiAgICAgICAgICAgICAoZnVuIGZtdCBuIC0+IHN0cmluZ19vZl9mb3JtYXQgZm10LCBuKVxuICAgICAgICAgICBFeGNlcHRpb246IENhbWxpbnRlcm5hbEZvcm1hdC5UeXBlX21pc21hdGNoLlxuXG4gICAgICAgICAgIFdlIHNob3VsZCBwcm9wZXJseSBjYXRjaCB0aGlzIGV4Y2VwdGlvbi5cbiAgICAgICAgKilcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgZm10dHkpLFxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQnIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChGb3JtYXQgKGZtdCwgcyksXG4gICAgICAgICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IChTb21lIHN0cCkgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBOb25lIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBsZXQgY291bnQgPSBnZXRfY291bnRlciBpYiBjb3VudGVyIGluXG4gICAgQ29ucyAoY291bnQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQpO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAneyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICdbJztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICBiZWdpbiBtYXRjaCBtYWtlX3NjYW5mIGliIGZtdCcgcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChfLCBhcmdfcmVzdCkgLT4gYXJnX3Jlc3RcbiAgICB8IE5pbCAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBOaWxcblxuKCogQ2FzZSBhbmFseXNpcyBvbiBwYWRkaW5nIGFuZCBwcmVjaXNpb24uICopXG4oKiBSZWplY3QgZm9ybWF0cyBjb250YWluaW5nIFwiJSpcIiBvciBcIiUuKlwiLiAqKVxuKCogUGFzcyBwYWRkaW5nIGFuZCBwcmVjaXNpb24gdG8gdGhlIGdlbmVyaWMgc2Nhbm5lciBgc2NhbicuICopXG5hbmQgcGFkX3ByZWNfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZiB4IHkgeiB0IC5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+ICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPlxuICAgICAgKGludCAtPiBpbnQgLT4gU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB0KSAtPlxuICAgICAgKFNjYW5uaW5nLmluX2NoYW5uZWwgLT4geikgLT5cbiAgICAgICh4LCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyBwYWQgcHJlYyBzY2FuIHRva2VuIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKExlZnQsIF8pLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUtXFxcIlwiXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgXyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBBcmdfcGFkZGluZyBfLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgKCogRGVmaW5pbmcgW3NjYW5mXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtzY2FuZl0gKilcblxudHlwZSAnYSBrc2NhbmZfcmVzdWx0ID0gQXJncyBvZiAnYSB8IEV4YyBvZiBleG5cblxubGV0IGtzY2FuZiBpYiBlZiAoRm9ybWF0IChmbXQsIHN0cikpID1cbiAgbGV0IHJlYyBhcHBseSA6IHR5cGUgYSBiIC4gYSAtPiAoYSwgYikgaGV0ZXJfbGlzdCAtPiBiID1cbiAgICBmdW4gZiBhcmdzIC0+IG1hdGNoIGFyZ3Mgd2l0aFxuICAgIHwgQ29ucyAoeCwgcikgLT4gYXBwbHkgKGYgeCkgclxuICAgIHwgTmlsIC0+IGZcbiAgaW5cbiAgbGV0IGsgcmVhZGVycyBmID1cbiAgICBTY2FubmluZy5yZXNldF90b2tlbiBpYjtcbiAgICBtYXRjaCB0cnkgQXJncyAobWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycykgd2l0aFxuICAgICAgfCAoU2Nhbl9mYWlsdXJlIF8gfCBGYWlsdXJlIF8gfCBFbmRfb2ZfZmlsZSkgYXMgZXhjIC0+IEV4YyBleGNcbiAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgKG1zZyBeIFwiIGluIGZvcm1hdCBcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzdHIgXiBcIlxcXCJcIilcbiAgICB3aXRoXG4gICAgICB8IEFyZ3MgYXJncyAtPiBhcHBseSBmIGFyZ3NcbiAgICAgIHwgRXhjIGV4YyAtPiBlZiBpYiBleGNcbiAgaW5cbiAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKVxuXG5sZXQga2JzY2FuZiA9IGtzY2FuZlxubGV0IGJzY2FuZiBpYiBmbXQgPSBrYnNjYW5mIGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IGtzc2NhbmYgcyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBlZiBmbXRcbmxldCBzc2NhbmYgcyBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBzY2FuZiBmbXQgPSBrc2NhbmYgU2Nhbm5pbmcuc3RkaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG4oKioqKVxuXG4oKiBTY2FubmluZyBmb3JtYXQgc3RyaW5ncy4gKilcbmxldCBic2NhbmZfZm9ybWF0IDpcbiAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIGliIGZvcm1hdCBmIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nIG1heF9pbnQgaWIgaW5cbiAgICBsZXQgc3RyID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCcgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciBmb3JtYXRcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZyBpblxuICAgIGYgZm10J1xuXG5cbmxldCBzc2NhbmZfZm9ybWF0IDpcbiAgc3RyaW5nIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gcyBmb3JtYXQgZiAtPiBic2NhbmZfZm9ybWF0IChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBmb3JtYXQgZlxuXG5cbmxldCBzdHJpbmdfdG9fU3RyaW5nIHMgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyKSBpblxuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIGxldCBjID0gcy5baV0gaW5cbiAgICBpZiBjID0gJ1xcXCInIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXFwnO1xuICAgIEJ1ZmZlci5hZGRfY2hhciBiIGM7XG4gIGRvbmU7XG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuXG5sZXQgZm9ybWF0X2Zyb21fc3RyaW5nIHMgZm10ID1cbiAgc3NjYW5mX2Zvcm1hdCAoc3RyaW5nX3RvX1N0cmluZyBzKSBmbXQgKGZ1biB4IC0+IHgpXG5cblxubGV0IHVuZXNjYXBlZCBzID1cbiAgc3NjYW5mIChcIlxcXCJcIiBeIHMgXiBcIlxcXCJcIikgXCIlUyUhXCIgKGZ1biB4IC0+IHgpXG5cblxuKCogRGVwcmVjYXRlZCAqKVxubGV0IGtmc2NhbmYgaWMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIGVmIGZtdFxubGV0IGZzY2FuZiBpYyBmbXQgPSBrc2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBzY2FuZl9iYWRfaW5wdXQgZm10XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFJlZ2lzdGVyaW5nIE9DYW1sIHZhbHVlcyB3aXRoIHRoZSBDIHJ1bnRpbWUgZm9yIGxhdGVyIGNhbGxiYWNrcyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiBPYmoudCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCByZWdpc3RlciBuYW1lIHYgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIChPYmoucmVwciB2KVxuXG5sZXQgcmVnaXN0ZXJfZXhjZXB0aW9uIG5hbWUgKGV4biA6IGV4bikgPVxuICBsZXQgZXhuID0gT2JqLnJlcHIgZXhuIGluXG4gIGxldCBzbG90ID0gaWYgT2JqLnRhZyBleG4gPSBPYmoub2JqZWN0X3RhZyB0aGVuIGV4biBlbHNlIE9iai5maWVsZCBleG4gMCBpblxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIHNsb3RcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIEplcm9tZSBWb3VpbGxvbiwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBPYmpcblxuKCoqKiogT2JqZWN0IHJlcHJlc2VudGF0aW9uICoqKiopXG5cbmV4dGVybmFsIHNldF9pZDogJ2EgLT4gJ2EgPSBcImNhbWxfc2V0X29vX2lkXCIgW0BAbm9hbGxvY11cblxuKCoqKiogT2JqZWN0IGNvcHkgKioqKilcblxubGV0IGNvcHkgbyA9XG4gIGxldCBvID0gKE9iai5vYmogKE9iai5kdXAgKE9iai5yZXByIG8pKSkgaW5cbiAgc2V0X2lkIG9cblxuKCoqKiogQ29tcHJlc3Npb24gb3B0aW9ucyAqKioqKVxuKCogUGFyYW1ldGVycyAqKVxudHlwZSBwYXJhbXMgPSB7XG4gICAgbXV0YWJsZSBjb21wYWN0X3RhYmxlIDogYm9vbDtcbiAgICBtdXRhYmxlIGNvcHlfcGFyZW50IDogYm9vbDtcbiAgICBtdXRhYmxlIGNsZWFuX3doZW5fY29weWluZyA6IGJvb2w7XG4gICAgbXV0YWJsZSByZXRyeV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGJ1Y2tldF9zbWFsbF9zaXplIDogaW50XG4gIH1cblxubGV0IHBhcmFtcyA9IHtcbiAgY29tcGFjdF90YWJsZSA9IHRydWU7XG4gIGNvcHlfcGFyZW50ID0gdHJ1ZTtcbiAgY2xlYW5fd2hlbl9jb3B5aW5nID0gdHJ1ZTtcbiAgcmV0cnlfY291bnQgPSAzO1xuICBidWNrZXRfc21hbGxfc2l6ZSA9IDE2XG59XG5cbigqKioqIFBhcmFtZXRlcnMgKioqKilcblxubGV0IGluaXRpYWxfb2JqZWN0X3NpemUgPSAyXG5cbigqKioqIEl0ZW1zICoqKiopXG5cbnR5cGUgaXRlbSA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxubGV0IGR1bW15X2l0ZW0gPSAobWFnaWMgKCkgOiBpdGVtKVxuXG4oKioqKiBUeXBlcyAqKioqKVxuXG50eXBlIHRhZ1xudHlwZSBsYWJlbCA9IGludFxudHlwZSBjbG9zdXJlID0gaXRlbVxudHlwZSB0ID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG50eXBlIG9iaiA9IHQgYXJyYXlcbmV4dGVybmFsIHJldCA6IChvYmogLT4gJ2EpIC0+IGNsb3N1cmUgPSBcIiVpZGVudGl0eVwiXG5cbigqKioqIExhYmVscyAqKioqKVxuXG5sZXQgcHVibGljX21ldGhvZF9sYWJlbCBzIDogdGFnID1cbiAgbGV0IGFjY3UgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgIGFjY3UgOj0gMjIzICogIWFjY3UgKyBDaGFyLmNvZGUgcy5baV1cbiAgZG9uZTtcbiAgKCogcmVkdWNlIHRvIDMxIGJpdHMgKilcbiAgYWNjdSA6PSAhYWNjdSBsYW5kICgxIGxzbCAzMSAtIDEpO1xuICAoKiBtYWtlIGl0IHNpZ25lZCBmb3IgNjQgYml0cyBhcmNoaXRlY3R1cmVzICopXG4gIGxldCB0YWcgPSBpZiAhYWNjdSA+IDB4M0ZGRkZGRkYgdGhlbiAhYWNjdSAtICgxIGxzbCAzMSkgZWxzZSAhYWNjdSBpblxuICAoKiBQcmludGYuZXByaW50ZiBcIiVzID0gJWRcXG5cIiBzIHRhZzsgZmx1c2ggc3RkZXJyOyAqKVxuICBtYWdpYyB0YWdcblxuKCoqKiogU3BhcnNlIGFycmF5ICoqKiopXG5cbm1vZHVsZSBWYXJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSB2YXJzID0gaW50IFZhcnMudFxuXG5tb2R1bGUgTWV0aHMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIG1ldGhzID0gbGFiZWwgTWV0aHMudFxubW9kdWxlIExhYnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gbGFiZWwgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbGFicyA9IGJvb2wgTGFicy50XG5cbigqIFRoZSBjb21waWxlciBhc3N1bWVzIHRoYXQgdGhlIGZpcnN0IGZpZWxkIG9mIHRoaXMgc3RydWN0dXJlIGlzIFtzaXplXS4gKilcbnR5cGUgdGFibGUgPVxuIHsgbXV0YWJsZSBzaXplOiBpbnQ7XG4gICBtdXRhYmxlIG1ldGhvZHM6IGNsb3N1cmUgYXJyYXk7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbmFtZTogbWV0aHM7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbGFiZWw6IGxhYnM7XG4gICBtdXRhYmxlIHByZXZpb3VzX3N0YXRlczpcbiAgICAgKG1ldGhzICogbGFicyAqIChsYWJlbCAqIGl0ZW0pIGxpc3QgKiB2YXJzICpcbiAgICAgIGxhYmVsIGxpc3QgKiBzdHJpbmcgbGlzdCkgbGlzdDtcbiAgIG11dGFibGUgaGlkZGVuX21ldGhzOiAobGFiZWwgKiBpdGVtKSBsaXN0O1xuICAgbXV0YWJsZSB2YXJzOiB2YXJzO1xuICAgbXV0YWJsZSBpbml0aWFsaXplcnM6IChvYmogLT4gdW5pdCkgbGlzdCB9XG5cbmxldCBkdW1teV90YWJsZSA9XG4gIHsgbWV0aG9kcyA9IFt8IGR1bW15X2l0ZW0gfF07XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IDAgfVxuXG5sZXQgdGFibGVfY291bnQgPSByZWYgMFxuXG4oKiBkdW1teV9tZXQgc2hvdWxkIGJlIGEgcG9pbnRlciwgc28gdXNlIGFuIGF0b20gKilcbmxldCBkdW1teV9tZXQgOiBpdGVtID0gb2JqIChPYmoubmV3X2Jsb2NrIDAgMClcbigqIGlmIGRlYnVnZ2luZyBpcyBuZWVkZWQsIHRoaXMgY291bGQgYmUgYSBnb29kIGlkZWE6ICopXG4oKiBsZXQgZHVtbXlfbWV0ICgpID0gZmFpbHdpdGggXCJVbmRlZmluZWQgbWV0aG9kXCIgKilcblxubGV0IHJlYyBmaXRfc2l6ZSBuID1cbiAgaWYgbiA8PSAyIHRoZW4gbiBlbHNlXG4gIGZpdF9zaXplICgobisxKS8yKSAqIDJcblxubGV0IG5ld190YWJsZSBwdWJfbGFiZWxzID1cbiAgaW5jciB0YWJsZV9jb3VudDtcbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBwdWJfbGFiZWxzIGluXG4gIGxldCBtZXRob2RzID0gQXJyYXkubWFrZSAobGVuKjIrMikgZHVtbXlfbWV0IGluXG4gIG1ldGhvZHMuKDApIDwtIG1hZ2ljIGxlbjtcbiAgbWV0aG9kcy4oMSkgPC0gbWFnaWMgKGZpdF9zaXplIGxlbiAqIFN5cy53b3JkX3NpemUgLyA4IC0gMSk7XG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvIG1ldGhvZHMuKGkqMiszKSA8LSBtYWdpYyBwdWJfbGFiZWxzLihpKSBkb25lO1xuICB7IG1ldGhvZHMgPSBtZXRob2RzO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSBpbml0aWFsX29iamVjdF9zaXplIH1cblxubGV0IHJlc2l6ZSBhcnJheSBuZXdfc2l6ZSA9XG4gIGxldCBvbGRfc2l6ZSA9IEFycmF5Lmxlbmd0aCBhcnJheS5tZXRob2RzIGluXG4gIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlbiBiZWdpblxuICAgIGxldCBuZXdfYnVjayA9IEFycmF5Lm1ha2UgbmV3X3NpemUgZHVtbXlfbWV0IGluXG4gICAgQXJyYXkuYmxpdCBhcnJheS5tZXRob2RzIDAgbmV3X2J1Y2sgMCBvbGRfc2l6ZTtcbiAgICBhcnJheS5tZXRob2RzIDwtIG5ld19idWNrXG4gZW5kXG5cbmxldCBwdXQgYXJyYXkgbGFiZWwgZWxlbWVudCA9XG4gIHJlc2l6ZSBhcnJheSAobGFiZWwgKyAxKTtcbiAgYXJyYXkubWV0aG9kcy4obGFiZWwpIDwtIGVsZW1lbnRcblxuKCoqKiogQ2xhc3NlcyAqKioqKVxuXG5sZXQgbWV0aG9kX2NvdW50ID0gcmVmIDBcbmxldCBpbnN0X3Zhcl9jb3VudCA9IHJlZiAwXG5cbigqIHR5cGUgdCAqKVxudHlwZSBtZXRoID0gaXRlbVxuXG5sZXQgbmV3X21ldGhvZCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IEFycmF5Lmxlbmd0aCB0YWJsZS5tZXRob2RzIGluXG4gIHJlc2l6ZSB0YWJsZSAoaW5kZXggKyAxKTtcbiAgaW5kZXhcblxubGV0IGdldF9tZXRob2RfbGFiZWwgdGFibGUgbmFtZSA9XG4gIHRyeVxuICAgIE1ldGhzLmZpbmQgbmFtZSB0YWJsZS5tZXRob2RzX2J5X25hbWVcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgbGFiZWwgPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gICAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIE1ldGhzLmFkZCBuYW1lIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYmVsIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbDtcbiAgICBsYWJlbFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbHMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIG5hbWVzXG5cbmxldCBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGVsZW1lbnQgPVxuICBpbmNyIG1ldGhvZF9jb3VudDtcbiAgaWYgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgdGhlblxuICAgIHB1dCB0YWJsZSBsYWJlbCBlbGVtZW50XG4gIGVsc2VcbiAgICB0YWJsZS5oaWRkZW5fbWV0aHMgPC0gKGxhYmVsLCBlbGVtZW50KSA6OiB0YWJsZS5oaWRkZW5fbWV0aHNcblxubGV0IGdldF9tZXRob2QgdGFibGUgbGFiZWwgPVxuICB0cnkgTGlzdC5hc3NvYyBsYWJlbCB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgd2l0aCBOb3RfZm91bmQgLT4gdGFibGUubWV0aG9kcy4obGFiZWwpXG5cbmxldCB0b19saXN0IGFyciA9XG4gIGlmIGFyciA9PSBtYWdpYyAwIHRoZW4gW10gZWxzZSBBcnJheS50b19saXN0IGFyclxuXG5sZXQgbmFycm93IHRhYmxlIHZhcnMgdmlydF9tZXRocyBjb25jcl9tZXRocyA9XG4gIGxldCB2YXJzID0gdG9fbGlzdCB2YXJzXG4gIGFuZCB2aXJ0X21ldGhzID0gdG9fbGlzdCB2aXJ0X21ldGhzXG4gIGFuZCBjb25jcl9tZXRocyA9IHRvX2xpc3QgY29uY3JfbWV0aHMgaW5cbiAgbGV0IHZpcnRfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIHZpcnRfbWV0aHMgaW5cbiAgbGV0IGNvbmNyX21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBjb25jcl9tZXRocyBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC1cbiAgICAgKHRhYmxlLm1ldGhvZHNfYnlfbmFtZSwgdGFibGUubWV0aG9kc19ieV9sYWJlbCwgdGFibGUuaGlkZGVuX21ldGhzLFxuICAgICAgdGFibGUudmFycywgdmlydF9tZXRoX2xhYnMsIHZhcnMpXG4gICAgIDo6IHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgIFZhcnMuZm9sZFxuICAgICAgKGZ1biBsYWIgaW5mbyB0dmFycyAtPlxuICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmFycyB0aGVuIFZhcnMuYWRkIGxhYiBpbmZvIHR2YXJzIGVsc2UgdHZhcnMpXG4gICAgICB0YWJsZS52YXJzIFZhcnMuZW1wdHk7XG4gIGxldCBieV9uYW1lID0gcmVmIE1ldGhzLmVtcHR5IGluXG4gIGxldCBieV9sYWJlbCA9IHJlZiBMYWJzLmVtcHR5IGluXG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PVxuICAgICAgICAgIExhYnMuYWRkIGxhYmVsXG4gICAgICAgICAgICAodHJ5IExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHdpdGggTm90X2ZvdW5kIC0+IHRydWUpXG4gICAgICAgICAgICAhYnlfbGFiZWwpXG4gICAgY29uY3JfbWV0aHMgY29uY3JfbWV0aF9sYWJzO1xuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj0gTGFicy5hZGQgbGFiZWwgZmFsc2UgIWJ5X2xhYmVsKVxuICAgIHZpcnRfbWV0aHMgdmlydF9tZXRoX2xhYnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSAhYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSAhYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aF9sYWJzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIFtdXG5cbmxldCB3aWRlbiB0YWJsZSA9XG4gIGxldCAoYnlfbmFtZSwgYnlfbGFiZWwsIHNhdmVkX2hpZGRlbl9tZXRocywgc2F2ZWRfdmFycywgdmlydF9tZXRocywgdmFycykgPVxuICAgIExpc3QuaGQgdGFibGUucHJldmlvdXNfc3RhdGVzXG4gIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LSBMaXN0LnRsIHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgIChmdW4gcyB2IC0+IFZhcnMuYWRkIHYgKFZhcnMuZmluZCB2IHRhYmxlLnZhcnMpIHMpXG4gICAgICAgc2F2ZWRfdmFycyB2YXJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRocyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBzYXZlZF9oaWRkZW5fbWV0aHNcblxubGV0IG5ld19zbG90IHRhYmxlID1cbiAgbGV0IGluZGV4ID0gdGFibGUuc2l6ZSBpblxuICB0YWJsZS5zaXplIDwtIGluZGV4ICsgMTtcbiAgaW5kZXhcblxubGV0IG5ld192YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnNcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgaW5kZXggPSBuZXdfc2xvdCB0YWJsZSBpblxuICAgIGlmIG5hbWUgPD4gXCJcIiB0aGVuIHRhYmxlLnZhcnMgPC0gVmFycy5hZGQgbmFtZSBpbmRleCB0YWJsZS52YXJzO1xuICAgIGluZGV4XG5cbmxldCB0b19hcnJheSBhcnIgPVxuICBpZiBhcnIgPSBPYmoubWFnaWMgMCB0aGVuIFt8fF0gZWxzZSBhcnJcblxubGV0IG5ld19tZXRob2RzX3ZhcmlhYmxlcyB0YWJsZSBtZXRocyB2YWxzID1cbiAgbGV0IG1ldGhzID0gdG9fYXJyYXkgbWV0aHMgaW5cbiAgbGV0IG5tZXRocyA9IEFycmF5Lmxlbmd0aCBtZXRocyBhbmQgbnZhbHMgPSBBcnJheS5sZW5ndGggdmFscyBpblxuICBsZXQgcmVzID0gQXJyYXkubWFrZSAobm1ldGhzICsgbnZhbHMpIDAgaW5cbiAgZm9yIGkgPSAwIHRvIG5tZXRocyAtIDEgZG9cbiAgICByZXMuKGkpIDwtIGdldF9tZXRob2RfbGFiZWwgdGFibGUgbWV0aHMuKGkpXG4gIGRvbmU7XG4gIGZvciBpID0gMCB0byBudmFscyAtIDEgZG9cbiAgICByZXMuKGkrbm1ldGhzKSA8LSBuZXdfdmFyaWFibGUgdGFibGUgdmFscy4oaSlcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBnZXRfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzIHdpdGggTm90X2ZvdW5kIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgZ2V0X3ZhcmlhYmxlcyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIHRhYmxlKSBuYW1lc1xuXG5sZXQgYWRkX2luaXRpYWxpemVyIHRhYmxlIGYgPVxuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gZjo6dGFibGUuaW5pdGlhbGl6ZXJzXG5cbigqXG5tb2R1bGUgS2V5cyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSB0YWcgYXJyYXkgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbmxldCBrZXlfbWFwID0gcmVmIEtleXMuZW1wdHlcbmxldCBnZXRfa2V5IHRhZ3MgOiBpdGVtID1cbiAgdHJ5IG1hZ2ljIChLZXlzLmZpbmQgdGFncyAha2V5X21hcCA6IHRhZyBhcnJheSlcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBrZXlfbWFwIDo9IEtleXMuYWRkIHRhZ3MgdGFncyAha2V5X21hcDtcbiAgICBtYWdpYyB0YWdzXG4qKVxuXG5sZXQgY3JlYXRlX3RhYmxlIHB1YmxpY19tZXRob2RzID1cbiAgaWYgcHVibGljX21ldGhvZHMgPT0gbWFnaWMgMCB0aGVuIG5ld190YWJsZSBbfHxdIGVsc2VcbiAgKCogW3B1YmxpY19tZXRob2RzXSBtdXN0IGJlIGluIGFzY2VuZGluZyBvcmRlciBmb3IgYnl0ZWNvZGUgKilcbiAgbGV0IHRhZ3MgPSBBcnJheS5tYXAgcHVibGljX21ldGhvZF9sYWJlbCBwdWJsaWNfbWV0aG9kcyBpblxuICBsZXQgdGFibGUgPSBuZXdfdGFibGUgdGFncyBpblxuICBBcnJheS5pdGVyaVxuICAgIChmdW4gaSBtZXQgLT5cbiAgICAgIGxldCBsYWIgPSBpKjIrMiBpblxuICAgICAgdGFibGUubWV0aG9kc19ieV9uYW1lICA8LSBNZXRocy5hZGQgbWV0IGxhYiB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYiB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwpXG4gICAgcHVibGljX21ldGhvZHM7XG4gIHRhYmxlXG5cbmxldCBpbml0X2NsYXNzIHRhYmxlID1cbiAgaW5zdF92YXJfY291bnQgOj0gIWluc3RfdmFyX2NvdW50ICsgdGFibGUuc2l6ZSAtIDE7XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBMaXN0LnJldiB0YWJsZS5pbml0aWFsaXplcnM7XG4gIHJlc2l6ZSB0YWJsZSAoMyArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplKVxuXG5sZXQgaW5oZXJpdHMgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocyAoXywgc3VwZXIsIF8sIGVudikgdG9wID1cbiAgbmFycm93IGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHM7XG4gIGxldCBpbml0ID1cbiAgICBpZiB0b3AgdGhlbiBzdXBlciBjbGEgZW52IGVsc2UgT2JqLnJlcHIgKHN1cGVyIGNsYSkgaW5cbiAgd2lkZW4gY2xhO1xuICBBcnJheS5jb25jYXRcbiAgICBbW3wgcmVwciBpbml0IHxdO1xuICAgICBtYWdpYyAoQXJyYXkubWFwIChnZXRfdmFyaWFibGUgY2xhKSAodG9fYXJyYXkgdmFscykgOiBpbnQgYXJyYXkpO1xuICAgICBBcnJheS5tYXBcbiAgICAgICAoZnVuIG5tIC0+IHJlcHIgKGdldF9tZXRob2QgY2xhIChnZXRfbWV0aG9kX2xhYmVsIGNsYSBubSkgOiBjbG9zdXJlKSlcbiAgICAgICAodG9fYXJyYXkgY29uY3JfbWV0aHMpIF1cblxubGV0IG1ha2VfY2xhc3MgcHViX21ldGhzIGNsYXNzX2luaXQgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgKGVudl9pbml0IChPYmoucmVwciAwKSwgY2xhc3NfaW5pdCwgZW52X2luaXQsIE9iai5yZXByIDApXG5cbnR5cGUgaW5pdF90YWJsZSA9IHsgbXV0YWJsZSBlbnZfaW5pdDogdDsgbXV0YWJsZSBjbGFzc19pbml0OiB0YWJsZSAtPiB0IH1cblxubGV0IG1ha2VfY2xhc3Nfc3RvcmUgcHViX21ldGhzIGNsYXNzX2luaXQgaW5pdF90YWJsZSA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICBpbml0X3RhYmxlLmNsYXNzX2luaXQgPC0gY2xhc3NfaW5pdDtcbiAgaW5pdF90YWJsZS5lbnZfaW5pdCA8LSBlbnZfaW5pdFxuXG5sZXQgZHVtbXlfY2xhc3MgbG9jID1cbiAgbGV0IHVuZGVmID0gZnVuIF8gLT4gcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYykgaW5cbiAgKE9iai5tYWdpYyB1bmRlZiwgdW5kZWYsIHVuZGVmLCBPYmoucmVwciAwKVxuXG4oKioqKiBPYmplY3RzICoqKiopXG5cbmxldCBjcmVhdGVfb2JqZWN0IHRhYmxlID1cbiAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgT2JqLm9iaiAoc2V0X2lkIG9iailcblxubGV0IGNyZWF0ZV9vYmplY3Rfb3B0IG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gICAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gICAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gICAgT2JqLm9iaiAoc2V0X2lkIG9iailcbiAgZW5kXG5cbmxldCByZWMgaXRlcl9mIG9iaiA9XG4gIGZ1bmN0aW9uXG4gICAgW10gICAtPiAoKVxuICB8IGY6OmwgLT4gZiBvYmo7IGl0ZXJfZiBvYmogbFxuXG5sZXQgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGUgPVxuICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgaWYgaW5pdHMgPD4gW10gdGhlblxuICAgIGl0ZXJfZiBvYmogaW5pdHNcblxubGV0IHJ1bl9pbml0aWFsaXplcnNfb3B0IG9ial8wIG9iaiB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9iaiBlbHNlIGJlZ2luXG4gICAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gICAgaWYgaW5pdHMgPD4gW10gdGhlbiBpdGVyX2Ygb2JqIGluaXRzO1xuICAgIG9ialxuICBlbmRcblxubGV0IGNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaXplcnMgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgbGV0IG9iaiA9IGNyZWF0ZV9vYmplY3QgdGFibGUgaW5cbiAgICBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZTtcbiAgICBvYmpcbiAgZW5kXG5cbigqIEVxdWl2YWxlbnQgcHJpbWl0aXZlIGJlbG93XG5sZXQgc2VuZHNlbGYgb2JqIGxhYiA9XG4gIChtYWdpYyBvYmogOiAob2JqIC0+IHQpIGFycmF5IGFycmF5KS4oMCkuKGxhYikgb2JqXG4qKVxuZXh0ZXJuYWwgc2VuZCA6IG9iaiAtPiB0YWcgLT4gJ2EgPSBcIiVzZW5kXCJcbmV4dGVybmFsIHNlbmRjYWNoZSA6IG9iaiAtPiB0YWcgLT4gdCAtPiBpbnQgLT4gJ2EgPSBcIiVzZW5kY2FjaGVcIlxuZXh0ZXJuYWwgc2VuZHNlbGYgOiBvYmogLT4gbGFiZWwgLT4gJ2EgPSBcIiVzZW5kc2VsZlwiXG5leHRlcm5hbCBnZXRfcHVibGljX21ldGhvZCA6IG9iaiAtPiB0YWcgLT4gY2xvc3VyZVxuICAgID0gXCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kXCIgW0BAbm9hbGxvY11cblxuKCoqKiogdGFibGUgY29sbGVjdGlvbiBhY2Nlc3MgKioqKilcblxudHlwZSB0YWJsZXMgPVxuICB8IEVtcHR5XG4gIHwgQ29ucyBvZiB7a2V5IDogY2xvc3VyZTsgbXV0YWJsZSBkYXRhOiB0YWJsZXM7IG11dGFibGUgbmV4dDogdGFibGVzfVxuXG5sZXQgc2V0X2RhdGEgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhIDwtIHZcbmxldCBzZXRfbmV4dCB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHQgPC0gdlxubGV0IGdldF9rZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5rZXlcbmxldCBnZXRfZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGFcbmxldCBnZXRfbmV4dCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHRcblxubGV0IGJ1aWxkX3BhdGggbiBrZXlzIHRhYmxlcyA9XG4gIGxldCByZXMgPSBDb25zIHtrZXkgPSBPYmoubWFnaWMgMDsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gIGxldCByID0gcmVmIHJlcyBpblxuICBmb3IgaSA9IDAgdG8gbiBkb1xuICAgIHIgOj0gQ29ucyB7a2V5ID0ga2V5cy4oaSk7IGRhdGEgPSAhcjsgbmV4dCA9IEVtcHR5fVxuICBkb25lO1xuICBzZXRfZGF0YSB0YWJsZXMgIXI7XG4gIHJlc1xuXG5sZXQgcmVjIGxvb2t1cF9rZXlzIGkga2V5cyB0YWJsZXMgPVxuICBpZiBpIDwgMCB0aGVuIHRhYmxlcyBlbHNlXG4gIGxldCBrZXkgPSBrZXlzLihpKSBpblxuICBsZXQgcmVjIGxvb2t1cF9rZXkgKHRhYmxlczp0YWJsZXMpID1cbiAgICBpZiBnZXRfa2V5IHRhYmxlcyA9PSBrZXkgdGhlblxuICAgICAgbWF0Y2ggZ2V0X2RhdGEgdGFibGVzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IENvbnMgXyBhcyB0YWJsZXNfZGF0YSAtPlxuICAgICAgICAgIGxvb2t1cF9rZXlzIChpLTEpIGtleXMgdGFibGVzX2RhdGFcbiAgICBlbHNlXG4gICAgICBtYXRjaCBnZXRfbmV4dCB0YWJsZXMgd2l0aFxuICAgICAgfCBDb25zIF8gYXMgbmV4dCAtPiBsb29rdXBfa2V5IG5leHRcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBsZXQgbmV4dCA6IHRhYmxlcyA9IENvbnMge2tleTsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gICAgICAgICAgc2V0X25leHQgdGFibGVzIG5leHQ7XG4gICAgICAgICAgYnVpbGRfcGF0aCAoaS0xKSBrZXlzIG5leHRcbiAgaW5cbiAgbG9va3VwX2tleSB0YWJsZXNcblxubGV0IGxvb2t1cF90YWJsZXMgcm9vdCBrZXlzID1cbiAgbWF0Y2ggZ2V0X2RhdGEgcm9vdCB3aXRoXG4gIHwgQ29ucyBfIGFzIHJvb3RfZGF0YSAtPlxuICAgIGxvb2t1cF9rZXlzIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdF9kYXRhXG4gIHwgRW1wdHkgLT5cbiAgICBidWlsZF9wYXRoIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdFxuXG4oKioqKiBidWlsdGluIG1ldGhvZHMgKioqKilcblxubGV0IGdldF9jb25zdCB4ID0gcmV0IChmdW4gX29iaiAtPiB4KVxubGV0IGdldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIC0+IEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pXG5sZXQgZ2V0X2VudiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKVxubGV0IGdldF9tZXRoIG4gID0gcmV0IChmdW4gb2JqIC0+IHNlbmRzZWxmIG9iaiBuKVxubGV0IHNldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIHggLT4gQXJyYXkudW5zYWZlX3NldCBvYmogbiB4KVxubGV0IGFwcF9jb25zdCBmIHggPSByZXQgKGZ1biBfb2JqIC0+IGYgeClcbmxldCBhcHBfdmFyIGYgbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9lbnYgZiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfbWV0aCBmIG4gID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfY29uc3RfY29uc3QgZiB4IHkgPSByZXQgKGZ1biBfb2JqIC0+IGYgeCB5KVxubGV0IGFwcF9jb25zdF92YXIgZiB4IG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIHggKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9tZXRoIGYgeCBuID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF92YXJfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgeClcbmxldCBhcHBfbWV0aF9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikgeClcbmxldCBhcHBfY29uc3RfZW52IGYgeCBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIHggKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9lbnZfY29uc3QgZiBlIG4geCA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIHgpXG5sZXQgbWV0aF9hcHBfY29uc3QgbiB4ID0gcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgeClcbmxldCBtZXRoX2FwcF92YXIgbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG0pKVxubGV0IG1ldGhfYXBwX2VudiBuIGUgbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbSkpXG5sZXQgbWV0aF9hcHBfbWV0aCBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoc2VuZHNlbGYgb2JqIG0pKVxubGV0IHNlbmRfY29uc3QgbSB4IGMgPVxuICByZXQgKGZ1biBvYmogLT4gc2VuZGNhY2hlIHggbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX3ZhciBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSA6IG9iaikgbVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9lbnYgbSBlIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZVxuICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldFxuICAgICAgICAgICAgICAgICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgOiBvYmopXG4gICAgICBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfbWV0aCBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoc2VuZHNlbGYgb2JqIG4pIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgbmV3X2NhY2hlIHRhYmxlID1cbiAgbGV0IG4gPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gIGxldCBuID1cbiAgICBpZiBuIG1vZCAyID0gMCB8fCBuID4gMiArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplXG4gICAgdGhlbiBuIGVsc2UgbmV3X21ldGhvZCB0YWJsZVxuICBpblxuICB0YWJsZS5tZXRob2RzLihuKSA8LSBPYmoubWFnaWMgMDtcbiAgblxuXG50eXBlIGltcGwgPVxuICAgIEdldENvbnN0XG4gIHwgR2V0VmFyXG4gIHwgR2V0RW52XG4gIHwgR2V0TWV0aFxuICB8IFNldFZhclxuICB8IEFwcENvbnN0XG4gIHwgQXBwVmFyXG4gIHwgQXBwRW52XG4gIHwgQXBwTWV0aFxuICB8IEFwcENvbnN0Q29uc3RcbiAgfCBBcHBDb25zdFZhclxuICB8IEFwcENvbnN0RW52XG4gIHwgQXBwQ29uc3RNZXRoXG4gIHwgQXBwVmFyQ29uc3RcbiAgfCBBcHBFbnZDb25zdFxuICB8IEFwcE1ldGhDb25zdFxuICB8IE1ldGhBcHBDb25zdFxuICB8IE1ldGhBcHBWYXJcbiAgfCBNZXRoQXBwRW52XG4gIHwgTWV0aEFwcE1ldGhcbiAgfCBTZW5kQ29uc3RcbiAgfCBTZW5kVmFyXG4gIHwgU2VuZEVudlxuICB8IFNlbmRNZXRoXG4gIHwgQ2xvc3VyZSBvZiBjbG9zdXJlXG5cbmxldCBtZXRob2RfaW1wbCB0YWJsZSBpIGFyciA9XG4gIGxldCBuZXh0ICgpID0gaW5jciBpOyBtYWdpYyBhcnIuKCFpKSBpblxuICBtYXRjaCBuZXh0KCkgd2l0aFxuICAgIEdldENvbnN0IC0+IGxldCB4IDogdCA9IG5leHQoKSBpbiBnZXRfY29uc3QgeFxuICB8IEdldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF92YXIgblxuICB8IEdldEVudiAgIC0+IGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGdldF9lbnYgZSBuXG4gIHwgR2V0TWV0aCAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X21ldGggblxuICB8IFNldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIHNldF92YXIgblxuICB8IEFwcENvbnN0IC0+IGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGFwcF9jb25zdCBmIHhcbiAgfCBBcHBWYXIgICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX3ZhciBmIG5cbiAgfCBBcHBFbnYgICAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52IGYgZSBuXG4gIHwgQXBwTWV0aCAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF9tZXRoIGYgblxuICB8IEFwcENvbnN0Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCB5ID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfY29uc3QgZiB4IHlcbiAgfCBBcHBDb25zdFZhciAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF92YXIgZiB4IG5cbiAgfCBBcHBDb25zdEVudiAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfZW52IGYgeCBlIG5cbiAgfCBBcHBDb25zdE1ldGggLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfbWV0aCBmIHggblxuICB8IEFwcFZhckNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX3Zhcl9jb25zdCBmIG4geFxuICB8IEFwcEVudkNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnZfY29uc3QgZiBlIG4geFxuICB8IEFwcE1ldGhDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9tZXRoX2NvbnN0IGYgbiB4XG4gIHwgTWV0aEFwcENvbnN0IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBtZXRoX2FwcF9jb25zdCBuIHhcbiAgfCBNZXRoQXBwVmFyIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF92YXIgbiBtXG4gIHwgTWV0aEFwcEVudiAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW5cbiAgICAgIG1ldGhfYXBwX2VudiBuIGUgbVxuICB8IE1ldGhBcHBNZXRoIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF9tZXRoIG4gbVxuICB8IFNlbmRDb25zdCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gc2VuZF9jb25zdCBtIHggKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kVmFyIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF92YXIgbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZEVudiAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIHNlbmRfZW52IG0gZSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZE1ldGggLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX21ldGggbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgQ2xvc3VyZSBfIGFzIGNsbyAtPiBtYWdpYyBjbG9cblxubGV0IHNldF9tZXRob2RzIHRhYmxlIG1ldGhvZHMgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIG1ldGhvZHMgaW4gbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiBkb1xuICAgIGxldCBsYWJlbCA9IG1ldGhvZHMuKCFpKSBpbiBsZXQgY2xvID0gbWV0aG9kX2ltcGwgdGFibGUgaSBtZXRob2RzIGluXG4gICAgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBjbG87XG4gICAgaW5jciBpXG4gIGRvbmVcblxuKCoqKiogU3RhdGlzdGljcyAqKioqKVxuXG50eXBlIHN0YXRzID1cbiAgeyBjbGFzc2VzOiBpbnQ7IG1ldGhvZHM6IGludDsgaW5zdF92YXJzOiBpbnQ7IH1cblxubGV0IHN0YXRzICgpID1cbiAgeyBjbGFzc2VzID0gIXRhYmxlX2NvdW50O1xuICAgIG1ldGhvZHMgPSAhbWV0aG9kX2NvdW50OyBpbnN0X3ZhcnMgPSAhaW5zdF92YXJfY291bnQ7IH1cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0b2tlbiA9XG4gICAgS3dkIG9mIHN0cmluZ1xuICB8IElkZW50IG9mIHN0cmluZ1xuICB8IEludCBvZiBpbnRcbiAgfCBGbG9hdCBvZiBmbG9hdFxuICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgfCBDaGFyIG9mIGNoYXJcblxuKCogVGhlIHN0cmluZyBidWZmZXJpbmcgbWFjaGluZXJ5ICopXG5cbmxldCBpbml0aWFsX2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAzMlxuXG5sZXQgYnVmZmVyID0gcmVmIGluaXRpYWxfYnVmZmVyXG5sZXQgYnVmcG9zID0gcmVmIDBcblxubGV0IHJlc2V0X2J1ZmZlciAoKSA9IGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgYnVmcG9zIDo9IDBcblxubGV0IHN0b3JlIGMgPVxuICBpZiAhYnVmcG9zID49IEJ5dGVzLmxlbmd0aCAhYnVmZmVyIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3YnVmZmVyID0gQnl0ZXMuY3JlYXRlICgyICogIWJ1ZnBvcykgaW5cbiAgICBCeXRlcy5ibGl0ICFidWZmZXIgMCBuZXdidWZmZXIgMCAhYnVmcG9zO1xuICAgIGJ1ZmZlciA6PSBuZXdidWZmZXJcbiAgZW5kO1xuICBCeXRlcy5zZXQgIWJ1ZmZlciAhYnVmcG9zIGM7XG4gIGluY3IgYnVmcG9zXG5cbmxldCBnZXRfc3RyaW5nICgpID1cbiAgbGV0IHMgPSBCeXRlcy5zdWJfc3RyaW5nICFidWZmZXIgMCAhYnVmcG9zIGluIGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgc1xuXG4oKiBUaGUgbGV4ZXIgKilcblxubGV0IG1ha2VfbGV4ZXIga2V5d29yZHMgPVxuICBsZXQga3dkX3RhYmxlID0gSGFzaHRibC5jcmVhdGUgMTcgaW5cbiAgTGlzdC5pdGVyIChmdW4gcyAtPiBIYXNodGJsLmFkZCBrd2RfdGFibGUgcyAoS3dkIHMpKSBrZXl3b3JkcztcbiAgbGV0IGlkZW50X29yX2tleXdvcmQgaWQgPVxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIGlkIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiBJZGVudCBpZFxuICBhbmQga2V5d29yZF9vcl9lcnJvciBjID1cbiAgICBsZXQgcyA9IFN0cmluZy5tYWtlIDEgYyBpblxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIHMgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgKFwiSWxsZWdhbCBjaGFyYWN0ZXIgXCIgXiBzKSlcbiAgaW5cbiAgbGV0IHJlYyBuZXh0X3Rva2VuIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcgJyB8ICdcXDAxMCcgfCAnXFwwMTMnIHwgJ1xcMDA5JyB8ICdcXDAyNicgfCAnXFwwMTInKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IG5leHRfdG9rZW4gc3RybV9fXG4gICAgfCBTb21lICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ18nIHwgJ1xcMTkyJy4uJ1xcMjU1JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHwgJz4nIHxcbiAgICAgICAgICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnXFwnJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgY2hhciBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgJ1xcJycgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChDaGFyIGMpXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSAnXFxcIicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IFNvbWUgKFN0cmluZyAoc3RyaW5nIHMpKVxuICAgIHwgU29tZSAnLScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBuZWdfbnVtYmVyIHN0cm1fX1xuICAgIHwgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoa2V5d29yZF9vcl9lcnJvciBjKVxuICAgIHwgXyAtPiBOb25lXG4gIGFuZCBpZGVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ1xcMTkyJy4uJ1xcMjU1JyB8ICcwJy4uJzknIHwgJ18nIHwgJ1xcJycgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgaWRlbnQyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICctJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8XG4gICAgICAgICAnPicgfCAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIG5lZ19udW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IF8gLT4gbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IGlkZW50MiBzXG4gIGFuZCBudW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnLicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnLic7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoSW50IChpbnRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBkZWNpbWFsX3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGV4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJysnIHwgJy0nIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBlbmRfZXhwb25lbnRfcGFydCBzdHJtX19cbiAgYW5kIGVuZF9leHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBzdHJpbmcgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcIicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBnZXRfc3RyaW5nICgpXG4gICAgfCBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgY2hhciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgZXNjYXBlIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ24nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcbidcbiAgICB8IFNvbWUgJ3InIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xccidcbiAgICB8IFNvbWUgJ3QnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcdCdcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMxKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzIpIC0+XG4gICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMykgLT5cbiAgICAgICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICAgICAgQ2hhci5jaHJcbiAgICAgICAgICAgICAgICAgICgoQ2hhci5jb2RlIGMxIC0gNDgpICogMTAwICsgKENoYXIuY29kZSBjMiAtIDQ4KSAqIDEwICtcbiAgICAgICAgICAgICAgICAgICAgIChDaGFyLmNvZGUgYzMgLSA0OCkpXG4gICAgICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgbmV4dF90b2tlbiBzXG4gICAgfCBfIC0+IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgJygnKVxuICBhbmQgY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX25lc3RlZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9uZXN0ZWRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgY29tbWVudCBzXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfZW5kX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAoKVxuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGluXG4gIGZ1biBpbnB1dCAtPiBTdHJlYW0uZnJvbSAoZnVuIF9jb3VudCAtPiBuZXh0X3Rva2VuIGlucHV0KVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TZWVkZWRTXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgR2VuSGFzaFRhYmxlID0gc3RydWN0XG5cbiAgdHlwZSBlcXVhbCA9XG4gIHwgRVRydWUgfCBFRmFsc2VcbiAgfCBFRGVhZCAoKiogdGhlIGdhcmJhZ2UgY29sbGVjdG9yIHJlY2xhaW1lZCB0aGUgZGF0YSAqKVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkKEg6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgJ2EgY29udGFpbmVyXG4gICAgdmFsIGNyZWF0ZTogdCAtPiAnYSAtPiAnYSBjb250YWluZXJcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAnYSBjb250YWluZXIgLT4gdCAtPiBlcXVhbFxuICAgIHZhbCBnZXRfZGF0YTogJ2EgY29udGFpbmVyIC0+ICdhIG9wdGlvblxuICAgIHZhbCBnZXRfa2V5OiAnYSBjb250YWluZXIgLT4gdCBvcHRpb25cbiAgICB2YWwgc2V0X2tleV9kYXRhOiAnYSBjb250YWluZXIgLT4gdCAtPiAnYSAtPiB1bml0XG4gICAgdmFsIGNoZWNrX2tleTogJ2EgY29udGFpbmVyIC0+IGJvb2xcbiAgZW5kKSA6IFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudFxuICA9IHN0cnVjdFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICAgICAgbXV0YWJsZSBkYXRhOiAnYSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICAgICAgbXV0YWJsZSBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICAgICAgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gICAgICB9XG5cbiAgICBhbmQgJ2EgYnVja2V0bGlzdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgQ29ucyBvZiBpbnQgKCogaGFzaCBvZiB0aGUga2V5ICopICogJ2EgSC5jb250YWluZXIgKiAnYSBidWNrZXRsaXN0XG5cbiAgICAoKiogdGhlIGhhc2ggb2YgdGhlIGtleSBpcyBrZXB0IGluIG9yZGVyIHRvIHRlc3QgdGhlIGVxdWFsaXR5IG9mIHRoZSBoYXNoXG4gICAgICBiZWZvcmUgdGhlIGtleS4gU2FtZSByZWFzb24gYXMgZm9yIFdlYWsuTWFrZSAqKVxuXG4gICAgdHlwZSBrZXkgPSBILnRcblxuICAgIGxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICAgICAgaWYgeCA+PSBuIHRoZW4geFxuICAgICAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICAgICAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG4gICAgbGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuICAgIGxldCBjcmVhdGUgPyhyYW5kb20gPSAoSGFzaHRibC5pc19yYW5kb21pemVkICgpKSkgaW5pdGlhbF9zaXplID1cbiAgICAgIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgICAgIGxldCBzZWVkID0gaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykgZWxzZSAwIGluXG4gICAgICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbiAgICBsZXQgY2xlYXIgaCA9XG4gICAgICBoLnNpemUgPC0gMDtcbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICBkb25lXG5cbiAgICBsZXQgcmVzZXQgaCA9XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgaWYgbGVuID0gaC5pbml0aWFsX3NpemUgdGhlblxuICAgICAgICBjbGVhciBoXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSBoLmluaXRpYWxfc2l6ZSBFbXB0eVxuICAgICAgZW5kXG5cbiAgICBsZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5LmNvcHkgaC5kYXRhIH1cblxuICAgIGxldCBrZXlfaW5kZXggaCBoa2V5ID1cbiAgICAgIGhrZXkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgY2xlYW4gaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIG5vdCAoSC5jaGVja19rZXkgYykgLT5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgfCBDb25zKGhrZXksIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBDb25zKGhrZXksIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgKCoqIHJlc2l6ZSBpcyB0aGUgb25seSBmdW5jdGlvbiB0byBkbyB0aGUgYWN0dWFsIGNsZWFuaW5nIG9mIGRlYWQga2V5c1xuICAgICAgICAocmVtb3ZlIGRvZXMgaXQganVzdCBiZWNhdXNlIGl0IGNvdWxkKS5cblxuICAgICAgICBUaGUgZ29hbCBpcyB0bzpcblxuICAgICAgICAtIG5vdCByZXNpemUgaW5maW5pdGVseSB3aGVuIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGFsaXZlIGtleXMgaXNcbiAgICAgICAgYm91bmRlZCBidXQga2V5cyBhcmUgY29udGludW91c2x5IGFkZGVkLiBUaGF0IHdvdWxkIGhhcHBlbiBpZlxuICAgICAgICB0aGlzIGZ1bmN0aW9uIGFsd2F5cyByZXNpemUuXG4gICAgICAgIC0gbm90IGNhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciBlYWNoIGFkZGl0aW9uLCB0aGF0IHdvdWxkIGhhcHBlbiBpZiB0aGlzXG4gICAgICAgIGZ1bmN0aW9uIGRvbid0IHJlc2l6ZSBldmVuIHdoZW4gb25seSBvbmUga2V5IGlzIGRlYWQuXG5cbiAgICAgICAgU28gdGhlIGFsZ29yaXRobTpcbiAgICAgICAgLSBjbGVhbiB0aGUga2V5cyBiZWZvcmUgcmVzaXppbmdcbiAgICAgICAgLSBpZiB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBrZXlzIGlzIGxlc3MgdGhhbiBoYWxmIHRoZSBzaXplIG9mIHRoZVxuICAgICAgICBhcnJheSwgZG9uJ3QgcmVzaXplLlxuICAgICAgICAtIGlmIGl0IGlzIG1vcmUsIHJlc2l6ZS5cblxuICAgICAgICBUaGUgc2Vjb25kIHByb2JsZW0gcmVtYWlucyBpZiB0aGUgdGFibGUgcmVhY2hlcyB7IVN5cy5tYXhfYXJyYXlfbGVuZ3RofS5cblxuICAgICopXG4gICAgbGV0IHJlc2l6ZSBoID1cbiAgICAgIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICAgICAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gICAgICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgICAgIGNsZWFuIGg7XG4gICAgICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoICYmIGguc2l6ZSA+PSBvc2l6ZSBsc3IgMSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICAgICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAoKiBzbyB0aGF0IGtleV9pbmRleCBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgICAgIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgICAgIHwgQ29ucyhoa2V5LCBkYXRhLCByZXN0KSAtPlxuICAgICAgICAgICAgICBpbnNlcnRfYnVja2V0IHJlc3Q7ICgqIHByZXNlcnZlIG9yaWdpbmFsIG9yZGVyIG9mIGVsZW1lbnRzICopXG4gICAgICAgICAgICAgIGxldCBuaWR4ID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgICAgICAgICBuZGF0YS4obmlkeCkgPC0gQ29ucyhoa2V5LCBkYXRhLCBuZGF0YS4obmlkeCkpIGluXG4gICAgICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICAgICAgICBkb25lXG4gICAgICBlbmRcblxuICAgIGxldCBhZGQgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnMoaGtleSwgY29udGFpbmVyLCBoLmRhdGEuKGkpKSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBoLnNpemUgPC0gaC5zaXplIC0gMTsgbmV4dFxuICAgICAgICAgICAgfCBFRmFsc2UgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KVxuICAgICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICAgICgqIFRoZSBkZWFkIGtleSBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuIEl0IGlzIGFjY2VwdGFibGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIHRoaXMgZnVuY3Rpb24gc2luY2UgaXQgYWxyZWFkeSByZW1vdmVzIGEgYmluZGluZyAqKVxuICAgICAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgICAgIHJlbW92ZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhoayxjLG5leHQpIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dCkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgaC5kYXRhLihpKSA8LSByZW1vdmVfYnVja2V0IGguZGF0YS4oaSlcblxuICAgICgqKiB7IWZpbmR9IGRvbid0IHJlbW92ZSBkZWFkIGtleXMgYmVjYXVzZSBpdCB3b3VsZCBiZSBzdXJwcmlzaW5nIGZvclxuICAgICAgICB0aGUgdXNlciB0aGF0IGEgcmVhZC1vbmx5IGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHN0YXRlIChlZy4gY29uY3VycmVudFxuICAgICAgICBhY2Nlc3MpLiBTYW1lIGZvciB7IWl0ZXJ9LCB7IWZvbGR9LCB7IW1lbX0uXG4gICAgKilcbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlYyBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gW11cbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZDo6ZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gSC5zZXRfa2V5X2RhdGEgYyBrZXkgaW5mb1xuICAgICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKF8sXyxuZXh0KSAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIHRyeVxuICAgICAgICByZXBsYWNlX2J1Y2tldCBsXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25zKGhrZXksIGNvbnRhaW5lciwgbCk7XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrID0gaGtleSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gdHJ1ZVxuICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gbWVtX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoX2hrLCBfYywgcmVzdCkgLT4gbWVtX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuICAgIGxldCBpdGVyIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgICgpXG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+ICgpXG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkXG4gICAgICAgICAgICBlbmQ7IGRvX2J1Y2tldCByZXN0IGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBmb2xkIGYgaCBpbml0ID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgICAgIG1hdGNoIGIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgICBhY2N1XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbGV0IGFjY3UgPSBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhY2N1XG4gICAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGQgYWNjdVxuICAgICAgICAgICAgZW5kIGluXG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdCBhY2N1ICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgYWNjdSA6PSBkb19idWNrZXQgZC4oaSkgIWFjY3VcbiAgICAgIGRvbmU7XG4gICAgICAhYWNjdVxuXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT5cbiAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPlxuICAgICAgICAgICAgICAgIG1hdGNoIGYgayBkIHdpdGhcbiAgICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgICB8IFNvbWUgbmV3X2QgLT5cbiAgICAgICAgICAgICAgICAgICAgSC5zZXRfa2V5X2RhdGEgYyBrIG5ld19kO1xuICAgICAgICAgICAgICAgICAgICBDb25zKGhrLCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIHJlc3RcblxuICAgIGxldCBzdGF0cyBoID1cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIEguY2hlY2tfa2V5IGMgLT5cbiAgICAgICAgICBidWNrZXRfbGVuZ3RoX2FsaXZlIChhY2N1ICsgMSkgcmVzdFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSByZXN0XG5cbiAgICBsZXQgc3RhdHNfYWxpdmUgaCA9XG4gICAgICBsZXQgc2l6ZSA9IHJlZiAwIGluXG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiIGluXG4gICAgICAgICAgIHNpemUgOj0gIXNpemUgKyBsO1xuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9ICFzaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHRvX3NlcSB0YmwgPVxuICAgICAgKCogY2FwdHVyZSBjdXJyZW50IGFycmF5LCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgd2VcbiAgICAgICAgIGtlZXAgaXRlcmF0aW5nIG9uIHRoZSBzYW1lIGFycmF5ICopXG4gICAgICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAgICAgKCogc3RhdGU6IGluZGV4ICogbmV4dCBidWNrZXQgdG8gdHJhdmVyc2UgKilcbiAgICAgIGxldCByZWMgYXV4IGkgYnVjayAoKSA9IG1hdGNoIGJ1Y2sgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRibF9kYXRhXG4gICAgICAgICAgICB0aGVuIFNlcS5OaWxcbiAgICAgICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgICAgIHwgQ29ucyAoXywgYywgbmV4dCkgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IGF1eCBpIG5leHQgKClcbiAgICAgICAgICAgICAgfCBTb21lIGtleSwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgICAgICAgICBTZXEuQ29ucyAoKGtleSwgZGF0YSksIGF1eCBpIG5leHQpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBhdXggMCBFbXB0eVxuXG4gICAgbGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbiAgICBsZXQgdG9fc2VxX3ZhbHVlcyBtID0gU2VxLm1hcCBzbmQgKHRvX3NlcSBtKVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICBlbmRcbmVuZFxuXG5tb2R1bGUgT2JqRXBoID0gT2JqLkVwaGVtZXJvblxuXG5sZXQgX29ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT5cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiB4XG4gIHwgU29tZSB2IC0+IFNvbWUgKE9iai5vYmogdilcblxuKCoqIFRoZSBwcmV2aW91cyBmdW5jdGlvbiBpcyB0eXBlZCBzbyB0aGlzIG9uZSBpcyBhbHNvIGNvcnJlY3QgKilcbmxldCBvYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+IE9iai5tYWdpYyB4XG5cblxubW9kdWxlIEsxID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAxXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKGs6J2spIDogdW5pdCA9IE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAodDI6KCdrLCdkKSB0KTogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXywnZCkgdCkgKHQyOihfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCA9IEguaGFzaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgICgqIHshZ2V0X2tleV9jb3B5fSBpcyBub3QgdXNlZCBiZWNhdXNlIHRoZSBlcXVhbGl0eSBvZiB0aGUgdXNlciBjYW4gYmVcbiAgICAgICAgICAgIHRoZSBwaHlzaWNhbCBlcXVhbGl0eSAqKVxuICAgICAgICBtYXRjaCBnZXRfa2V5IGMgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrJyAtPlxuICAgICAgICAgICAgaWYgSC5lcXVhbCBrIGsnIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5ID0gZ2V0X2tleVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSA9IGNoZWNrX2tleVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLMiA9IHN0cnVjdFxuICB0eXBlICgnazEsICdrMiwgJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2sxLCdrMiwnZCkgdCA9IE9iakVwaC5jcmVhdGUgMlxuXG4gIGxldCBnZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleTFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSAoazonazEpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGdldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDEpXG4gIGxldCBnZXRfa2V5Ml9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAxKVxuICBsZXQgc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMikgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDEgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMVxuICBsZXQgY2hlY2tfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDFcblxuXG4gIGxldCBibGl0X2tleTEgKHQxOignazEsXyxfKSB0KSAodDI6KCdrMSxfLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG4gIGxldCBibGl0X2tleTIgKHQxOihfLCdrMixfKSB0KSAodDI6KF8sJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDEgdDIgMSAxXG4gIGxldCBibGl0X2tleTEyICh0MTooJ2sxLCdrMixfKSB0KSAodDI6KCdrMSwnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDJcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSAoZDonZCkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sXywnZCkgdCkgKHQyOihfLF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZFxuICAgICAgKEgxOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSlcbiAgICAgIChIMjpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgxLnQsSDIudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSDEudCAqIEgyLnRcbiAgICAgIGxldCBjcmVhdGUgKGsxLGsyKSBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIChrMSxrMikgPVxuICAgICAgICBIMS5oYXNoIHNlZWQgazEgKyBIMi5oYXNoIHNlZWQgazIgKiA2NTU5OVxuICAgICAgbGV0IGVxdWFsIGMgKGsxLGsyKSA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT5cbiAgICAgICAgICAgIGlmIEgxLmVxdWFsIGsxIGsxJyAmJiBIMi5lcXVhbCBrMiBrMidcbiAgICAgICAgICAgIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPiBTb21lIChrMScsIGsyJylcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyAoazEsazIpIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID0gY2hlY2tfa2V5MSBjICYmIGNoZWNrX2tleTIgY1xuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIMTogSGFzaHRibC5IYXNoZWRUeXBlKShIMjogSGFzaHRibC5IYXNoZWRUeXBlKTpcbiAgICAoUyB3aXRoIHR5cGUga2V5ID0gSDEudCAqIEgyLnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMS50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDEuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgxLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMi50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDIuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgyLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEtuID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlIG4gOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIG5cbiAgbGV0IGxlbmd0aCAoazooJ2ssJ2QpIHQpIDogaW50ID0gT2JqRXBoLmxlbmd0aCBrXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCBuKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IG4pXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSAoazonaykgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IG4gKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCBuXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCBuXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpIChvMTppbnQpICh0MjooJ2ssJ2QpIHQpIChvMjppbnQpIChsOmludCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgbzEgdDIgbzIgbFxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnQgYXJyYXlcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKEFycmF5Lmxlbmd0aCBrKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCBrID1cbiAgICAgICAgbGV0IGggPSByZWYgMCBpblxuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgaCA6PSBILmhhc2ggc2VlZCBrLihpKSAqIDY1NTk5ICsgIWg7XG4gICAgICAgIGRvbmU7XG4gICAgICAgICFoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgbGV0IGxlbiAgPSBBcnJheS5sZW5ndGggayBpblxuICAgICAgICBsZXQgbGVuJyA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiAhPSBsZW4nIHRoZW4gR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHJlYyBlcXVhbF9hcnJheSBrIGMgaSA9XG4gICAgICAgICAgICBpZiBpIDwgMCB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGsuKGkpIGtpXG4gICAgICAgICAgICAgICAgICB0aGVuIGVxdWFsX2FycmF5IGsgYyAoaS0xKVxuICAgICAgICAgICAgICAgICAgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgICAgaW5cbiAgICAgICAgICBlcXVhbF9hcnJheSBrIGMgKGxlbi0xKVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBsZXQgbGVuID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuID0gMCB0aGVuIFNvbWUgW3x8XVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIDAgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIGswIC0+XG4gICAgICAgICAgICAgIGxldCByZWMgZmlsbCBhIGkgPVxuICAgICAgICAgICAgICAgIGlmIGkgPCAxIHRoZW4gU29tZSBhXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgICAgIGEuKGkpIDwtIGtpO1xuICAgICAgICAgICAgICAgICAgICAgIGZpbGwgYSAoaS0xKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgYSA9IEFycmF5Lm1ha2UgbGVuIGswIGluXG4gICAgICAgICAgICAgIGZpbGwgYSAobGVuLTEpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID1cbiAgICAgICAgbGV0IHJlYyBjaGVjayBjIGkgPVxuICAgICAgICAgIGkgPCAwIHx8IChjaGVja19rZXkgYyBpICYmIGNoZWNrIGMgKGktMSkpIGluXG4gICAgICAgIGNoZWNrIGMgKGxlbmd0aCBjIC0gMSlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCBhcnJheSkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgZW5kXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBNYXJrIFNoaW53ZWxsIGFuZCBMZW8gV2hpdGUsIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTUtLTIwMTYgSmFuZSBTdHJlZXQgR3JvdXAgTExDICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgc3BhY2V0aW1lX2VuYWJsZWQgOiB1bml0IC0+IGJvb2xcbiAgPSBcImNhbWxfc3BhY2V0aW1lX2VuYWJsZWRcIiBbQEBub2FsbG9jXVxuXG5sZXQgZW5hYmxlZCA9IHNwYWNldGltZV9lbmFibGVkICgpXG5cbmxldCBpZl9zcGFjZXRpbWVfZW5hYmxlZCBmID1cbiAgaWYgZW5hYmxlZCB0aGVuIGYgKCkgZWxzZSAoKVxuXG5tb2R1bGUgU2VyaWVzID0gc3RydWN0XG4gIHR5cGUgdCA9IHtcbiAgICBjaGFubmVsIDogb3V0X2NoYW5uZWw7XG4gICAgbXV0YWJsZSBjbG9zZWQgOiBib29sO1xuICB9XG5cbiAgZXh0ZXJuYWwgd3JpdGVfbWFnaWNfbnVtYmVyIDogb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3dyaXRlX21hZ2ljX251bWJlclwiXG5cbiAgZXh0ZXJuYWwgcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIDogb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZVwiXG5cbiAgbGV0IGNyZWF0ZSB+cGF0aCA9XG4gICAgaWYgc3BhY2V0aW1lX2VuYWJsZWQgKCkgdGhlbiBiZWdpblxuICAgICAgbGV0IGNoYW5uZWwgPSBvcGVuX291dCBwYXRoIGluXG4gICAgICByZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgY2hhbm5lbDtcbiAgICAgIGxldCB0ID1cbiAgICAgICAgeyBjaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgICBjbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgaW5cbiAgICAgIHdyaXRlX21hZ2ljX251bWJlciB0LmNoYW5uZWw7XG4gICAgICB0XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHsgY2hhbm5lbCA9IHN0ZG91dDsgICgqIGFyYml0cmFyeSB2YWx1ZSAqKVxuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIGVuZFxuXG4gIGV4dGVybmFsIHNhdmVfZXZlbnQgOiA/dGltZTpmbG9hdCAtPiBvdXRfY2hhbm5lbCAtPiBldmVudF9uYW1lOnN0cmluZyAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfc2F2ZV9ldmVudFwiXG5cbiAgbGV0IHNhdmVfZXZlbnQgP3RpbWUgdCB+ZXZlbnRfbmFtZSA9XG4gICAgaWZfc3BhY2V0aW1lX2VuYWJsZWQgKGZ1biAoKSAtPlxuICAgICAgc2F2ZV9ldmVudCA/dGltZSB0LmNoYW5uZWwgfmV2ZW50X25hbWUpXG5cbiAgZXh0ZXJuYWwgc2F2ZV90cmllIDogP3RpbWU6ZmxvYXQgLT4gb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3NhdmVfdHJpZVwiXG5cbiAgbGV0IHNhdmVfYW5kX2Nsb3NlID90aW1lIHQgPVxuICAgIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICAgIGlmIHQuY2xvc2VkIHRoZW4gZmFpbHdpdGggXCJTZXJpZXMgaXMgY2xvc2VkXCI7XG4gICAgICBzYXZlX3RyaWUgP3RpbWUgdC5jaGFubmVsO1xuICAgICAgY2xvc2Vfb3V0IHQuY2hhbm5lbDtcbiAgICAgIHQuY2xvc2VkIDwtIHRydWUpXG5lbmRcblxubW9kdWxlIFNuYXBzaG90ID0gc3RydWN0XG4gIGV4dGVybmFsIHRha2UgOiA/dGltZTpmbG9hdCAtPiBvdXRfY2hhbm5lbCAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfdGFrZV9zbmFwc2hvdFwiXG5cbiAgbGV0IHRha2UgP3RpbWUgeyBTZXJpZXMuY2xvc2VkOyBjaGFubmVsIH0gPVxuICAgIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICAgIGlmIGNsb3NlZCB0aGVuIGZhaWx3aXRoIFwiU2VyaWVzIGlzIGNsb3NlZFwiO1xuICAgICAgR2MubWlub3IgKCk7XG4gICAgICB0YWtlID90aW1lIGNoYW5uZWwpXG5lbmRcblxuZXh0ZXJuYWwgc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyA6IGV2ZW50X25hbWU6c3RyaW5nIC0+IHVuaXRcbiAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICBcImNhbWxfc3BhY2V0aW1lX3NhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHNcIlxuXG5sZXQgc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyB+ZXZlbnRfbmFtZSA9XG4gIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICBzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzIH5ldmVudF9uYW1lKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIE1hbnVlbCBTZXJyYW5vIGV0IFhhdmllciBMZXJveSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0JpZ2FycmF5XTogbGFyZ2UsIG11bHRpLWRpbWVuc2lvbmFsLCBudW1lcmljYWwgYXJyYXlzICopXG5cbigqIFRoZXNlIHR5cGVzIGluIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIHRhYmxlcyBpblxuICAgLi4vdHlwaW5nL3R5cGVvcHQubWwgKilcblxudHlwZSBmbG9hdDMyX2VsdCA9IEZsb2F0MzJfZWx0XG50eXBlIGZsb2F0NjRfZWx0ID0gRmxvYXQ2NF9lbHRcbnR5cGUgaW50OF9zaWduZWRfZWx0ID0gSW50OF9zaWduZWRfZWx0XG50eXBlIGludDhfdW5zaWduZWRfZWx0ID0gSW50OF91bnNpZ25lZF9lbHRcbnR5cGUgaW50MTZfc2lnbmVkX2VsdCA9IEludDE2X3NpZ25lZF9lbHRcbnR5cGUgaW50MTZfdW5zaWduZWRfZWx0ID0gSW50MTZfdW5zaWduZWRfZWx0XG50eXBlIGludDMyX2VsdCA9IEludDMyX2VsdFxudHlwZSBpbnQ2NF9lbHQgPSBJbnQ2NF9lbHRcbnR5cGUgaW50X2VsdCA9IEludF9lbHRcbnR5cGUgbmF0aXZlaW50X2VsdCA9IE5hdGl2ZWludF9lbHRcbnR5cGUgY29tcGxleDMyX2VsdCA9IENvbXBsZXgzMl9lbHRcbnR5cGUgY29tcGxleDY0X2VsdCA9IENvbXBsZXg2NF9lbHRcblxudHlwZSAoJ2EsICdiKSBraW5kID1cbiAgICBGbG9hdDMyIDogKGZsb2F0LCBmbG9hdDMyX2VsdCkga2luZFxuICB8IEZsb2F0NjQgOiAoZmxvYXQsIGZsb2F0NjRfZWx0KSBraW5kXG4gIHwgSW50OF9zaWduZWQgOiAoaW50LCBpbnQ4X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3Vuc2lnbmVkIDogKGludCwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl9zaWduZWQgOiAoaW50LCBpbnQxNl9zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MTZfdW5zaWduZWQgOiAoaW50LCBpbnQxNl91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQzMiA6IChpbnQzMiwgaW50MzJfZWx0KSBraW5kXG4gIHwgSW50NjQgOiAoaW50NjQsIGludDY0X2VsdCkga2luZFxuICB8IEludCA6IChpbnQsIGludF9lbHQpIGtpbmRcbiAgfCBOYXRpdmVpbnQgOiAobmF0aXZlaW50LCBuYXRpdmVpbnRfZWx0KSBraW5kXG4gIHwgQ29tcGxleDMyIDogKENvbXBsZXgudCwgY29tcGxleDMyX2VsdCkga2luZFxuICB8IENvbXBsZXg2NCA6IChDb21wbGV4LnQsIGNvbXBsZXg2NF9lbHQpIGtpbmRcbiAgfCBDaGFyIDogKGNoYXIsIGludDhfdW5zaWduZWRfZWx0KSBraW5kXG5cbnR5cGUgY19sYXlvdXQgPSBDX2xheW91dF90eXBcbnR5cGUgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dF90eXAgKCoqKVxuXG50eXBlICdhIGxheW91dCA9XG4gICAgQ19sYXlvdXQ6IGNfbGF5b3V0IGxheW91dFxuICB8IEZvcnRyYW5fbGF5b3V0OiBmb3J0cmFuX2xheW91dCBsYXlvdXRcblxuKCogS2VlcCB0aG9zZSBjb25zdGFudHMgaW4gc3luYyB3aXRoIHRoZSBjYW1sX2JhX2tpbmQgZW51bWVyYXRpb25cbiAgIGluIGJpZ2FycmF5LmggKilcblxubGV0IGZsb2F0MzIgPSBGbG9hdDMyXG5sZXQgZmxvYXQ2NCA9IEZsb2F0NjRcbmxldCBpbnQ4X3NpZ25lZCA9IEludDhfc2lnbmVkXG5sZXQgaW50OF91bnNpZ25lZCA9IEludDhfdW5zaWduZWRcbmxldCBpbnQxNl9zaWduZWQgPSBJbnQxNl9zaWduZWRcbmxldCBpbnQxNl91bnNpZ25lZCA9IEludDE2X3Vuc2lnbmVkXG5sZXQgaW50MzIgPSBJbnQzMlxubGV0IGludDY0ID0gSW50NjRcbmxldCBpbnQgPSBJbnRcbmxldCBuYXRpdmVpbnQgPSBOYXRpdmVpbnRcbmxldCBjb21wbGV4MzIgPSBDb21wbGV4MzJcbmxldCBjb21wbGV4NjQgPSBDb21wbGV4NjRcbmxldCBjaGFyID0gQ2hhclxuXG5sZXQga2luZF9zaXplX2luX2J5dGVzIDogdHlwZSBhIGIuIChhLCBiKSBraW5kIC0+IGludCA9IGZ1bmN0aW9uXG4gIHwgRmxvYXQzMiAtPiA0XG4gIHwgRmxvYXQ2NCAtPiA4XG4gIHwgSW50OF9zaWduZWQgLT4gMVxuICB8IEludDhfdW5zaWduZWQgLT4gMVxuICB8IEludDE2X3NpZ25lZCAtPiAyXG4gIHwgSW50MTZfdW5zaWduZWQgLT4gMlxuICB8IEludDMyIC0+IDRcbiAgfCBJbnQ2NCAtPiA4XG4gIHwgSW50IC0+IFN5cy53b3JkX3NpemUgLyA4XG4gIHwgTmF0aXZlaW50IC0+IFN5cy53b3JkX3NpemUgLyA4XG4gIHwgQ29tcGxleDMyIC0+IDhcbiAgfCBDb21wbGV4NjQgLT4gMTZcbiAgfCBDaGFyIC0+IDFcblxuKCogS2VlcCB0aG9zZSBjb25zdGFudHMgaW4gc3luYyB3aXRoIHRoZSBjYW1sX2JhX2xheW91dCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgY19sYXlvdXQgPSBDX2xheW91dFxubGV0IGZvcnRyYW5fbGF5b3V0ID0gRm9ydHJhbl9sYXlvdXRcblxubW9kdWxlIEdlbmFycmF5ID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcbiAgZXh0ZXJuYWwgY3JlYXRlOiAoJ2EsICdiKSBraW5kIC0+ICdjIGxheW91dCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgPSBcImNhbWxfYmFfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgYXJyYXkgLT4gJ2FcbiAgICAgPSBcImNhbWxfYmFfZ2V0X2dlbmVyaWNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYSAtPiB1bml0XG4gICAgID0gXCJjYW1sX2JhX3NldF9nZW5lcmljXCJcbiAgZXh0ZXJuYWwgbnVtX2RpbXM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiY2FtbF9iYV9udW1fZGltc1wiXG4gIGV4dGVybmFsIG50aF9kaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfYmFfZGltXCJcbiAgbGV0IGRpbXMgYSA9XG4gICAgbGV0IG4gPSBudW1fZGltcyBhIGluXG4gICAgbGV0IGQgPSBBcnJheS5tYWtlIG4gMCBpblxuICAgIGZvciBpID0gMCB0byBuLTEgZG8gZC4oaSkgPC0gbnRoX2RpbSBhIGkgZG9uZTtcbiAgICBkXG5cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChBcnJheS5mb2xkX2xlZnQgKCAqICkgMSAoZGltcyBhcnIpKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzbGljZV9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBzbGljZV9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbmVuZFxuXG5tb2R1bGUgQXJyYXkwID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0ID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3x8XVxuICBsZXQgZ2V0IGFyciA9IEdlbmFycmF5LmdldCBhcnIgW3x8XVxuICBsZXQgc2V0IGFyciA9IEdlbmFycmF5LnNldCBhcnIgW3x8XVxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9IGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpXG5cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcblxuICBsZXQgb2ZfdmFsdWUga2luZCBsYXlvdXQgdiA9XG4gICAgbGV0IGEgPSBjcmVhdGUga2luZCBsYXlvdXQgaW5cbiAgICBzZXQgYSB2O1xuICAgIGFcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8xXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzFcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzFcIlxuICBleHRlcm5hbCBkaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0gYXJyKVxuXG4gIGV4dGVybmFsIHN1YjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCAnYykgdCA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2UgKHR5cGUgdCkgKGEgOiAoXywgXywgdCkgR2VuYXJyYXkudCkgbiA9XG4gICAgbWF0Y2ggbGF5b3V0IGEgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XSA6IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF06IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IChBcnJheS5sZW5ndGggZGF0YSkgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkYXRhIC0gMSBkbyB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSBkYXRhLihpKSBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTJ8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8yXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzJcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdCBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0IGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkyLm9mX2FycmF5OiBub24tcmVjdGFuZ3VsYXIgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgcm93LihqKVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkzID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yOyBkaW0zfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3NldF8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfM1wiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwgZGltMzogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fM1wiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycikgKiAoZGltMyBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9sZWZ0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBkaW0zID0gaWYgZGltMiA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIGxldCBjb2wgPSByb3cuKGopIGluXG4gICAgICAgIGlmIEFycmF5Lmxlbmd0aCBjb2wgPD4gZGltMyB0aGVuXG4gICAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgICBmb3IgayA9IDAgdG8gZGltMyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgKGsgKyBvZnMpIGNvbC4oaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTA6ICgnYSwgJ2IsICdjKSBBcnJheTAudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTE6ICgnYSwgJ2IsICdjKSBBcnJheTEudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTI6ICgnYSwgJ2IsICdjKSBBcnJheTIudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTM6ICgnYSwgJ2IsICdjKSBBcnJheTMudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5sZXQgYXJyYXkwX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMCB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MF9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkxX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMSB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MV9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkyX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMiB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5Ml9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkzX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMyB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5M19vZl9nZW5hcnJheVwiXG5cbmV4dGVybmFsIHJlc2hhcGU6XG4gICAoJ2EsICdiLCAnYykgR2VuYXJyYXkudCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCJjYW1sX2JhX3Jlc2hhcGVcIlxubGV0IHJlc2hhcGVfMCBhID0gcmVzaGFwZSBhIFt8fF1cbmxldCByZXNoYXBlXzEgYSBkaW0xID0gcmVzaGFwZSBhIFt8ZGltMXxdXG5sZXQgcmVzaGFwZV8yIGEgZGltMSBkaW0yID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yfF1cbmxldCByZXNoYXBlXzMgYSBkaW0xIGRpbTIgZGltMyA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMjtkaW0zfF1cblxuKCogRm9yY2UgY2FtbF9iYV9nZXRfezEsMiwzLE59IHRvIGJlIGxpbmtlZCBpbiwgc2luY2Ugd2UgZG9uJ3QgcmVmZXJcbiAgIHRvIHRob3NlIHByaW1pdGl2ZXMgZGlyZWN0bHkgaW4gdGhpcyBmaWxlICopXG5cbmxldCBfID1cbiAgbGV0IF8gPSBHZW5hcnJheS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTEuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkyLmdldCBpblxuICBsZXQgXyA9IEFycmF5My5nZXQgaW5cbiAgKClcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbmV4dGVybmFsIGdldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMVwiXG5leHRlcm5hbCBnZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzJcIlxuZXh0ZXJuYWwgZ2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8zXCJcbmV4dGVybmFsIHNldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMVwiXG5leHRlcm5hbCBzZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzJcIlxuZXh0ZXJuYWwgc2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8zXCJcbiIsIiMgMSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4oKiBDb3B5cmlnaHQgMjAxNy0yMDE4IFZpbmNlbnQgSmFjcXVlcyA8dmluY2VudEB2aW5jZW50LWphY3F1ZXMubmV0PiAqKVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4jIDEgXCJzcmMvUy5pbmNsLm1saVwiXG4oKiBDb3B5cmlnaHQgMjAxNy0yMDE4IFZpbmNlbnQgSmFjcXVlcyA8dmluY2VudEB2aW5jZW50LWphY3F1ZXMubmV0PiAqKVxuXG4oKiBPcGVyYXRpb25zIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTDUgY2FudmFzLlxuV2Ugd2lsbCBwcm9iYWJseSBub3QgdHJ5IHRvIGltcGxlbWVudCB0aGVzZSBmdW5jdGlvbnMuXG5cbnR5cGUgYW50aWFsaWFzID0gQU5USUFMSUFTX0RFRkFVTFQgfCBBTlRJQUxJQVNfTk9ORSB8IEFOVElBTElBU19HUkFZIHwgQU5USUFMSUFTX1NVQlBJWEVMXG52YWwgc2V0X2FudGlhbGlhczogY29udGV4dCAtPiBhbnRpYWxpYXMgLT4gdW5pdFxudmFsIGdldF9hbnRpYWxpYXM6IGNvbnRleHQgLT4gYW50aWFsaWFzXG5cbnZhbCBjbGlwX3Jlc2V0OiBjb250ZXh0IC0+IHVuaXRcblxudmFsIHNldF90b2xlcmFuY2U6IGNvbnRleHQgLT4gZmxvYXQgLT4gdW5pdFxudmFsIGdldF90b2xlcmFuY2U6IGNvbnRleHQgLT4gZmxvYXRcblxudmFsIGNvcHlfcGFnZTogY29udGV4dCAtPiB1bml0XG52YWwgc2hvd19wYWdlOiBjb250ZXh0IC0+IHVuaXRcblxudmFsIG1hc2s6IGNvbnRleHQgLT4gJ2EgUGF0dGVybi50IC0+IHVuaXRcbnZhbCBtYXNrX3N1cmZhY2U6IGNvbnRleHQgLT4gU3VyZmFjZS50IC0+IHg6ZmxvYXQgLT4geTpmbG9hdCAtPiB1bml0XG5cbnZhbCBjbGlwX2V4dGVudHM6IGNvbnRleHQgLT4gcmVjdGFuZ2xlXG52YWwgY2xpcF9yZWN0YW5nbGVfbGlzdDogY29udGV4dCAtPiByZWN0YW5nbGUgbGlzdFxuXG52YWwgZmlsbF9leHRlbnRzOiBjb250ZXh0IC0+IHJlY3RhbmdsZVxudmFsIGluX2ZpbGw6IGNvbnRleHQgLT4geDpmbG9hdCAtPiB5OmZsb2F0IC0+IGJvb2xcblxudmFsIHN0cm9rZV9leHRlbnRzOiBjb250ZXh0IC0+IHJlY3RhbmdsZVxudmFsIGluX3N0cm9rZTogY29udGV4dCAtPiB4OmZsb2F0IC0+IHk6ZmxvYXQgLT4gYm9vbFxuXG5tb2R1bGUgUGF0dGVybjogc2lnXG4gIHR5cGUgZXh0ZW5kID0gTk9ORSB8IFJFUEVBVCB8IFJFRkxFQ1QgfCBQQURcbiAgdmFsIHNldF9leHRlbmQ6ICdhIHQgLT4gZXh0ZW5kIC0+IHVuaXRcbiAgdmFsIGdldF9leHRlbmQ6ICdhIHQgLT4gZXh0ZW5kXG5cbiAgdHlwZSBmaWx0ZXIgPSBGQVNUIHwgR09PRCB8IEJFU1QgfCBORUFSRVNUIHwgQklMSU5FQVJcbiAgdmFsIHNldF9maWx0ZXI6ICdhIHQgLT4gZmlsdGVyIC0+IHVuaXRcbiAgdmFsIGdldF9maWx0ZXI6ICdhIHQgLT4gZmlsdGVyXG4gIHZhbCBzZXRfbWF0cml4OiAnYSB0IC0+IE1hdHJpeC50IC0+IHVuaXRcbiAgdmFsIGdldF9tYXRyaXg6ICdhIHQgLT4gTWF0cml4LnRcblxuICBJIHRyaWVkIGltcGxlbWVudGluZyBzdXJmYWNlIHBhdHRlcm5zIHVzaW5nIGNyZWF0ZVBhdHRlcm4gd2l0aCBhIG5ldyBjYW52YXMgZWxlbWVudCwgYnV0OlxuICAtIHRoZSByZXBlYXQgb3B0aW9ucyBkb24ndCBtYXRjaCB0eXBlIGV4dGVuZFxuICAtIHRoZXJlIGlzIG5vIHN1cHBvcnQgZm9yIHRyYW5zZm9ybWF0aW9ucyAob25seSBhbiBleHBlcmltZW50YWwgc2V0VHJhbnNmb3JtIGluIEZpcmVmb3gpXG4gIHNvIEkgY291bGRuJ3QgaW1wbGVtZW50IHNldF9tYXRyaXggYW5kIHRoZSB4IGFuZCB5IHBhcmFtZXRlcnMgb2Ygc2V0X3NvdXJjZV9zdXJmYWNlLlxuXG4gIHZhbCBjcmVhdGVfZm9yX3N1cmZhY2U6IFN1cmZhY2UudCAtPiBbYFN1cmZhY2VdIHRcbiAgdmFsIGdldF9zdXJmYWNlOiBbYFN1cmZhY2VdIHQgLT4gU3VyZmFjZS50XG5lbmRcblxudmFsIHNldF9zb3VyY2Vfc3VyZmFjZTogY29udGV4dCAtPiBTdXJmYWNlLnQgLT4geDpmbG9hdCAtPiB5OmZsb2F0IC0+IHVuaXRcblxuKilcblxuKCogT3RoZXIgdHlwZXMgYW5kIGZ1bmN0aW9ucyBjb21tZW50ZWQgb3V0IGJlbG93IGhhdmUgbm90IGJlZW4gYW5hbHl6ZWQgeWV0LlxuVGhleSBtYXkgb3IgbWF5IG5vdCBiZSBpbXBsZW1lbnRlZCBsYXRlci4gKilcblxudHlwZSBzdGF0dXMgPSBJTlZBTElEX1JFU1RPUkUgfCBJTlZBTElEX1BPUF9HUk9VUCB8IE5PX0NVUlJFTlRfUE9JTlQgfCBJTlZBTElEX01BVFJJWCB8IElOVkFMSURfU1RBVFVTIHwgTlVMTF9QT0lOVEVSIHwgSU5WQUxJRF9TVFJJTkcgfCBJTlZBTElEX1BBVEhfREFUQSB8IFJFQURfRVJST1IgfCBXUklURV9FUlJPUiB8IFNVUkZBQ0VfRklOSVNIRUQgfCBTVVJGQUNFX1RZUEVfTUlTTUFUQ0ggfCBQQVRURVJOX1RZUEVfTUlTTUFUQ0ggfCBJTlZBTElEX0NPTlRFTlQgfCBJTlZBTElEX0ZPUk1BVCB8IElOVkFMSURfVklTVUFMIHwgRklMRV9OT1RfRk9VTkQgfCBJTlZBTElEX0RBU0ggfCBJTlZBTElEX0RTQ19DT01NRU5UIHwgSU5WQUxJRF9JTkRFWCB8IENMSVBfTk9UX1JFUFJFU0VOVEFCTEUgfCBURU1QX0ZJTEVfRVJST1IgfCBJTlZBTElEX1NUUklERSB8IEZPTlRfVFlQRV9NSVNNQVRDSCB8IFVTRVJfRk9OVF9JTU1VVEFCTEUgfCBVU0VSX0ZPTlRfRVJST1IgfCBORUdBVElWRV9DT1VOVCB8IElOVkFMSURfQ0xVU1RFUlMgfCBJTlZBTElEX1NMQU5UIHwgSU5WQUxJRF9XRUlHSFQgfCBJTlZBTElEX1NJWkUgfCBVU0VSX0ZPTlRfTk9UX0lNUExFTUVOVEVEIHwgREVWSUNFX1RZUEVfTUlTTUFUQ0ggfCBERVZJQ0VfRVJST1IgfCBJTlZBTElEX01FU0hfQ09OU1RSVUNUSU9OIHwgREVWSUNFX0ZJTklTSEVEIHwgSkJJRzJfR0xPQkFMX01JU1NJTkdcblxuZXhjZXB0aW9uIEVycm9yIG9mIHN0YXR1c1xuXG52YWwgc3RhdHVzX3RvX3N0cmluZzogc3RhdHVzIC0+IHN0cmluZ1xuXG5leGNlcHRpb24gVW5hdmFpbGFibGVcblxudHlwZSBjb250ZXh0XG5cbnR5cGUgbWF0cml4ID0ge1xuICBtdXRhYmxlIHh4OiBmbG9hdDtcbiAgbXV0YWJsZSB5eDogZmxvYXQ7XG4gIG11dGFibGUgeHk6IGZsb2F0O1xuICBtdXRhYmxlIHl5OiBmbG9hdDtcbiAgbXV0YWJsZSB4MDogZmxvYXQ7XG4gIG11dGFibGUgeTA6IGZsb2F0O1xufVxuXG5tb2R1bGUgTWF0cml4OiBzaWdcbiAgdHlwZSB0ID0gbWF0cml4XG5cbiAgdmFsIGluaXRfaWRlbnRpdHk6IHVuaXQgLT4gdFxuICB2YWwgaW5pdF90cmFuc2xhdGU6IGZsb2F0IC0+IGZsb2F0IC0+IHRcbiAgdmFsIGluaXRfc2NhbGU6IGZsb2F0IC0+IGZsb2F0IC0+IHRcbiAgdmFsIGluaXRfcm90YXRlOiBmbG9hdCAtPiB0XG4gIHZhbCB0cmFuc2xhdGU6IHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdFxuICB2YWwgc2NhbGU6IHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdFxuICB2YWwgcm90YXRlOiB0IC0+IGZsb2F0IC0+IHVuaXRcbiAgdmFsIGludmVydDogdCAtPiB1bml0XG4gIHZhbCBtdWx0aXBseTogdCAtPiB0IC0+IHRcbiAgdmFsIHRyYW5zZm9ybV9kaXN0YW5jZTogdCAtPiBkeDpmbG9hdCAtPiBkeTpmbG9hdCAtPiBmbG9hdCAqIGZsb2F0XG4gIHZhbCB0cmFuc2Zvcm1fcG9pbnQ6IHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgKiBmbG9hdFxuZW5kXG5cbnR5cGUgdGV4dF9leHRlbnRzID0ge1xuICB4X2JlYXJpbmc6IGZsb2F0O1xuICB5X2JlYXJpbmc6IGZsb2F0O1xuICB3aWR0aDogZmxvYXQ7XG4gIGhlaWdodDogZmxvYXQ7XG4gIHhfYWR2YW5jZTogZmxvYXQ7XG4gIHlfYWR2YW5jZTogZmxvYXQ7XG59XG5cbigqIG1vZHVsZSBHbHlwaDogc2lnXG4gIHR5cGUgdCA9IHtcbiAgICBpbmRleDogaW50O1xuICAgIHg6IGZsb2F0O1xuICAgIHk6IGZsb2F0O1xuICB9XG5cbiAgdHlwZSBjbHVzdGVyID0ge1xuICAgIG51bV9ieXRlczogaW50O1xuICAgIG51bV9nbHlwaHM6IGludDtcbiAgfVxuXG4gIHR5cGUgY2x1c3Rlcl9mbGFncyA9IEJBQ0tXQVJEXG5cbiAgdmFsIGV4dGVudHM6IGNvbnRleHQgLT4gdCBhcnJheSAtPiB0ZXh0X2V4dGVudHNcbiAgdmFsIHNob3c6IGNvbnRleHQgLT4gdCBhcnJheSAtPiB1bml0XG4gIHZhbCBzaG93X3RleHQ6IGNvbnRleHQgLT4gc3RyaW5nIC0+IHQgYXJyYXkgLT4gY2x1c3RlciBhcnJheSAtPiBjbHVzdGVyX2ZsYWdzIC0+IHVuaXRcbmVuZCAqKVxuXG4oKiB0eXBlIHN1YnBpeGVsX29yZGVyID0gU1VCUElYRUxfT1JERVJfREVGQVVMVCB8IFNVQlBJWEVMX09SREVSX1JHQiB8IFNVQlBJWEVMX09SREVSX0JHUiB8IFNVQlBJWEVMX09SREVSX1ZSR0IgfCBTVUJQSVhFTF9PUkRFUl9WQkdSICopXG5cbigqIHR5cGUgaGludF9zdHlsZSA9IEhJTlRfU1RZTEVfREVGQVVMVCB8IEhJTlRfU1RZTEVfTk9ORSB8IEhJTlRfU1RZTEVfU0xJR0hUIHwgSElOVF9TVFlMRV9NRURJVU0gfCBISU5UX1NUWUxFX0ZVTEwgKilcblxuKCogdHlwZSBoaW50X21ldHJpY3MgPSBISU5UX01FVFJJQ1NfREVGQVVMVCB8IEhJTlRfTUVUUklDU19PRkYgfCBISU5UX01FVFJJQ1NfT04gKilcblxuKCogbW9kdWxlIEZvbnRfb3B0aW9uczogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBzZXQ6IGNvbnRleHQgLT4gdCAtPiB1bml0XG4gIHZhbCBnZXQ6IGNvbnRleHQgLT4gdFxuICB2YWwgY3JlYXRlOiB1bml0IC0+IHRcbiAgdmFsIG1ha2U6ID9hbnRpYWxpYXM6YW50aWFsaWFzIC0+ID9zdWJwaXhlbF9vcmRlcjpzdWJwaXhlbF9vcmRlciAtPiA/aGludF9zdHlsZTpoaW50X3N0eWxlIC0+ID9oaW50X21ldHJpY3M6aGludF9tZXRyaWNzIC0+IHVuaXQgLT4gdFxuICB2YWwgY29weTogdCAtPiB0XG4gIHZhbCBtZXJnZTogdCAtPiB0IC0+IHVuaXRcbiAgdmFsIHNldF9hbnRpYWxpYXM6IHQgLT4gYW50aWFsaWFzIC0+IHVuaXRcbiAgdmFsIGdldF9hbnRpYWxpYXM6IHQgLT4gYW50aWFsaWFzXG4gIHZhbCBzZXRfc3VicGl4ZWxfb3JkZXI6IHQgLT4gc3VicGl4ZWxfb3JkZXIgLT4gdW5pdFxuICB2YWwgZ2V0X3N1YnBpeGVsX29yZGVyOiB0IC0+IHN1YnBpeGVsX29yZGVyXG4gIHZhbCBzZXRfaGludF9zdHlsZTogdCAtPiBoaW50X3N0eWxlIC0+IHVuaXRcbiAgdmFsIGdldF9oaW50X3N0eWxlOiB0IC0+IGhpbnRfc3R5bGVcbiAgdmFsIHNldF9oaW50X21ldHJpY3M6IHQgLT4gaGludF9tZXRyaWNzIC0+IHVuaXRcbiAgdmFsIGdldF9oaW50X21ldHJpY3M6IHQgLT4gaGludF9tZXRyaWNzXG5lbmQgKilcblxudHlwZSBzbGFudCA9IFVwcmlnaHQgfCBJdGFsaWMgfCBPYmxpcXVlXG5cbnR5cGUgd2VpZ2h0ID0gTm9ybWFsIHwgQm9sZFxuXG4oKiB0eXBlIGZvbnRfdHlwZSA9IFsgYFRveSB8IGBGdCB8IGBXaW4zMiB8IGBRdWFydHogfCBgVXNlciBdICopXG5cbigqIG1vZHVsZSBGb250X2ZhY2U6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgc2V0OiBjb250ZXh0IC0+IF8gdCAtPiB1bml0XG4gIHZhbCBnZXQ6IGNvbnRleHQgLT4gZm9udF90eXBlIHRcbiAgdmFsIGdldF90eXBlOiAnYSB0IC0+IGZvbnRfdHlwZVxuICB2YWwgY3JlYXRlOiA/ZmFtaWx5OnN0cmluZyAtPiBzbGFudCAtPiB3ZWlnaHQgLT4gW2BUb3ldIHRcbiAgdmFsIGdldF9mYW1pbHk6IFtgVG95XSB0IC0+IHN0cmluZ1xuICB2YWwgZ2V0X3NsYW50OiBbYFRveV0gdCAtPiBzbGFudFxuICB2YWwgZ2V0X3dlaWdodDogW2BUb3ldIHQgLT4gd2VpZ2h0XG5lbmQgKilcblxudHlwZSBmb250X2V4dGVudHMgPSB7XG4gIGFzY2VudDogZmxvYXQ7XG4gIGRlc2NlbnQ6IGZsb2F0O1xuICBiYXNlbGluZTogZmxvYXQ7XG4gIG1heF94X2FkdmFuY2U6IGZsb2F0O1xuICBtYXhfeV9hZHZhbmNlOiBmbG9hdDtcbn1cblxuKCogbW9kdWxlIFNjYWxlZF9mb250OiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIHNldDogY29udGV4dCAtPiBfIHQgLT4gdW5pdFxuICB2YWwgZ2V0OiBjb250ZXh0IC0+ICdhIHRcbiAgdmFsIGNyZWF0ZTogJ2EgRm9udF9mYWNlLnQgLT4gTWF0cml4LnQgLT4gTWF0cml4LnQgLT4gRm9udF9vcHRpb25zLnQgLT4gJ2EgdFxuICB2YWwgZXh0ZW50czogXyB0IC0+IGZvbnRfZXh0ZW50c1xuICB2YWwgdGV4dF9leHRlbnRzOiBfIHQgLT4gc3RyaW5nIC0+IHRleHRfZXh0ZW50c1xuICB2YWwgZ2x5cGhfZXh0ZW50czogXyB0IC0+IEdseXBoLnQgYXJyYXkgLT4gdGV4dF9leHRlbnRzXG4gIHZhbCB0ZXh0X3RvX2dseXBoczogXyB0IC0+IHg6ZmxvYXQgLT4geTpmbG9hdCAtPiBzdHJpbmcgLT4gR2x5cGgudCBhcnJheSAqIEdseXBoLmNsdXN0ZXIgYXJyYXkgKiBHbHlwaC5jbHVzdGVyX2ZsYWdzXG4gIHZhbCBnZXRfZm9udF9mYWNlOiAnYSB0IC0+ICdhIEZvbnRfZmFjZS50XG4gIHZhbCBnZXRfZm9udF9vcHRpb25zOiBfIHQgLT4gRm9udF9vcHRpb25zLnRcbiAgdmFsIGdldF9mb250X21hdHJpeDogXyB0IC0+IE1hdHJpeC50XG4gIHZhbCBnZXRfY3RtOiBfIHQgLT4gTWF0cml4LnRcbiAgdmFsIGdldF9zY2FsZV9tYXRyaXg6IF8gdCAtPiBNYXRyaXgudFxuICB2YWwgZ2V0X3R5cGU6ICdhIHQgLT4gZm9udF90eXBlXG5lbmQgKilcblxudmFsIHNlbGVjdF9mb250X2ZhY2U6IGNvbnRleHQgLT4gP3NsYW50OnNsYW50IC0+ID93ZWlnaHQ6d2VpZ2h0IC0+IHN0cmluZyAtPiB1bml0XG52YWwgc2V0X2ZvbnRfc2l6ZTogY29udGV4dCAtPiBmbG9hdCAtPiB1bml0XG4oKiB2YWwgc2V0X2ZvbnRfbWF0cml4OiBjb250ZXh0IC0+IE1hdHJpeC50IC0+IHVuaXQgKilcbigqIHZhbCBnZXRfZm9udF9tYXRyaXg6IGNvbnRleHQgLT4gTWF0cml4LnQgKilcbnZhbCBzaG93X3RleHQ6IGNvbnRleHQgLT4gc3RyaW5nIC0+IHVuaXRcbnZhbCBmb250X2V4dGVudHM6IGNvbnRleHQgLT4gZm9udF9leHRlbnRzXG52YWwgdGV4dF9leHRlbnRzOiBjb250ZXh0IC0+IHN0cmluZyAtPiB0ZXh0X2V4dGVudHNcblxuKCogdHlwZSByZWN0YW5nbGUgPSB7XG4gIHg6IGZsb2F0O1xuICB5OiBmbG9hdDtcbiAgdzogZmxvYXQ7XG4gIGg6IGZsb2F0O1xufSAqKVxuXG4oKiB0eXBlIGNvbnRlbnQgPSBDT0xPUiB8IEFMUEhBIHwgQ09MT1JfQUxQSEEgKilcblxuKCogbW9kdWxlIFN1cmZhY2U6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgY3JlYXRlX3NpbWlsYXI6IHQgLT4gY29udGVudCAtPiB3aWR0aDppbnQgLT4gaGVpZ2h0OmludCAtPiB0XG4gIHZhbCBmaW5pc2g6IHQgLT4gdW5pdFxuICB2YWwgZmx1c2g6IHQgLT4gdW5pdFxuICB2YWwgZ2V0X2ZvbnRfb3B0aW9uczogdCAtPiBGb250X29wdGlvbnMudFxuICB2YWwgZ2V0X2NvbnRlbnQ6IHQgLT4gY29udGVudFxuICB2YWwgbWFya19kaXJ0eTogdCAtPiB1bml0XG4gIHZhbCBtYXJrX2RpcnR5X3JlY3RhbmdsZTogdCAtPiB4OmludCAtPiB5OmludCAtPiB3OmludCAtPiBoOmludCAtPiB1bml0XG4gIHZhbCBzZXRfZGV2aWNlX29mZnNldDogdCAtPiB4OmZsb2F0IC0+IHk6ZmxvYXQgLT4gdW5pdFxuICB2YWwgZ2V0X2RldmljZV9vZmZzZXQ6IHQgLT4gZmxvYXQgKiBmbG9hdFxuICB2YWwgc2V0X2ZhbGxiYWNrX3Jlc29sdXRpb246IHQgLT4geDpmbG9hdCAtPiB5OmZsb2F0IC0+IHVuaXRcbiAgdmFsIGdldF9mYWxsYmFja19yZXNvbHV0aW9uOiB0IC0+IGZsb2F0ICogZmxvYXRcblxuICB0eXBlIGtpbmQgPSBbIGBJbWFnZSB8IGBQREYgfCBgUFMgfCBgWExpYiB8IGBYQ0IgfCBgR0xJVFogfCBgUXVhcnR6IHwgYFdpbjMyIHwgYEJFT1MgfCBgRGlyZWN0RkIgfCBgU1ZHIHwgYE9TMiB8IGBXaW4zMl9wcmludGluZyB8IGBRdWFydHpfaW1hZ2UgfCBgUmVjb3JkaW5nIF1cblxuICB2YWwgZ2V0X3R5cGU6IHQgLT4ga2luZFxuICB2YWwgY29weV9wYWdlOiB0IC0+IHVuaXRcbiAgdmFsIHNob3dfcGFnZTogdCAtPiB1bml0XG4gIHZhbCBoYXNfc2hvd190ZXh0X2dseXBoczogdCAtPiBib29sXG5lbmQgKilcblxuKCogbW9kdWxlIEltYWdlOiBzaWdcbiAgdHlwZSBmb3JtYXQgPSB8IEFSR0IzMiB8IFJHQjI0IHwgQTggfCBBMVxuXG4gIHZhbCBjcmVhdGU6IGZvcm1hdCAtPiB3aWR0aDppbnQgLT4gaGVpZ2h0OmludCAtPiBTdXJmYWNlLnRcblxuICB0eXBlIGRhdGE4ID0gKGludCwgQmlnYXJyYXkuaW50OF91bnNpZ25lZF9lbHQsIEJpZ2FycmF5LmNfbGF5b3V0KSBCaWdhcnJheS5BcnJheTEudFxuXG4gIHR5cGUgZGF0YTMyID0gKGludDMyLCBCaWdhcnJheS5pbnQzMl9lbHQsIEJpZ2FycmF5LmNfbGF5b3V0KSBCaWdhcnJheS5BcnJheTIudFxuXG4gIHZhbCBjcmVhdGVfZm9yX2RhdGE4OiBkYXRhOCAtPiBmb3JtYXQgLT4gP3N0cmlkZTppbnQgLT4gaW50IC0+IGludCAtPiBTdXJmYWNlLnRcbiAgdmFsIGNyZWF0ZV9mb3JfZGF0YTMyOiA/d2lkdGg6aW50IC0+ID9oZWlnaHQ6aW50IC0+ID9hbHBoYTpib29sIC0+IGRhdGEzMiAtPiBTdXJmYWNlLnRcbiAgdmFsIGdldF9kYXRhODogU3VyZmFjZS50IC0+IGRhdGE4XG4gIHZhbCBnZXRfZGF0YTMyOiBTdXJmYWNlLnQgLT4gZGF0YTMyXG4gIHZhbCBnZXRfZm9ybWF0OiBTdXJmYWNlLnQgLT4gZm9ybWF0XG4gIHZhbCBnZXRfd2lkdGg6IFN1cmZhY2UudCAtPiBpbnRcbiAgdmFsIGdldF9oZWlnaHQ6IFN1cmZhY2UudCAtPiBpbnRcbiAgdmFsIGdldF9zdHJpZGU6IFN1cmZhY2UudCAtPiBpbnRcbiAgdmFsIHN0cmlkZV9mb3Jfd2lkdGg6IGZvcm1hdCAtPiB3aWR0aDppbnQgLT4gaW50XG4gIHZhbCBvdXRwdXRfcHBtOiBvdXRfY2hhbm5lbCAtPiA/d2lkdGg6aW50IC0+ID9oZWlnaHQ6aW50IC0+IGRhdGEzMiAtPiB1bml0XG5lbmQgKilcblxuKCogbW9kdWxlIFBERjogc2lnXG4gIHZhbCBjcmVhdGU6IGZuYW1lOnN0cmluZyAtPiB3aWR0aDpmbG9hdCAtPiBoZWlnaHQ6ZmxvYXQgLT4gU3VyZmFjZS50XG4gIHZhbCBjcmVhdGVfZm9yX3N0cmVhbTogb3V0cHV0OihzdHJpbmcgLT4gdW5pdCkgLT4gd2lkdGg6ZmxvYXQgLT4gaGVpZ2h0OmZsb2F0IC0+IFN1cmZhY2UudFxuICB2YWwgc2V0X3NpemU6IFN1cmZhY2UudCAtPiB3aWR0aDpmbG9hdCAtPiBoZWlnaHQ6ZmxvYXQgLT4gdW5pdFxuZW5kICopXG5cbigqIG1vZHVsZSBQTkc6IHNpZ1xuICB2YWwgY3JlYXRlOiBzdHJpbmcgLT4gU3VyZmFjZS50XG4gIHZhbCBjcmVhdGVfZnJvbV9zdHJlYW06IGlucHV0OihzdHJpbmcgLT4gaW50IC0+IHVuaXQpIC0+IFN1cmZhY2UudFxuICB2YWwgd3JpdGU6IFN1cmZhY2UudCAtPiBzdHJpbmcgLT4gdW5pdFxuICB2YWwgd3JpdGVfdG9fc3RyZWFtOiBTdXJmYWNlLnQgLT4gb3V0cHV0OihzdHJpbmcgLT4gdW5pdCkgLT4gdW5pdFxuZW5kICopXG5cbigqIG1vZHVsZSBQUzogc2lnXG4gIHZhbCBjcmVhdGU6IGZuYW1lOnN0cmluZyAtPiB3aWR0aDpmbG9hdCAtPiBoZWlnaHQ6ZmxvYXQgLT4gU3VyZmFjZS50XG4gIHZhbCBjcmVhdGVfZm9yX3N0cmVhbTogb3V0cHV0OihzdHJpbmcgLT4gdW5pdCkgLT4gd2lkdGg6ZmxvYXQgLT4gaGVpZ2h0OmZsb2F0IC0+IFN1cmZhY2UudFxuXG4gIHR5cGUgbGV2ZWwgPSBMRVZFTF8yIHwgTEVWRUxfM1xuXG4gIHZhbCByZXN0cmljdF90b19sZXZlbDogU3VyZmFjZS50IC0+IGxldmVsIC0+IHVuaXRcbiAgdmFsIGdldF9sZXZlbHM6IHVuaXQgLT4gbGV2ZWwgbGlzdFxuICB2YWwgbGV2ZWxfdG9fc3RyaW5nOiBsZXZlbCAtPiBzdHJpbmdcbiAgdmFsIHNldF9lcHM6IFN1cmZhY2UudCAtPiBlcHM6Ym9vbCAtPiB1bml0XG4gIHZhbCBnZXRfZXBzOiBTdXJmYWNlLnQgLT4gYm9vbFxuICB2YWwgc2V0X3NpemU6IFN1cmZhY2UudCAtPiB3aWR0aDpmbG9hdCAtPiBoZWlnaHQ6ZmxvYXQgLT4gdW5pdFxuXG4gIG1vZHVsZSBEc2M6IHNpZ1xuICAgIHZhbCBiZWdpbl9zZXR1cDogU3VyZmFjZS50IC0+IHVuaXRcbiAgICB2YWwgYmVnaW5fcGFnZV9zZXR1cDogU3VyZmFjZS50IC0+IHVuaXRcbiAgICB2YWwgY29tbWVudDogU3VyZmFjZS50IC0+IHN0cmluZyAtPiB1bml0XG4gIGVuZFxuZW5kICopXG5cbigqIG1vZHVsZSBTVkc6IHNpZ1xuICB2YWwgY3JlYXRlOiBmbmFtZTpzdHJpbmcgLT4gd2lkdGg6ZmxvYXQgLT4gaGVpZ2h0OmZsb2F0IC0+IFN1cmZhY2UudFxuICB2YWwgY3JlYXRlX2Zvcl9zdHJlYW06IG91dHB1dDooc3RyaW5nIC0+IHVuaXQpIC0+IHdpZHRoOmZsb2F0IC0+IGhlaWdodDpmbG9hdCAtPiBTdXJmYWNlLnRcblxuICB0eXBlIHZlcnNpb24gPSBWRVJTSU9OXzFfMSB8IFZFUlNJT05fMV8yXG5cbiAgdmFsIHJlc3RyaWN0X3RvX3ZlcnNpb246IFN1cmZhY2UudCAtPiB2ZXJzaW9uIC0+IHVuaXRcbiAgdmFsIGdldF92ZXJzaW9uczogdW5pdCAtPiB2ZXJzaW9uIGxpc3RcbiAgdmFsIHZlcnNpb25fdG9fc3RyaW5nOiB2ZXJzaW9uIC0+IHN0cmluZ1xuZW5kICopXG5cbigqIG1vZHVsZSBSZWNvcmRpbmc6IHNpZ1xuICB2YWwgY3JlYXRlOiA/ZXh0ZW50czpyZWN0YW5nbGUgLT4gY29udGVudCAtPiBTdXJmYWNlLnRcbiAgdmFsIGlua19leHRlbnRzOiBTdXJmYWNlLnQgLT4gcmVjdGFuZ2xlXG5lbmQgKilcblxubW9kdWxlIFBhdHRlcm46IHNpZ1xuICB0eXBlICdhIHQgY29uc3RyYWludCAnYSA9IFs8YFNvbGlkIHwgYFN1cmZhY2UgfCBgR3JhZGllbnQgfCBgTGluZWFyIHwgYFJhZGlhbF1cbiAgdHlwZSBhbnkgPSBbYFNvbGlkIHwgYFN1cmZhY2UgfCBgR3JhZGllbnQgfCBgTGluZWFyIHwgYFJhZGlhbF0gdFxuXG4gIHZhbCBhZGRfY29sb3Jfc3RvcF9yZ2I6IFs+IGBHcmFkaWVudF0gdCAtPiA/b2ZzOmZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXRcbiAgdmFsIGFkZF9jb2xvcl9zdG9wX3JnYmE6IFs+IGBHcmFkaWVudF0gdCAtPiA/b2ZzOmZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXRcbiAgdmFsIGdldF9jb2xvcl9zdG9wX2NvdW50OiBbPiBgR3JhZGllbnRdIHQgLT4gaW50XG4gIHZhbCBnZXRfY29sb3Jfc3RvcF9yZ2JhOiBbPiBgR3JhZGllbnRdIHQgLT4gaWR4OmludCAtPiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0XG4gIHZhbCBjcmVhdGVfcmdiOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBbYFNvbGlkXSB0XG4gIHZhbCBjcmVhdGVfcmdiYTogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gW2BTb2xpZF0gdFxuICB2YWwgZ2V0X3JnYmE6IFs+IGBTb2xpZF0gdCAtPiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgKiBmbG9hdFxuICB2YWwgY3JlYXRlX2xpbmVhcjogeDA6ZmxvYXQgLT4geTA6ZmxvYXQgLT4geDE6ZmxvYXQgLT4geTE6ZmxvYXQgLT4gW2BMaW5lYXIgfCBgR3JhZGllbnRdIHRcbiAgdmFsIGdldF9saW5lYXJfcG9pbnRzOiBbPiBgTGluZWFyIHwgYEdyYWRpZW50XSB0IC0+IGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0XG4gIHZhbCBjcmVhdGVfcmFkaWFsOiB4MDpmbG9hdCAtPiB5MDpmbG9hdCAtPiByMDpmbG9hdCAtPiB4MTpmbG9hdCAtPiB5MTpmbG9hdCAtPiByMTpmbG9hdCAtPiBbYFJhZGlhbCB8IGBHcmFkaWVudF0gdFxuICB2YWwgZ2V0X3JhZGlhbF9jaXJjbGVzOiBbPiBgUmFkaWFsIHwgYEdyYWRpZW50XSB0IC0+IGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgKiBmbG9hdFxuZW5kXG5cbigqIHZhbCBjcmVhdGU6IFN1cmZhY2UudCAtPiBjb250ZXh0ICopXG52YWwgc2F2ZTogY29udGV4dCAtPiB1bml0XG52YWwgcmVzdG9yZTogY29udGV4dCAtPiB1bml0XG4oKiB2YWwgZ2V0X3RhcmdldDogY29udGV4dCAtPiBTdXJmYWNlLnQgKilcblxuKCogbW9kdWxlIEdyb3VwOiBzaWdcbiAgdmFsIHB1c2g6ID9jb250ZW50OmNvbnRlbnQgLT4gY29udGV4dCAtPiB1bml0XG4gIHZhbCBwb3A6IGNvbnRleHQgLT4gUGF0dGVybi5hbnlcbiAgdmFsIHBvcF90b19zb3VyY2U6IGNvbnRleHQgLT4gdW5pdFxuICB2YWwgZ2V0X3RhcmdldDogY29udGV4dCAtPiBTdXJmYWNlLnRcbmVuZCAqKVxuXG52YWwgc2V0X3NvdXJjZV9yZ2I6IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdFxudmFsIHNldF9zb3VyY2VfcmdiYTogY29udGV4dCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0XG52YWwgc2V0X3NvdXJjZTogY29udGV4dCAtPiAnYSBQYXR0ZXJuLnQgLT4gdW5pdFxudmFsIGdldF9zb3VyY2U6IGNvbnRleHQgLT4gUGF0dGVybi5hbnlcblxudHlwZSBsaW5lX2NhcCA9IEJVVFQgfCBST1VORCB8IFNRVUFSRVxudmFsIHNldF9saW5lX2NhcDogY29udGV4dCAtPiBsaW5lX2NhcCAtPiB1bml0XG52YWwgZ2V0X2xpbmVfY2FwOiBjb250ZXh0IC0+IGxpbmVfY2FwXG5cbnR5cGUgbGluZV9qb2luID0gSk9JTl9NSVRFUiB8IEpPSU5fUk9VTkQgfCBKT0lOX0JFVkVMXG52YWwgc2V0X2xpbmVfam9pbjogY29udGV4dCAtPiBsaW5lX2pvaW4gLT4gdW5pdFxudmFsIGdldF9saW5lX2pvaW46IGNvbnRleHQgLT4gbGluZV9qb2luXG5cbnZhbCBzZXRfbGluZV93aWR0aDogY29udGV4dCAtPiBmbG9hdCAtPiB1bml0XG52YWwgZ2V0X2xpbmVfd2lkdGg6IGNvbnRleHQgLT4gZmxvYXRcblxudmFsIHNldF9taXRlcl9saW1pdDogY29udGV4dCAtPiBmbG9hdCAtPiB1bml0XG52YWwgZ2V0X21pdGVyX2xpbWl0OiBjb250ZXh0IC0+IGZsb2F0XG5cbnZhbCBzZXRfZGFzaDogY29udGV4dCAtPiA/b2ZzOmZsb2F0IC0+IGZsb2F0IGFycmF5IC0+IHVuaXRcbnZhbCBnZXRfZGFzaDogY29udGV4dCAtPiBmbG9hdCBhcnJheSAqIGZsb2F0XG5cbnR5cGUgb3BlcmF0b3IgPSBDTEVBUiB8IFNPVVJDRSB8IE9WRVIgfCBJTiB8IE9VVCB8IEFUT1AgfCBERVNUIHwgREVTVF9PVkVSIHwgREVTVF9JTiB8IERFU1RfT1VUIHwgREVTVF9BVE9QIHwgWE9SIHwgQUREIHwgU0FUVVJBVEVcbnZhbCBzZXRfb3BlcmF0b3I6IGNvbnRleHQgLT4gb3BlcmF0b3IgLT4gdW5pdFxudmFsIGdldF9vcGVyYXRvcjogY29udGV4dCAtPiBvcGVyYXRvclxuXG50eXBlIGZpbGxfcnVsZSA9IFdJTkRJTkcgfCBFVkVOX09ERFxudmFsIHNldF9maWxsX3J1bGU6IGNvbnRleHQgLT4gZmlsbF9ydWxlIC0+IHVuaXRcbnZhbCBnZXRfZmlsbF9ydWxlOiBjb250ZXh0IC0+IGZpbGxfcnVsZVxuXG52YWwgY2xpcDogY29udGV4dCAtPiB1bml0XG52YWwgY2xpcF9wcmVzZXJ2ZTogY29udGV4dCAtPiB1bml0XG52YWwgZmlsbDogY29udGV4dCAtPiB1bml0XG52YWwgZmlsbF9wcmVzZXJ2ZTogY29udGV4dCAtPiB1bml0XG52YWwgcGFpbnQ6ID9hbHBoYTpmbG9hdCAtPiBjb250ZXh0IC0+IHVuaXRcbnZhbCBzdHJva2U6IGNvbnRleHQgLT4gdW5pdFxudmFsIHN0cm9rZV9wcmVzZXJ2ZTogY29udGV4dCAtPiB1bml0XG5cbigqIEFyY3MgYXJlIHRyYW5zbGF0ZWQgdG8gb25lIG9yIG1vcmUgQ1VSVkVfVE8uIE5vdCBzdXBwb3J0ZWQgYnkgSFRNTDUgYW5kIGRpZmZpY3VsdCB0byByZS1pbXBsZW1lbnQgZXhhY3RseS4gKilcbigqIHR5cGUgcGF0aF9kYXRhID1cbiAgfCBNT1ZFX1RPIG9mIGZsb2F0ICogZmxvYXRcbiAgfCBMSU5FX1RPIG9mIGZsb2F0ICogZmxvYXRcbiAgfCBDVVJWRV9UTyBvZiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ICogZmxvYXRcbiAgfCBDTE9TRV9QQVRIICopXG5cbm1vZHVsZSBQYXRoOiBzaWdcbiAgKCogdHlwZSB0ICopXG5cbiAgKCogdmFsIGNvcHk6IGNvbnRleHQgLT4gdCAqKVxuICAoKiB2YWwgY29weV9mbGF0OiBjb250ZXh0IC0+IHQgKilcbiAgKCogdmFsIGFwcGVuZDogY29udGV4dCAtPiB0IC0+IHVuaXQgKilcbiAgdmFsIGdldF9jdXJyZW50X3BvaW50OiBjb250ZXh0IC0+IGZsb2F0ICogZmxvYXRcbiAgdmFsIGNsZWFyOiBjb250ZXh0IC0+IHVuaXRcbiAgKCogdmFsIHN1YjogY29udGV4dCAtPiB1bml0ICopXG4gIHZhbCBjbG9zZTogY29udGV4dCAtPiB1bml0XG4gICgqIHZhbCBnbHlwaDogY29udGV4dCAtPiBHbHlwaC50IGFycmF5IC0+IHVuaXQgKilcbiAgKCogdmFsIHRleHQ6IGNvbnRleHQgLT4gc3RyaW5nIC0+IHVuaXQgKilcbiAgKCogdmFsIGV4dGVudHM6IGNvbnRleHQgLT4gcmVjdGFuZ2xlICopXG4gICgqIHZhbCBmb2xkOiB0IC0+ICgnYSAtPiBwYXRoX2RhdGEgLT4gJ2EpIC0+ICdhIC0+ICdhICopXG4gICgqIHZhbCB0b19hcnJheTogdCAtPiBwYXRoX2RhdGEgYXJyYXkgKilcbiAgKCogdmFsIG9mX2FycmF5OiBwYXRoX2RhdGEgYXJyYXkgLT4gdCAqKVxuZW5kXG5cbnZhbCBhcmM6IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gcjpmbG9hdCAtPiBhMTpmbG9hdCAtPiBhMjpmbG9hdCAtPiB1bml0XG52YWwgYXJjX25lZ2F0aXZlOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHI6ZmxvYXQgLT4gYTE6ZmxvYXQgLT4gYTI6ZmxvYXQgLT4gdW5pdFxudmFsIGN1cnZlX3RvOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXRcbnZhbCBsaW5lX3RvOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXRcbnZhbCBtb3ZlX3RvOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXRcbnZhbCByZWN0YW5nbGU6IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdzpmbG9hdCAtPiBoOmZsb2F0IC0+IHVuaXRcbnZhbCByZWxfY3VydmVfdG86IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdFxudmFsIHJlbF9saW5lX3RvOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXRcbnZhbCByZWxfbW92ZV90bzogY29udGV4dCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0XG52YWwgdHJhbnNsYXRlOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXRcbnZhbCBzY2FsZTogY29udGV4dCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0XG52YWwgcm90YXRlOiBjb250ZXh0IC0+IGZsb2F0IC0+IHVuaXRcbnZhbCB0cmFuc2Zvcm06IGNvbnRleHQgLT4gTWF0cml4LnQgLT4gdW5pdFxudmFsIHNldF9tYXRyaXg6IGNvbnRleHQgLT4gTWF0cml4LnQgLT4gdW5pdFxudmFsIGdldF9tYXRyaXg6IGNvbnRleHQgLT4gTWF0cml4LnRcbnZhbCBpZGVudGl0eV9tYXRyaXg6IGNvbnRleHQgLT4gdW5pdFxudmFsIHVzZXJfdG9fZGV2aWNlOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ICogZmxvYXRcbnZhbCB1c2VyX3RvX2RldmljZV9kaXN0YW5jZTogY29udGV4dCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0XG52YWwgZGV2aWNlX3RvX3VzZXI6IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgKiBmbG9hdFxudmFsIGRldmljZV90b191c2VyX2Rpc3RhbmNlOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ICogZmxvYXRcbiMgNSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG5lbmRcblxubW9kdWxlIE1vY2sgPSBzdHJ1Y3RcbiMgMSBcInNyYy9CYWNrZW5kLmluY2wubWxcIlxuKCogQ29weXJpZ2h0IDIwMTctMjAxOCBWaW5jZW50IEphY3F1ZXMgPHZpbmNlbnRAdmluY2VudC1qYWNxdWVzLm5ldD4gKilcblxub3BlbiBTdGRMYWJlbHNcblxudHlwZSBzdGF0dXMgPVxuICB8IElOVkFMSURfUkVTVE9SRVxuICB8IElOVkFMSURfUE9QX0dST1VQXG4gIHwgTk9fQ1VSUkVOVF9QT0lOVFxuICB8IElOVkFMSURfTUFUUklYXG4gIHwgSU5WQUxJRF9TVEFUVVNcbiAgfCBOVUxMX1BPSU5URVJcbiAgfCBJTlZBTElEX1NUUklOR1xuICB8IElOVkFMSURfUEFUSF9EQVRBXG4gIHwgUkVBRF9FUlJPUlxuICB8IFdSSVRFX0VSUk9SXG4gIHwgU1VSRkFDRV9GSU5JU0hFRFxuICB8IFNVUkZBQ0VfVFlQRV9NSVNNQVRDSFxuICB8IFBBVFRFUk5fVFlQRV9NSVNNQVRDSFxuICB8IElOVkFMSURfQ09OVEVOVFxuICB8IElOVkFMSURfRk9STUFUXG4gIHwgSU5WQUxJRF9WSVNVQUxcbiAgfCBGSUxFX05PVF9GT1VORFxuICB8IElOVkFMSURfREFTSFxuICB8IElOVkFMSURfRFNDX0NPTU1FTlRcbiAgfCBJTlZBTElEX0lOREVYXG4gIHwgQ0xJUF9OT1RfUkVQUkVTRU5UQUJMRVxuICB8IFRFTVBfRklMRV9FUlJPUlxuICB8IElOVkFMSURfU1RSSURFXG4gIHwgRk9OVF9UWVBFX01JU01BVENIXG4gIHwgVVNFUl9GT05UX0lNTVVUQUJMRVxuICB8IFVTRVJfRk9OVF9FUlJPUlxuICB8IE5FR0FUSVZFX0NPVU5UXG4gIHwgSU5WQUxJRF9DTFVTVEVSU1xuICB8IElOVkFMSURfU0xBTlRcbiAgfCBJTlZBTElEX1dFSUdIVFxuICB8IElOVkFMSURfU0laRVxuICB8IFVTRVJfRk9OVF9OT1RfSU1QTEVNRU5URURcbiAgfCBERVZJQ0VfVFlQRV9NSVNNQVRDSFxuICB8IERFVklDRV9FUlJPUlxuICB8IElOVkFMSURfTUVTSF9DT05TVFJVQ1RJT05cbiAgfCBERVZJQ0VfRklOSVNIRURcbiAgfCBKQklHMl9HTE9CQUxfTUlTU0lOR1xuXG5leGNlcHRpb24gRXJyb3Igb2Ygc3RhdHVzXG5cbmxldCBzdGF0dXNfdG9fc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBJTlZBTElEX1JFU1RPUkUgLT4gXCJjYWlyb19yZXN0b3JlKCkgd2l0aG91dCBtYXRjaGluZyBjYWlyb19zYXZlKClcIlxuICB8IElOVkFMSURfUE9QX0dST1VQIC0+IFwibm8gc2F2ZWQgZ3JvdXAgdG8gcG9wLCBpLmUuIGNhaXJvX3BvcF9ncm91cCgpIHdpdGhvdXQgbWF0Y2hpbmcgY2Fpcm9fcHVzaF9ncm91cCgpXCJcbiAgfCBOT19DVVJSRU5UX1BPSU5UIC0+IFwibm8gY3VycmVudCBwb2ludCBkZWZpbmVkXCJcbiAgfCBJTlZBTElEX01BVFJJWCAtPiBcImludmFsaWQgbWF0cml4IChub3QgaW52ZXJ0aWJsZSlcIlxuICB8IElOVkFMSURfU1RBVFVTIC0+IFwiaW52YWxpZCB2YWx1ZSBmb3IgYW4gaW5wdXQgY2Fpcm9fc3RhdHVzX3RcIlxuICB8IE5VTExfUE9JTlRFUiAtPiBcIk5VTEwgcG9pbnRlclwiXG4gIHwgSU5WQUxJRF9TVFJJTkcgLT4gXCJpbnB1dCBzdHJpbmcgbm90IHZhbGlkIFVURi04XCJcbiAgfCBJTlZBTElEX1BBVEhfREFUQSAtPiBcImlucHV0IHBhdGggZGF0YSBub3QgdmFsaWRcIlxuICB8IFJFQURfRVJST1IgLT4gXCJlcnJvciB3aGlsZSByZWFkaW5nIGZyb20gaW5wdXQgc3RyZWFtXCJcbiAgfCBXUklURV9FUlJPUiAtPiBcImVycm9yIHdoaWxlIHdyaXRpbmcgdG8gb3V0cHV0IHN0cmVhbVwiXG4gIHwgU1VSRkFDRV9GSU5JU0hFRCAtPiBcInRoZSB0YXJnZXQgc3VyZmFjZSBoYXMgYmVlbiBmaW5pc2hlZFwiXG4gIHwgU1VSRkFDRV9UWVBFX01JU01BVENIIC0+IFwidGhlIHN1cmZhY2UgdHlwZSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoZSBvcGVyYXRpb25cIlxuICB8IFBBVFRFUk5fVFlQRV9NSVNNQVRDSCAtPiBcInRoZSBwYXR0ZXJuIHR5cGUgaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGUgb3BlcmF0aW9uXCJcbiAgfCBJTlZBTElEX0NPTlRFTlQgLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBhbiBpbnB1dCBjYWlyb19jb250ZW50X3RcIlxuICB8IElOVkFMSURfRk9STUFUIC0+IFwiaW52YWxpZCB2YWx1ZSBmb3IgYW4gaW5wdXQgY2Fpcm9fZm9ybWF0X3RcIlxuICB8IElOVkFMSURfVklTVUFMIC0+IFwiaW52YWxpZCB2YWx1ZSBmb3IgYW4gaW5wdXQgVmlzdWFsKlwiXG4gIHwgRklMRV9OT1RfRk9VTkQgLT4gXCJmaWxlIG5vdCBmb3VuZFwiXG4gIHwgSU5WQUxJRF9EQVNIIC0+IFwiaW52YWxpZCB2YWx1ZSBmb3IgYSBkYXNoIHNldHRpbmdcIlxuICB8IElOVkFMSURfRFNDX0NPTU1FTlQgLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBhIERTQyBjb21tZW50XCJcbiAgfCBJTlZBTElEX0lOREVYIC0+IFwiaW52YWxpZCBpbmRleCBwYXNzZWQgdG8gZ2V0dGVyXCJcbiAgfCBDTElQX05PVF9SRVBSRVNFTlRBQkxFIC0+IFwiY2xpcCByZWdpb24gbm90IHJlcHJlc2VudGFibGUgaW4gZGVzaXJlZCBmb3JtYXRcIlxuICB8IFRFTVBfRklMRV9FUlJPUiAtPiBcImVycm9yIGNyZWF0aW5nIG9yIHdyaXRpbmcgdG8gYSB0ZW1wb3JhcnkgZmlsZVwiXG4gIHwgSU5WQUxJRF9TVFJJREUgLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBzdHJpZGVcIlxuICB8IEZPTlRfVFlQRV9NSVNNQVRDSCAtPiBcInRoZSBmb250IHR5cGUgaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGUgb3BlcmF0aW9uXCJcbiAgfCBVU0VSX0ZPTlRfSU1NVVRBQkxFIC0+IFwidGhlIHVzZXItZm9udCBpcyBpbW11dGFibGVcIlxuICB8IFVTRVJfRk9OVF9FUlJPUiAtPiBcImVycm9yIG9jY3VycmVkIGluIGEgdXNlci1mb250IGNhbGxiYWNrIGZ1bmN0aW9uXCJcbiAgfCBORUdBVElWRV9DT1VOVCAtPiBcIm5lZ2F0aXZlIG51bWJlciB1c2VkIHdoZXJlIGl0IGlzIG5vdCBhbGxvd2VkXCJcbiAgfCBJTlZBTElEX0NMVVNURVJTIC0+IFwiaW5wdXQgY2x1c3RlcnMgZG8gbm90IHJlcHJlc2VudCB0aGUgYWNjb21wYW55aW5nIHRleHQgYW5kIGdseXBoIGFycmF5c1wiXG4gIHwgSU5WQUxJRF9TTEFOVCAtPiBcImludmFsaWQgdmFsdWUgZm9yIGFuIGlucHV0IGNhaXJvX2ZvbnRfc2xhbnRfdFwiXG4gIHwgSU5WQUxJRF9XRUlHSFQgLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBhbiBpbnB1dCBjYWlyb19mb250X3dlaWdodF90XCJcbiAgfCBJTlZBTElEX1NJWkUgLT4gXCJpbnZhbGlkIHZhbHVlICh0eXBpY2FsbHkgdG9vIGJpZykgZm9yIHRoZSBzaXplIG9mIHRoZSBpbnB1dCAoc3VyZmFjZSwgcGF0dGVybiwgZXRjLilcIlxuICB8IFVTRVJfRk9OVF9OT1RfSU1QTEVNRU5URUQgLT4gXCJ1c2VyLWZvbnQgbWV0aG9kIG5vdCBpbXBsZW1lbnRlZFwiXG4gIHwgREVWSUNFX1RZUEVfTUlTTUFUQ0ggLT4gXCJ0aGUgZGV2aWNlIHR5cGUgaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGUgb3BlcmF0aW9uXCJcbiAgfCBERVZJQ0VfRVJST1IgLT4gXCJhbiBvcGVyYXRpb24gdG8gdGhlIGRldmljZSBjYXVzZWQgYW4gdW5zcGVjaWZpZWQgZXJyb3JcIlxuICB8IElOVkFMSURfTUVTSF9DT05TVFJVQ1RJT04gLT4gXCJpbnZhbGlkIG9wZXJhdGlvbiBkdXJpbmcgbWVzaCBwYXR0ZXJuIGNvbnN0cnVjdGlvblwiXG4gIHwgREVWSUNFX0ZJTklTSEVEIC0+IFwidGhlIHRhcmdldCBkZXZpY2UgaGFzIGJlZW4gZmluaXNoZWRcIlxuICB8IEpCSUcyX0dMT0JBTF9NSVNTSU5HIC0+IFwiQ0FJUk9fTUlNRV9UWVBFX0pCSUcyX0dMT0JBTF9JRCB1c2VkIGJ1dCBubyBDQUlST19NSU1FX1RZUEVfSkJJRzJfR0xPQkFMIGRhdGEgcHJvdmlkZWRcIlxuXG5sZXQgc3RhdHVzX3JlcHIgPSBmdW5jdGlvblxuICB8IElOVkFMSURfUkVTVE9SRSAtPiBcIklOVkFMSURfUkVTVE9SRVwiXG4gIHwgTk9fQ1VSUkVOVF9QT0lOVCAtPiBcIk5PX0NVUlJFTlRfUE9JTlRcIlxuICAoKkJJU0VDVC1JR05PUkUtQkVHSU4qKSAoKiBJIGRvbid0IGtub3cgaG93IHRvIG1ha2UgQ2Fpcm8gcmFpc2UgdGhlc2UgZXhjZXB0aW9ucyAqKVxuICB8IElOVkFMSURfUE9QX0dST1VQIC0+IFwiSU5WQUxJRF9QT1BfR1JPVVBcIlxuICB8IElOVkFMSURfTUFUUklYIC0+IFwiSU5WQUxJRF9NQVRSSVhcIlxuICB8IElOVkFMSURfU1RBVFVTIC0+IFwiSU5WQUxJRF9TVEFUVVNcIlxuICB8IE5VTExfUE9JTlRFUiAtPiBcIk5VTExfUE9JTlRFUlwiXG4gIHwgSU5WQUxJRF9TVFJJTkcgLT4gXCJJTlZBTElEX1NUUklOR1wiXG4gIHwgSU5WQUxJRF9QQVRIX0RBVEEgLT4gXCJJTlZBTElEX1BBVEhfREFUQVwiXG4gIHwgUkVBRF9FUlJPUiAtPiBcIlJFQURfRVJST1JcIlxuICB8IFdSSVRFX0VSUk9SIC0+IFwiV1JJVEVfRVJST1JcIlxuICB8IFNVUkZBQ0VfRklOSVNIRUQgLT4gXCJTVVJGQUNFX0ZJTklTSEVEXCJcbiAgfCBTVVJGQUNFX1RZUEVfTUlTTUFUQ0ggLT4gXCJTVVJGQUNFX1RZUEVfTUlTTUFUQ0hcIlxuICB8IFBBVFRFUk5fVFlQRV9NSVNNQVRDSCAtPiBcIlBBVFRFUk5fVFlQRV9NSVNNQVRDSFwiXG4gIHwgSU5WQUxJRF9DT05URU5UIC0+IFwiSU5WQUxJRF9DT05URU5UXCJcbiAgfCBJTlZBTElEX0ZPUk1BVCAtPiBcIklOVkFMSURfRk9STUFUXCJcbiAgfCBJTlZBTElEX1ZJU1VBTCAtPiBcIklOVkFMSURfVklTVUFMXCJcbiAgfCBGSUxFX05PVF9GT1VORCAtPiBcIkZJTEVfTk9UX0ZPVU5EXCJcbiAgfCBJTlZBTElEX0RBU0ggLT4gXCJJTlZBTElEX0RBU0hcIlxuICB8IElOVkFMSURfRFNDX0NPTU1FTlQgLT4gXCJJTlZBTElEX0RTQ19DT01NRU5UXCJcbiAgfCBJTlZBTElEX0lOREVYIC0+IFwiSU5WQUxJRF9JTkRFWFwiXG4gIHwgQ0xJUF9OT1RfUkVQUkVTRU5UQUJMRSAtPiBcIkNMSVBfTk9UX1JFUFJFU0VOVEFCTEVcIlxuICB8IFRFTVBfRklMRV9FUlJPUiAtPiBcIlRFTVBfRklMRV9FUlJPUlwiXG4gIHwgSU5WQUxJRF9TVFJJREUgLT4gXCJJTlZBTElEX1NUUklERVwiXG4gIHwgRk9OVF9UWVBFX01JU01BVENIIC0+IFwiRk9OVF9UWVBFX01JU01BVENIXCJcbiAgfCBVU0VSX0ZPTlRfSU1NVVRBQkxFIC0+IFwiVVNFUl9GT05UX0lNTVVUQUJMRVwiXG4gIHwgVVNFUl9GT05UX0VSUk9SIC0+IFwiVVNFUl9GT05UX0VSUk9SXCJcbiAgfCBORUdBVElWRV9DT1VOVCAtPiBcIk5FR0FUSVZFX0NPVU5UXCJcbiAgfCBJTlZBTElEX0NMVVNURVJTIC0+IFwiSU5WQUxJRF9DTFVTVEVSU1wiXG4gIHwgSU5WQUxJRF9TTEFOVCAtPiBcIklOVkFMSURfU0xBTlRcIlxuICB8IElOVkFMSURfV0VJR0hUIC0+IFwiSU5WQUxJRF9XRUlHSFRcIlxuICB8IElOVkFMSURfU0laRSAtPiBcIklOVkFMSURfU0laRVwiXG4gIHwgVVNFUl9GT05UX05PVF9JTVBMRU1FTlRFRCAtPiBcIlVTRVJfRk9OVF9OT1RfSU1QTEVNRU5URURcIlxuICB8IERFVklDRV9UWVBFX01JU01BVENIIC0+IFwiREVWSUNFX1RZUEVfTUlTTUFUQ0hcIlxuICB8IERFVklDRV9FUlJPUiAtPiBcIkRFVklDRV9FUlJPUlwiXG4gIHwgSU5WQUxJRF9NRVNIX0NPTlNUUlVDVElPTiAtPiBcIklOVkFMSURfTUVTSF9DT05TVFJVQ1RJT05cIlxuICB8IERFVklDRV9GSU5JU0hFRCAtPiBcIkRFVklDRV9GSU5JU0hFRFwiXG4gIHwgSkJJRzJfR0xPQkFMX01JU1NJTkcgLT4gXCJKQklHMl9HTE9CQUxfTUlTU0lOR1wiXG4gICgqQklTRUNULUlHTk9SRS1FTkQqKVxuXG5leGNlcHRpb24gVW5hdmFpbGFibGVcblxudHlwZSBtYXRyaXggPSB7XG4gIG11dGFibGUgeHg6IGZsb2F0O1xuICBtdXRhYmxlIHl4OiBmbG9hdDtcbiAgbXV0YWJsZSB4eTogZmxvYXQ7XG4gIG11dGFibGUgeXk6IGZsb2F0O1xuICBtdXRhYmxlIHgwOiBmbG9hdDtcbiAgbXV0YWJsZSB5MDogZmxvYXQ7XG59XG5cbm1vZHVsZSBNYXRyaXggPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gbWF0cml4XG5cbiAgKCpcbiAgICAyIGJ5IDIgbWF0cml4IHdpdGggKHgwLCB5MCkgb2Zmc2V0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIGZvbGxvd2luZyAzIGJ5IDMgbWF0cml4OlxuICAgIC8geHggeHkgeDAgXFwgICAvIHggXFwgICAvIHh4KnggKyB4eSp5ICsgeDAgXFxcbiAgICB8IHl4IHl5IHkwIHwgKiB8IHkgfCA9IHwgeXgqeCArIHl5KnkgKyB5MCB8XG4gICAgXFwgIDAgIDAgIDEgLyAgIFxcIDEgLyAgIFxcICAgICAgICAgICAgICAgIDEgL1xuICAqKVxuXG4gIGxldCBpbml0X2lkZW50aXR5ICgpID1cbiAgICB7eHg9MS47IHh5PTAuOyB5eD0wLjsgeXk9MS47IHgwPTAuOyB5MD0wLn1cblxuICBsZXQgaW5pdF90cmFuc2xhdGUgeCB5ID1cbiAgICB7eHg9MS47IHh5PTAuOyB5eD0wLjsgeXk9MS47IHgwPXg7IHkwPXl9XG5cbiAgbGV0IGluaXRfc2NhbGUgeCB5ID1cbiAgICB7eHg9eDsgeHk9MC47IHl4PTAuOyB5eT15OyB4MD0wLjsgeTA9MC59XG5cbiAgbGV0IGluaXRfcm90YXRlIGFuZ2xlID1cbiAgICB7XG4gICAgICB4eCA9IGNvcyBhbmdsZTtcbiAgICAgIHh5ID0gLS5zaW4gYW5nbGU7XG4gICAgICB5eCA9IHNpbiBhbmdsZTtcbiAgICAgIHl5ID0gY29zIGFuZ2xlO1xuICAgICAgeDAgPSAwLjtcbiAgICAgIHkwID0gMC47XG4gICAgfVxuXG4gIGxldCBpbml0X2ludmVyc2Uge3h4OyB4eTsgeXg7IHl5OyB4MDsgeTB9ID1cbiAgICBsZXQgZCA9IHh4ICouIHl5IC0uIHh5ICouIHl4IGluXG4gICAgaWYgZCA9IDAuIHRoZW4gcmFpc2UgKEVycm9yIElOVkFMSURfTUFUUklYKTtcbiAgICBsZXQgeHggPSB5eSAvLiBkXG4gICAgYW5kIHh5ID0gLS4geHkgLy4gZFxuICAgIGFuZCB5eCA9IC0uIHl4IC8uIGRcbiAgICBhbmQgeXkgPSB4eCAvLiBkXG4gICAgYW5kIHgwID0gKHh5ICouIHkwIC0uIHl5ICouIHgwKSAvLiBkXG4gICAgYW5kIHkwID0gKHl4ICouIHgwIC0uIHh4ICouIHkwKSAvLiBkIGluXG4gICAge3h4OyB4eTsgeXg7IHl5OyB4MDsgeTB9XG5cbiAgbGV0IG11bHRpcGx5IHt4eDsgeHk7IHl4OyB5eTsgeDA7IHkwfSB7eHg9eHgnOyB4eT14eSc7IHl4PXl4JzsgeXk9eXknOyB4MD14MCc7IHkwPXkwJ30gPVxuICAgIGxldCB4eCA9IHh4ICouIHh4JyArLiB4eSAqLiB5eCdcbiAgICBhbmQgeHkgPSB4eCAqLiB4eScgKy4geHkgKi4geXknXG4gICAgYW5kIHl4ID0geXggKi4geHgnICsuIHl5ICouIHl4J1xuICAgIGFuZCB5eSA9IHl4ICouIHh5JyArLiB5eSAqLiB5eSdcbiAgICBhbmQgeDAgPSB4eCAqLiB4MCcgKy4geHkgKi4geTAnICsuIHgwXG4gICAgYW5kIHkwID0geXggKi4geDAnICsuIHl5ICouIHkwJyArLiB5MCBpblxuICAgIHt4eDsgeHk7IHl4OyB5eTsgeDA7IHkwfVxuXG4gIGxldCB0cmFuc2Zvcm1fcG9pbnQge3h4OyB4eTsgeXg7IHl5OyB4MDsgeTB9IHggeSA9XG4gICAgKHh4ICouIHggKy4geHkgKi4geSArLiB4MCwgeXggKi4geCArLiB5eSAqLiB5ICsuIHkwKVxuXG4gIGxldCB0cmFuc2Zvcm1fZGlzdGFuY2Uge3h4OyB4eTsgeXg7IHl5OyB4MD1fOyB5MD1ffSB+ZHggfmR5ID1cbiAgICAoeHggKi4gZHggKy4geHkgKi4gZHksIHl4ICouIGR4ICsuIHl5ICouIGR5KVxuXG4gIGxldCBzZXQgbSB7eHg7IHh5OyB5eDsgeXk7IHgwOyB5MH0gPVxuICAgIG0ueHggPC0geHg7XG4gICAgbS54eSA8LSB4eTtcbiAgICBtLnl4IDwtIHl4O1xuICAgIG0ueXkgPC0geXk7XG4gICAgbS54MCA8LSB4MDtcbiAgICBtLnkwIDwtIHkwXG5cbiAgbGV0IHNjYWxlIG0geCB5ID1cbiAgICBzZXQgbSAobXVsdGlwbHkgbSAoaW5pdF9zY2FsZSB4IHkpKVxuXG4gIGxldCB0cmFuc2xhdGUgbSB4IHkgPVxuICAgIHNldCBtIChtdWx0aXBseSBtIChpbml0X3RyYW5zbGF0ZSB4IHkpKVxuXG4gIGxldCByb3RhdGUgbSBhbmdsZSA9XG4gICAgc2V0IG0gKG11bHRpcGx5IG0gKGluaXRfcm90YXRlIGFuZ2xlKSlcblxuICBsZXQgaW52ZXJ0IG0gPVxuICAgIHNldCBtIChpbml0X2ludmVyc2UgbSlcbmVuZFxuXG50eXBlIHNsYW50ID1cbiAgfCBVcHJpZ2h0XG4gIHwgSXRhbGljXG4gIHwgT2JsaXF1ZVxuXG50eXBlIHdlaWdodCA9XG4gIHwgTm9ybWFsXG4gIHwgQm9sZFxuXG50eXBlIGZvbnQgPSB7XG4gIHNsYW50OiBzbGFudDtcbiAgd2VpZ2h0OiB3ZWlnaHQ7XG4gIHNpemU6IGZsb2F0O1xuICBmYW1pbHk6IHN0cmluZztcbn1cblxubW9kdWxlIFBhdHRlcm4gPSBzdHJ1Y3RcbiAgKCogV2Ugc3RvcmUgdHVwbGVzIChpbnN0ZWFkIG9mIG1vcmUgZXhwbGljaXQgcmVjb3JkIHR5cGVzKSBiZWNhdXNlIHRoZSBwdWJsaWMgaW50ZXJmYWNlIHVzZXMgdHVwbGVzXG4gIChnZXRfY29sb3Jfc3RvcF9yZ2JhLCBnZXRfcmdiYSwgZ2V0X2xpbmVhcl9wb2ludHMsIGdldF9yYWRpYWxfY2lyY2xlcykgKilcblxuICB0eXBlIHN0b3BfcG9pbnQgPSBmbG9hdCAqIGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ICgqIChwb3NpdGlvbiwgciwgZywgYiwgYSkgKilcblxuICBtb2R1bGUgU3RvcFBvaW50TGlzdDogc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVtcHR5OiB0XG4gICAgdmFsIGFkZDogdCAtPiBzdG9wX3BvaW50IC0+IHRcbiAgICB2YWwgc2l6ZTogdCAtPiBpbnRcbiAgICB2YWwgZ2V0OiB0IC0+IGk6aW50IC0+IHN0b3BfcG9pbnRcbiAgICB2YWwgdG9fbGlzdDogdCAtPiBzdG9wX3BvaW50IGxpc3RcbiAgZW5kID0gc3RydWN0XG4gICAgbW9kdWxlIEVsZW1lbnQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IHtcbiAgICAgICAgYWRkZWQ6IGludDtcbiAgICAgICAgc3RvcF9wb2ludDogc3RvcF9wb2ludDtcbiAgICAgIH1cblxuICAgICAgbGV0IGNvbXBhcmUge3N0b3BfcG9pbnQ9KHBvc2l0aW9uX2EsIF8sIF8sIF8sIF8pOyBhZGRlZD1hZGRlZF9hOyBffSB7c3RvcF9wb2ludD0ocG9zaXRpb25fYiwgXywgXywgXywgXyk7IGFkZGVkPWFkZGVkX2I7IF99ID1cbiAgICAgICAgbWF0Y2ggY29tcGFyZSBwb3NpdGlvbl9hIHBvc2l0aW9uX2Igd2l0aFxuICAgICAgICAgIHwgMCAtPiBjb21wYXJlIGFkZGVkX2EgYWRkZWRfYlxuICAgICAgICAgIHwgbiAtPiBuXG4gICAgZW5kXG5cbiAgICB0eXBlIHQgPSBFbGVtZW50LnQgbGlzdFxuXG4gICAgbGV0IGVtcHR5ID0gW11cblxuICAgIGxldCBzaXplID0gTGlzdC5sZW5ndGhcblxuICAgIGxldCBhZGQgeHMgc3RvcF9wb2ludCA9XG4gICAgICBsZXQgZWxlbWVudCA9IHtFbGVtZW50LnN0b3BfcG9pbnQ7IGFkZGVkPUxpc3QubGVuZ3RoIHhzfSBpblxuICAgICAgbGV0IHJlYyBhdXggPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+IFtlbGVtZW50XVxuICAgICAgICB8IHg6OnhzIGFzIHh4cyAtPiBtYXRjaCBFbGVtZW50LmNvbXBhcmUgZWxlbWVudCB4IHdpdGhcbiAgICAgICAgICB8IC0xIC0+IGVsZW1lbnQ6Onh4c1xuICAgICAgICAgIHwgXyAtPiB4OjooYXV4IHhzKVxuICAgICAgaW4gYXV4IHhzXG5cbiAgICBsZXQgdG9fbGlzdCB4cyA9XG4gICAgICBMaXN0Lm1hcCB4cyB+ZjooZnVuIHtFbGVtZW50LnN0b3BfcG9pbnQ7IF99IC0+IHN0b3BfcG9pbnQpXG5cbiAgICBsZXQgZ2V0IHhzIH5pID1cbiAgICAgIGxldCB7RWxlbWVudC5zdG9wX3BvaW50OyBffSA9IExpc3QubnRoIHhzIGkgaW5cbiAgICAgIHN0b3BfcG9pbnRcbiAgZW5kXG5cbiAgKCogVGhpcyBpcyBqdXN0IHRvIGNvdmVyIFN0b3BQb2ludExpc3QudG9fbGlzdCwgd2hpY2ggaXMgdXNlZCBvbmx5IGluIEpzT2ZPQ2Fpcm8sIHdob3NlIHRlc3QgY292ZXJhZ2UgaXNuJ3QgbWVhc3VyZWQuICopXG4gIGxldCBfID0gU3RvcFBvaW50TGlzdC4oYWRkIGVtcHR5ICgwLiwgMC4sIDAuLCAwLiwgMC4pIHw+IHRvX2xpc3QpXG5cbiAgKCogV2hlbiB3ZSBkcm9wIHN1cHBvcnQgb2YgT0NhbWwgNC4wMiwgd2UgY2FuIHVzZSBbaW5saW5lIHJlY29yZHNdKGh0dHBzOi8vY2FtbC5pbnJpYS5mci9wdWIvZG9jcy9tYW51YWwtb2NhbWwtNC4wNi9leHRuLmh0bWwjcyUzQWlubGluZS1yZWNvcmRzKSAqKVxuICB0eXBlIGxpbmVhcl9ncmFkaWVudCA9IHtcbiAgICBwb2ludHM6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0OyAoKiAoeDAsIHkwLCB4MSwgeTEpICopXG4gICAgc3RvcF9wb2ludHM6IFN0b3BQb2ludExpc3QudDtcbiAgfVxuXG4gIHR5cGUgcmFkaWFsX2dyYWRpZW50ID0ge1xuICAgIGNpcmNsZXM6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgKiBmbG9hdDsgKCogKHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpICopXG4gICAgc3RvcF9wb2ludHM6IFN0b3BQb2ludExpc3QudDtcbiAgfVxuXG4gIHR5cGUgc291cmNlID1cbiAgICB8IFJnYmEgb2YgKGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0KSAoKiAociwgZywgYiwgYSkgKilcbiAgICB8IExpbmVhckdyYWRpZW50IG9mIGxpbmVhcl9ncmFkaWVudFxuICAgIHwgUmFkaWFsR3JhZGllbnQgb2YgcmFkaWFsX2dyYWRpZW50XG4gICAgfCBUeXBlTWlzbWF0Y2hcblxuICB0eXBlICdhIHQgPSBzb3VyY2UgcmVmIGNvbnN0cmFpbnQgJ2EgPSBbPGBTb2xpZCB8IGBTdXJmYWNlIHwgYEdyYWRpZW50IHwgYExpbmVhciB8IGBSYWRpYWxdXG5cbiAgdHlwZSBhbnkgPSBbYFNvbGlkIHwgYFN1cmZhY2UgfCBgR3JhZGllbnQgfCBgTGluZWFyIHwgYFJhZGlhbF0gdFxuXG4gIGxldCBjcmVhdGVfcmdiYSByIGcgYiBhID1cbiAgICByZWYgKFJnYmEgKHIsIGcsIGIsIGEpKVxuXG4gIGxldCBjcmVhdGVfcmdiIHIgZyBiID1cbiAgICBjcmVhdGVfcmdiYSByIGcgYiAxLlxuXG4gIGxldCBnZXRfcmdiYSBwYXR0ZXJuID1cbiAgICBtYXRjaCAhcGF0dGVybiB3aXRoXG4gICAgICB8IFJnYmEgY29sb3IgLT4gY29sb3JcbiAgICAgIHwgTGluZWFyR3JhZGllbnQgX1xuICAgICAgfCBSYWRpYWxHcmFkaWVudCBfXG4gICAgICB8IFR5cGVNaXNtYXRjaCAtPiByYWlzZSAoRXJyb3IgUEFUVEVSTl9UWVBFX01JU01BVENIKVxuXG4gIGxldCBjcmVhdGVfbGluZWFyIH54MCB+eTAgfngxIH55MSA9XG4gICAgcmVmIChMaW5lYXJHcmFkaWVudCB7cG9pbnRzPSh4MCwgeTAsIHgxLCB5MSk7IHN0b3BfcG9pbnRzPVN0b3BQb2ludExpc3QuZW1wdHl9KVxuXG4gIGxldCBnZXRfbGluZWFyX3BvaW50cyBwYXR0ZXJuID1cbiAgICBtYXRjaCAhcGF0dGVybiB3aXRoXG4gICAgICB8IExpbmVhckdyYWRpZW50IHtwb2ludHM7IF99IC0+IHBvaW50c1xuICAgICAgfCBSZ2JhIF9cbiAgICAgIHwgUmFkaWFsR3JhZGllbnQgX1xuICAgICAgfCBUeXBlTWlzbWF0Y2ggLT4gcmFpc2UgKEVycm9yIFBBVFRFUk5fVFlQRV9NSVNNQVRDSClcblxuICBsZXQgY3JlYXRlX3JhZGlhbCB+eDAgfnkwIH5yMCB+eDEgfnkxIH5yMSA9XG4gICAgcmVmIChSYWRpYWxHcmFkaWVudCB7Y2lyY2xlcz0oeDAsIHkwLCByMCwgeDEsIHkxLCByMSk7IHN0b3BfcG9pbnRzPVN0b3BQb2ludExpc3QuZW1wdHl9KVxuXG4gIGxldCBnZXRfcmFkaWFsX2NpcmNsZXMgcGF0dGVybiA9XG4gICAgbWF0Y2ggIXBhdHRlcm4gd2l0aFxuICAgICAgfCBSYWRpYWxHcmFkaWVudCB7Y2lyY2xlczsgX30gLT4gY2lyY2xlc1xuICAgICAgfCBMaW5lYXJHcmFkaWVudCBfXG4gICAgICB8IFJnYmEgX1xuICAgICAgfCBUeXBlTWlzbWF0Y2ggLT4gcmFpc2UgKEVycm9yIFBBVFRFUk5fVFlQRV9NSVNNQVRDSClcblxuICBsZXQgYWRkX2NvbG9yX3N0b3BfcmdiYSBwYXR0ZXJuID8ob2ZzPTAuKSByIGcgYiBhID1cbiAgICBsZXQgc3RvcF9wb2ludCA9IChvZnMsIHIsIGcsIGIsIGEpIGluXG4gICAgbWF0Y2ggIXBhdHRlcm4gd2l0aFxuICAgICAgfCBMaW5lYXJHcmFkaWVudCBncmFkaWVudCAtPlxuICAgICAgICBwYXR0ZXJuIDo9IExpbmVhckdyYWRpZW50IHtncmFkaWVudCB3aXRoIHN0b3BfcG9pbnRzPShTdG9wUG9pbnRMaXN0LmFkZCBncmFkaWVudC5zdG9wX3BvaW50cyBzdG9wX3BvaW50KX1cbiAgICAgIHwgUmFkaWFsR3JhZGllbnQgZ3JhZGllbnQgLT5cbiAgICAgICAgcGF0dGVybiA6PSBSYWRpYWxHcmFkaWVudCB7Z3JhZGllbnQgd2l0aCBzdG9wX3BvaW50cz0oU3RvcFBvaW50TGlzdC5hZGQgZ3JhZGllbnQuc3RvcF9wb2ludHMgc3RvcF9wb2ludCl9XG4gICAgICB8IFJnYmEgXyAtPiBwYXR0ZXJuIDo9IFR5cGVNaXNtYXRjaFxuICAgICAgfCBUeXBlTWlzbWF0Y2ggLT4gKClcblxuICBsZXQgYWRkX2NvbG9yX3N0b3BfcmdiIHBhdHRlcm4gP29mcyByIGcgYiA9XG4gICAgYWRkX2NvbG9yX3N0b3BfcmdiYSBwYXR0ZXJuID9vZnMgciBnIGIgMS5cblxuICBsZXQgZ2V0X2NvbG9yX3N0b3BfY291bnQgcGF0dGVybiA9XG4gICAgbWF0Y2ggIXBhdHRlcm4gd2l0aFxuICAgICAgfCBMaW5lYXJHcmFkaWVudCB7c3RvcF9wb2ludHM7IF99IHwgUmFkaWFsR3JhZGllbnQge3N0b3BfcG9pbnRzOyBffSAtPiBTdG9wUG9pbnRMaXN0LnNpemUgc3RvcF9wb2ludHNcbiAgICAgIHwgUmdiYSBfXG4gICAgICB8IFR5cGVNaXNtYXRjaCAtPiByYWlzZSAoRXJyb3IgUEFUVEVSTl9UWVBFX01JU01BVENIKVxuXG4gIGxldCBnZXRfY29sb3Jfc3RvcF9yZ2JhIHBhdHRlcm4gfmlkeCA9XG4gICAgbWF0Y2ggIXBhdHRlcm4gd2l0aFxuICAgICAgfCBMaW5lYXJHcmFkaWVudCB7c3RvcF9wb2ludHM7IF99IHwgUmFkaWFsR3JhZGllbnQge3N0b3BfcG9pbnRzOyBffSAtPiBTdG9wUG9pbnRMaXN0LmdldCBzdG9wX3BvaW50cyB+aTppZHhcbiAgICAgIHwgUmdiYSBfXG4gICAgICB8IFR5cGVNaXNtYXRjaCAtPiByYWlzZSAoRXJyb3IgUEFUVEVSTl9UWVBFX01JU01BVENIKVxuZW5kXG5cbnR5cGUgZmlsbF9ydWxlID1cbiAgfCBXSU5ESU5HXG4gIHwgRVZFTl9PRERcblxudHlwZSBsaW5lX2NhcCA9XG4gIHwgQlVUVFxuICB8IFJPVU5EXG4gIHwgU1FVQVJFXG5cbnR5cGUgbGluZV9qb2luID1cbiAgfCBKT0lOX01JVEVSXG4gIHwgSk9JTl9ST1VORFxuICB8IEpPSU5fQkVWRUxcblxudHlwZSBmb250X2V4dGVudHMgPSB7XG4gIGFzY2VudDogZmxvYXQ7XG4gIGRlc2NlbnQ6IGZsb2F0O1xuICBiYXNlbGluZTogZmxvYXQ7XG4gIG1heF94X2FkdmFuY2U6IGZsb2F0O1xuICBtYXhfeV9hZHZhbmNlOiBmbG9hdDtcbn1cblxudHlwZSB0ZXh0X2V4dGVudHMgPSB7XG4gIHhfYmVhcmluZzogZmxvYXQ7XG4gIHlfYmVhcmluZzogZmxvYXQ7XG4gIHdpZHRoOiBmbG9hdDtcbiAgaGVpZ2h0OiBmbG9hdDtcbiAgeF9hZHZhbmNlOiBmbG9hdDtcbiAgeV9hZHZhbmNlOiBmbG9hdDtcbn1cblxudHlwZSBvcGVyYXRvciA9XG4gIHwgQ0xFQVJcbiAgfCBTT1VSQ0VcbiAgfCBPVkVSXG4gIHwgSU5cbiAgfCBPVVRcbiAgfCBBVE9QXG4gIHwgREVTVFxuICB8IERFU1RfT1ZFUlxuICB8IERFU1RfSU5cbiAgfCBERVNUX09VVFxuICB8IERFU1RfQVRPUFxuICB8IFhPUlxuICB8IEFERFxuICB8IFNBVFVSQVRFXG5cbm1vZHVsZSBQb2ludHM6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgY3JlYXRlOiB1bml0IC0+IHRcblxuICB2YWwgc2V0X3N0YXJ0OiB0IC0+IHRyYW5zZm9ybWF0aW9uOk1hdHJpeC50IC0+IHg6ZmxvYXQgLT4geTpmbG9hdCAtPiB1bml0XG4gIHZhbCBzZXRfc3RhcnRfaWZfbm9uZTogdCAtPiB0cmFuc2Zvcm1hdGlvbjpNYXRyaXgudCAtPiB4OmZsb2F0IC0+IHk6ZmxvYXQgLT4gdW5pdFxuICB2YWwgcmVzZXRfc3RhcnQ6IHQgLT4gdW5pdFxuXG4gIHZhbCBzZXRfY3VycmVudDogdCAtPiB0cmFuc2Zvcm1hdGlvbjpNYXRyaXgudCAtPiB4OmZsb2F0IC0+IHk6ZmxvYXQgLT4gdW5pdFxuICB2YWwgc2V0X2N1cnJlbnRfZnJvbV9zdGFydDogdCAtPiB1bml0XG4gIHZhbCByZXNldF9jdXJyZW50OiB0IC0+IHVuaXRcbiAgdmFsIGN1cnJlbnQ6IHQgLT4gdHJhbnNmb3JtYXRpb246TWF0cml4LnQgLT4gKGZsb2F0ICogZmxvYXQpIG9wdGlvblxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IHtcbiAgICBtdXRhYmxlIHN0YXJ0OiAoZmxvYXQgKiBmbG9hdCkgb3B0aW9uO1xuICAgIG11dGFibGUgY3VycmVudDogKGZsb2F0ICogZmxvYXQpIG9wdGlvbjtcbiAgfVxuXG4gIGxldCBjcmVhdGUgKCkgPSB7XG4gICAgc3RhcnQgPSBOb25lO1xuICAgIGN1cnJlbnQgPSBOb25lO1xuICB9XG5cbiAgbGV0IHNldF9zdGFydCBwb2ludHMgfnRyYW5zZm9ybWF0aW9uIH54IH55ID1cbiAgICBwb2ludHMuc3RhcnQgPC0gU29tZSAoTWF0cml4LnRyYW5zZm9ybV9wb2ludCB0cmFuc2Zvcm1hdGlvbiB4IHkpXG5cbiAgbGV0IHNldF9zdGFydF9pZl9ub25lIHBvaW50cyB+dHJhbnNmb3JtYXRpb24gfnggfnkgPVxuICAgIGlmIHBvaW50cy5zdGFydCA9IE5vbmUgdGhlblxuICAgIHBvaW50cy5zdGFydCA8LSBTb21lIChNYXRyaXgudHJhbnNmb3JtX3BvaW50IHRyYW5zZm9ybWF0aW9uIHggeSlcblxuICBsZXQgcmVzZXRfc3RhcnQgcG9pbnRzID1cbiAgICBwb2ludHMuc3RhcnQgPC0gTm9uZVxuXG4gIGxldCBzZXRfY3VycmVudCBwb2ludHMgfnRyYW5zZm9ybWF0aW9uIH54IH55ID1cbiAgICBwb2ludHMuY3VycmVudCA8LSBTb21lIChNYXRyaXgudHJhbnNmb3JtX3BvaW50IHRyYW5zZm9ybWF0aW9uIHggeSlcblxuICBsZXQgc2V0X2N1cnJlbnRfZnJvbV9zdGFydCBwb2ludHMgPVxuICAgIHBvaW50cy5jdXJyZW50IDwtIHBvaW50cy5zdGFydFxuXG4gIGxldCByZXNldF9jdXJyZW50IHBvaW50cyA9XG4gICAgcG9pbnRzLmN1cnJlbnQgPC0gTm9uZVxuXG4gIGxldCBjdXJyZW50IHBvaW50cyB+dHJhbnNmb3JtYXRpb24gPVxuICAgIG1hdGNoIHBvaW50cy5jdXJyZW50IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgKHgsIHkpIC0+IFNvbWUgKE1hdHJpeC50cmFuc2Zvcm1fcG9pbnQgKE1hdHJpeC5pbml0X2ludmVyc2UgdHJhbnNmb3JtYXRpb24pIHggeSlcbmVuZFxuXG4gIFxuIyAxMCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gIGxldCAoKSA9IFByaW50ZXhjLnJlZ2lzdGVyX3ByaW50ZXIgKGZ1bmN0aW9uXG4gICAgfCBFcnJvciBzdGF0dXMgLT4gU29tZSAoUHJpbnRmLnNwcmludGYgXCJDYWlyb01vY2suRXJyb3IoJXMpXCIgKHN0YXR1c19yZXByIHN0YXR1cykpXG4gICAgfCBfIC0+IE5vbmVcbiAgKVxuXG4gIG1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IHtcbiAgICAgIGRhc2hlczogZmxvYXQgYXJyYXk7XG4gICAgICBmaWxsX3J1bGU6IGZpbGxfcnVsZTtcbiAgICAgIGZvbnQ6IGZvbnQ7XG4gICAgICBsaW5lX2NhcDogbGluZV9jYXA7XG4gICAgICBsaW5lX2pvaW46IGxpbmVfam9pbjtcbiAgICAgIGxpbmVfd2lkdGg6IGZsb2F0O1xuICAgICAgbWl0ZXJfbGltaXQ6IGZsb2F0O1xuICAgICAgb2ZzOiBmbG9hdDtcbiAgICAgIG9wZXJhdG9yOiBvcGVyYXRvcjtcbiAgICAgIHNvdXJjZTogUGF0dGVybi5zb3VyY2U7XG4gICAgICB0cmFuc2Zvcm1hdGlvbjogTWF0cml4LnQ7XG4gICAgfVxuICBlbmRcblxuICB0eXBlIGNvbnRleHQgPSB7XG4gICAgbXV0YWJsZSBzdGF0ZXM6IFN0YXRlLnQgbGlzdDtcbiAgICBwb2ludHM6IFBvaW50cy50O1xuICB9XG5cbiAgbGV0IGNyZWF0ZSAoKSA9IHtcbiAgICBzdGF0ZXMgPSBbXG4gICAgICB7XG4gICAgICAgIGRhc2hlcyA9IFt8fF07XG4gICAgICAgIGZpbGxfcnVsZSA9IFdJTkRJTkc7XG4gICAgICAgIGZvbnQgPSB7XG4gICAgICAgICAgc2xhbnQgPSBVcHJpZ2h0O1xuICAgICAgICAgIHdlaWdodCA9IE5vcm1hbDtcbiAgICAgICAgICBzaXplID0gMTAuO1xuICAgICAgICAgIGZhbWlseSA9IFwic2Fucy1zZXJpZlwiO1xuICAgICAgICB9O1xuICAgICAgICBsaW5lX2NhcCA9IEJVVFQ7XG4gICAgICAgIGxpbmVfam9pbiA9IEpPSU5fTUlURVI7XG4gICAgICAgIGxpbmVfd2lkdGggPSAyLjtcbiAgICAgICAgbWl0ZXJfbGltaXQgPSAxMC47XG4gICAgICAgIG9mcyA9IDAuO1xuICAgICAgICBvcGVyYXRvciA9IE9WRVI7XG4gICAgICAgIHNvdXJjZSA9ICEoUGF0dGVybi5jcmVhdGVfcmdiIDAuIDAuIDAuKTtcbiAgICAgICAgdHJhbnNmb3JtYXRpb24gPSBNYXRyaXguaW5pdF9pZGVudGl0eSAoKTtcbiAgICAgIH07XG4gICAgXTtcbiAgICBwb2ludHMgPSBQb2ludHMuY3JlYXRlICgpO1xuICB9XG5cbiAgbGV0IHN0YXRlIHtzdGF0ZXM7IF99ID1cbiAgICBMaXN0LmhkIHN0YXRlc1xuXG4gIGxldCBtdXRhdGVfc3RhdGUgY29udGV4dCBmID1cbiAgICBsZXQgc3RhdGUgPSBmIChzdGF0ZSBjb250ZXh0KSBpblxuICAgIGNvbnRleHQuc3RhdGVzIDwtIHN0YXRlOjooTGlzdC50bCBjb250ZXh0LnN0YXRlcylcblxuXG4gIGxldCBzYXZlIGNvbnRleHQgPVxuICAgIGNvbnRleHQuc3RhdGVzIDwtIChzdGF0ZSBjb250ZXh0KTo6Y29udGV4dC5zdGF0ZXNcblxuICBsZXQgcmVzdG9yZSBjb250ZXh0ID1cbiAgICBsZXQgc3RhdGVzID1cbiAgICAgIG1hdGNoIGNvbnRleHQuc3RhdGVzIHdpdGhcbiAgICAgICAgfCBbXSAoKkJJU0VDVC1JR05PUkUqKSAoKiBUaGlzIGNhbm5vdCBoYXBwZW46IHJlc3RvcmUgaXMgdGhlIG9ubHkgZnVuY3Rpb24gcmVtb3Zpbmcgc3RhdGVzIGFuZCBpdCByZWZ1c2VzIHRvIHJlbW92ZSB0aGUgbGFzdCBvbmUuICopXG4gICAgICAgIHwgW19dIC0+IHJhaXNlIChFcnJvciBJTlZBTElEX1JFU1RPUkUpXG4gICAgICAgIHwgXzo6c3RhdGVzIC0+IHN0YXRlc1xuICAgIGluXG4gICAgY29udGV4dC5zdGF0ZXMgPC0gc3RhdGVzXG5cblxuICBsZXQgc2V0X21hdHJpeCBjb250ZXh0IHRyYW5zZm9ybWF0aW9uID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAoZnVuIHMgLT4ge3Mgd2l0aCB0cmFuc2Zvcm1hdGlvbn0pXG5cbiAgbGV0IGdldF9tYXRyaXggY29udGV4dCA9XG4gICAgKHN0YXRlIGNvbnRleHQpLnRyYW5zZm9ybWF0aW9uXG5cbiAgbGV0IHRyYW5zZm9ybV8gbSBzID1cbiAgICB7cyB3aXRoIFN0YXRlLnRyYW5zZm9ybWF0aW9uPU1hdHJpeC5tdWx0aXBseSBzLlN0YXRlLnRyYW5zZm9ybWF0aW9uIG19XG5cbiAgbGV0IHRyYW5zZm9ybSBjb250ZXh0IG0gPVxuICAgIG11dGF0ZV9zdGF0ZSBjb250ZXh0ICh0cmFuc2Zvcm1fIG0pXG5cbiAgbGV0IHNjYWxlIGNvbnRleHQgeCB5ID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAodHJhbnNmb3JtXyAoTWF0cml4LmluaXRfc2NhbGUgeCB5KSlcblxuICBsZXQgdHJhbnNsYXRlIGNvbnRleHQgeCB5ID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAodHJhbnNmb3JtXyAoTWF0cml4LmluaXRfdHJhbnNsYXRlIHggeSkpXG5cbiAgbGV0IHJvdGF0ZSBjb250ZXh0IGFuZ2xlID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAodHJhbnNmb3JtXyAoTWF0cml4LmluaXRfcm90YXRlIGFuZ2xlKSlcblxuICBsZXQgaWRlbnRpdHlfbWF0cml4IGNvbnRleHQgPVxuICAgIG11dGF0ZV9zdGF0ZSBjb250ZXh0IChmdW4gcyAtPiB7cyB3aXRoIHRyYW5zZm9ybWF0aW9uPU1hdHJpeC5pbml0X2lkZW50aXR5ICgpfSlcblxuICBsZXQgZGV2aWNlX3RvX3VzZXIgY29udGV4dCB4IHkgPVxuICAgIE1hdHJpeC50cmFuc2Zvcm1fcG9pbnQgKE1hdHJpeC5pbml0X2ludmVyc2UgKHN0YXRlIGNvbnRleHQpLnRyYW5zZm9ybWF0aW9uKSB4IHlcblxuICBsZXQgZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2UgY29udGV4dCBkeCBkeSA9XG4gICAgTWF0cml4LnRyYW5zZm9ybV9kaXN0YW5jZSAoTWF0cml4LmluaXRfaW52ZXJzZSAoc3RhdGUgY29udGV4dCkudHJhbnNmb3JtYXRpb24pIH5keCB+ZHlcblxuICBsZXQgdXNlcl90b19kZXZpY2UgY29udGV4dCB4IHkgPVxuICAgIE1hdHJpeC50cmFuc2Zvcm1fcG9pbnQgKHN0YXRlIGNvbnRleHQpLnRyYW5zZm9ybWF0aW9uIHggeVxuXG4gIGxldCB1c2VyX3RvX2RldmljZV9kaXN0YW5jZSBjb250ZXh0IGR4IGR5ID1cbiAgICBNYXRyaXgudHJhbnNmb3JtX2Rpc3RhbmNlIChzdGF0ZSBjb250ZXh0KS50cmFuc2Zvcm1hdGlvbiB+ZHggfmR5XG5cblxuICBsZXQgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydCB+Y3VycmVudCA9XG4gICAgbGV0IHRyYW5zZm9ybWF0aW9uID0gKHN0YXRlIGNvbnRleHQpLnRyYW5zZm9ybWF0aW9uIGluXG4gICAgbGV0IG1ha2VfcmVsYXRpdmUgfmR4IH5keSA9XG4gICAgICBsZXQgKHgsIHkpID1cbiAgICAgICAgbWF0Y2ggUG9pbnRzLmN1cnJlbnQgY29udGV4dC5wb2ludHMgfnRyYW5zZm9ybWF0aW9uIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKEVycm9yIE5PX0NVUlJFTlRfUE9JTlQpXG4gICAgICAgICAgfCBTb21lICh4LCB5KSAtPiAoeCwgeSlcbiAgICAgIGluXG4gICAgICAoeCArLiBkeCwgeSArLiBkeSlcbiAgICBpblxuICAgIGJlZ2luIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICAgIHwgYE5vbmUgLT4gKClcbiAgICAgIHwgYFJlc2V0IC0+IFBvaW50cy5yZXNldF9zdGFydCBjb250ZXh0LnBvaW50c1xuICAgICAgfCBgSWZOb25lICh4LCB5KSAtPiBQb2ludHMuc2V0X3N0YXJ0X2lmX25vbmUgY29udGV4dC5wb2ludHMgfnRyYW5zZm9ybWF0aW9uIH54IH55XG4gICAgICB8IGBTZXQgKHgsIHkpIC0+IFBvaW50cy5zZXRfc3RhcnQgY29udGV4dC5wb2ludHMgfnRyYW5zZm9ybWF0aW9uIH54IH55XG4gICAgICB8IGBSZWxhdGl2ZSAoZHgsIGR5KSAtPlxuICAgICAgICBsZXQgKHgsIHkpID0gbWFrZV9yZWxhdGl2ZSB+ZHggfmR5IGluXG4gICAgICAgIFBvaW50cy5zZXRfc3RhcnQgY29udGV4dC5wb2ludHMgfnRyYW5zZm9ybWF0aW9uIH54IH55XG4gICAgZW5kO1xuICAgIGJlZ2luIG1hdGNoIGN1cnJlbnQgd2l0aFxuICAgICAgfCBgUmVzZXQgLT4gUG9pbnRzLnJlc2V0X2N1cnJlbnQgY29udGV4dC5wb2ludHNcbiAgICAgIHwgYEZyb21TdGFydCAtPiBQb2ludHMuc2V0X2N1cnJlbnRfZnJvbV9zdGFydCBjb250ZXh0LnBvaW50c1xuICAgICAgfCBgU2V0ICh4LCB5KSAtPiBQb2ludHMuc2V0X2N1cnJlbnQgY29udGV4dC5wb2ludHMgfnRyYW5zZm9ybWF0aW9uIH54IH55XG4gICAgICB8IGBSZWxhdGl2ZSAoZHgsIGR5KSAtPlxuICAgICAgICBsZXQgKHgsIHkpID0gbWFrZV9yZWxhdGl2ZSB+ZHggfmR5IGluXG4gICAgICAgIFBvaW50cy5zZXRfY3VycmVudCBjb250ZXh0LnBvaW50cyB+dHJhbnNmb3JtYXRpb24gfnggfnlcbiAgICBlbmRcblxuXG4gIGxldCBtb3ZlX3RvIGNvbnRleHQgeCB5ID1cbiAgICBtdXRhdGVfcG9pbnRzIGNvbnRleHQgfnN0YXJ0OihgU2V0ICh4LCB5KSkgfmN1cnJlbnQ6YEZyb21TdGFydFxuXG4gIGxldCByZWxfbW92ZV90byBjb250ZXh0IHggeSA9XG4gICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDooYFJlbGF0aXZlICh4LCB5KSkgfmN1cnJlbnQ6YEZyb21TdGFydFxuXG4gIGxldCBsaW5lX3RvIGNvbnRleHQgeCB5ID1cbiAgICBtdXRhdGVfcG9pbnRzIGNvbnRleHQgfnN0YXJ0OihgSWZOb25lICh4LCB5KSkgfmN1cnJlbnQ6KGBTZXQgKHgsIHkpKVxuXG4gIGxldCByZWxfbGluZV90byBjb250ZXh0IHggeSA9XG4gICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDooYElmTm9uZSAoeCwgeSkpIH5jdXJyZW50OihgUmVsYXRpdmUgKHgsIHkpKVxuXG4gIGxldCBjdXJ2ZV90byBjb250ZXh0IHgxIHkxIF8gXyB4MyB5MyA9XG4gICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDooYElmTm9uZSAoeDEsIHkxKSkgfmN1cnJlbnQ6KGBTZXQgKHgzLCB5MykpXG5cbiAgbGV0IHJlbF9jdXJ2ZV90byBjb250ZXh0IHgxIHkxIF8gXyB4MyB5MyA9XG4gICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDooYElmTm9uZSAoeDEsIHkxKSkgfmN1cnJlbnQ6KGBSZWxhdGl2ZSAoeDMsIHkzKSlcblxuICBsZXQgcmVjdGFuZ2xlIGNvbnRleHQgeCB5IH53Ol8gfmg6XyA9XG4gICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDpgTm9uZSB+Y3VycmVudDooYFNldCAoeCwgeSkpXG5cbiAgbGV0IGFyYyBjb250ZXh0IHggeSB+ciB+YTEgfmEyID1cbiAgICBtdXRhdGVfcG9pbnRzIGNvbnRleHQgfnN0YXJ0OihgSWZOb25lICh4ICsuIHIgKi4gKGNvcyBhMSksIHkgKy4gciAqLiAoc2luIGExKSkpIH5jdXJyZW50OihgU2V0ICh4ICsuIHIgKi4gKGNvcyBhMiksIHkgKy4gciAqLiAoc2luIGEyKSkpXG5cbiAgbGV0IGFyY19uZWdhdGl2ZSBjb250ZXh0IHggeSB+ciB+YTEgfmEyID1cbiAgICBtdXRhdGVfcG9pbnRzIGNvbnRleHQgfnN0YXJ0OihgSWZOb25lICh4ICsuIHIgKi4gKGNvcyBhMSksIHkgKy4gciAqLiAoc2luIGExKSkpIH5jdXJyZW50OihgU2V0ICh4ICsuIHIgKi4gKGNvcyBhMiksIHkgKy4gciAqLiAoc2luIGEyKSkpXG5cbiAgbW9kdWxlIFBhdGggPSBzdHJ1Y3RcbiAgICBsZXQgZ2V0X2N1cnJlbnRfcG9pbnQgY29udGV4dCA9XG4gICAgICBsZXQgdHJhbnNmb3JtYXRpb24gPSAoc3RhdGUgY29udGV4dCkudHJhbnNmb3JtYXRpb24gaW5cbiAgICAgIG1hdGNoIFBvaW50cy5jdXJyZW50IH50cmFuc2Zvcm1hdGlvbiBjb250ZXh0LnBvaW50cyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiAoMC4sIDAuKVxuICAgICAgICB8IFNvbWUgKHgsIHkpIC0+ICh4LCB5KVxuXG4gICAgbGV0IGNsZWFyIGNvbnRleHQgPVxuICAgICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDpgUmVzZXQgfmN1cnJlbnQ6YFJlc2V0XG5cbiAgICBsZXQgY2xvc2UgY29udGV4dCA9XG4gICAgICBtdXRhdGVfcG9pbnRzIGNvbnRleHQgfnN0YXJ0OmBOb25lIH5jdXJyZW50OmBGcm9tU3RhcnRcbiAgZW5kXG5cbiAgbGV0IHN0cm9rZV9wcmVzZXJ2ZSBfID1cbiAgICAoKVxuXG4gIGxldCBzdHJva2UgY29udGV4dCA9XG4gICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDpgUmVzZXQgfmN1cnJlbnQ6YFJlc2V0XG5cbiAgbGV0IGZpbGxfcHJlc2VydmUgXyA9XG4gICAgKClcblxuICBsZXQgZmlsbCBjb250ZXh0ID1cbiAgICBtdXRhdGVfcG9pbnRzIGNvbnRleHQgfnN0YXJ0OmBSZXNldCB+Y3VycmVudDpgUmVzZXRcblxuICBsZXQgY2xpcF9wcmVzZXJ2ZSBfID1cbiAgICAoKVxuXG4gIGxldCBjbGlwIGNvbnRleHQgPVxuICAgIG11dGF0ZV9wb2ludHMgY29udGV4dCB+c3RhcnQ6YFJlc2V0IH5jdXJyZW50OmBSZXNldFxuXG4gIGxldCBwYWludCA/YWxwaGE6XyBfID1cbiAgICAoKVxuXG5cbiAgbGV0IHNldF9saW5lX3dpZHRoIGNvbnRleHQgbGluZV93aWR0aCA9XG4gICAgbXV0YXRlX3N0YXRlIGNvbnRleHQgKGZ1biBzIC0+IHtzIHdpdGggbGluZV93aWR0aH0pXG5cbiAgbGV0IGdldF9saW5lX3dpZHRoIGNvbnRleHQgPVxuICAgIChzdGF0ZSBjb250ZXh0KS5saW5lX3dpZHRoXG5cbiAgbGV0IHNldF9kYXNoIGNvbnRleHQgPyhvZnM9MC4pIGRhc2hlcyA9XG4gICAgbXV0YXRlX3N0YXRlIGNvbnRleHQgKGZ1biBzIC0+IHtzIHdpdGggZGFzaGVzOyBvZnN9KVxuXG4gIGxldCBnZXRfZGFzaCBjb250ZXh0ID1cbiAgICBsZXQgc3RhdGUgPSBzdGF0ZSBjb250ZXh0IGluXG4gICAgKHN0YXRlLmRhc2hlcywgc3RhdGUub2ZzKVxuXG4gIGxldCBzZXRfZmlsbF9ydWxlIGNvbnRleHQgZmlsbF9ydWxlID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAoZnVuIHMgLT4ge3Mgd2l0aCBmaWxsX3J1bGV9KVxuXG4gIGxldCBnZXRfZmlsbF9ydWxlIGNvbnRleHQgPVxuICAgIChzdGF0ZSBjb250ZXh0KS5maWxsX3J1bGVcblxuICBsZXQgc2V0X2xpbmVfY2FwIGNvbnRleHQgbGluZV9jYXAgPVxuICAgIG11dGF0ZV9zdGF0ZSBjb250ZXh0IChmdW4gcyAtPiB7cyB3aXRoIGxpbmVfY2FwfSlcblxuICBsZXQgZ2V0X2xpbmVfY2FwIGNvbnRleHQgPVxuICAgIChzdGF0ZSBjb250ZXh0KS5saW5lX2NhcFxuXG4gIGxldCBzZXRfbGluZV9qb2luIGNvbnRleHQgbGluZV9qb2luID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAoZnVuIHMgLT4ge3Mgd2l0aCBsaW5lX2pvaW59KVxuXG4gIGxldCBnZXRfbGluZV9qb2luIGNvbnRleHQgPVxuICAgIChzdGF0ZSBjb250ZXh0KS5saW5lX2pvaW5cblxuICBsZXQgc2V0X21pdGVyX2xpbWl0IGNvbnRleHQgbWl0ZXJfbGltaXQgPVxuICAgIG11dGF0ZV9zdGF0ZSBjb250ZXh0IChmdW4gcyAtPiB7cyB3aXRoIG1pdGVyX2xpbWl0fSlcblxuICBsZXQgZ2V0X21pdGVyX2xpbWl0IGNvbnRleHQgPVxuICAgIChzdGF0ZSBjb250ZXh0KS5taXRlcl9saW1pdFxuXG4gIGxldCBzZXRfb3BlcmF0b3IgY29udGV4dCBvcGVyYXRvciA9XG4gICAgbXV0YXRlX3N0YXRlIGNvbnRleHQgKGZ1biBzIC0+IHtzIHdpdGggb3BlcmF0b3J9KVxuXG4gIGxldCBnZXRfb3BlcmF0b3IgY29udGV4dCA9XG4gICAgKHN0YXRlIGNvbnRleHQpLm9wZXJhdG9yXG5cblxuICBsZXQgc2V0X3NvdXJjZSBjb250ZXh0IHBhdHRlcm4gPVxuICAgIGxldCBzb3VyY2UgPSAhcGF0dGVybiBpblxuICAgIG11dGF0ZV9zdGF0ZSBjb250ZXh0IChmdW4gcyAtPiB7cyB3aXRoIHNvdXJjZX0pXG5cbiAgbGV0IGdldF9zb3VyY2UgY29udGV4dCA9XG4gICAgcmVmIChzdGF0ZSBjb250ZXh0KS5zb3VyY2VcblxuICBsZXQgc2V0X3NvdXJjZV9yZ2IgY29udGV4dCByIGcgYiA9XG4gICAgbGV0IHNvdXJjZSA9ICEoUGF0dGVybi5jcmVhdGVfcmdiIHIgZyBiKSBpblxuICAgIG11dGF0ZV9zdGF0ZSBjb250ZXh0IChmdW4gcyAtPiB7cyB3aXRoIHNvdXJjZX0pXG5cbiAgbGV0IHNldF9zb3VyY2VfcmdiYSBjb250ZXh0IHIgZyBiIGEgPVxuICAgIGxldCBzb3VyY2UgPSAhKFBhdHRlcm4uY3JlYXRlX3JnYmEgciBnIGIgYSkgaW5cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAoZnVuIHMgLT4ge3Mgd2l0aCBzb3VyY2V9KVxuXG5cbiAgbGV0IHNlbGVjdF9mb250X2ZhY2UgY29udGV4dCA/KHNsYW50PVVwcmlnaHQpID8od2VpZ2h0PU5vcm1hbCkgZmFtaWx5ID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAoZnVuIHMgLT4ge3Mgd2l0aCBmb250PXtzLmZvbnQgd2l0aCBzbGFudDsgd2VpZ2h0OyBmYW1pbHl9fSlcblxuICBsZXQgc2V0X2ZvbnRfc2l6ZSBjb250ZXh0IHNpemUgPVxuICAgIG11dGF0ZV9zdGF0ZSBjb250ZXh0IChmdW4gcyAtPiB7cyB3aXRoIGZvbnQ9e3MuZm9udCB3aXRoIHNpemV9fSlcblxuICBsZXQgc2hvd190ZXh0IGNvbnRleHQgcyA9XG4gICAgbGV0ICh4LCB5KSA9XG4gICAgICBQYXRoLmdldF9jdXJyZW50X3BvaW50IGNvbnRleHRcbiAgICBhbmQgd2lkdGggPVxuICAgICAgKHN0YXRlIGNvbnRleHQpLmZvbnQuc2l6ZSAqLiAwLjggKi4gKGZsb2F0X29mX2ludCAoU3RyaW5nLmxlbmd0aCBzKSlcbiAgICBpblxuICAgIG11dGF0ZV9wb2ludHMgY29udGV4dCB+c3RhcnQ6YE5vbmUgfmN1cnJlbnQ6KGBTZXQgKHggKy4gd2lkdGgsIHkpKVxuXG4gIGxldCBmb250X2V4dGVudHMgY29udGV4dCA9XG4gICAgbGV0IGFzY2VudCA9IChzdGF0ZSBjb250ZXh0KS5mb250LnNpemUgaW5cbiAgICB7XG4gICAgICBhc2NlbnQ7XG4gICAgICBkZXNjZW50PWFzY2VudCAvLiA0LjtcbiAgICAgIGJhc2VsaW5lPTAuO1xuICAgICAgbWF4X3hfYWR2YW5jZT0yLiAqLiBhc2NlbnQ7XG4gICAgICBtYXhfeV9hZHZhbmNlPTAuO1xuICAgIH1cblxuICBsZXQgdGV4dF9leHRlbnRzIGNvbnRleHQgcyA9XG4gICAgbGV0IHdpZHRoID1cbiAgICAgIChzdGF0ZSBjb250ZXh0KS5mb250LnNpemUgKi4gMC44ICouIChmbG9hdF9vZl9pbnQgKFN0cmluZy5sZW5ndGggcykpXG4gICAgYW5kIGhlaWdodCA9XG4gICAgICAoc3RhdGUgY29udGV4dCkuZm9udC5zaXplXG4gICAgaW5cbiAgICB7eF9iZWFyaW5nPTAuOyB5X2JlYXJpbmc9MC47IHdpZHRoOyBoZWlnaHQ7IHhfYWR2YW5jZT13aWR0aDsgeV9hZHZhbmNlPTAufVxuZW5kXG5cbm1vZHVsZSBEZWNvcmF0ZShDOiBTKSA9IHN0cnVjdFxuICBvcGVuIFN0ZExhYmVsc1xuXG4gIHR5cGUgZmlsbF9ydWxlID0gQy5maWxsX3J1bGUgPVxuICAgIHwgV0lORElOR1xuICAgIHwgRVZFTl9PRERcblxuICB0eXBlIGxpbmVfY2FwID0gQy5saW5lX2NhcCA9XG4gICAgfCBCVVRUXG4gICAgfCBST1VORFxuICAgIHwgU1FVQVJFXG5cbiAgdHlwZSBsaW5lX2pvaW4gPSBDLmxpbmVfam9pbiA9XG4gICAgfCBKT0lOX01JVEVSXG4gICAgfCBKT0lOX1JPVU5EXG4gICAgfCBKT0lOX0JFVkVMXG5cbiAgdHlwZSBtYXRyaXggPSBDLm1hdHJpeD0ge1xuICAgIG11dGFibGUgeHg6IGZsb2F0O1xuICAgIG11dGFibGUgeXg6IGZsb2F0O1xuICAgIG11dGFibGUgeHk6IGZsb2F0O1xuICAgIG11dGFibGUgeXk6IGZsb2F0O1xuICAgIG11dGFibGUgeDA6IGZsb2F0O1xuICAgIG11dGFibGUgeTA6IGZsb2F0O1xuICB9XG5cbiAgdHlwZSB0ZXh0X2V4dGVudHMgPSBDLnRleHRfZXh0ZW50cyA9IHtcbiAgICB4X2JlYXJpbmcgOiBmbG9hdDtcbiAgICB5X2JlYXJpbmcgOiBmbG9hdDtcbiAgICB3aWR0aCA6IGZsb2F0O1xuICAgIGhlaWdodCA6IGZsb2F0O1xuICAgIHhfYWR2YW5jZSA6IGZsb2F0O1xuICAgIHlfYWR2YW5jZSA6IGZsb2F0O1xuICB9XG5cbiAgdHlwZSBmb250X2V4dGVudHMgPSBDLmZvbnRfZXh0ZW50cyA9IHtcbiAgICBhc2NlbnQ6IGZsb2F0O1xuICAgIGRlc2NlbnQ6IGZsb2F0O1xuICAgIGJhc2VsaW5lOiBmbG9hdDtcbiAgICBtYXhfeF9hZHZhbmNlOiBmbG9hdDtcbiAgICBtYXhfeV9hZHZhbmNlOiBmbG9hdDtcbiAgfVxuXG4gIHR5cGUgb3BlcmF0b3IgPSBDLm9wZXJhdG9yID1cbiAgICB8IENMRUFSXG4gICAgfCBTT1VSQ0VcbiAgICB8IE9WRVJcbiAgICB8IElOXG4gICAgfCBPVVRcbiAgICB8IEFUT1BcbiAgICB8IERFU1RcbiAgICB8IERFU1RfT1ZFUlxuICAgIHwgREVTVF9JTlxuICAgIHwgREVTVF9PVVRcbiAgICB8IERFU1RfQVRPUFxuICAgIHwgWE9SXG4gICAgfCBBRERcbiAgICB8IFNBVFVSQVRFXG5cbiAgdHlwZSB3ZWlnaHQgPSBDLndlaWdodCA9XG4gICAgfCBOb3JtYWxcbiAgICB8IEJvbGRcblxuICB0eXBlIHNsYW50ID0gQy5zbGFudCA9XG4gICAgfCBVcHJpZ2h0XG4gICAgfCBJdGFsaWNcbiAgICB8IE9ibGlxdWVcblxuICB0eXBlIHN0YXR1cyA9IEMuc3RhdHVzID1cbiAgICB8IElOVkFMSURfUkVTVE9SRVxuICAgIHwgSU5WQUxJRF9QT1BfR1JPVVBcbiAgICB8IE5PX0NVUlJFTlRfUE9JTlRcbiAgICB8IElOVkFMSURfTUFUUklYXG4gICAgfCBJTlZBTElEX1NUQVRVU1xuICAgIHwgTlVMTF9QT0lOVEVSXG4gICAgfCBJTlZBTElEX1NUUklOR1xuICAgIHwgSU5WQUxJRF9QQVRIX0RBVEFcbiAgICB8IFJFQURfRVJST1JcbiAgICB8IFdSSVRFX0VSUk9SXG4gICAgfCBTVVJGQUNFX0ZJTklTSEVEXG4gICAgfCBTVVJGQUNFX1RZUEVfTUlTTUFUQ0hcbiAgICB8IFBBVFRFUk5fVFlQRV9NSVNNQVRDSFxuICAgIHwgSU5WQUxJRF9DT05URU5UXG4gICAgfCBJTlZBTElEX0ZPUk1BVFxuICAgIHwgSU5WQUxJRF9WSVNVQUxcbiAgICB8IEZJTEVfTk9UX0ZPVU5EXG4gICAgfCBJTlZBTElEX0RBU0hcbiAgICB8IElOVkFMSURfRFNDX0NPTU1FTlRcbiAgICB8IElOVkFMSURfSU5ERVhcbiAgICB8IENMSVBfTk9UX1JFUFJFU0VOVEFCTEVcbiAgICB8IFRFTVBfRklMRV9FUlJPUlxuICAgIHwgSU5WQUxJRF9TVFJJREVcbiAgICB8IEZPTlRfVFlQRV9NSVNNQVRDSFxuICAgIHwgVVNFUl9GT05UX0lNTVVUQUJMRVxuICAgIHwgVVNFUl9GT05UX0VSUk9SXG4gICAgfCBORUdBVElWRV9DT1VOVFxuICAgIHwgSU5WQUxJRF9DTFVTVEVSU1xuICAgIHwgSU5WQUxJRF9TTEFOVFxuICAgIHwgSU5WQUxJRF9XRUlHSFRcbiAgICB8IElOVkFMSURfU0laRVxuICAgIHwgVVNFUl9GT05UX05PVF9JTVBMRU1FTlRFRFxuICAgIHwgREVWSUNFX1RZUEVfTUlTTUFUQ0hcbiAgICB8IERFVklDRV9FUlJPUlxuICAgIHwgSU5WQUxJRF9NRVNIX0NPTlNUUlVDVElPTlxuICAgIHwgREVWSUNFX0ZJTklTSEVEXG4gICAgfCBKQklHMl9HTE9CQUxfTUlTU0lOR1xuXG4gIG1vZHVsZSBQYXR0ZXJuID0gQy5QYXR0ZXJuXG5cbiAgbW9kdWxlIE1hdHJpeCA9IEMuTWF0cml4XG5cbiAgZXhjZXB0aW9uIEVycm9yID0gQy5FcnJvclxuXG4gIGV4Y2VwdGlvbiBVbmF2YWlsYWJsZSA9IEMuVW5hdmFpbGFibGVcblxuICBsZXQgc3RhdHVzX3RvX3N0cmluZyA9IEMuc3RhdHVzX3RvX3N0cmluZ1xuXG4gIG1vZHVsZSBQID0gc3RydWN0XG4gICAgb3BlbiBDXG5cbiAgICBsZXQgdW5pdCAoKSA9XG4gICAgICBcIlwiXG5cbiAgICBsZXQgZmxvYXQgeCA9XG4gICAgICBQcmludGYuc3ByaW50ZiBcIiUuMmZcIiB4XG5cbiAgICBsZXQgbWF0cml4IHt4eDsgeHk7IHl4OyB5eTsgeDA7IHkwfSA9XG4gICAgICBQcmludGYuc3ByaW50ZiBcInt4eD0lLjJmOyB4eT0lLjJmOyB5eD0lLjJmOyB5eT0lLjJmOyB4MD0lLjJmOyB5MD0lLjJmfVwiIHh4IHh5IHl4IHl5IHgwIHkwXG5cbiAgICBsZXQgY29vcmRzICh4LCB5KSA9XG4gICAgICBQcmludGYuc3ByaW50ZiBcIiglLjJmLCAlLjJmKVwiIHggeVxuXG4gICAgbGV0IGRhc2hlcyBkYXNoZXMgPVxuICAgICAgZGFzaGVzXG4gICAgICB8PiBBcnJheS50b19saXN0XG4gICAgICB8PiBMaXN0Lm1hcCB+ZjooUHJpbnRmLnNwcmludGYgXCIlLjJmXCIpXG4gICAgICB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCI7IFwiXG4gICAgICB8PiBQcmludGYuc3ByaW50ZiBcIlt8JXN8XVwiXG5cbiAgICBsZXQgZGFzaGVzX29mcyAoZHMsIG9mcykgPVxuICAgICAgUHJpbnRmLnNwcmludGYgXCIoJXMsICUuMmYpXCIgKGRhc2hlcyBkcykgb2ZzXG5cbiAgICBsZXQgZmlsbF9ydWxlID0gZnVuY3Rpb25cbiAgICAgIHwgV0lORElORyAtPiBcIldJTkRJTkdcIlxuICAgICAgfCBFVkVOX09ERCAtPiBcIkVWRU5fT0REXCJcblxuICAgIGxldCBsaW5lX2NhcCA9IGZ1bmN0aW9uXG4gICAgICB8IEJVVFQgLT4gXCJCVVRUXCJcbiAgICAgIHwgUk9VTkQgLT4gXCJST1VORFwiXG4gICAgICB8IFNRVUFSRSAtPiBcIlNRVUFSRVwiXG5cbiAgICBsZXQgbGluZV9qb2luID0gZnVuY3Rpb25cbiAgICAgIHwgSk9JTl9NSVRFUiAtPiBcIkpPSU5fTUlURVJcIlxuICAgICAgfCBKT0lOX1JPVU5EIC0+IFwiSk9JTl9ST1VORFwiXG4gICAgICB8IEpPSU5fQkVWRUwgLT4gXCJKT0lOX0JFVkVMXCJcblxuICAgIGxldCBvcGVyYXRvciA9IGZ1bmN0aW9uXG4gICAgICB8IENMRUFSIC0+IFwiQ0xFQVJcIlxuICAgICAgfCBTT1VSQ0UgLT4gXCJTT1VSQ0VcIlxuICAgICAgfCBPVkVSIC0+IFwiT1ZFUlwiXG4gICAgICB8IElOIC0+IFwiSU5cIlxuICAgICAgfCBPVVQgLT4gXCJPVVRcIlxuICAgICAgfCBBVE9QIC0+IFwiQVRPUFwiXG4gICAgICB8IERFU1QgLT4gXCJERVNUXCJcbiAgICAgIHwgREVTVF9PVkVSIC0+IFwiREVTVF9PVkVSXCJcbiAgICAgIHwgREVTVF9JTiAtPiBcIkRFU1RfSU5cIlxuICAgICAgfCBERVNUX09VVCAtPiBcIkRFU1RfT1VUXCJcbiAgICAgIHwgREVTVF9BVE9QIC0+IFwiREVTVF9BVE9QXCJcbiAgICAgIHwgWE9SIC0+IFwiWE9SXCJcbiAgICAgIHwgQUREIC0+IFwiQUREXCJcbiAgICAgIHwgU0FUVVJBVEUgLT4gXCJTQVRVUkFURVwiXG5cbiAgICBsZXQgc291cmNlIHNvdXJjZSA9IFBhdHRlcm4uKFxuICAgICAgbGV0IGdldCBnZXQgPVxuICAgICAgICB0cnkgU29tZSAoZ2V0IHNvdXJjZSkgd2l0aCBFcnJvciBQQVRURVJOX1RZUEVfTUlTTUFUQ0ggLT4gTm9uZVxuICAgICAgYW5kIHN0b3BfcG9pbnRzICgpID1cbiAgICAgICAgbGV0IGNvdW50ID0gZ2V0X2NvbG9yX3N0b3BfY291bnQgc291cmNlIGluXG4gICAgICAgIGxldCBzdG9wX3BvaW50cyA9IEFycmF5Lm1ha2UgY291bnQgKDAuLCAwLiwgMC4sIDAuLCAwLikgaW5cbiAgICAgICAgZm9yIGlkeCA9IDAgdG8gY291bnQgLSAxIGRvXG4gICAgICAgICAgc3RvcF9wb2ludHMuKGlkeCkgPC0gZ2V0X2NvbG9yX3N0b3BfcmdiYSBzb3VyY2UgfmlkeFxuICAgICAgICBkb25lO1xuICAgICAgICBzdG9wX3BvaW50c1xuICAgICAgICB8PiBBcnJheS50b19saXN0XG4gICAgICAgIHw+IExpc3QubWFwIH5mOihmdW4gKHBvc2l0aW9uLCByLCBnLCBiLCBhKSAtPiBQcmludGYuc3ByaW50ZiBcIntwb3NpdGlvbj0lLjJmOyByPSUuMmY7IGc9JS4yZjsgYj0lLjJmOyBhPSUuMmZ9XCIgcG9zaXRpb24gciBnIGIgYSlcbiAgICAgICAgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiOyBcIlxuICAgICAgICB8PiBQcmludGYuc3ByaW50ZiBcIlslc11cIlxuICAgICAgaW5cbiAgICAgIG1hdGNoIGdldCBnZXRfcmdiYSB3aXRoXG4gICAgICAgIHwgU29tZSAociwgZywgYiwgYSkgLT5cbiAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIihSZ2JhIHtyPSUuMmY7IGc9JS4yZjsgYj0lLjJmOyBhPSUuMmZ9KVwiIHIgZyBiIGFcbiAgICAgICAgfCBOb25lIC0+IG1hdGNoIGdldCBnZXRfbGluZWFyX3BvaW50cyB3aXRoXG4gICAgICAgICAgfCBTb21lICh4MSwgeTEsIHgyLCB5MikgLT5cbiAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiKExpbmVhckdyYWRpZW50IHt4MD0lLjJmOyB5MD0lLjJmOyB4MT0lLjJmOyB5MT0lLjJmOyBzdG9wX3BvaW50cz0lc30pXCIgeDEgeTEgeDIgeTIgKHN0b3BfcG9pbnRzICgpKVxuICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgbGV0ICh4MSwgeTEsIHIxLCB4MiwgeTIsIHIyKSA9IGdldF9yYWRpYWxfY2lyY2xlcyBzb3VyY2UgaW5cbiAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiKFJhZGlhbEdyYWRpZW50IHt4MD0lLjJmOyB5MD0lLjJmOyByMD0lLjJmOyB4MT0lLjJmOyB5MT0lLjJmOyByMSUuMmY7IHN0b3BfcG9pbnRzPSVzfSlcIiB4MSB5MSByMSB4MiB5MiByMiAoc3RvcF9wb2ludHMgKCkpXG4gICAgKVxuXG4gICAgbGV0IGZvbnRfZXh0ZW50cyB7YXNjZW50OyBkZXNjZW50OyBiYXNlbGluZTsgbWF4X3hfYWR2YW5jZTsgbWF4X3lfYWR2YW5jZX0gPVxuICAgICAgUHJpbnRmLnNwcmludGYgXCJ7YXNjZW50PSUuMmY7IGRlc2NlbnQ9JS4yZjsgYmFzZWxpbmU9JS4yZjsgbWF4X3hfYWR2YW5jZT0lLjJmOyBtYXhfeV9hZHZhbmNlPSUuMmZ9XCIgYXNjZW50IGRlc2NlbnQgYmFzZWxpbmUgbWF4X3hfYWR2YW5jZSBtYXhfeV9hZHZhbmNlXG5cbiAgICBsZXQgdGV4dF9leHRlbnRzIHt4X2JlYXJpbmc7IHlfYmVhcmluZzsgd2lkdGg7IGhlaWdodDsgeF9hZHZhbmNlOyB5X2FkdmFuY2V9ID1cbiAgICAgIFByaW50Zi5zcHJpbnRmIFwie3hfYmVhcmluZz0lLjJmOyB5X2JlYXJpbmc9JS4yZjsgd2lkdGg9JS4yZjsgaGVpZ2h0PSUuMmY7IHhfYWR2YW5jZT0lLjJmOyB5X2FkdmFuY2U9JS4yZn1cIiB4X2JlYXJpbmcgeV9iZWFyaW5nIHdpZHRoIGhlaWdodCB4X2FkdmFuY2UgeV9hZHZhbmNlXG5cbiAgICBsZXQgc2xhbnQgPSBmdW5jdGlvblxuICAgICAgfCBVcHJpZ2h0IC0+IFwiVXByaWdodFwiXG4gICAgICB8IEl0YWxpYyAtPiBcIkl0YWxpY1wiXG4gICAgICB8IE9ibGlxdWUgLT4gXCJPYmxpcXVlXCJcblxuICAgIGxldCB3ZWlnaHQgPSBmdW5jdGlvblxuICAgICAgfCBOb3JtYWwgLT4gXCJOb3JtYWxcIlxuICAgICAgfCBCb2xkIC0+IFwiQm9sZFwiXG4gIGVuZFxuXG4gIG1vZHVsZSBBID0gc3RydWN0XG4gICAgbGV0IG1hdHJpeCAoKSA9XG4gICAgICBQLm1hdHJpeFxuXG4gICAgbGV0IG9wZXJhdG9yICgpID1cbiAgICAgIFAub3BlcmF0b3JcblxuICAgIGxldCBmaWxsX3J1bGUgKCkgPVxuICAgICAgUC5maWxsX3J1bGVcblxuICAgIGxldCBsaW5lX2NhcCAoKSA9XG4gICAgICBQLmxpbmVfY2FwXG5cbiAgICBsZXQgbGluZV9qb2luICgpID1cbiAgICAgIFAubGluZV9qb2luXG5cbiAgICBsZXQgc291cmNlICgpID1cbiAgICAgIFAuc291cmNlXG5cbiAgICBsZXQgZGFzaGVzICgpID1cbiAgICAgIFAuZGFzaGVzXG5cbiAgICBsZXQgb3B0aW9uIG5hbWUgcCAoKSA9IGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gXCJcIlxuICAgICAgfCBTb21lIHggLT4gUHJpbnRmLnNwcmludGYgXCIgfiVzOiVzXCIgbmFtZSAocCB4KVxuICBlbmRcblxuICBtb2R1bGUgQ29udGV4dDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgY3JlYXRlOiBDLmNvbnRleHQgLT4gdFxuICAgIHZhbCBjYWxsOiB0IC0+ICgnYSwgdW5pdCwgc3RyaW5nLCAoJ2IgLT4gc3RyaW5nKSAtPiAoQy5jb250ZXh0IC0+ICdiKSAtPiAnYikgZm9ybWF0NCAtPiAnYVxuICAgIHZhbCBjYWxsczogdCAtPiBzdHJpbmcgbGlzdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSB7XG4gICAgICBjOiBDLmNvbnRleHQ7XG4gICAgICBtdXRhYmxlIGNhbGxzOiBzdHJpbmcgbGlzdDtcbiAgICB9XG5cbiAgICBsZXQgY3JlYXRlIGMgPVxuICAgICAge2M7IGNhbGxzPVtdfVxuXG4gICAgbGV0IGNhbGxzIHtjYWxsczsgX30gPVxuICAgICAgTGlzdC5yZXYgY2FsbHNcblxuICAgIGxldCBjYWxsIGNvbnRleHQgZm9ybWF0ID1cbiAgICAgIFByaW50Zi5rc3ByaW50ZiAoZnVuIGNhbGwgcHJpbnRfcmV0IGYgLT5cbiAgICAgICAgdHJ5IGJlZ2luXG4gICAgICAgICAgbGV0IHJldCA9IGYgY29udGV4dC5jIGluXG4gICAgICAgICAgbGV0IHByaW50ZWRfcmV0ID0gcHJpbnRfcmV0IHJldCBpblxuICAgICAgICAgIGxldCBjYWxsID1cbiAgICAgICAgICAgIGlmIHByaW50ZWRfcmV0IDw+IFwiXCIgdGhlblxuICAgICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIiVzIC0+ICVzXCIgY2FsbCBwcmludGVkX3JldFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBjYWxsXG4gICAgICAgICAgaW5cbiAgICAgICAgICBjb250ZXh0LmNhbGxzIDwtIGNhbGw6OmNvbnRleHQuY2FsbHM7XG4gICAgICAgICAgcmV0XG4gICAgICAgIGVuZCB3aXRoXG4gICAgICAgICAgfCBleCAtPiBiZWdpblxuICAgICAgICAgICAgbGV0IGNhbGwgPSBQcmludGYuc3ByaW50ZiBcIiVzIC0+IHJhaXNlICglcylcIiBjYWxsIChQcmludGV4Yy50b19zdHJpbmcgZXgpIGluXG4gICAgICAgICAgICBjb250ZXh0LmNhbGxzIDwtIGNhbGw6OmNvbnRleHQuY2FsbHM7XG4gICAgICAgICAgICByYWlzZSBleFxuICAgICAgICAgIGVuZFxuICAgICAgKSBmb3JtYXRcbiAgZW5kXG5cbiAgdHlwZSBjb250ZXh0ID0gQ29udGV4dC50XG5cbiAgbGV0IGNyZWF0ZSA9IENvbnRleHQuY3JlYXRlXG5cbiAgbGV0IGNhbGxzID0gQ29udGV4dC5jYWxsc1xuXG5cblxuICBcbiMgNTkzIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgbGV0IHNhdmUgY29udGV4dCA9XG4gICAgXG4jIDU5NCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNTk0IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInNhdmVcIiBQLnVuaXQgQy5zYXZlXG5cbiAgbGV0IHJlc3RvcmUgY29udGV4dCA9XG4gICAgXG4jIDU5NyBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNTk3IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInJlc3RvcmVcIiBQLnVuaXQgQy5yZXN0b3JlXG5cblxuICBsZXQgc2V0X21hdHJpeCBjb250ZXh0IG0gPVxuICAgIFxuIyA2MDEgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDYwMSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJzZXRfbWF0cml4ICVhXCIgQS5tYXRyaXggbSBQLnVuaXQgKGZ1biBjIC0+IEMuc2V0X21hdHJpeCBjIG0pXG5cbiAgbGV0IGdldF9tYXRyaXggY29udGV4dCA9XG4gICAgXG4jIDYwNCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjA0IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcImdldF9tYXRyaXhcIiBQLm1hdHJpeCBDLmdldF9tYXRyaXhcblxuICBsZXQgdHJhbnNmb3JtIGNvbnRleHQgbSA9XG4gICAgXG4jIDYwNyBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjA3IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInRyYW5zZm9ybSAlYVwiIEEubWF0cml4IG0gUC51bml0IChmdW4gYyAtPiBDLnRyYW5zZm9ybSBjIG0pXG5cbiAgbGV0IHNjYWxlIGNvbnRleHQgeCB5ID1cbiAgICBcbiMgNjEwIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2MTAgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwic2NhbGUgJS4yZiAlLjJmXCIgeCB5IFAudW5pdCAoZnVuIGMgLT4gQy5zY2FsZSBjIHggeSlcblxuICBsZXQgdHJhbnNsYXRlIGNvbnRleHQgeCB5ID1cbiAgICBcbiMgNjEzIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2MTMgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwidHJhbnNsYXRlICUuMmYgJS4yZlwiIHggeSBQLnVuaXQgKGZ1biBjIC0+IEMudHJhbnNsYXRlIGMgeCB5KVxuXG4gIGxldCByb3RhdGUgY29udGV4dCBhbmdsZSA9XG4gICAgXG4jIDYxNiBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjE2IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInJvdGF0ZSAlLjJmXCIgYW5nbGUgUC51bml0IChmdW4gYyAtPiBDLnJvdGF0ZSBjIGFuZ2xlKVxuXG4gIGxldCBpZGVudGl0eV9tYXRyaXggY29udGV4dCA9XG4gICAgXG4jIDYxOSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjE5IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcImlkZW50aXR5X21hdHJpeFwiIFAudW5pdCBDLmlkZW50aXR5X21hdHJpeFxuXG4gIGxldCBkZXZpY2VfdG9fdXNlciBjb250ZXh0IHggeSA9XG4gICAgXG4jIDYyMiBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjIyIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcImRldmljZV90b191c2VyICUuMmYgJS4yZlwiIHggeSBQLmNvb3JkcyAoZnVuIGMgLT4gQy5kZXZpY2VfdG9fdXNlciBjIHggeSlcblxuICBsZXQgZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2UgY29udGV4dCB4IHkgPVxuICAgIFxuIyA2MjUgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDYyNSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJkZXZpY2VfdG9fdXNlcl9kaXN0YW5jZSAlLjJmICUuMmZcIiB4IHkgUC5jb29yZHMgKGZ1biBjIC0+IEMuZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2UgYyB4IHkpXG5cbiAgbGV0IHVzZXJfdG9fZGV2aWNlIGNvbnRleHQgeCB5ID1cbiAgICBcbiMgNjI4IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2MjggXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwidXNlcl90b19kZXZpY2UgJS4yZiAlLjJmXCIgeCB5IFAuY29vcmRzIChmdW4gYyAtPiBDLnVzZXJfdG9fZGV2aWNlIGMgeCB5KVxuXG4gIGxldCB1c2VyX3RvX2RldmljZV9kaXN0YW5jZSBjb250ZXh0IHggeSA9XG4gICAgXG4jIDYzMSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjMxIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInVzZXJfdG9fZGV2aWNlX2Rpc3RhbmNlICUuMmYgJS4yZlwiIHggeSBQLmNvb3JkcyAoZnVuIGMgLT4gQy51c2VyX3RvX2RldmljZV9kaXN0YW5jZSBjIHggeSlcblxuXG4gIGxldCBtb3ZlX3RvIGNvbnRleHQgeCB5ID1cbiAgICBcbiMgNjM1IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2MzUgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwibW92ZV90byAlLjJmICUuMmZcIiB4IHkgUC51bml0IChmdW4gYyAtPiBDLm1vdmVfdG8gYyB4IHkpXG5cbiAgbGV0IHJlbF9tb3ZlX3RvIGNvbnRleHQgeCB5ID1cbiAgICBcbiMgNjM4IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2MzggXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwicmVsX21vdmVfdG8gJS4yZiAlLjJmXCIgeCB5IFAudW5pdCAoZnVuIGMgLT4gQy5yZWxfbW92ZV90byBjIHggeSlcblxuICBsZXQgbGluZV90byBjb250ZXh0IHggeSA9XG4gICAgXG4jIDY0MSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjQxIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcImxpbmVfdG8gJS4yZiAlLjJmXCIgeCB5IFAudW5pdCAoZnVuIGMgLT4gQy5saW5lX3RvIGMgeCB5KVxuXG4gIGxldCByZWxfbGluZV90byBjb250ZXh0IHggeSA9XG4gICAgXG4jIDY0NCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjQ0IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInJlbF9saW5lX3RvICUuMmYgJS4yZlwiIHggeSBQLnVuaXQgKGZ1biBjIC0+IEMucmVsX2xpbmVfdG8gYyB4IHkpXG5cbiAgbGV0IGN1cnZlX3RvIGNvbnRleHQgeDEgeTEgeDIgeTIgeDMgeTMgPVxuICAgIFxuIyA2NDcgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDY0NyBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJjdXJ2ZV90byAlLjJmICUuMmYgJS4yZiAlLjJmICUuMmYgJS4yZlwiIHgxIHkxIHgyIHkyIHgzIHkzIFAudW5pdCAoZnVuIGMgLT4gQy5jdXJ2ZV90byBjIHgxIHkxIHgyIHkyIHgzIHkzKVxuXG4gIGxldCByZWxfY3VydmVfdG8gY29udGV4dCB4MSB5MSB4MiB5MiB4MyB5MyA9XG4gICAgXG4jIDY1MCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjUwIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInJlbF9jdXJ2ZV90byAlLjJmICUuMmYgJS4yZiAlLjJmICUuMmYgJS4yZlwiIHgxIHkxIHgyIHkyIHgzIHkzIFAudW5pdCAoZnVuIGMgLT4gQy5yZWxfY3VydmVfdG8gYyB4MSB5MSB4MiB5MiB4MyB5MylcblxuICBsZXQgcmVjdGFuZ2xlIGNvbnRleHQgeCB5IH53IH5oID1cbiAgICBcbiMgNjUzIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2NTMgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwicmVjdGFuZ2xlICUuMmYgJS4yZiB+dzolLjJmIH5oOiUuMmZcIiB4IHkgdyBoIFAudW5pdCAoZnVuIGMgLT4gQy5yZWN0YW5nbGUgYyB4IHkgfncgfmgpXG5cbiAgbGV0IGFyYyBjb250ZXh0IHggeSB+ciB+YTEgfmEyID1cbiAgICBcbiMgNjU2IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2NTYgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwiYXJjICUuMmYgJS4yZiB+cjolLjJmIH5hMTolLjJmIH5hMjolLjJmXCIgeCB5IHIgYTEgYTIgUC51bml0IChmdW4gYyAtPiBDLmFyYyBjIHggeSB+ciB+YTEgfmEyKVxuXG4gIGxldCBhcmNfbmVnYXRpdmUgY29udGV4dCB4IHkgfnIgfmExIH5hMiA9XG4gICAgXG4jIDY1OSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjU5IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcImFyY19uZWdhdGl2ZSAlLjJmICUuMmYgfnI6JS4yZiB+YTE6JS4yZiB+YTI6JS4yZlwiIHggeSByIGExIGEyIFAudW5pdCAoZnVuIGMgLT4gQy5hcmNfbmVnYXRpdmUgYyB4IHkgfnIgfmExIH5hMilcblxuICBtb2R1bGUgUGF0aCA9IHN0cnVjdFxuICAgIGxldCBnZXRfY3VycmVudF9wb2ludCBjb250ZXh0ID1cbiAgICAgIFxuIyA2NjMgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjYzIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICAgIFwiUGF0aC5nZXRfY3VycmVudF9wb2ludFwiIFAuY29vcmRzIEMuUGF0aC5nZXRfY3VycmVudF9wb2ludFxuXG4gICAgbGV0IGNsZWFyIGNvbnRleHQgPVxuICAgICAgXG4jIDY2NiBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2NjYgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgICAgXCJQYXRoLmNsZWFyXCIgUC51bml0IEMuUGF0aC5jbGVhclxuXG4gICAgbGV0IGNsb3NlIGNvbnRleHQgPVxuICAgICAgXG4jIDY2OSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2NjkgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgICAgXCJQYXRoLmNsb3NlXCIgUC51bml0IEMuUGF0aC5jbG9zZVxuICBlbmRcblxuICBsZXQgc3Ryb2tlX3ByZXNlcnZlIGNvbnRleHQgPVxuICAgIFxuIyA2NzMgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDY3MyBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJzdHJva2VfcHJlc2VydmVcIiBQLnVuaXQgQy5zdHJva2VfcHJlc2VydmVcblxuICBsZXQgc3Ryb2tlIGNvbnRleHQgPVxuICAgIFxuIyA2NzYgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDY3NiBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJzdHJva2VcIiBQLnVuaXQgQy5zdHJva2VcblxuICBsZXQgZmlsbF9wcmVzZXJ2ZSBjb250ZXh0ID1cbiAgICBcbiMgNjc5IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2NzkgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwiZmlsbF9wcmVzZXJ2ZVwiIFAudW5pdCBDLmZpbGxfcHJlc2VydmVcblxuICBsZXQgZmlsbCBjb250ZXh0ID1cbiAgICBcbiMgNjgyIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2ODIgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwiZmlsbFwiIFAudW5pdCBDLmZpbGxcblxuICBsZXQgY2xpcF9wcmVzZXJ2ZSBjb250ZXh0ID1cbiAgICBcbiMgNjg1IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2ODUgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwiY2xpcF9wcmVzZXJ2ZVwiIFAudW5pdCBDLmNsaXBfcHJlc2VydmVcblxuICBsZXQgY2xpcCBjb250ZXh0ID1cbiAgICBcbiMgNjg4IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA2ODggXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwiY2xpcFwiIFAudW5pdCBDLmNsaXBcblxuICBsZXQgcGFpbnQgP2FscGhhIGNvbnRleHQgPVxuICAgIFxuIyA2OTEgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDY5MSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJwYWludCVhXCIgKEEub3B0aW9uIFwiYWxwaGFcIiBQLmZsb2F0KSBhbHBoYSBQLnVuaXQgKEMucGFpbnQgP2FscGhhKVxuXG5cbiAgbGV0IHNldF9saW5lX3dpZHRoIGNvbnRleHQgbGluZV93aWR0aCA9XG4gICAgXG4jIDY5NSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNjk1IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInNldF9saW5lX3dpZHRoICUuMmZcIiBsaW5lX3dpZHRoIFAudW5pdCAoZnVuIGMgLT4gQy5zZXRfbGluZV93aWR0aCBjIGxpbmVfd2lkdGgpXG5cbiAgbGV0IGdldF9saW5lX3dpZHRoIGNvbnRleHQgPVxuICAgIFxuIyA2OTggXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDY5OCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJnZXRfbGluZV93aWR0aFwiIFAuZmxvYXQgQy5nZXRfbGluZV93aWR0aFxuXG4gIGxldCBzZXRfZGFzaCBjb250ZXh0ID9vZnMgZGFzaGVzID1cbiAgICBcbiMgNzAxIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA3MDEgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwic2V0X2Rhc2glYSAlYVwiIChBLm9wdGlvbiBcIm9mc1wiIFAuZmxvYXQpIG9mcyBBLmRhc2hlcyBkYXNoZXMgUC51bml0IChmdW4gYyAtPiBDLnNldF9kYXNoIGMgP29mcyBkYXNoZXMpXG5cbiAgbGV0IGdldF9kYXNoIGNvbnRleHQgPVxuICAgIFxuIyA3MDQgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDcwNCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJnZXRfZGFzaFwiIFAuZGFzaGVzX29mcyBDLmdldF9kYXNoXG5cbiAgbGV0IHNldF9maWxsX3J1bGUgY29udGV4dCBmaWxsX3J1bGUgPVxuICAgIFxuIyA3MDcgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDcwNyBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJzZXRfZmlsbF9ydWxlICVhXCIgQS5maWxsX3J1bGUgZmlsbF9ydWxlIFAudW5pdCAoZnVuIGMgLT4gQy5zZXRfZmlsbF9ydWxlIGMgZmlsbF9ydWxlKVxuXG4gIGxldCBnZXRfZmlsbF9ydWxlIGNvbnRleHQgPVxuICAgIFxuIyA3MTAgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDcxMCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJnZXRfZmlsbF9ydWxlXCIgUC5maWxsX3J1bGUgQy5nZXRfZmlsbF9ydWxlXG5cbiAgbGV0IHNldF9saW5lX2NhcCBjb250ZXh0IGxpbmVfY2FwID1cbiAgICBcbiMgNzEzIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA3MTMgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwic2V0X2xpbmVfY2FwICVhXCIgQS5saW5lX2NhcCBsaW5lX2NhcCBQLnVuaXQgKGZ1biBjIC0+IEMuc2V0X2xpbmVfY2FwIGMgbGluZV9jYXApXG5cbiAgbGV0IGdldF9saW5lX2NhcCBjb250ZXh0ID1cbiAgICBcbiMgNzE2IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA3MTYgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwiZ2V0X2xpbmVfY2FwXCIgUC5saW5lX2NhcCBDLmdldF9saW5lX2NhcFxuXG4gIGxldCBzZXRfbGluZV9qb2luIGNvbnRleHQgbGluZV9qb2luID1cbiAgICBcbiMgNzE5IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA3MTkgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwic2V0X2xpbmVfam9pbiAlYVwiIEEubGluZV9qb2luIGxpbmVfam9pbiBQLnVuaXQgKGZ1biBjIC0+IEMuc2V0X2xpbmVfam9pbiBjIGxpbmVfam9pbilcblxuICBsZXQgZ2V0X2xpbmVfam9pbiBjb250ZXh0ID1cbiAgICBcbiMgNzIyIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA3MjIgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwiZ2V0X2xpbmVfam9pblwiIFAubGluZV9qb2luIEMuZ2V0X2xpbmVfam9pblxuXG4gIGxldCBzZXRfbWl0ZXJfbGltaXQgY29udGV4dCBtaXRlcl9saW1pdCA9XG4gICAgXG4jIDcyNSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNzI1IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInNldF9taXRlcl9saW1pdCAlLjJmXCIgbWl0ZXJfbGltaXQgUC51bml0IChmdW4gYyAtPiBDLnNldF9taXRlcl9saW1pdCBjIG1pdGVyX2xpbWl0KVxuXG4gIGxldCBnZXRfbWl0ZXJfbGltaXQgY29udGV4dCA9XG4gICAgXG4jIDcyOCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNzI4IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcImdldF9taXRlcl9saW1pdFwiIFAuZmxvYXQgQy5nZXRfbWl0ZXJfbGltaXRcblxuICBsZXQgc2V0X29wZXJhdG9yIGNvbnRleHQgb3BlcmF0b3IgPVxuICAgIFxuIyA3MzEgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDczMSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJzZXRfb3BlcmF0b3IgJWFcIiBBLm9wZXJhdG9yIG9wZXJhdG9yIFAudW5pdCAoZnVuIGMgLT4gQy5zZXRfb3BlcmF0b3IgYyBvcGVyYXRvcilcblxuICBsZXQgZ2V0X29wZXJhdG9yIGNvbnRleHQgPVxuICAgIFxuIyA3MzQgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDczNCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJnZXRfb3BlcmF0b3JcIiBQLm9wZXJhdG9yIEMuZ2V0X29wZXJhdG9yXG5cblxuICBsZXQgc2V0X3NvdXJjZSBjb250ZXh0IHNvdXJjZSA9XG4gICAgXG4jIDczOCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNzM4IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInNldF9zb3VyY2UgJWFcIiBBLnNvdXJjZSAoT2JqLm1hZ2ljIHNvdXJjZSkgUC51bml0IChmdW4gYyAtPiBDLnNldF9zb3VyY2UgYyBzb3VyY2UpXG5cbiAgbGV0IGdldF9zb3VyY2UgY29udGV4dCA9XG4gICAgXG4jIDc0MSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNzQxIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcImdldF9zb3VyY2VcIiBQLnNvdXJjZSBDLmdldF9zb3VyY2VcblxuICBsZXQgc2V0X3NvdXJjZV9yZ2IgY29udGV4dCByIGcgYiA9XG4gICAgXG4jIDc0NCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNzQ0IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInNldF9zb3VyY2VfcmdiICUuMmYgJS4yZiAlLjJmXCIgciBnIGIgUC51bml0IChmdW4gYyAtPiBDLnNldF9zb3VyY2VfcmdiIGMgciBnIGIpXG5cbiAgbGV0IHNldF9zb3VyY2VfcmdiYSBjb250ZXh0IHIgZyBiIGEgPVxuICAgIFxuIyA3NDcgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICBDb250ZXh0LmNhbGwgY29udGV4dCAgXG4jIDc0NyBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgICAgXCJzZXRfc291cmNlX3JnYmEgJS4yZiAlLjJmICUuMmYgJS4yZlwiIHIgZyBiIGEgUC51bml0IChmdW4gYyAtPiBDLnNldF9zb3VyY2VfcmdiYSBjIHIgZyBiIGEpXG5cblxuICBsZXQgc2VsZWN0X2ZvbnRfZmFjZSBjb250ZXh0ID9zbGFudCA/d2VpZ2h0IGZhbWlseSA9XG4gICAgXG4jIDc1MSBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNzUxIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInNlbGVjdF9mb250X2ZhY2UlYSVhICVTXCIgKEEub3B0aW9uIFwic2xhbnRcIiBQLnNsYW50KSBzbGFudCAoQS5vcHRpb24gXCJ3ZWlnaHRcIiBQLndlaWdodCkgd2VpZ2h0IGZhbWlseSBQLnVuaXQgKGZ1biBjIC0+IEMuc2VsZWN0X2ZvbnRfZmFjZSBjID9zbGFudCA/d2VpZ2h0IGZhbWlseSlcblxuICBsZXQgc2V0X2ZvbnRfc2l6ZSBjb250ZXh0IGZvbnRfc2l6ZSA9XG4gICAgXG4jIDc1NCBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNzU0IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInNldF9mb250X3NpemUgJS4yZlwiIGZvbnRfc2l6ZSBQLnVuaXQgKGZ1biBjIC0+IEMuc2V0X2ZvbnRfc2l6ZSBjIGZvbnRfc2l6ZSlcblxuICBsZXQgc2hvd190ZXh0IGNvbnRleHQgcyA9XG4gICAgXG4jIDc1NyBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNzU3IFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInNob3dfdGV4dCAlU1wiIHMgUC51bml0IChmdW4gYyAtPiBDLnNob3dfdGV4dCBjIHMpXG5cbiAgbGV0IGZvbnRfZXh0ZW50cyBjb250ZXh0ID1cbiAgICBcbiMgNzYwIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgQ29udGV4dC5jYWxsIGNvbnRleHQgIFxuIyA3NjAgXCJzcmMvQ2Fpcm9Nb2NrLmNwcG8ubWxcIlxuICAgICAgIFwiZm9udF9leHRlbnRzXCIgUC5mb250X2V4dGVudHMgQy5mb250X2V4dGVudHNcblxuICBsZXQgdGV4dF9leHRlbnRzIGNvbnRleHQgcyA9XG4gICAgXG4jIDc2MyBcInNyYy9DYWlyb01vY2suY3Bwby5tbFwiXG4gICAgIENvbnRleHQuY2FsbCBjb250ZXh0ICBcbiMgNzYzIFwic3JjL0NhaXJvTW9jay5jcHBvLm1sXCJcbiAgICAgICBcInRleHRfZXh0ZW50cyAlU1wiIHMgUC50ZXh0X2V4dGVudHMgKGZ1biBjIC0+IEMudGV4dF9leHRlbnRzIGMgcylcbmVuZFxuXG5pbmNsdWRlIERlY29yYXRlKE1vY2spXG5cbmxldCBjcmVhdGUgKCkgPVxuICBDb250ZXh0LmNyZWF0ZSAoTW9jay5jcmVhdGUgKCkpXG4iLCIjIDEgXCJzcmMvSnNPZk9DYWlyby5jcHBvLm1sXCJcbigqIENvcHlyaWdodCAyMDE3LTIwMTggVmluY2VudCBKYWNxdWVzIDx2aW5jZW50QHZpbmNlbnQtamFjcXVlcy5uZXQ+ICopXG5cbm1vZHVsZSB0eXBlIFMgPSBDYWlyb01vY2suU1xuXG4oKlxuQ2FudmFzOlxuLSBodHRwOi8vd3d3Lnczc2Nob29scy5jb20vdGFncy9yZWZfY2FudmFzLmFzcFxuLSBodHRwczovL29jc2lnZW4ub3JnL2pzX29mX29jYW1sLzIuOC40L2FwaS9Eb21faHRtbC5jYW52YXNSZW5kZXJpbmdDb250ZXh0MkQtY1xuXG5DYWlybzpcbi0gaHR0cDovL2NhaXJvLmZvcmdlLm9jYW1sY29yZS5vcmcvdHV0b3JpYWwvQ2Fpcm8uaHRtbFxuLSBodHRwczovL2dpdGh1Yi5jb20vQ2hyaXMwMC9vY2FtbC1jYWlyb1xuLSB1dG9wIC1yZXF1aXJlIGNhaXJvMlxuKilcblxuIyAxIFwic3JjL0JhY2tlbmQuaW5jbC5tbFwiXG4oKiBDb3B5cmlnaHQgMjAxNy0yMDE4IFZpbmNlbnQgSmFjcXVlcyA8dmluY2VudEB2aW5jZW50LWphY3F1ZXMubmV0PiAqKVxuXG5vcGVuIFN0ZExhYmVsc1xuXG50eXBlIHN0YXR1cyA9XG4gIHwgSU5WQUxJRF9SRVNUT1JFXG4gIHwgSU5WQUxJRF9QT1BfR1JPVVBcbiAgfCBOT19DVVJSRU5UX1BPSU5UXG4gIHwgSU5WQUxJRF9NQVRSSVhcbiAgfCBJTlZBTElEX1NUQVRVU1xuICB8IE5VTExfUE9JTlRFUlxuICB8IElOVkFMSURfU1RSSU5HXG4gIHwgSU5WQUxJRF9QQVRIX0RBVEFcbiAgfCBSRUFEX0VSUk9SXG4gIHwgV1JJVEVfRVJST1JcbiAgfCBTVVJGQUNFX0ZJTklTSEVEXG4gIHwgU1VSRkFDRV9UWVBFX01JU01BVENIXG4gIHwgUEFUVEVSTl9UWVBFX01JU01BVENIXG4gIHwgSU5WQUxJRF9DT05URU5UXG4gIHwgSU5WQUxJRF9GT1JNQVRcbiAgfCBJTlZBTElEX1ZJU1VBTFxuICB8IEZJTEVfTk9UX0ZPVU5EXG4gIHwgSU5WQUxJRF9EQVNIXG4gIHwgSU5WQUxJRF9EU0NfQ09NTUVOVFxuICB8IElOVkFMSURfSU5ERVhcbiAgfCBDTElQX05PVF9SRVBSRVNFTlRBQkxFXG4gIHwgVEVNUF9GSUxFX0VSUk9SXG4gIHwgSU5WQUxJRF9TVFJJREVcbiAgfCBGT05UX1RZUEVfTUlTTUFUQ0hcbiAgfCBVU0VSX0ZPTlRfSU1NVVRBQkxFXG4gIHwgVVNFUl9GT05UX0VSUk9SXG4gIHwgTkVHQVRJVkVfQ09VTlRcbiAgfCBJTlZBTElEX0NMVVNURVJTXG4gIHwgSU5WQUxJRF9TTEFOVFxuICB8IElOVkFMSURfV0VJR0hUXG4gIHwgSU5WQUxJRF9TSVpFXG4gIHwgVVNFUl9GT05UX05PVF9JTVBMRU1FTlRFRFxuICB8IERFVklDRV9UWVBFX01JU01BVENIXG4gIHwgREVWSUNFX0VSUk9SXG4gIHwgSU5WQUxJRF9NRVNIX0NPTlNUUlVDVElPTlxuICB8IERFVklDRV9GSU5JU0hFRFxuICB8IEpCSUcyX0dMT0JBTF9NSVNTSU5HXG5cbmV4Y2VwdGlvbiBFcnJvciBvZiBzdGF0dXNcblxubGV0IHN0YXR1c190b19zdHJpbmcgPSBmdW5jdGlvblxuICB8IElOVkFMSURfUkVTVE9SRSAtPiBcImNhaXJvX3Jlc3RvcmUoKSB3aXRob3V0IG1hdGNoaW5nIGNhaXJvX3NhdmUoKVwiXG4gIHwgSU5WQUxJRF9QT1BfR1JPVVAgLT4gXCJubyBzYXZlZCBncm91cCB0byBwb3AsIGkuZS4gY2Fpcm9fcG9wX2dyb3VwKCkgd2l0aG91dCBtYXRjaGluZyBjYWlyb19wdXNoX2dyb3VwKClcIlxuICB8IE5PX0NVUlJFTlRfUE9JTlQgLT4gXCJubyBjdXJyZW50IHBvaW50IGRlZmluZWRcIlxuICB8IElOVkFMSURfTUFUUklYIC0+IFwiaW52YWxpZCBtYXRyaXggKG5vdCBpbnZlcnRpYmxlKVwiXG4gIHwgSU5WQUxJRF9TVEFUVVMgLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBhbiBpbnB1dCBjYWlyb19zdGF0dXNfdFwiXG4gIHwgTlVMTF9QT0lOVEVSIC0+IFwiTlVMTCBwb2ludGVyXCJcbiAgfCBJTlZBTElEX1NUUklORyAtPiBcImlucHV0IHN0cmluZyBub3QgdmFsaWQgVVRGLThcIlxuICB8IElOVkFMSURfUEFUSF9EQVRBIC0+IFwiaW5wdXQgcGF0aCBkYXRhIG5vdCB2YWxpZFwiXG4gIHwgUkVBRF9FUlJPUiAtPiBcImVycm9yIHdoaWxlIHJlYWRpbmcgZnJvbSBpbnB1dCBzdHJlYW1cIlxuICB8IFdSSVRFX0VSUk9SIC0+IFwiZXJyb3Igd2hpbGUgd3JpdGluZyB0byBvdXRwdXQgc3RyZWFtXCJcbiAgfCBTVVJGQUNFX0ZJTklTSEVEIC0+IFwidGhlIHRhcmdldCBzdXJmYWNlIGhhcyBiZWVuIGZpbmlzaGVkXCJcbiAgfCBTVVJGQUNFX1RZUEVfTUlTTUFUQ0ggLT4gXCJ0aGUgc3VyZmFjZSB0eXBlIGlzIG5vdCBhcHByb3ByaWF0ZSBmb3IgdGhlIG9wZXJhdGlvblwiXG4gIHwgUEFUVEVSTl9UWVBFX01JU01BVENIIC0+IFwidGhlIHBhdHRlcm4gdHlwZSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoZSBvcGVyYXRpb25cIlxuICB8IElOVkFMSURfQ09OVEVOVCAtPiBcImludmFsaWQgdmFsdWUgZm9yIGFuIGlucHV0IGNhaXJvX2NvbnRlbnRfdFwiXG4gIHwgSU5WQUxJRF9GT1JNQVQgLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBhbiBpbnB1dCBjYWlyb19mb3JtYXRfdFwiXG4gIHwgSU5WQUxJRF9WSVNVQUwgLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBhbiBpbnB1dCBWaXN1YWwqXCJcbiAgfCBGSUxFX05PVF9GT1VORCAtPiBcImZpbGUgbm90IGZvdW5kXCJcbiAgfCBJTlZBTElEX0RBU0ggLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBhIGRhc2ggc2V0dGluZ1wiXG4gIHwgSU5WQUxJRF9EU0NfQ09NTUVOVCAtPiBcImludmFsaWQgdmFsdWUgZm9yIGEgRFNDIGNvbW1lbnRcIlxuICB8IElOVkFMSURfSU5ERVggLT4gXCJpbnZhbGlkIGluZGV4IHBhc3NlZCB0byBnZXR0ZXJcIlxuICB8IENMSVBfTk9UX1JFUFJFU0VOVEFCTEUgLT4gXCJjbGlwIHJlZ2lvbiBub3QgcmVwcmVzZW50YWJsZSBpbiBkZXNpcmVkIGZvcm1hdFwiXG4gIHwgVEVNUF9GSUxFX0VSUk9SIC0+IFwiZXJyb3IgY3JlYXRpbmcgb3Igd3JpdGluZyB0byBhIHRlbXBvcmFyeSBmaWxlXCJcbiAgfCBJTlZBTElEX1NUUklERSAtPiBcImludmFsaWQgdmFsdWUgZm9yIHN0cmlkZVwiXG4gIHwgRk9OVF9UWVBFX01JU01BVENIIC0+IFwidGhlIGZvbnQgdHlwZSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoZSBvcGVyYXRpb25cIlxuICB8IFVTRVJfRk9OVF9JTU1VVEFCTEUgLT4gXCJ0aGUgdXNlci1mb250IGlzIGltbXV0YWJsZVwiXG4gIHwgVVNFUl9GT05UX0VSUk9SIC0+IFwiZXJyb3Igb2NjdXJyZWQgaW4gYSB1c2VyLWZvbnQgY2FsbGJhY2sgZnVuY3Rpb25cIlxuICB8IE5FR0FUSVZFX0NPVU5UIC0+IFwibmVnYXRpdmUgbnVtYmVyIHVzZWQgd2hlcmUgaXQgaXMgbm90IGFsbG93ZWRcIlxuICB8IElOVkFMSURfQ0xVU1RFUlMgLT4gXCJpbnB1dCBjbHVzdGVycyBkbyBub3QgcmVwcmVzZW50IHRoZSBhY2NvbXBhbnlpbmcgdGV4dCBhbmQgZ2x5cGggYXJyYXlzXCJcbiAgfCBJTlZBTElEX1NMQU5UIC0+IFwiaW52YWxpZCB2YWx1ZSBmb3IgYW4gaW5wdXQgY2Fpcm9fZm9udF9zbGFudF90XCJcbiAgfCBJTlZBTElEX1dFSUdIVCAtPiBcImludmFsaWQgdmFsdWUgZm9yIGFuIGlucHV0IGNhaXJvX2ZvbnRfd2VpZ2h0X3RcIlxuICB8IElOVkFMSURfU0laRSAtPiBcImludmFsaWQgdmFsdWUgKHR5cGljYWxseSB0b28gYmlnKSBmb3IgdGhlIHNpemUgb2YgdGhlIGlucHV0IChzdXJmYWNlLCBwYXR0ZXJuLCBldGMuKVwiXG4gIHwgVVNFUl9GT05UX05PVF9JTVBMRU1FTlRFRCAtPiBcInVzZXItZm9udCBtZXRob2Qgbm90IGltcGxlbWVudGVkXCJcbiAgfCBERVZJQ0VfVFlQRV9NSVNNQVRDSCAtPiBcInRoZSBkZXZpY2UgdHlwZSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoZSBvcGVyYXRpb25cIlxuICB8IERFVklDRV9FUlJPUiAtPiBcImFuIG9wZXJhdGlvbiB0byB0aGUgZGV2aWNlIGNhdXNlZCBhbiB1bnNwZWNpZmllZCBlcnJvclwiXG4gIHwgSU5WQUxJRF9NRVNIX0NPTlNUUlVDVElPTiAtPiBcImludmFsaWQgb3BlcmF0aW9uIGR1cmluZyBtZXNoIHBhdHRlcm4gY29uc3RydWN0aW9uXCJcbiAgfCBERVZJQ0VfRklOSVNIRUQgLT4gXCJ0aGUgdGFyZ2V0IGRldmljZSBoYXMgYmVlbiBmaW5pc2hlZFwiXG4gIHwgSkJJRzJfR0xPQkFMX01JU1NJTkcgLT4gXCJDQUlST19NSU1FX1RZUEVfSkJJRzJfR0xPQkFMX0lEIHVzZWQgYnV0IG5vIENBSVJPX01JTUVfVFlQRV9KQklHMl9HTE9CQUwgZGF0YSBwcm92aWRlZFwiXG5cbmxldCBzdGF0dXNfcmVwciA9IGZ1bmN0aW9uXG4gIHwgSU5WQUxJRF9SRVNUT1JFIC0+IFwiSU5WQUxJRF9SRVNUT1JFXCJcbiAgfCBOT19DVVJSRU5UX1BPSU5UIC0+IFwiTk9fQ1VSUkVOVF9QT0lOVFwiXG4gICgqQklTRUNULUlHTk9SRS1CRUdJTiopICgqIEkgZG9uJ3Qga25vdyBob3cgdG8gbWFrZSBDYWlybyByYWlzZSB0aGVzZSBleGNlcHRpb25zICopXG4gIHwgSU5WQUxJRF9QT1BfR1JPVVAgLT4gXCJJTlZBTElEX1BPUF9HUk9VUFwiXG4gIHwgSU5WQUxJRF9NQVRSSVggLT4gXCJJTlZBTElEX01BVFJJWFwiXG4gIHwgSU5WQUxJRF9TVEFUVVMgLT4gXCJJTlZBTElEX1NUQVRVU1wiXG4gIHwgTlVMTF9QT0lOVEVSIC0+IFwiTlVMTF9QT0lOVEVSXCJcbiAgfCBJTlZBTElEX1NUUklORyAtPiBcIklOVkFMSURfU1RSSU5HXCJcbiAgfCBJTlZBTElEX1BBVEhfREFUQSAtPiBcIklOVkFMSURfUEFUSF9EQVRBXCJcbiAgfCBSRUFEX0VSUk9SIC0+IFwiUkVBRF9FUlJPUlwiXG4gIHwgV1JJVEVfRVJST1IgLT4gXCJXUklURV9FUlJPUlwiXG4gIHwgU1VSRkFDRV9GSU5JU0hFRCAtPiBcIlNVUkZBQ0VfRklOSVNIRURcIlxuICB8IFNVUkZBQ0VfVFlQRV9NSVNNQVRDSCAtPiBcIlNVUkZBQ0VfVFlQRV9NSVNNQVRDSFwiXG4gIHwgUEFUVEVSTl9UWVBFX01JU01BVENIIC0+IFwiUEFUVEVSTl9UWVBFX01JU01BVENIXCJcbiAgfCBJTlZBTElEX0NPTlRFTlQgLT4gXCJJTlZBTElEX0NPTlRFTlRcIlxuICB8IElOVkFMSURfRk9STUFUIC0+IFwiSU5WQUxJRF9GT1JNQVRcIlxuICB8IElOVkFMSURfVklTVUFMIC0+IFwiSU5WQUxJRF9WSVNVQUxcIlxuICB8IEZJTEVfTk9UX0ZPVU5EIC0+IFwiRklMRV9OT1RfRk9VTkRcIlxuICB8IElOVkFMSURfREFTSCAtPiBcIklOVkFMSURfREFTSFwiXG4gIHwgSU5WQUxJRF9EU0NfQ09NTUVOVCAtPiBcIklOVkFMSURfRFNDX0NPTU1FTlRcIlxuICB8IElOVkFMSURfSU5ERVggLT4gXCJJTlZBTElEX0lOREVYXCJcbiAgfCBDTElQX05PVF9SRVBSRVNFTlRBQkxFIC0+IFwiQ0xJUF9OT1RfUkVQUkVTRU5UQUJMRVwiXG4gIHwgVEVNUF9GSUxFX0VSUk9SIC0+IFwiVEVNUF9GSUxFX0VSUk9SXCJcbiAgfCBJTlZBTElEX1NUUklERSAtPiBcIklOVkFMSURfU1RSSURFXCJcbiAgfCBGT05UX1RZUEVfTUlTTUFUQ0ggLT4gXCJGT05UX1RZUEVfTUlTTUFUQ0hcIlxuICB8IFVTRVJfRk9OVF9JTU1VVEFCTEUgLT4gXCJVU0VSX0ZPTlRfSU1NVVRBQkxFXCJcbiAgfCBVU0VSX0ZPTlRfRVJST1IgLT4gXCJVU0VSX0ZPTlRfRVJST1JcIlxuICB8IE5FR0FUSVZFX0NPVU5UIC0+IFwiTkVHQVRJVkVfQ09VTlRcIlxuICB8IElOVkFMSURfQ0xVU1RFUlMgLT4gXCJJTlZBTElEX0NMVVNURVJTXCJcbiAgfCBJTlZBTElEX1NMQU5UIC0+IFwiSU5WQUxJRF9TTEFOVFwiXG4gIHwgSU5WQUxJRF9XRUlHSFQgLT4gXCJJTlZBTElEX1dFSUdIVFwiXG4gIHwgSU5WQUxJRF9TSVpFIC0+IFwiSU5WQUxJRF9TSVpFXCJcbiAgfCBVU0VSX0ZPTlRfTk9UX0lNUExFTUVOVEVEIC0+IFwiVVNFUl9GT05UX05PVF9JTVBMRU1FTlRFRFwiXG4gIHwgREVWSUNFX1RZUEVfTUlTTUFUQ0ggLT4gXCJERVZJQ0VfVFlQRV9NSVNNQVRDSFwiXG4gIHwgREVWSUNFX0VSUk9SIC0+IFwiREVWSUNFX0VSUk9SXCJcbiAgfCBJTlZBTElEX01FU0hfQ09OU1RSVUNUSU9OIC0+IFwiSU5WQUxJRF9NRVNIX0NPTlNUUlVDVElPTlwiXG4gIHwgREVWSUNFX0ZJTklTSEVEIC0+IFwiREVWSUNFX0ZJTklTSEVEXCJcbiAgfCBKQklHMl9HTE9CQUxfTUlTU0lORyAtPiBcIkpCSUcyX0dMT0JBTF9NSVNTSU5HXCJcbiAgKCpCSVNFQ1QtSUdOT1JFLUVORCopXG5cbmV4Y2VwdGlvbiBVbmF2YWlsYWJsZVxuXG50eXBlIG1hdHJpeCA9IHtcbiAgbXV0YWJsZSB4eDogZmxvYXQ7XG4gIG11dGFibGUgeXg6IGZsb2F0O1xuICBtdXRhYmxlIHh5OiBmbG9hdDtcbiAgbXV0YWJsZSB5eTogZmxvYXQ7XG4gIG11dGFibGUgeDA6IGZsb2F0O1xuICBtdXRhYmxlIHkwOiBmbG9hdDtcbn1cblxubW9kdWxlIE1hdHJpeCA9IHN0cnVjdFxuICB0eXBlIHQgPSBtYXRyaXhcblxuICAoKlxuICAgIDIgYnkgMiBtYXRyaXggd2l0aCAoeDAsIHkwKSBvZmZzZXQgaXMgZXF1aXZhbGVudCB0byB0aGUgZm9sbG93aW5nIDMgYnkgMyBtYXRyaXg6XG4gICAgLyB4eCB4eSB4MCBcXCAgIC8geCBcXCAgIC8geHgqeCArIHh5KnkgKyB4MCBcXFxuICAgIHwgeXggeXkgeTAgfCAqIHwgeSB8ID0gfCB5eCp4ICsgeXkqeSArIHkwIHxcbiAgICBcXCAgMCAgMCAgMSAvICAgXFwgMSAvICAgXFwgICAgICAgICAgICAgICAgMSAvXG4gICopXG5cbiAgbGV0IGluaXRfaWRlbnRpdHkgKCkgPVxuICAgIHt4eD0xLjsgeHk9MC47IHl4PTAuOyB5eT0xLjsgeDA9MC47IHkwPTAufVxuXG4gIGxldCBpbml0X3RyYW5zbGF0ZSB4IHkgPVxuICAgIHt4eD0xLjsgeHk9MC47IHl4PTAuOyB5eT0xLjsgeDA9eDsgeTA9eX1cblxuICBsZXQgaW5pdF9zY2FsZSB4IHkgPVxuICAgIHt4eD14OyB4eT0wLjsgeXg9MC47IHl5PXk7IHgwPTAuOyB5MD0wLn1cblxuICBsZXQgaW5pdF9yb3RhdGUgYW5nbGUgPVxuICAgIHtcbiAgICAgIHh4ID0gY29zIGFuZ2xlO1xuICAgICAgeHkgPSAtLnNpbiBhbmdsZTtcbiAgICAgIHl4ID0gc2luIGFuZ2xlO1xuICAgICAgeXkgPSBjb3MgYW5nbGU7XG4gICAgICB4MCA9IDAuO1xuICAgICAgeTAgPSAwLjtcbiAgICB9XG5cbiAgbGV0IGluaXRfaW52ZXJzZSB7eHg7IHh5OyB5eDsgeXk7IHgwOyB5MH0gPVxuICAgIGxldCBkID0geHggKi4geXkgLS4geHkgKi4geXggaW5cbiAgICBpZiBkID0gMC4gdGhlbiByYWlzZSAoRXJyb3IgSU5WQUxJRF9NQVRSSVgpO1xuICAgIGxldCB4eCA9IHl5IC8uIGRcbiAgICBhbmQgeHkgPSAtLiB4eSAvLiBkXG4gICAgYW5kIHl4ID0gLS4geXggLy4gZFxuICAgIGFuZCB5eSA9IHh4IC8uIGRcbiAgICBhbmQgeDAgPSAoeHkgKi4geTAgLS4geXkgKi4geDApIC8uIGRcbiAgICBhbmQgeTAgPSAoeXggKi4geDAgLS4geHggKi4geTApIC8uIGQgaW5cbiAgICB7eHg7IHh5OyB5eDsgeXk7IHgwOyB5MH1cblxuICBsZXQgbXVsdGlwbHkge3h4OyB4eTsgeXg7IHl5OyB4MDsgeTB9IHt4eD14eCc7IHh5PXh5JzsgeXg9eXgnOyB5eT15eSc7IHgwPXgwJzsgeTA9eTAnfSA9XG4gICAgbGV0IHh4ID0geHggKi4geHgnICsuIHh5ICouIHl4J1xuICAgIGFuZCB4eSA9IHh4ICouIHh5JyArLiB4eSAqLiB5eSdcbiAgICBhbmQgeXggPSB5eCAqLiB4eCcgKy4geXkgKi4geXgnXG4gICAgYW5kIHl5ID0geXggKi4geHknICsuIHl5ICouIHl5J1xuICAgIGFuZCB4MCA9IHh4ICouIHgwJyArLiB4eSAqLiB5MCcgKy4geDBcbiAgICBhbmQgeTAgPSB5eCAqLiB4MCcgKy4geXkgKi4geTAnICsuIHkwIGluXG4gICAge3h4OyB4eTsgeXg7IHl5OyB4MDsgeTB9XG5cbiAgbGV0IHRyYW5zZm9ybV9wb2ludCB7eHg7IHh5OyB5eDsgeXk7IHgwOyB5MH0geCB5ID1cbiAgICAoeHggKi4geCArLiB4eSAqLiB5ICsuIHgwLCB5eCAqLiB4ICsuIHl5ICouIHkgKy4geTApXG5cbiAgbGV0IHRyYW5zZm9ybV9kaXN0YW5jZSB7eHg7IHh5OyB5eDsgeXk7IHgwPV87IHkwPV99IH5keCB+ZHkgPVxuICAgICh4eCAqLiBkeCArLiB4eSAqLiBkeSwgeXggKi4gZHggKy4geXkgKi4gZHkpXG5cbiAgbGV0IHNldCBtIHt4eDsgeHk7IHl4OyB5eTsgeDA7IHkwfSA9XG4gICAgbS54eCA8LSB4eDtcbiAgICBtLnh5IDwtIHh5O1xuICAgIG0ueXggPC0geXg7XG4gICAgbS55eSA8LSB5eTtcbiAgICBtLngwIDwtIHgwO1xuICAgIG0ueTAgPC0geTBcblxuICBsZXQgc2NhbGUgbSB4IHkgPVxuICAgIHNldCBtIChtdWx0aXBseSBtIChpbml0X3NjYWxlIHggeSkpXG5cbiAgbGV0IHRyYW5zbGF0ZSBtIHggeSA9XG4gICAgc2V0IG0gKG11bHRpcGx5IG0gKGluaXRfdHJhbnNsYXRlIHggeSkpXG5cbiAgbGV0IHJvdGF0ZSBtIGFuZ2xlID1cbiAgICBzZXQgbSAobXVsdGlwbHkgbSAoaW5pdF9yb3RhdGUgYW5nbGUpKVxuXG4gIGxldCBpbnZlcnQgbSA9XG4gICAgc2V0IG0gKGluaXRfaW52ZXJzZSBtKVxuZW5kXG5cbnR5cGUgc2xhbnQgPVxuICB8IFVwcmlnaHRcbiAgfCBJdGFsaWNcbiAgfCBPYmxpcXVlXG5cbnR5cGUgd2VpZ2h0ID1cbiAgfCBOb3JtYWxcbiAgfCBCb2xkXG5cbnR5cGUgZm9udCA9IHtcbiAgc2xhbnQ6IHNsYW50O1xuICB3ZWlnaHQ6IHdlaWdodDtcbiAgc2l6ZTogZmxvYXQ7XG4gIGZhbWlseTogc3RyaW5nO1xufVxuXG5tb2R1bGUgUGF0dGVybiA9IHN0cnVjdFxuICAoKiBXZSBzdG9yZSB0dXBsZXMgKGluc3RlYWQgb2YgbW9yZSBleHBsaWNpdCByZWNvcmQgdHlwZXMpIGJlY2F1c2UgdGhlIHB1YmxpYyBpbnRlcmZhY2UgdXNlcyB0dXBsZXNcbiAgKGdldF9jb2xvcl9zdG9wX3JnYmEsIGdldF9yZ2JhLCBnZXRfbGluZWFyX3BvaW50cywgZ2V0X3JhZGlhbF9jaXJjbGVzKSAqKVxuXG4gIHR5cGUgc3RvcF9wb2ludCA9IGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgKCogKHBvc2l0aW9uLCByLCBnLCBiLCBhKSAqKVxuXG4gIG1vZHVsZSBTdG9wUG9pbnRMaXN0OiBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZW1wdHk6IHRcbiAgICB2YWwgYWRkOiB0IC0+IHN0b3BfcG9pbnQgLT4gdFxuICAgIHZhbCBzaXplOiB0IC0+IGludFxuICAgIHZhbCBnZXQ6IHQgLT4gaTppbnQgLT4gc3RvcF9wb2ludFxuICAgIHZhbCB0b19saXN0OiB0IC0+IHN0b3BfcG9pbnQgbGlzdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRWxlbWVudCA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0ge1xuICAgICAgICBhZGRlZDogaW50O1xuICAgICAgICBzdG9wX3BvaW50OiBzdG9wX3BvaW50O1xuICAgICAgfVxuXG4gICAgICBsZXQgY29tcGFyZSB7c3RvcF9wb2ludD0ocG9zaXRpb25fYSwgXywgXywgXywgXyk7IGFkZGVkPWFkZGVkX2E7IF99IHtzdG9wX3BvaW50PShwb3NpdGlvbl9iLCBfLCBfLCBfLCBfKTsgYWRkZWQ9YWRkZWRfYjsgX30gPVxuICAgICAgICBtYXRjaCBjb21wYXJlIHBvc2l0aW9uX2EgcG9zaXRpb25fYiB3aXRoXG4gICAgICAgICAgfCAwIC0+IGNvbXBhcmUgYWRkZWRfYSBhZGRlZF9iXG4gICAgICAgICAgfCBuIC0+IG5cbiAgICBlbmRcblxuICAgIHR5cGUgdCA9IEVsZW1lbnQudCBsaXN0XG5cbiAgICBsZXQgZW1wdHkgPSBbXVxuXG4gICAgbGV0IHNpemUgPSBMaXN0Lmxlbmd0aFxuXG4gICAgbGV0IGFkZCB4cyBzdG9wX3BvaW50ID1cbiAgICAgIGxldCBlbGVtZW50ID0ge0VsZW1lbnQuc3RvcF9wb2ludDsgYWRkZWQ9TGlzdC5sZW5ndGggeHN9IGluXG4gICAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT4gW2VsZW1lbnRdXG4gICAgICAgIHwgeDo6eHMgYXMgeHhzIC0+IG1hdGNoIEVsZW1lbnQuY29tcGFyZSBlbGVtZW50IHggd2l0aFxuICAgICAgICAgIHwgLTEgLT4gZWxlbWVudDo6eHhzXG4gICAgICAgICAgfCBfIC0+IHg6OihhdXggeHMpXG4gICAgICBpbiBhdXggeHNcblxuICAgIGxldCB0b19saXN0IHhzID1cbiAgICAgIExpc3QubWFwIHhzIH5mOihmdW4ge0VsZW1lbnQuc3RvcF9wb2ludDsgX30gLT4gc3RvcF9wb2ludClcblxuICAgIGxldCBnZXQgeHMgfmkgPVxuICAgICAgbGV0IHtFbGVtZW50LnN0b3BfcG9pbnQ7IF99ID0gTGlzdC5udGggeHMgaSBpblxuICAgICAgc3RvcF9wb2ludFxuICBlbmRcblxuICAoKiBUaGlzIGlzIGp1c3QgdG8gY292ZXIgU3RvcFBvaW50TGlzdC50b19saXN0LCB3aGljaCBpcyB1c2VkIG9ubHkgaW4gSnNPZk9DYWlybywgd2hvc2UgdGVzdCBjb3ZlcmFnZSBpc24ndCBtZWFzdXJlZC4gKilcbiAgbGV0IF8gPSBTdG9wUG9pbnRMaXN0LihhZGQgZW1wdHkgKDAuLCAwLiwgMC4sIDAuLCAwLikgfD4gdG9fbGlzdClcblxuICAoKiBXaGVuIHdlIGRyb3Agc3VwcG9ydCBvZiBPQ2FtbCA0LjAyLCB3ZSBjYW4gdXNlIFtpbmxpbmUgcmVjb3Jkc10oaHR0cHM6Ly9jYW1sLmlucmlhLmZyL3B1Yi9kb2NzL21hbnVhbC1vY2FtbC00LjA2L2V4dG4uaHRtbCNzJTNBaW5saW5lLXJlY29yZHMpICopXG4gIHR5cGUgbGluZWFyX2dyYWRpZW50ID0ge1xuICAgIHBvaW50czogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ICogZmxvYXQ7ICgqICh4MCwgeTAsIHgxLCB5MSkgKilcbiAgICBzdG9wX3BvaW50czogU3RvcFBvaW50TGlzdC50O1xuICB9XG5cbiAgdHlwZSByYWRpYWxfZ3JhZGllbnQgPSB7XG4gICAgY2lyY2xlczogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0OyAoKiAoeDAsIHkwLCByMCwgeDEsIHkxLCByMSkgKilcbiAgICBzdG9wX3BvaW50czogU3RvcFBvaW50TGlzdC50O1xuICB9XG5cbiAgdHlwZSBzb3VyY2UgPVxuICAgIHwgUmdiYSBvZiAoZmxvYXQgKiBmbG9hdCAqIGZsb2F0ICogZmxvYXQpICgqIChyLCBnLCBiLCBhKSAqKVxuICAgIHwgTGluZWFyR3JhZGllbnQgb2YgbGluZWFyX2dyYWRpZW50XG4gICAgfCBSYWRpYWxHcmFkaWVudCBvZiByYWRpYWxfZ3JhZGllbnRcbiAgICB8IFR5cGVNaXNtYXRjaFxuXG4gIHR5cGUgJ2EgdCA9IHNvdXJjZSByZWYgY29uc3RyYWludCAnYSA9IFs8YFNvbGlkIHwgYFN1cmZhY2UgfCBgR3JhZGllbnQgfCBgTGluZWFyIHwgYFJhZGlhbF1cblxuICB0eXBlIGFueSA9IFtgU29saWQgfCBgU3VyZmFjZSB8IGBHcmFkaWVudCB8IGBMaW5lYXIgfCBgUmFkaWFsXSB0XG5cbiAgbGV0IGNyZWF0ZV9yZ2JhIHIgZyBiIGEgPVxuICAgIHJlZiAoUmdiYSAociwgZywgYiwgYSkpXG5cbiAgbGV0IGNyZWF0ZV9yZ2IgciBnIGIgPVxuICAgIGNyZWF0ZV9yZ2JhIHIgZyBiIDEuXG5cbiAgbGV0IGdldF9yZ2JhIHBhdHRlcm4gPVxuICAgIG1hdGNoICFwYXR0ZXJuIHdpdGhcbiAgICAgIHwgUmdiYSBjb2xvciAtPiBjb2xvclxuICAgICAgfCBMaW5lYXJHcmFkaWVudCBfXG4gICAgICB8IFJhZGlhbEdyYWRpZW50IF9cbiAgICAgIHwgVHlwZU1pc21hdGNoIC0+IHJhaXNlIChFcnJvciBQQVRURVJOX1RZUEVfTUlTTUFUQ0gpXG5cbiAgbGV0IGNyZWF0ZV9saW5lYXIgfngwIH55MCB+eDEgfnkxID1cbiAgICByZWYgKExpbmVhckdyYWRpZW50IHtwb2ludHM9KHgwLCB5MCwgeDEsIHkxKTsgc3RvcF9wb2ludHM9U3RvcFBvaW50TGlzdC5lbXB0eX0pXG5cbiAgbGV0IGdldF9saW5lYXJfcG9pbnRzIHBhdHRlcm4gPVxuICAgIG1hdGNoICFwYXR0ZXJuIHdpdGhcbiAgICAgIHwgTGluZWFyR3JhZGllbnQge3BvaW50czsgX30gLT4gcG9pbnRzXG4gICAgICB8IFJnYmEgX1xuICAgICAgfCBSYWRpYWxHcmFkaWVudCBfXG4gICAgICB8IFR5cGVNaXNtYXRjaCAtPiByYWlzZSAoRXJyb3IgUEFUVEVSTl9UWVBFX01JU01BVENIKVxuXG4gIGxldCBjcmVhdGVfcmFkaWFsIH54MCB+eTAgfnIwIH54MSB+eTEgfnIxID1cbiAgICByZWYgKFJhZGlhbEdyYWRpZW50IHtjaXJjbGVzPSh4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKTsgc3RvcF9wb2ludHM9U3RvcFBvaW50TGlzdC5lbXB0eX0pXG5cbiAgbGV0IGdldF9yYWRpYWxfY2lyY2xlcyBwYXR0ZXJuID1cbiAgICBtYXRjaCAhcGF0dGVybiB3aXRoXG4gICAgICB8IFJhZGlhbEdyYWRpZW50IHtjaXJjbGVzOyBffSAtPiBjaXJjbGVzXG4gICAgICB8IExpbmVhckdyYWRpZW50IF9cbiAgICAgIHwgUmdiYSBfXG4gICAgICB8IFR5cGVNaXNtYXRjaCAtPiByYWlzZSAoRXJyb3IgUEFUVEVSTl9UWVBFX01JU01BVENIKVxuXG4gIGxldCBhZGRfY29sb3Jfc3RvcF9yZ2JhIHBhdHRlcm4gPyhvZnM9MC4pIHIgZyBiIGEgPVxuICAgIGxldCBzdG9wX3BvaW50ID0gKG9mcywgciwgZywgYiwgYSkgaW5cbiAgICBtYXRjaCAhcGF0dGVybiB3aXRoXG4gICAgICB8IExpbmVhckdyYWRpZW50IGdyYWRpZW50IC0+XG4gICAgICAgIHBhdHRlcm4gOj0gTGluZWFyR3JhZGllbnQge2dyYWRpZW50IHdpdGggc3RvcF9wb2ludHM9KFN0b3BQb2ludExpc3QuYWRkIGdyYWRpZW50LnN0b3BfcG9pbnRzIHN0b3BfcG9pbnQpfVxuICAgICAgfCBSYWRpYWxHcmFkaWVudCBncmFkaWVudCAtPlxuICAgICAgICBwYXR0ZXJuIDo9IFJhZGlhbEdyYWRpZW50IHtncmFkaWVudCB3aXRoIHN0b3BfcG9pbnRzPShTdG9wUG9pbnRMaXN0LmFkZCBncmFkaWVudC5zdG9wX3BvaW50cyBzdG9wX3BvaW50KX1cbiAgICAgIHwgUmdiYSBfIC0+IHBhdHRlcm4gOj0gVHlwZU1pc21hdGNoXG4gICAgICB8IFR5cGVNaXNtYXRjaCAtPiAoKVxuXG4gIGxldCBhZGRfY29sb3Jfc3RvcF9yZ2IgcGF0dGVybiA/b2ZzIHIgZyBiID1cbiAgICBhZGRfY29sb3Jfc3RvcF9yZ2JhIHBhdHRlcm4gP29mcyByIGcgYiAxLlxuXG4gIGxldCBnZXRfY29sb3Jfc3RvcF9jb3VudCBwYXR0ZXJuID1cbiAgICBtYXRjaCAhcGF0dGVybiB3aXRoXG4gICAgICB8IExpbmVhckdyYWRpZW50IHtzdG9wX3BvaW50czsgX30gfCBSYWRpYWxHcmFkaWVudCB7c3RvcF9wb2ludHM7IF99IC0+IFN0b3BQb2ludExpc3Quc2l6ZSBzdG9wX3BvaW50c1xuICAgICAgfCBSZ2JhIF9cbiAgICAgIHwgVHlwZU1pc21hdGNoIC0+IHJhaXNlIChFcnJvciBQQVRURVJOX1RZUEVfTUlTTUFUQ0gpXG5cbiAgbGV0IGdldF9jb2xvcl9zdG9wX3JnYmEgcGF0dGVybiB+aWR4ID1cbiAgICBtYXRjaCAhcGF0dGVybiB3aXRoXG4gICAgICB8IExpbmVhckdyYWRpZW50IHtzdG9wX3BvaW50czsgX30gfCBSYWRpYWxHcmFkaWVudCB7c3RvcF9wb2ludHM7IF99IC0+IFN0b3BQb2ludExpc3QuZ2V0IHN0b3BfcG9pbnRzIH5pOmlkeFxuICAgICAgfCBSZ2JhIF9cbiAgICAgIHwgVHlwZU1pc21hdGNoIC0+IHJhaXNlIChFcnJvciBQQVRURVJOX1RZUEVfTUlTTUFUQ0gpXG5lbmRcblxudHlwZSBmaWxsX3J1bGUgPVxuICB8IFdJTkRJTkdcbiAgfCBFVkVOX09ERFxuXG50eXBlIGxpbmVfY2FwID1cbiAgfCBCVVRUXG4gIHwgUk9VTkRcbiAgfCBTUVVBUkVcblxudHlwZSBsaW5lX2pvaW4gPVxuICB8IEpPSU5fTUlURVJcbiAgfCBKT0lOX1JPVU5EXG4gIHwgSk9JTl9CRVZFTFxuXG50eXBlIGZvbnRfZXh0ZW50cyA9IHtcbiAgYXNjZW50OiBmbG9hdDtcbiAgZGVzY2VudDogZmxvYXQ7XG4gIGJhc2VsaW5lOiBmbG9hdDtcbiAgbWF4X3hfYWR2YW5jZTogZmxvYXQ7XG4gIG1heF95X2FkdmFuY2U6IGZsb2F0O1xufVxuXG50eXBlIHRleHRfZXh0ZW50cyA9IHtcbiAgeF9iZWFyaW5nOiBmbG9hdDtcbiAgeV9iZWFyaW5nOiBmbG9hdDtcbiAgd2lkdGg6IGZsb2F0O1xuICBoZWlnaHQ6IGZsb2F0O1xuICB4X2FkdmFuY2U6IGZsb2F0O1xuICB5X2FkdmFuY2U6IGZsb2F0O1xufVxuXG50eXBlIG9wZXJhdG9yID1cbiAgfCBDTEVBUlxuICB8IFNPVVJDRVxuICB8IE9WRVJcbiAgfCBJTlxuICB8IE9VVFxuICB8IEFUT1BcbiAgfCBERVNUXG4gIHwgREVTVF9PVkVSXG4gIHwgREVTVF9JTlxuICB8IERFU1RfT1VUXG4gIHwgREVTVF9BVE9QXG4gIHwgWE9SXG4gIHwgQUREXG4gIHwgU0FUVVJBVEVcblxubW9kdWxlIFBvaW50czogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBjcmVhdGU6IHVuaXQgLT4gdFxuXG4gIHZhbCBzZXRfc3RhcnQ6IHQgLT4gdHJhbnNmb3JtYXRpb246TWF0cml4LnQgLT4geDpmbG9hdCAtPiB5OmZsb2F0IC0+IHVuaXRcbiAgdmFsIHNldF9zdGFydF9pZl9ub25lOiB0IC0+IHRyYW5zZm9ybWF0aW9uOk1hdHJpeC50IC0+IHg6ZmxvYXQgLT4geTpmbG9hdCAtPiB1bml0XG4gIHZhbCByZXNldF9zdGFydDogdCAtPiB1bml0XG5cbiAgdmFsIHNldF9jdXJyZW50OiB0IC0+IHRyYW5zZm9ybWF0aW9uOk1hdHJpeC50IC0+IHg6ZmxvYXQgLT4geTpmbG9hdCAtPiB1bml0XG4gIHZhbCBzZXRfY3VycmVudF9mcm9tX3N0YXJ0OiB0IC0+IHVuaXRcbiAgdmFsIHJlc2V0X2N1cnJlbnQ6IHQgLT4gdW5pdFxuICB2YWwgY3VycmVudDogdCAtPiB0cmFuc2Zvcm1hdGlvbjpNYXRyaXgudCAtPiAoZmxvYXQgKiBmbG9hdCkgb3B0aW9uXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0ge1xuICAgIG11dGFibGUgc3RhcnQ6IChmbG9hdCAqIGZsb2F0KSBvcHRpb247XG4gICAgbXV0YWJsZSBjdXJyZW50OiAoZmxvYXQgKiBmbG9hdCkgb3B0aW9uO1xuICB9XG5cbiAgbGV0IGNyZWF0ZSAoKSA9IHtcbiAgICBzdGFydCA9IE5vbmU7XG4gICAgY3VycmVudCA9IE5vbmU7XG4gIH1cblxuICBsZXQgc2V0X3N0YXJ0IHBvaW50cyB+dHJhbnNmb3JtYXRpb24gfnggfnkgPVxuICAgIHBvaW50cy5zdGFydCA8LSBTb21lIChNYXRyaXgudHJhbnNmb3JtX3BvaW50IHRyYW5zZm9ybWF0aW9uIHggeSlcblxuICBsZXQgc2V0X3N0YXJ0X2lmX25vbmUgcG9pbnRzIH50cmFuc2Zvcm1hdGlvbiB+eCB+eSA9XG4gICAgaWYgcG9pbnRzLnN0YXJ0ID0gTm9uZSB0aGVuXG4gICAgcG9pbnRzLnN0YXJ0IDwtIFNvbWUgKE1hdHJpeC50cmFuc2Zvcm1fcG9pbnQgdHJhbnNmb3JtYXRpb24geCB5KVxuXG4gIGxldCByZXNldF9zdGFydCBwb2ludHMgPVxuICAgIHBvaW50cy5zdGFydCA8LSBOb25lXG5cbiAgbGV0IHNldF9jdXJyZW50IHBvaW50cyB+dHJhbnNmb3JtYXRpb24gfnggfnkgPVxuICAgIHBvaW50cy5jdXJyZW50IDwtIFNvbWUgKE1hdHJpeC50cmFuc2Zvcm1fcG9pbnQgdHJhbnNmb3JtYXRpb24geCB5KVxuXG4gIGxldCBzZXRfY3VycmVudF9mcm9tX3N0YXJ0IHBvaW50cyA9XG4gICAgcG9pbnRzLmN1cnJlbnQgPC0gcG9pbnRzLnN0YXJ0XG5cbiAgbGV0IHJlc2V0X2N1cnJlbnQgcG9pbnRzID1cbiAgICBwb2ludHMuY3VycmVudCA8LSBOb25lXG5cbiAgbGV0IGN1cnJlbnQgcG9pbnRzIH50cmFuc2Zvcm1hdGlvbiA9XG4gICAgbWF0Y2ggcG9pbnRzLmN1cnJlbnQgd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgIHwgU29tZSAoeCwgeSkgLT4gU29tZSAoTWF0cml4LnRyYW5zZm9ybV9wb2ludCAoTWF0cml4LmluaXRfaW52ZXJzZSB0cmFuc2Zvcm1hdGlvbikgeCB5KVxuZW5kXG5cbiMgMTggXCJzcmMvSnNPZk9DYWlyby5jcHBvLm1sXCJcbmxldCAoKSA9IFByaW50ZXhjLnJlZ2lzdGVyX3ByaW50ZXIgKGZ1bmN0aW9uXG4gIHwgRXJyb3Igc3RhdHVzIC0+IFNvbWUgKFByaW50Zi5zcHJpbnRmIFwiSnNPZk9DYWlyby5FcnJvciglcylcIiAoc3RhdHVzX3JlcHIgc3RhdHVzKSlcbiAgfCBfIC0+IE5vbmVcbilcblxubW9kdWxlIEh0bWwgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gRG9tX2h0bWwuY2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIEpzLnRcbmVuZFxuXG5tb2R1bGUgTG9jYWw6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgY3JlYXRlOiB1bml0IC0+IHRcblxuICB2YWwgc2F2ZTogdCAtPiB1bml0XG4gIHZhbCByZXN0b3JlOiB0IC0+IHVuaXRcblxuICB2YWwgdHJhbnNmb3JtYXRpb246IHQgLT4gTWF0cml4LnRcbiAgdmFsIHNldF90cmFuc2Zvcm1hdGlvbjogdCAtPiB0cmFuc2Zvcm1hdGlvbjpNYXRyaXgudCAtPiB1bml0XG5cbiAgdmFsIGZvbnQ6IHQgLT4gZm9udFxuICB2YWwgc2V0X2ZvbnQ6IHQgLT4gZm9udDpmb250IC0+IHVuaXRcblxuICB2YWwgc291cmNlOiB0IC0+IFBhdHRlcm4uc291cmNlXG4gIHZhbCBzZXRfc291cmNlOiB0IC0+IHNvdXJjZTpQYXR0ZXJuLnNvdXJjZSAtPiB1bml0XG5cbiAgdmFsIGZpbGxfcnVsZTogdCAtPiBmaWxsX3J1bGVcbiAgdmFsIHNldF9maWxsX3J1bGU6IHQgLT4gZmlsbF9ydWxlOmZpbGxfcnVsZSAtPiB1bml0XG5cbiAgdmFsIHNldF9zdGFydF9wb2ludDogdCAtPiBmbG9hdCAqIGZsb2F0IC0+IHVuaXRcbiAgdmFsIHNldF9zdGFydF9wb2ludF9pZl9ub25lOiB0IC0+IGZsb2F0ICogZmxvYXQgLT4gdW5pdFxuICB2YWwgcmVzZXRfc3RhcnRfcG9pbnQ6IHQgLT4gdW5pdFxuICB2YWwgc2V0X3N0YXJ0X3BvaW50X2FzX2N1cnJlbnRfcG9pbnQ6IHQgLT4gdW5pdFxuXG4gIHZhbCBjdXJyZW50X3BvaW50OiB0IC0+IChmbG9hdCAqIGZsb2F0KSBvcHRpb25cbiAgdmFsIHNldF9jdXJyZW50X3BvaW50OiB0IC0+IGZsb2F0ICogZmxvYXQgLT4gdW5pdFxuICB2YWwgcmVzZXRfY3VycmVudF9wb2ludDogdCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFN0YXRlID0gc3RydWN0XG4gICAgdHlwZSB0ID0ge1xuICAgICAgdHJhbnNmb3JtYXRpb246IE1hdHJpeC50O1xuICAgICAgZm9udDogZm9udDtcbiAgICAgIHNvdXJjZTogUGF0dGVybi5zb3VyY2U7XG4gICAgICBmaWxsX3J1bGU6IGZpbGxfcnVsZTtcbiAgICB9XG4gIGVuZFxuXG4gIHR5cGUgdCA9IHtcbiAgICBwb2ludHM6IFBvaW50cy50O1xuICAgIG11dGFibGUgc3RhdGVzOiBTdGF0ZS50IGxpc3Q7XG4gIH1cblxuICBsZXQgY3JlYXRlICgpID0ge1xuICAgIHBvaW50cyA9IFBvaW50cy5jcmVhdGUgKCk7XG4gICAgc3RhdGVzID0gW1xuICAgICAge1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbiA9IE1hdHJpeC5pbml0X2lkZW50aXR5ICgpO1xuICAgICAgICBmb250ID0ge1xuICAgICAgICAgIHNsYW50ID0gVXByaWdodDtcbiAgICAgICAgICB3ZWlnaHQgPSBOb3JtYWw7XG4gICAgICAgICAgc2l6ZSA9IDEwLjtcbiAgICAgICAgICBmYW1pbHkgPSBcInNhbnMtc2VyaWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgc291cmNlID0gIShQYXR0ZXJuLmNyZWF0ZV9yZ2IgMC4gMC4gMC4pO1xuICAgICAgICBmaWxsX3J1bGUgPSBXSU5ESU5HO1xuICAgICAgfTtcbiAgICBdO1xuICB9XG5cbiAgbGV0IHN0YXRlIGNvbnRleHQgPVxuICAgIExpc3QuaGQgY29udGV4dC5zdGF0ZXNcblxuICBsZXQgc2V0X3N0YXRlIGNvbnRleHQgc3RhdGUgPVxuICAgIGNvbnRleHQuc3RhdGVzIDwtIHN0YXRlOjooTGlzdC50bCBjb250ZXh0LnN0YXRlcylcblxuICBsZXQgc2F2ZSBjb250ZXh0ID1cbiAgICBjb250ZXh0LnN0YXRlcyA8LSAoc3RhdGUgY29udGV4dCk6OmNvbnRleHQuc3RhdGVzXG5cbiAgbGV0IHJlc3RvcmUgY29udGV4dCA9XG4gICAgbGV0IHN0YXRlcyA9XG4gICAgICBtYXRjaCBjb250ZXh0LnN0YXRlcyB3aXRoXG4gICAgICAgIHwgW10gfCBbX10gLT4gcmFpc2UgKEVycm9yIElOVkFMSURfUkVTVE9SRSlcbiAgICAgICAgfCBfOjpzdGF0ZXMgLT4gc3RhdGVzXG4gICAgaW5cbiAgICBjb250ZXh0LnN0YXRlcyA8LSBzdGF0ZXNcblxuICBsZXQgdHJhbnNmb3JtYXRpb24gY29udGV4dCA9XG4gICAgKHN0YXRlIGNvbnRleHQpLnRyYW5zZm9ybWF0aW9uXG5cbiAgbGV0IHNldF90cmFuc2Zvcm1hdGlvbiBjb250ZXh0IH50cmFuc2Zvcm1hdGlvbiA9XG4gICAgc2V0X3N0YXRlIGNvbnRleHQgKHsoc3RhdGUgY29udGV4dCkgd2l0aCB0cmFuc2Zvcm1hdGlvbn0pXG5cbiAgbGV0IGZvbnQgY29udGV4dCA9XG4gICAgKHN0YXRlIGNvbnRleHQpLmZvbnRcblxuICBsZXQgc2V0X2ZvbnQgY29udGV4dCB+Zm9udCA9XG4gICAgc2V0X3N0YXRlIGNvbnRleHQgKHsoc3RhdGUgY29udGV4dCkgd2l0aCBmb250fSlcblxuICBsZXQgc291cmNlIGNvbnRleHQgPVxuICAgIChzdGF0ZSBjb250ZXh0KS5zb3VyY2VcblxuICBsZXQgc2V0X3NvdXJjZSBjb250ZXh0IH5zb3VyY2UgPVxuICAgIHNldF9zdGF0ZSBjb250ZXh0ICh7KHN0YXRlIGNvbnRleHQpIHdpdGggc291cmNlfSlcblxuICBsZXQgZmlsbF9ydWxlIGNvbnRleHQgPVxuICAgIChzdGF0ZSBjb250ZXh0KS5maWxsX3J1bGVcblxuICBsZXQgc2V0X2ZpbGxfcnVsZSBjb250ZXh0IH5maWxsX3J1bGUgPVxuICAgIHNldF9zdGF0ZSBjb250ZXh0ICh7KHN0YXRlIGNvbnRleHQpIHdpdGggZmlsbF9ydWxlfSlcblxuICBsZXQgc2V0X3N0YXJ0X3BvaW50IGNvbnRleHQgKHgsIHkpID1cbiAgICBsZXQgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbiBjb250ZXh0IGluXG4gICAgUG9pbnRzLnNldF9zdGFydCBjb250ZXh0LnBvaW50cyB+dHJhbnNmb3JtYXRpb24gfnggfnlcblxuICBsZXQgcmVzZXRfc3RhcnRfcG9pbnQgY29udGV4dCA9XG4gICAgUG9pbnRzLnJlc2V0X3N0YXJ0IGNvbnRleHQucG9pbnRzXG5cbiAgbGV0IHNldF9zdGFydF9wb2ludF9pZl9ub25lIGNvbnRleHQgKHgsIHkpID1cbiAgICBsZXQgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbiBjb250ZXh0IGluXG4gICAgUG9pbnRzLnNldF9zdGFydF9pZl9ub25lIGNvbnRleHQucG9pbnRzIH50cmFuc2Zvcm1hdGlvbiB+eCB+eVxuXG4gIGxldCBzZXRfc3RhcnRfcG9pbnRfYXNfY3VycmVudF9wb2ludCBjb250ZXh0ID1cbiAgICBQb2ludHMuc2V0X2N1cnJlbnRfZnJvbV9zdGFydCBjb250ZXh0LnBvaW50c1xuXG4gIGxldCBjdXJyZW50X3BvaW50IGNvbnRleHQgPVxuICAgIGxldCB0cmFuc2Zvcm1hdGlvbiA9IHRyYW5zZm9ybWF0aW9uIGNvbnRleHQgaW5cbiAgICBQb2ludHMuY3VycmVudCBjb250ZXh0LnBvaW50cyB+dHJhbnNmb3JtYXRpb25cblxuICBsZXQgc2V0X2N1cnJlbnRfcG9pbnQgY29udGV4dCAoeCwgeSkgPVxuICAgIGxldCB0cmFuc2Zvcm1hdGlvbiA9IHRyYW5zZm9ybWF0aW9uIGNvbnRleHQgaW5cbiAgICBQb2ludHMuc2V0X2N1cnJlbnQgY29udGV4dC5wb2ludHMgfnRyYW5zZm9ybWF0aW9uIH54IH55XG5cbiAgbGV0IHJlc2V0X2N1cnJlbnRfcG9pbnQgY29udGV4dCA9XG4gICAgUG9pbnRzLnJlc2V0X2N1cnJlbnQgY29udGV4dC5wb2ludHNcbmVuZFxuXG50eXBlIGNvbnRleHQgPSB7XG4gIGh0bWw6IEh0bWwudDtcbiAgbG9jYWw6IExvY2FsLnQ7XG59XG5cblxubGV0IHNhdmUgY29udGV4dCA9XG4gIGNvbnRleHQuaHRtbCMjc2F2ZTtcbiAgTG9jYWwuc2F2ZSBjb250ZXh0LmxvY2FsXG5cbmxldCByZXN0b3JlIGNvbnRleHQgPVxuICBjb250ZXh0Lmh0bWwjI3Jlc3RvcmU7XG4gIExvY2FsLnJlc3RvcmUgY29udGV4dC5sb2NhbFxuXG5cbmxldCBzZXRfbWF0cml4IGNvbnRleHQgKHt4eDsgeHk7IHl4OyB5eTsgeDA7IHkwfSBhcyB0cmFuc2Zvcm1hdGlvbikgPVxuICBjb250ZXh0Lmh0bWwjI3NldFRyYW5zZm9ybSB4eCB5eCB4eSB5eSB4MCB5MDtcbiAgTG9jYWwuc2V0X3RyYW5zZm9ybWF0aW9uIGNvbnRleHQubG9jYWwgfnRyYW5zZm9ybWF0aW9uXG5cbmxldCBnZXRfbWF0cml4IGNvbnRleHQgPVxuICBMb2NhbC50cmFuc2Zvcm1hdGlvbiBjb250ZXh0LmxvY2FsXG5cbmxldCB0cmFuc2Zvcm0gY29udGV4dCBtID1cbiAgc2V0X21hdHJpeCBjb250ZXh0IChNYXRyaXgubXVsdGlwbHkgKExvY2FsLnRyYW5zZm9ybWF0aW9uIGNvbnRleHQubG9jYWwpIG0pXG5cbmxldCBzY2FsZSBjb250ZXh0IHggeSA9XG4gIHRyYW5zZm9ybSBjb250ZXh0IChNYXRyaXguaW5pdF9zY2FsZSB4IHkpXG5cbmxldCB0cmFuc2xhdGUgY29udGV4dCB4IHkgPVxuICB0cmFuc2Zvcm0gY29udGV4dCAoTWF0cml4LmluaXRfdHJhbnNsYXRlIHggeSlcblxubGV0IHJvdGF0ZSBjb250ZXh0IGFuZ2xlID1cbiAgdHJhbnNmb3JtIGNvbnRleHQgKE1hdHJpeC5pbml0X3JvdGF0ZSBhbmdsZSlcblxubGV0IGlkZW50aXR5X21hdHJpeCBjb250ZXh0ID1cbiAgc2V0X21hdHJpeCBjb250ZXh0IChNYXRyaXguaW5pdF9pZGVudGl0eSAoKSlcblxubGV0IGRldmljZV90b191c2VyIGNvbnRleHQgeCB5ID1cbiAgTWF0cml4LnRyYW5zZm9ybV9wb2ludCAoTWF0cml4LmluaXRfaW52ZXJzZSAoTG9jYWwudHJhbnNmb3JtYXRpb24gY29udGV4dC5sb2NhbCkpIHggeVxuXG5sZXQgZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2UgY29udGV4dCBkeCBkeSA9XG4gIE1hdHJpeC50cmFuc2Zvcm1fZGlzdGFuY2UgKE1hdHJpeC5pbml0X2ludmVyc2UgKExvY2FsLnRyYW5zZm9ybWF0aW9uIGNvbnRleHQubG9jYWwpKSB+ZHggfmR5XG5cbmxldCB1c2VyX3RvX2RldmljZSBjb250ZXh0IHggeSA9XG4gIE1hdHJpeC50cmFuc2Zvcm1fcG9pbnQgKExvY2FsLnRyYW5zZm9ybWF0aW9uIGNvbnRleHQubG9jYWwpIHggeVxuXG5sZXQgdXNlcl90b19kZXZpY2VfZGlzdGFuY2UgY29udGV4dCBkeCBkeSA9XG4gIE1hdHJpeC50cmFuc2Zvcm1fZGlzdGFuY2UgKExvY2FsLnRyYW5zZm9ybWF0aW9uIGNvbnRleHQubG9jYWwpIH5keCB+ZHlcblxuXG5sZXQgbWFrZV9yZWwgY29udGV4dCB+eDpkeCB+eTpkeSA9XG4gIG1hdGNoIExvY2FsLmN1cnJlbnRfcG9pbnQgY29udGV4dC5sb2NhbCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIChFcnJvciBOT19DVVJSRU5UX1BPSU5UKVxuICAgIHwgU29tZSAoeCwgeSkgLT4gKHggKy4gZHgsIHkgKy4gZHkpXG5cbmxldCBtb3ZlX3RvIGNvbnRleHQgeCB5ID1cbiAgY29udGV4dC5odG1sIyNtb3ZlVG8geCB5O1xuICBMb2NhbC5zZXRfc3RhcnRfcG9pbnQgY29udGV4dC5sb2NhbCAoeCwgeSk7XG4gIExvY2FsLnNldF9zdGFydF9wb2ludF9hc19jdXJyZW50X3BvaW50IGNvbnRleHQubG9jYWxcblxubGV0IHJlbF9tb3ZlX3RvIGNvbnRleHQgeCB5ID1cbiAgbGV0ICh4LCB5KSA9IG1ha2VfcmVsIGNvbnRleHQgfnggfnkgaW5cbiAgbW92ZV90byBjb250ZXh0IHggeVxuXG5sZXQgbGluZV90byBjb250ZXh0IHggeSA9XG4gIGNvbnRleHQuaHRtbCMjbGluZVRvIHggeTtcbiAgTG9jYWwuc2V0X3N0YXJ0X3BvaW50X2lmX25vbmUgY29udGV4dC5sb2NhbCAoeCwgeSk7XG4gIExvY2FsLnNldF9jdXJyZW50X3BvaW50IGNvbnRleHQubG9jYWwgKHgsIHkpXG5cbmxldCByZWxfbGluZV90byBjb250ZXh0IHggeSA9XG4gIGxldCAoeCwgeSkgPSBtYWtlX3JlbCBjb250ZXh0IH54IH55IGluXG4gIGxpbmVfdG8gY29udGV4dCB4IHlcblxubGV0IGN1cnZlX3RvIGNvbnRleHQgeDEgeTEgeDIgeTIgeDMgeTMgPVxuICBjb250ZXh0Lmh0bWwjI2JlemllckN1cnZlVG8geDEgeTEgeDIgeTIgeDMgeTM7XG4gIExvY2FsLnNldF9zdGFydF9wb2ludF9pZl9ub25lIGNvbnRleHQubG9jYWwgKHgxLCB5MSk7XG4gIExvY2FsLnNldF9jdXJyZW50X3BvaW50IGNvbnRleHQubG9jYWwgKHgzLCB5MylcblxubGV0IHJlbF9jdXJ2ZV90byBjb250ZXh0IHgxIHkxIHgyIHkyIHgzIHkzID1cbiAgbGV0ICh4MSwgeTEpID0gbWFrZV9yZWwgY29udGV4dCB+eDp4MSB+eTp5MVxuICBhbmQgKHgyLCB5MikgPSBtYWtlX3JlbCBjb250ZXh0IH54OngyIH55OnkyXG4gIGFuZCAoeDMsIHkzKSA9IG1ha2VfcmVsIGNvbnRleHQgfng6eDMgfnk6eTMgaW5cbiAgY3VydmVfdG8gY29udGV4dCB4MSB5MSB4MiB5MiB4MyB5M1xuXG5sZXQgcmVjdGFuZ2xlIGNvbnRleHQgeCB5IH53IH5oID1cbiAgTG9jYWwuc2V0X2N1cnJlbnRfcG9pbnQgY29udGV4dC5sb2NhbCAoeCwgeSk7XG4gIGNvbnRleHQuaHRtbCMjcmVjdCB4IHkgdyBoXG5cbmxldCBhcmNfIH5kaXIgY29udGV4dCB4IHkgfnIgfmExIH5hMiA9XG4gIGNvbnRleHQuaHRtbCMjYXJjIHggeSByIGExIGEyIGRpcjtcbiAgTG9jYWwuc2V0X3N0YXJ0X3BvaW50X2lmX25vbmUgY29udGV4dC5sb2NhbCAoeCArLiByICouIChjb3MgYTEpLCB5ICsuIHIgKi4gKHNpbiBhMSkpO1xuICBMb2NhbC5zZXRfY3VycmVudF9wb2ludCBjb250ZXh0LmxvY2FsICh4ICsuIHIgKi4gKGNvcyBhMiksIHkgKy4gciAqLiAoc2luIGEyKSlcblxubGV0IGFyYyA9IGFyY18gfmRpcjpKcy5fZmFsc2VcblxubGV0IGFyY19uZWdhdGl2ZSA9IGFyY18gfmRpcjpKcy5fdHJ1ZVxuXG5tb2R1bGUgUGF0aCA9IHN0cnVjdFxuICBsZXQgZ2V0X2N1cnJlbnRfcG9pbnQgY29udGV4dCA9XG4gICAgbWF0Y2ggTG9jYWwuY3VycmVudF9wb2ludCBjb250ZXh0LmxvY2FsIHdpdGhcbiAgICAgIHwgTm9uZSAtPiAoMC4sIDAuKVxuICAgICAgfCBTb21lICh4LCB5KSAtPiAoeCwgeSlcblxuICBsZXQgY2xlYXIgY29udGV4dCA9XG4gICAgY29udGV4dC5odG1sIyNiZWdpblBhdGg7XG4gICAgTG9jYWwucmVzZXRfc3RhcnRfcG9pbnQgY29udGV4dC5sb2NhbDtcbiAgICBMb2NhbC5yZXNldF9jdXJyZW50X3BvaW50IGNvbnRleHQubG9jYWxcblxuICBsZXQgY2xvc2UgY29udGV4dCA9XG4gICAgY29udGV4dC5odG1sIyNjbG9zZVBhdGg7XG4gICAgTG9jYWwuc2V0X3N0YXJ0X3BvaW50X2FzX2N1cnJlbnRfcG9pbnQgY29udGV4dC5sb2NhbFxuZW5kXG5cbmxldCBzdHJva2VfcHJlc2VydmUgY29udGV4dCA9XG4gIGNvbnRleHQuaHRtbCMjc3Ryb2tlXG5cbmxldCBzdHJva2UgY29udGV4dCA9XG4gIHN0cm9rZV9wcmVzZXJ2ZSBjb250ZXh0O1xuICBQYXRoLmNsZWFyIGNvbnRleHRcblxubGV0IGZpbGxfcHJlc2VydmUgY29udGV4dCA9XG4gIG1hdGNoIExvY2FsLmZpbGxfcnVsZSBjb250ZXh0LmxvY2FsIHdpdGhcbiAgICB8IFdJTkRJTkcgLT4gY29udGV4dC5odG1sIyNmaWxsXG4gICAgfCBFVkVOX09ERCAtPiAoSnMuVW5zYWZlLmNvZXJjZSBjb250ZXh0Lmh0bWwpIyNmaWxsIChKcy5zdHJpbmcgXCJldmVub2RkXCIpXG5cbmxldCBmaWxsIGNvbnRleHQgPVxuICBmaWxsX3ByZXNlcnZlIGNvbnRleHQ7XG4gIFBhdGguY2xlYXIgY29udGV4dFxuXG5sZXQgY2xpcF9wcmVzZXJ2ZSBjb250ZXh0ID1cbiAgY29udGV4dC5odG1sIyNjbGlwXG5cbmxldCBjbGlwIGNvbnRleHQgPVxuICBjbGlwX3ByZXNlcnZlIGNvbnRleHQ7XG4gIFBhdGguY2xlYXIgY29udGV4dFxuXG5sZXQgcGFpbnQgPyhhbHBoYT0xLikgY29udGV4dCA9XG4gIHNhdmUgY29udGV4dDtcbiAgY29udGV4dC5odG1sIyMuZ2xvYmFsQWxwaGEgOj0gYWxwaGE7XG4gIGlkZW50aXR5X21hdHJpeCBjb250ZXh0O1xuICBsZXQgd2lkdGggPSAoZmxvYXRfb2ZfaW50IGNvbnRleHQuaHRtbCMjLmNhbnZhcyMjLndpZHRoKVxuICBhbmQgaGVpZ2h0ID0gKGZsb2F0X29mX2ludCBjb250ZXh0Lmh0bWwjIy5jYW52YXMjIy5oZWlnaHQpIGluXG4gIGNvbnRleHQuaHRtbCMjZmlsbFJlY3QgMC4gMC4gd2lkdGggaGVpZ2h0O1xuICByZXN0b3JlIGNvbnRleHRcblxuXG5sZXQgc2V0X2xpbmVfd2lkdGggY29udGV4dCB3aWR0aCA9XG4gIGNvbnRleHQuaHRtbCMjLmxpbmVXaWR0aCA6PSB3aWR0aFxuXG5sZXQgZ2V0X2xpbmVfd2lkdGggY29udGV4dCA9XG4gIGNvbnRleHQuaHRtbCMjLmxpbmVXaWR0aFxuXG5sZXQgc2V0X2Rhc2ggY29udGV4dCA/KG9mcz0wLikgZGFzaGVzID1cbiAgbGV0IGh0bWwgPSBKcy5VbnNhZmUuY29lcmNlIGNvbnRleHQuaHRtbCBpblxuICBodG1sIyMubGluZURhc2hPZmZzZXQgOj0gb2ZzO1xuICBodG1sIyNzZXRMaW5lRGFzaCAoSnMuYXJyYXkgZGFzaGVzKVxuXG5sZXQgZ2V0X2Rhc2ggY29udGV4dCA9XG4gIGxldCBodG1sID0gSnMuVW5zYWZlLmNvZXJjZSBjb250ZXh0Lmh0bWwgaW5cbiAgKEpzLnRvX2FycmF5IChodG1sIyNnZXRMaW5lRGFzaCksIGh0bWwjIy5saW5lRGFzaE9mZnNldClcblxubGV0IHNldF9maWxsX3J1bGUgY29udGV4dCBmaWxsX3J1bGUgPVxuICBMb2NhbC5zZXRfZmlsbF9ydWxlIGNvbnRleHQubG9jYWwgfmZpbGxfcnVsZVxuXG5sZXQgZ2V0X2ZpbGxfcnVsZSBjb250ZXh0ID1cbiAgTG9jYWwuZmlsbF9ydWxlIGNvbnRleHQubG9jYWxcblxubGV0IHNldF9saW5lX2NhcCBjb250ZXh0IGNhcCA9XG4gIGxldCBjYXAgPSBtYXRjaCBjYXAgd2l0aFxuICAgIHwgQlVUVCAtPiBcImJ1dHRcIlxuICAgIHwgUk9VTkQgLT4gXCJyb3VuZFwiXG4gICAgfCBTUVVBUkUgLT4gXCJzcXVhcmVcIlxuICBpblxuICBjb250ZXh0Lmh0bWwjIy5saW5lQ2FwIDo9IEpzLnN0cmluZyBjYXBcblxubGV0IGdldF9saW5lX2NhcCBjb250ZXh0ID1cbiAgbWF0Y2ggSnMudG9fc3RyaW5nIGNvbnRleHQuaHRtbCMjLmxpbmVDYXAgd2l0aFxuICAgIHwgXCJyb3VuZFwiIC0+IFJPVU5EXG4gICAgfCBcInNxdWFyZVwiIC0+IFNRVUFSRVxuICAgIHwgXyAtPiBCVVRUXG5cbmxldCBzZXRfbGluZV9qb2luIGNvbnRleHQgam9pbiA9XG4gIGxldCBqb2luID0gbWF0Y2ggam9pbiB3aXRoXG4gICAgfCBKT0lOX01JVEVSIC0+ICBcIm1pdGVyXCJcbiAgICB8IEpPSU5fUk9VTkQgLT4gXCJyb3VuZFwiXG4gICAgfCBKT0lOX0JFVkVMIC0+IFwiYmV2ZWxcIlxuICBpblxuICBjb250ZXh0Lmh0bWwjIy5saW5lSm9pbiA6PSBKcy5zdHJpbmcgam9pblxuXG5sZXQgZ2V0X2xpbmVfam9pbiBjb250ZXh0ID1cbiAgbWF0Y2ggSnMudG9fc3RyaW5nIGNvbnRleHQuaHRtbCMjLmxpbmVKb2luIHdpdGhcbiAgICB8IFwicm91bmRcIiAtPiBKT0lOX1JPVU5EXG4gICAgfCBcImJldmVsXCIgLT4gSk9JTl9CRVZFTFxuICAgIHwgXyAtPiBKT0lOX01JVEVSXG5cbmxldCBzZXRfbWl0ZXJfbGltaXQgY29udGV4dCBsID1cbiAgY29udGV4dC5odG1sIyMubWl0ZXJMaW1pdCA6PSBsXG5cbmxldCBnZXRfbWl0ZXJfbGltaXQgY29udGV4dCA9XG4gIGNvbnRleHQuaHRtbCMjLm1pdGVyTGltaXRcblxubGV0IHNldF9vcGVyYXRvciBjb250ZXh0IG9wZXJhdG9yID1cbiAgbGV0IG9wZXJhdG9yID0gbWF0Y2ggb3BlcmF0b3Igd2l0aFxuICAgIHwgQ0xFQVIgLT4gZmFpbHdpdGggXCJVbnN1cHBvcnRlZCBvcGVyYXRvciBDTEVBUlwiXG4gICAgfCBTT1VSQ0UgLT4gZmFpbHdpdGggXCJVbnN1cHBvcnRlZCBvcGVyYXRvciBTT1VSQ0VcIlxuICAgIHwgT1ZFUiAtPiBcInNvdXJjZS1vdmVyXCJcbiAgICB8IEFUT1AgLT4gXCJzb3VyY2UtYXRvcFwiXG4gICAgfCBJTiAtPiBcInNvdXJjZS1pblwiXG4gICAgfCBPVVQgLT4gXCJzb3VyY2Utb3V0XCJcbiAgICB8IERFU1RfT1ZFUiAtPiBcImRlc3RpbmF0aW9uLW92ZXJcIlxuICAgIHwgREVTVF9BVE9QIC0+IFwiZGVzdGluYXRpb24tYXRvcFwiXG4gICAgfCBERVNUX0lOIC0+IFwiZGVzdGluYXRpb24taW5cIlxuICAgIHwgREVTVF9PVVQgLT4gXCJkZXN0aW5hdGlvbi1vdXRcIlxuICAgIHwgQUREIC0+IFwibGlnaHRlclwiXG4gICAgfCBYT1IgLT4gXCJ4b3JcIlxuICAgIHwgREVTVCAtPiBmYWlsd2l0aCBcIlVuc3VwcG9ydGVkIG9wZXJhdG9yIERFU1RcIlxuICAgIHwgU0FUVVJBVEUgLT4gZmFpbHdpdGggXCJVbnN1cHBvcnRlZCBvcGVyYXRvciBTQVRVUkFURVwiXG4gIGluXG4gIGNvbnRleHQuaHRtbCMjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA6PSBKcy5zdHJpbmcgb3BlcmF0b3JcblxubGV0IGdldF9vcGVyYXRvciBjb250ZXh0ID1cbiAgbWF0Y2ggSnMudG9fc3RyaW5nIGNvbnRleHQuaHRtbCMjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiB3aXRoXG4gICAgfCBcIm92ZXJcIiAtPiBPVkVSICgqIFNwZWNpYWwgY2FzZSBmb3Igbm9kZS1jYW52YXMgd2hpY2ggc2VlbXMgdG8gaGF2ZSBhIHdyb25nIGRlZmF1bHQgdmFsdWUgKilcbiAgICB8IFwiYWRkXCIgLT4gQUREICgqIFNwZWNpYWwgY2FzZSBmb3Igbm9kZS1jYW52YXMgKilcbiAgICB8IFwic291cmNlLW92ZXJcIiAtPiBPVkVSXG4gICAgfCBcInNvdXJjZS1hdG9wXCIgLT4gQVRPUFxuICAgIHwgXCJzb3VyY2UtaW5cIiAtPiBJTlxuICAgIHwgXCJzb3VyY2Utb3V0XCIgLT4gT1VUXG4gICAgfCBcImRlc3RpbmF0aW9uLW92ZXJcIiAtPiBERVNUX09WRVJcbiAgICB8IFwiZGVzdGluYXRpb24tYXRvcFwiIC0+IERFU1RfQVRPUFxuICAgIHwgXCJkZXN0aW5hdGlvbi1pblwiIC0+IERFU1RfSU5cbiAgICB8IFwiZGVzdGluYXRpb24tb3V0XCIgLT4gREVTVF9PVVRcbiAgICB8IFwibGlnaHRlclwiIC0+IEFERFxuICAgIHwgXCJ4b3JcIiAtPiBYT1JcbiAgICB8IG9wIC0+IGZhaWx3aXRoIChQcmludGYuc3ByaW50ZiBcIlVuZXhwZWN0ZWQgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uICVTXCIgb3ApXG5cblxubGV0IHNldF9zb3VyY2UgY29udGV4dCBwYXR0ZXJuID1cbiAgbGV0IGNvbnZlcnQgeCA9IHN0cmluZ19vZl9pbnQgKGludF9vZl9mbG9hdCAoMjU1LjAgKi4geCkpIGluXG4gIGxldCBjb252ZXJ0X3JnYmEgciBnIGIgYSA9IEpzLnN0cmluZyAoUHJpbnRmLnNwcmludGYgXCJyZ2JhKCVzLCAlcywgJXMsICVmKVwiIChjb252ZXJ0IHIpIChjb252ZXJ0IGcpIChjb252ZXJ0IGIpIGEpIGluXG4gIGxldCBzb3VyY2UgPSAhcGF0dGVybiBpblxuICBMb2NhbC5zZXRfc291cmNlIGNvbnRleHQubG9jYWwgfnNvdXJjZTtcbiAgbWF0Y2ggc291cmNlIHdpdGhcbiAgICB8IFBhdHRlcm4uUmdiYSAociwgZywgYiwgYSkgLT5cbiAgICAgIGxldCBjb2xvciA9IGNvbnZlcnRfcmdiYSByIGcgYiBhIGluXG4gICAgICBjb250ZXh0Lmh0bWwjIy5maWxsU3R5bGUgOj0gY29sb3I7XG4gICAgICBjb250ZXh0Lmh0bWwjIy5zdHJva2VTdHlsZSA6PSBjb2xvclxuICAgIHwgUGF0dGVybi5MaW5lYXJHcmFkaWVudCB7cG9pbnRzPSh4MCwgeTAsIHgxLCB5MSk7IHN0b3BfcG9pbnRzfSAtPlxuICAgICAgbGV0IGdyYWRpZW50ID0gY29udGV4dC5odG1sIyNjcmVhdGVMaW5lYXJHcmFkaWVudCB4MCB5MCB4MSB5MSBpblxuICAgICAgc3RvcF9wb2ludHNcbiAgICAgIHw+IFBhdHRlcm4uU3RvcFBvaW50TGlzdC50b19saXN0XG4gICAgICB8PiBMaXN0Lml0ZXIgfmY6KGZ1biAocG9zaXRpb24sIHIsIGcsIGIsIGEpIC0+XG4gICAgICAgIGdyYWRpZW50IyNhZGRDb2xvclN0b3AgcG9zaXRpb24gKGNvbnZlcnRfcmdiYSByIGcgYiBhKVxuICAgICAgKTtcbiAgICAgIGNvbnRleHQuaHRtbCMjLmZpbGxTdHlsZV9ncmFkaWVudCA6PSBncmFkaWVudDtcbiAgICAgIGNvbnRleHQuaHRtbCMjLnN0cm9rZVN0eWxlX2dyYWRpZW50IDo9IGdyYWRpZW50XG4gICAgfCBQYXR0ZXJuLlJhZGlhbEdyYWRpZW50IHtjaXJjbGVzPSh4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKTsgc3RvcF9wb2ludHN9IC0+XG4gICAgICBsZXQgZ3JhZGllbnQgPSBjb250ZXh0Lmh0bWwjI2NyZWF0ZVJhZGlhbEdyYWRpZW50IHgwIHkwIHIwIHgxIHkxIHIxIGluXG4gICAgICBzdG9wX3BvaW50c1xuICAgICAgfD4gUGF0dGVybi5TdG9wUG9pbnRMaXN0LnRvX2xpc3RcbiAgICAgIHw+IExpc3QuaXRlciB+ZjooZnVuIChwb3NpdGlvbiwgciwgZywgYiwgYSkgLT5cbiAgICAgICAgZ3JhZGllbnQjI2FkZENvbG9yU3RvcCBwb3NpdGlvbiAoY29udmVydF9yZ2JhIHIgZyBiIGEpXG4gICAgICApO1xuICAgICAgY29udGV4dC5odG1sIyMuZmlsbFN0eWxlX2dyYWRpZW50IDo9IGdyYWRpZW50O1xuICAgICAgY29udGV4dC5odG1sIyMuc3Ryb2tlU3R5bGVfZ3JhZGllbnQgOj0gZ3JhZGllbnRcbiAgICB8IFBhdHRlcm4uVHlwZU1pc21hdGNoIC0+XG4gICAgICAoKVxuXG5sZXQgZ2V0X3NvdXJjZSBjb250ZXh0ID1cbiAgcmVmIChMb2NhbC5zb3VyY2UgY29udGV4dC5sb2NhbClcblxubGV0IHNldF9zb3VyY2VfcmdiIGNvbnRleHQgciBnIGIgPVxuICBzZXRfc291cmNlIGNvbnRleHQgKFBhdHRlcm4uY3JlYXRlX3JnYiByIGcgYilcblxubGV0IHNldF9zb3VyY2VfcmdiYSBjb250ZXh0IHIgZyBiIGEgPVxuICBzZXRfc291cmNlIGNvbnRleHQgKFBhdHRlcm4uY3JlYXRlX3JnYmEgciBnIGIgYSlcblxuXG5sZXQgX3NldF9mb250IGNvbnRleHQgKHtzbGFudDsgd2VpZ2h0OyBzaXplOyBmYW1pbHl9IGFzIGZvbnQpID1cbiAgTG9jYWwuc2V0X2ZvbnQgY29udGV4dC5sb2NhbCB+Zm9udDtcbiAgbGV0IGZvbnRfc3R5bGUgPSBtYXRjaCBzbGFudCB3aXRoXG4gICAgfCBVcHJpZ2h0IC0+IFwibm9ybWFsXCJcbiAgICB8IEl0YWxpYyAtPiBcIml0YWxpY1wiXG4gICAgfCBPYmxpcXVlIC0+IFwib2JsaXF1ZVwiXG4gIGFuZCBmb250X3dlaWdodCA9IG1hdGNoIHdlaWdodCB3aXRoXG4gICAgfCBOb3JtYWwgLT4gXCJub3JtYWxcIlxuICAgIHwgQm9sZCAtPiBcImJvbGRcIlxuICBpblxuICBsZXQgZm9udCA9IFByaW50Zi5zcHJpbnRmIFwiJXMgJXMgJW5weCAlc1wiIGZvbnRfc3R5bGUgZm9udF93ZWlnaHQgKGludF9vZl9mbG9hdCBzaXplKSBmYW1pbHkgaW5cbiAgY29udGV4dC5odG1sIyMuZm9udCA6PSBKcy5zdHJpbmcgZm9udFxuXG5sZXQgc2VsZWN0X2ZvbnRfZmFjZSBjb250ZXh0ID8oc2xhbnQ9VXByaWdodCkgPyh3ZWlnaHQ9Tm9ybWFsKSBmYW1pbHkgPVxuICBfc2V0X2ZvbnQgY29udGV4dCB7KExvY2FsLmZvbnQgY29udGV4dC5sb2NhbCkgd2l0aCBzbGFudDsgd2VpZ2h0OyBmYW1pbHl9XG5cbmxldCBzZXRfZm9udF9zaXplIGNvbnRleHQgc2l6ZSA9XG4gIF9zZXRfZm9udCBjb250ZXh0IHsoTG9jYWwuZm9udCBjb250ZXh0LmxvY2FsKSB3aXRoIHNpemV9XG5cbmxldCBzaG93X3RleHQgY29udGV4dCBzID1cbiAgbGV0ICh4LCB5KSA9IFBhdGguZ2V0X2N1cnJlbnRfcG9pbnQgY29udGV4dFxuICBhbmQgdyA9IChjb250ZXh0Lmh0bWwjI21lYXN1cmVUZXh0IChKcy5zdHJpbmcgcykpIyMud2lkdGggaW5cbiAgTG9jYWwuc2V0X2N1cnJlbnRfcG9pbnQgY29udGV4dC5sb2NhbCAoeCArLiB3LCB5KTtcbiAgY29udGV4dC5odG1sIyNmaWxsVGV4dCAoSnMuc3RyaW5nIHMpIHggeVxuXG5sZXQgZm9udF9leHRlbnRzIGNvbnRleHQgPVxuICBsZXQge3NpemU7IF99ID0gKExvY2FsLmZvbnQgY29udGV4dC5sb2NhbCkgaW5cbiAge1xuICAgIGFzY2VudCA9IHNpemU7XG4gICAgZGVzY2VudCA9IHNpemUgLy4gNC47XG4gICAgYmFzZWxpbmUgPSAwLjtcbiAgICBtYXhfeF9hZHZhbmNlID0gMi4gKi4gc2l6ZTtcbiAgICBtYXhfeV9hZHZhbmNlID0gMC47XG4gIH1cblxubGV0IHRleHRfZXh0ZW50cyBjb250ZXh0IHMgPVxuICBsZXQge3NpemU7IF99ID0gKExvY2FsLmZvbnQgY29udGV4dC5sb2NhbClcbiAgYW5kIHcgPSAoY29udGV4dC5odG1sIyNtZWFzdXJlVGV4dCAoSnMuc3RyaW5nIHMpKSMjLndpZHRoIGluXG4gIHtcbiAgICB4X2JlYXJpbmcgPSAwLjtcbiAgICB5X2JlYXJpbmcgPSAwLjtcbiAgICB3aWR0aCA9IHc7XG4gICAgaGVpZ2h0ID0gc2l6ZTtcbiAgICB4X2FkdmFuY2UgPSB3O1xuICAgIHlfYWR2YW5jZSA9IDAuO1xuICB9XG5cbmxldCBjcmVhdGUgY2FudmFzID1cbiAgbGV0IGh0bWwgPSBjYW52YXMjI2dldENvbnRleHQgRG9tX2h0bWwuXzJkX1xuICBhbmQgbG9jYWwgPSBMb2NhbC5jcmVhdGUgKCkgaW5cbiAgbGV0IGNvbnRleHQgPSB7XG4gICAgaHRtbDtcbiAgICBsb2NhbDtcbiAgfSBpblxuICBzZXRfbGluZV93aWR0aCBjb250ZXh0IDIuMDtcbiAgY29udGV4dFxuIiwiKCogQ29weXJpZ2h0IDIwMTctMjAxOCBWaW5jZW50IEphY3F1ZXMgPHZpbmNlbnRAdmluY2VudC1qYWNxdWVzLm5ldD4gKilcblxub3BlbiBTdGRMYWJlbHNcblxudHlwZSBzdGF0dXMgPVxuICB8IElOVkFMSURfUkVTVE9SRVxuICB8IElOVkFMSURfUE9QX0dST1VQXG4gIHwgTk9fQ1VSUkVOVF9QT0lOVFxuICB8IElOVkFMSURfTUFUUklYXG4gIHwgSU5WQUxJRF9TVEFUVVNcbiAgfCBOVUxMX1BPSU5URVJcbiAgfCBJTlZBTElEX1NUUklOR1xuICB8IElOVkFMSURfUEFUSF9EQVRBXG4gIHwgUkVBRF9FUlJPUlxuICB8IFdSSVRFX0VSUk9SXG4gIHwgU1VSRkFDRV9GSU5JU0hFRFxuICB8IFNVUkZBQ0VfVFlQRV9NSVNNQVRDSFxuICB8IFBBVFRFUk5fVFlQRV9NSVNNQVRDSFxuICB8IElOVkFMSURfQ09OVEVOVFxuICB8IElOVkFMSURfRk9STUFUXG4gIHwgSU5WQUxJRF9WSVNVQUxcbiAgfCBGSUxFX05PVF9GT1VORFxuICB8IElOVkFMSURfREFTSFxuICB8IElOVkFMSURfRFNDX0NPTU1FTlRcbiAgfCBJTlZBTElEX0lOREVYXG4gIHwgQ0xJUF9OT1RfUkVQUkVTRU5UQUJMRVxuICB8IFRFTVBfRklMRV9FUlJPUlxuICB8IElOVkFMSURfU1RSSURFXG4gIHwgRk9OVF9UWVBFX01JU01BVENIXG4gIHwgVVNFUl9GT05UX0lNTVVUQUJMRVxuICB8IFVTRVJfRk9OVF9FUlJPUlxuICB8IE5FR0FUSVZFX0NPVU5UXG4gIHwgSU5WQUxJRF9DTFVTVEVSU1xuICB8IElOVkFMSURfU0xBTlRcbiAgfCBJTlZBTElEX1dFSUdIVFxuICB8IElOVkFMSURfU0laRVxuICB8IFVTRVJfRk9OVF9OT1RfSU1QTEVNRU5URURcbiAgfCBERVZJQ0VfVFlQRV9NSVNNQVRDSFxuICB8IERFVklDRV9FUlJPUlxuICB8IElOVkFMSURfTUVTSF9DT05TVFJVQ1RJT05cbiAgfCBERVZJQ0VfRklOSVNIRURcbiAgfCBKQklHMl9HTE9CQUxfTUlTU0lOR1xuXG5leGNlcHRpb24gRXJyb3Igb2Ygc3RhdHVzXG5cbmxldCBzdGF0dXNfdG9fc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBJTlZBTElEX1JFU1RPUkUgLT4gXCJjYWlyb19yZXN0b3JlKCkgd2l0aG91dCBtYXRjaGluZyBjYWlyb19zYXZlKClcIlxuICB8IElOVkFMSURfUE9QX0dST1VQIC0+IFwibm8gc2F2ZWQgZ3JvdXAgdG8gcG9wLCBpLmUuIGNhaXJvX3BvcF9ncm91cCgpIHdpdGhvdXQgbWF0Y2hpbmcgY2Fpcm9fcHVzaF9ncm91cCgpXCJcbiAgfCBOT19DVVJSRU5UX1BPSU5UIC0+IFwibm8gY3VycmVudCBwb2ludCBkZWZpbmVkXCJcbiAgfCBJTlZBTElEX01BVFJJWCAtPiBcImludmFsaWQgbWF0cml4IChub3QgaW52ZXJ0aWJsZSlcIlxuICB8IElOVkFMSURfU1RBVFVTIC0+IFwiaW52YWxpZCB2YWx1ZSBmb3IgYW4gaW5wdXQgY2Fpcm9fc3RhdHVzX3RcIlxuICB8IE5VTExfUE9JTlRFUiAtPiBcIk5VTEwgcG9pbnRlclwiXG4gIHwgSU5WQUxJRF9TVFJJTkcgLT4gXCJpbnB1dCBzdHJpbmcgbm90IHZhbGlkIFVURi04XCJcbiAgfCBJTlZBTElEX1BBVEhfREFUQSAtPiBcImlucHV0IHBhdGggZGF0YSBub3QgdmFsaWRcIlxuICB8IFJFQURfRVJST1IgLT4gXCJlcnJvciB3aGlsZSByZWFkaW5nIGZyb20gaW5wdXQgc3RyZWFtXCJcbiAgfCBXUklURV9FUlJPUiAtPiBcImVycm9yIHdoaWxlIHdyaXRpbmcgdG8gb3V0cHV0IHN0cmVhbVwiXG4gIHwgU1VSRkFDRV9GSU5JU0hFRCAtPiBcInRoZSB0YXJnZXQgc3VyZmFjZSBoYXMgYmVlbiBmaW5pc2hlZFwiXG4gIHwgU1VSRkFDRV9UWVBFX01JU01BVENIIC0+IFwidGhlIHN1cmZhY2UgdHlwZSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoZSBvcGVyYXRpb25cIlxuICB8IFBBVFRFUk5fVFlQRV9NSVNNQVRDSCAtPiBcInRoZSBwYXR0ZXJuIHR5cGUgaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGUgb3BlcmF0aW9uXCJcbiAgfCBJTlZBTElEX0NPTlRFTlQgLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBhbiBpbnB1dCBjYWlyb19jb250ZW50X3RcIlxuICB8IElOVkFMSURfRk9STUFUIC0+IFwiaW52YWxpZCB2YWx1ZSBmb3IgYW4gaW5wdXQgY2Fpcm9fZm9ybWF0X3RcIlxuICB8IElOVkFMSURfVklTVUFMIC0+IFwiaW52YWxpZCB2YWx1ZSBmb3IgYW4gaW5wdXQgVmlzdWFsKlwiXG4gIHwgRklMRV9OT1RfRk9VTkQgLT4gXCJmaWxlIG5vdCBmb3VuZFwiXG4gIHwgSU5WQUxJRF9EQVNIIC0+IFwiaW52YWxpZCB2YWx1ZSBmb3IgYSBkYXNoIHNldHRpbmdcIlxuICB8IElOVkFMSURfRFNDX0NPTU1FTlQgLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBhIERTQyBjb21tZW50XCJcbiAgfCBJTlZBTElEX0lOREVYIC0+IFwiaW52YWxpZCBpbmRleCBwYXNzZWQgdG8gZ2V0dGVyXCJcbiAgfCBDTElQX05PVF9SRVBSRVNFTlRBQkxFIC0+IFwiY2xpcCByZWdpb24gbm90IHJlcHJlc2VudGFibGUgaW4gZGVzaXJlZCBmb3JtYXRcIlxuICB8IFRFTVBfRklMRV9FUlJPUiAtPiBcImVycm9yIGNyZWF0aW5nIG9yIHdyaXRpbmcgdG8gYSB0ZW1wb3JhcnkgZmlsZVwiXG4gIHwgSU5WQUxJRF9TVFJJREUgLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBzdHJpZGVcIlxuICB8IEZPTlRfVFlQRV9NSVNNQVRDSCAtPiBcInRoZSBmb250IHR5cGUgaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGUgb3BlcmF0aW9uXCJcbiAgfCBVU0VSX0ZPTlRfSU1NVVRBQkxFIC0+IFwidGhlIHVzZXItZm9udCBpcyBpbW11dGFibGVcIlxuICB8IFVTRVJfRk9OVF9FUlJPUiAtPiBcImVycm9yIG9jY3VycmVkIGluIGEgdXNlci1mb250IGNhbGxiYWNrIGZ1bmN0aW9uXCJcbiAgfCBORUdBVElWRV9DT1VOVCAtPiBcIm5lZ2F0aXZlIG51bWJlciB1c2VkIHdoZXJlIGl0IGlzIG5vdCBhbGxvd2VkXCJcbiAgfCBJTlZBTElEX0NMVVNURVJTIC0+IFwiaW5wdXQgY2x1c3RlcnMgZG8gbm90IHJlcHJlc2VudCB0aGUgYWNjb21wYW55aW5nIHRleHQgYW5kIGdseXBoIGFycmF5c1wiXG4gIHwgSU5WQUxJRF9TTEFOVCAtPiBcImludmFsaWQgdmFsdWUgZm9yIGFuIGlucHV0IGNhaXJvX2ZvbnRfc2xhbnRfdFwiXG4gIHwgSU5WQUxJRF9XRUlHSFQgLT4gXCJpbnZhbGlkIHZhbHVlIGZvciBhbiBpbnB1dCBjYWlyb19mb250X3dlaWdodF90XCJcbiAgfCBJTlZBTElEX1NJWkUgLT4gXCJpbnZhbGlkIHZhbHVlICh0eXBpY2FsbHkgdG9vIGJpZykgZm9yIHRoZSBzaXplIG9mIHRoZSBpbnB1dCAoc3VyZmFjZSwgcGF0dGVybiwgZXRjLilcIlxuICB8IFVTRVJfRk9OVF9OT1RfSU1QTEVNRU5URUQgLT4gXCJ1c2VyLWZvbnQgbWV0aG9kIG5vdCBpbXBsZW1lbnRlZFwiXG4gIHwgREVWSUNFX1RZUEVfTUlTTUFUQ0ggLT4gXCJ0aGUgZGV2aWNlIHR5cGUgaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGUgb3BlcmF0aW9uXCJcbiAgfCBERVZJQ0VfRVJST1IgLT4gXCJhbiBvcGVyYXRpb24gdG8gdGhlIGRldmljZSBjYXVzZWQgYW4gdW5zcGVjaWZpZWQgZXJyb3JcIlxuICB8IElOVkFMSURfTUVTSF9DT05TVFJVQ1RJT04gLT4gXCJpbnZhbGlkIG9wZXJhdGlvbiBkdXJpbmcgbWVzaCBwYXR0ZXJuIGNvbnN0cnVjdGlvblwiXG4gIHwgREVWSUNFX0ZJTklTSEVEIC0+IFwidGhlIHRhcmdldCBkZXZpY2UgaGFzIGJlZW4gZmluaXNoZWRcIlxuICB8IEpCSUcyX0dMT0JBTF9NSVNTSU5HIC0+IFwiQ0FJUk9fTUlNRV9UWVBFX0pCSUcyX0dMT0JBTF9JRCB1c2VkIGJ1dCBubyBDQUlST19NSU1FX1RZUEVfSkJJRzJfR0xPQkFMIGRhdGEgcHJvdmlkZWRcIlxuXG5sZXQgc3RhdHVzX3JlcHIgPSBmdW5jdGlvblxuICB8IElOVkFMSURfUkVTVE9SRSAtPiBcIklOVkFMSURfUkVTVE9SRVwiXG4gIHwgTk9fQ1VSUkVOVF9QT0lOVCAtPiBcIk5PX0NVUlJFTlRfUE9JTlRcIlxuICAoKkJJU0VDVC1JR05PUkUtQkVHSU4qKSAoKiBJIGRvbid0IGtub3cgaG93IHRvIG1ha2UgQ2Fpcm8gcmFpc2UgdGhlc2UgZXhjZXB0aW9ucyAqKVxuICB8IElOVkFMSURfUE9QX0dST1VQIC0+IFwiSU5WQUxJRF9QT1BfR1JPVVBcIlxuICB8IElOVkFMSURfTUFUUklYIC0+IFwiSU5WQUxJRF9NQVRSSVhcIlxuICB8IElOVkFMSURfU1RBVFVTIC0+IFwiSU5WQUxJRF9TVEFUVVNcIlxuICB8IE5VTExfUE9JTlRFUiAtPiBcIk5VTExfUE9JTlRFUlwiXG4gIHwgSU5WQUxJRF9TVFJJTkcgLT4gXCJJTlZBTElEX1NUUklOR1wiXG4gIHwgSU5WQUxJRF9QQVRIX0RBVEEgLT4gXCJJTlZBTElEX1BBVEhfREFUQVwiXG4gIHwgUkVBRF9FUlJPUiAtPiBcIlJFQURfRVJST1JcIlxuICB8IFdSSVRFX0VSUk9SIC0+IFwiV1JJVEVfRVJST1JcIlxuICB8IFNVUkZBQ0VfRklOSVNIRUQgLT4gXCJTVVJGQUNFX0ZJTklTSEVEXCJcbiAgfCBTVVJGQUNFX1RZUEVfTUlTTUFUQ0ggLT4gXCJTVVJGQUNFX1RZUEVfTUlTTUFUQ0hcIlxuICB8IFBBVFRFUk5fVFlQRV9NSVNNQVRDSCAtPiBcIlBBVFRFUk5fVFlQRV9NSVNNQVRDSFwiXG4gIHwgSU5WQUxJRF9DT05URU5UIC0+IFwiSU5WQUxJRF9DT05URU5UXCJcbiAgfCBJTlZBTElEX0ZPUk1BVCAtPiBcIklOVkFMSURfRk9STUFUXCJcbiAgfCBJTlZBTElEX1ZJU1VBTCAtPiBcIklOVkFMSURfVklTVUFMXCJcbiAgfCBGSUxFX05PVF9GT1VORCAtPiBcIkZJTEVfTk9UX0ZPVU5EXCJcbiAgfCBJTlZBTElEX0RBU0ggLT4gXCJJTlZBTElEX0RBU0hcIlxuICB8IElOVkFMSURfRFNDX0NPTU1FTlQgLT4gXCJJTlZBTElEX0RTQ19DT01NRU5UXCJcbiAgfCBJTlZBTElEX0lOREVYIC0+IFwiSU5WQUxJRF9JTkRFWFwiXG4gIHwgQ0xJUF9OT1RfUkVQUkVTRU5UQUJMRSAtPiBcIkNMSVBfTk9UX1JFUFJFU0VOVEFCTEVcIlxuICB8IFRFTVBfRklMRV9FUlJPUiAtPiBcIlRFTVBfRklMRV9FUlJPUlwiXG4gIHwgSU5WQUxJRF9TVFJJREUgLT4gXCJJTlZBTElEX1NUUklERVwiXG4gIHwgRk9OVF9UWVBFX01JU01BVENIIC0+IFwiRk9OVF9UWVBFX01JU01BVENIXCJcbiAgfCBVU0VSX0ZPTlRfSU1NVVRBQkxFIC0+IFwiVVNFUl9GT05UX0lNTVVUQUJMRVwiXG4gIHwgVVNFUl9GT05UX0VSUk9SIC0+IFwiVVNFUl9GT05UX0VSUk9SXCJcbiAgfCBORUdBVElWRV9DT1VOVCAtPiBcIk5FR0FUSVZFX0NPVU5UXCJcbiAgfCBJTlZBTElEX0NMVVNURVJTIC0+IFwiSU5WQUxJRF9DTFVTVEVSU1wiXG4gIHwgSU5WQUxJRF9TTEFOVCAtPiBcIklOVkFMSURfU0xBTlRcIlxuICB8IElOVkFMSURfV0VJR0hUIC0+IFwiSU5WQUxJRF9XRUlHSFRcIlxuICB8IElOVkFMSURfU0laRSAtPiBcIklOVkFMSURfU0laRVwiXG4gIHwgVVNFUl9GT05UX05PVF9JTVBMRU1FTlRFRCAtPiBcIlVTRVJfRk9OVF9OT1RfSU1QTEVNRU5URURcIlxuICB8IERFVklDRV9UWVBFX01JU01BVENIIC0+IFwiREVWSUNFX1RZUEVfTUlTTUFUQ0hcIlxuICB8IERFVklDRV9FUlJPUiAtPiBcIkRFVklDRV9FUlJPUlwiXG4gIHwgSU5WQUxJRF9NRVNIX0NPTlNUUlVDVElPTiAtPiBcIklOVkFMSURfTUVTSF9DT05TVFJVQ1RJT05cIlxuICB8IERFVklDRV9GSU5JU0hFRCAtPiBcIkRFVklDRV9GSU5JU0hFRFwiXG4gIHwgSkJJRzJfR0xPQkFMX01JU1NJTkcgLT4gXCJKQklHMl9HTE9CQUxfTUlTU0lOR1wiXG4gICgqQklTRUNULUlHTk9SRS1FTkQqKVxuXG5leGNlcHRpb24gVW5hdmFpbGFibGVcblxudHlwZSBtYXRyaXggPSB7XG4gIG11dGFibGUgeHg6IGZsb2F0O1xuICBtdXRhYmxlIHl4OiBmbG9hdDtcbiAgbXV0YWJsZSB4eTogZmxvYXQ7XG4gIG11dGFibGUgeXk6IGZsb2F0O1xuICBtdXRhYmxlIHgwOiBmbG9hdDtcbiAgbXV0YWJsZSB5MDogZmxvYXQ7XG59XG5cbm1vZHVsZSBNYXRyaXggPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gbWF0cml4XG5cbiAgKCpcbiAgICAyIGJ5IDIgbWF0cml4IHdpdGggKHgwLCB5MCkgb2Zmc2V0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIGZvbGxvd2luZyAzIGJ5IDMgbWF0cml4OlxuICAgIC8geHggeHkgeDAgXFwgICAvIHggXFwgICAvIHh4KnggKyB4eSp5ICsgeDAgXFxcbiAgICB8IHl4IHl5IHkwIHwgKiB8IHkgfCA9IHwgeXgqeCArIHl5KnkgKyB5MCB8XG4gICAgXFwgIDAgIDAgIDEgLyAgIFxcIDEgLyAgIFxcICAgICAgICAgICAgICAgIDEgL1xuICAqKVxuXG4gIGxldCBpbml0X2lkZW50aXR5ICgpID1cbiAgICB7eHg9MS47IHh5PTAuOyB5eD0wLjsgeXk9MS47IHgwPTAuOyB5MD0wLn1cblxuICBsZXQgaW5pdF90cmFuc2xhdGUgeCB5ID1cbiAgICB7eHg9MS47IHh5PTAuOyB5eD0wLjsgeXk9MS47IHgwPXg7IHkwPXl9XG5cbiAgbGV0IGluaXRfc2NhbGUgeCB5ID1cbiAgICB7eHg9eDsgeHk9MC47IHl4PTAuOyB5eT15OyB4MD0wLjsgeTA9MC59XG5cbiAgbGV0IGluaXRfcm90YXRlIGFuZ2xlID1cbiAgICB7XG4gICAgICB4eCA9IGNvcyBhbmdsZTtcbiAgICAgIHh5ID0gLS5zaW4gYW5nbGU7XG4gICAgICB5eCA9IHNpbiBhbmdsZTtcbiAgICAgIHl5ID0gY29zIGFuZ2xlO1xuICAgICAgeDAgPSAwLjtcbiAgICAgIHkwID0gMC47XG4gICAgfVxuXG4gIGxldCBpbml0X2ludmVyc2Uge3h4OyB4eTsgeXg7IHl5OyB4MDsgeTB9ID1cbiAgICBsZXQgZCA9IHh4ICouIHl5IC0uIHh5ICouIHl4IGluXG4gICAgaWYgZCA9IDAuIHRoZW4gcmFpc2UgKEVycm9yIElOVkFMSURfTUFUUklYKTtcbiAgICBsZXQgeHggPSB5eSAvLiBkXG4gICAgYW5kIHh5ID0gLS4geHkgLy4gZFxuICAgIGFuZCB5eCA9IC0uIHl4IC8uIGRcbiAgICBhbmQgeXkgPSB4eCAvLiBkXG4gICAgYW5kIHgwID0gKHh5ICouIHkwIC0uIHl5ICouIHgwKSAvLiBkXG4gICAgYW5kIHkwID0gKHl4ICouIHgwIC0uIHh4ICouIHkwKSAvLiBkIGluXG4gICAge3h4OyB4eTsgeXg7IHl5OyB4MDsgeTB9XG5cbiAgbGV0IG11bHRpcGx5IHt4eDsgeHk7IHl4OyB5eTsgeDA7IHkwfSB7eHg9eHgnOyB4eT14eSc7IHl4PXl4JzsgeXk9eXknOyB4MD14MCc7IHkwPXkwJ30gPVxuICAgIGxldCB4eCA9IHh4ICouIHh4JyArLiB4eSAqLiB5eCdcbiAgICBhbmQgeHkgPSB4eCAqLiB4eScgKy4geHkgKi4geXknXG4gICAgYW5kIHl4ID0geXggKi4geHgnICsuIHl5ICouIHl4J1xuICAgIGFuZCB5eSA9IHl4ICouIHh5JyArLiB5eSAqLiB5eSdcbiAgICBhbmQgeDAgPSB4eCAqLiB4MCcgKy4geHkgKi4geTAnICsuIHgwXG4gICAgYW5kIHkwID0geXggKi4geDAnICsuIHl5ICouIHkwJyArLiB5MCBpblxuICAgIHt4eDsgeHk7IHl4OyB5eTsgeDA7IHkwfVxuXG4gIGxldCB0cmFuc2Zvcm1fcG9pbnQge3h4OyB4eTsgeXg7IHl5OyB4MDsgeTB9IHggeSA9XG4gICAgKHh4ICouIHggKy4geHkgKi4geSArLiB4MCwgeXggKi4geCArLiB5eSAqLiB5ICsuIHkwKVxuXG4gIGxldCB0cmFuc2Zvcm1fZGlzdGFuY2Uge3h4OyB4eTsgeXg7IHl5OyB4MD1fOyB5MD1ffSB+ZHggfmR5ID1cbiAgICAoeHggKi4gZHggKy4geHkgKi4gZHksIHl4ICouIGR4ICsuIHl5ICouIGR5KVxuXG4gIGxldCBzZXQgbSB7eHg7IHh5OyB5eDsgeXk7IHgwOyB5MH0gPVxuICAgIG0ueHggPC0geHg7XG4gICAgbS54eSA8LSB4eTtcbiAgICBtLnl4IDwtIHl4O1xuICAgIG0ueXkgPC0geXk7XG4gICAgbS54MCA8LSB4MDtcbiAgICBtLnkwIDwtIHkwXG5cbiAgbGV0IHNjYWxlIG0geCB5ID1cbiAgICBzZXQgbSAobXVsdGlwbHkgbSAoaW5pdF9zY2FsZSB4IHkpKVxuXG4gIGxldCB0cmFuc2xhdGUgbSB4IHkgPVxuICAgIHNldCBtIChtdWx0aXBseSBtIChpbml0X3RyYW5zbGF0ZSB4IHkpKVxuXG4gIGxldCByb3RhdGUgbSBhbmdsZSA9XG4gICAgc2V0IG0gKG11bHRpcGx5IG0gKGluaXRfcm90YXRlIGFuZ2xlKSlcblxuICBsZXQgaW52ZXJ0IG0gPVxuICAgIHNldCBtIChpbml0X2ludmVyc2UgbSlcbmVuZFxuXG50eXBlIHNsYW50ID1cbiAgfCBVcHJpZ2h0XG4gIHwgSXRhbGljXG4gIHwgT2JsaXF1ZVxuXG50eXBlIHdlaWdodCA9XG4gIHwgTm9ybWFsXG4gIHwgQm9sZFxuXG50eXBlIGZvbnQgPSB7XG4gIHNsYW50OiBzbGFudDtcbiAgd2VpZ2h0OiB3ZWlnaHQ7XG4gIHNpemU6IGZsb2F0O1xuICBmYW1pbHk6IHN0cmluZztcbn1cblxubW9kdWxlIFBhdHRlcm4gPSBzdHJ1Y3RcbiAgKCogV2Ugc3RvcmUgdHVwbGVzIChpbnN0ZWFkIG9mIG1vcmUgZXhwbGljaXQgcmVjb3JkIHR5cGVzKSBiZWNhdXNlIHRoZSBwdWJsaWMgaW50ZXJmYWNlIHVzZXMgdHVwbGVzXG4gIChnZXRfY29sb3Jfc3RvcF9yZ2JhLCBnZXRfcmdiYSwgZ2V0X2xpbmVhcl9wb2ludHMsIGdldF9yYWRpYWxfY2lyY2xlcykgKilcblxuICB0eXBlIHN0b3BfcG9pbnQgPSBmbG9hdCAqIGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ICgqIChwb3NpdGlvbiwgciwgZywgYiwgYSkgKilcblxuICBtb2R1bGUgU3RvcFBvaW50TGlzdDogc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVtcHR5OiB0XG4gICAgdmFsIGFkZDogdCAtPiBzdG9wX3BvaW50IC0+IHRcbiAgICB2YWwgc2l6ZTogdCAtPiBpbnRcbiAgICB2YWwgZ2V0OiB0IC0+IGk6aW50IC0+IHN0b3BfcG9pbnRcbiAgICB2YWwgdG9fbGlzdDogdCAtPiBzdG9wX3BvaW50IGxpc3RcbiAgZW5kID0gc3RydWN0XG4gICAgbW9kdWxlIEVsZW1lbnQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IHtcbiAgICAgICAgYWRkZWQ6IGludDtcbiAgICAgICAgc3RvcF9wb2ludDogc3RvcF9wb2ludDtcbiAgICAgIH1cblxuICAgICAgbGV0IGNvbXBhcmUge3N0b3BfcG9pbnQ9KHBvc2l0aW9uX2EsIF8sIF8sIF8sIF8pOyBhZGRlZD1hZGRlZF9hOyBffSB7c3RvcF9wb2ludD0ocG9zaXRpb25fYiwgXywgXywgXywgXyk7IGFkZGVkPWFkZGVkX2I7IF99ID1cbiAgICAgICAgbWF0Y2ggY29tcGFyZSBwb3NpdGlvbl9hIHBvc2l0aW9uX2Igd2l0aFxuICAgICAgICAgIHwgMCAtPiBjb21wYXJlIGFkZGVkX2EgYWRkZWRfYlxuICAgICAgICAgIHwgbiAtPiBuXG4gICAgZW5kXG5cbiAgICB0eXBlIHQgPSBFbGVtZW50LnQgbGlzdFxuXG4gICAgbGV0IGVtcHR5ID0gW11cblxuICAgIGxldCBzaXplID0gTGlzdC5sZW5ndGhcblxuICAgIGxldCBhZGQgeHMgc3RvcF9wb2ludCA9XG4gICAgICBsZXQgZWxlbWVudCA9IHtFbGVtZW50LnN0b3BfcG9pbnQ7IGFkZGVkPUxpc3QubGVuZ3RoIHhzfSBpblxuICAgICAgbGV0IHJlYyBhdXggPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+IFtlbGVtZW50XVxuICAgICAgICB8IHg6OnhzIGFzIHh4cyAtPiBtYXRjaCBFbGVtZW50LmNvbXBhcmUgZWxlbWVudCB4IHdpdGhcbiAgICAgICAgICB8IC0xIC0+IGVsZW1lbnQ6Onh4c1xuICAgICAgICAgIHwgXyAtPiB4OjooYXV4IHhzKVxuICAgICAgaW4gYXV4IHhzXG5cbiAgICBsZXQgdG9fbGlzdCB4cyA9XG4gICAgICBMaXN0Lm1hcCB4cyB+ZjooZnVuIHtFbGVtZW50LnN0b3BfcG9pbnQ7IF99IC0+IHN0b3BfcG9pbnQpXG5cbiAgICBsZXQgZ2V0IHhzIH5pID1cbiAgICAgIGxldCB7RWxlbWVudC5zdG9wX3BvaW50OyBffSA9IExpc3QubnRoIHhzIGkgaW5cbiAgICAgIHN0b3BfcG9pbnRcbiAgZW5kXG5cbiAgKCogVGhpcyBpcyBqdXN0IHRvIGNvdmVyIFN0b3BQb2ludExpc3QudG9fbGlzdCwgd2hpY2ggaXMgdXNlZCBvbmx5IGluIEpzT2ZPQ2Fpcm8sIHdob3NlIHRlc3QgY292ZXJhZ2UgaXNuJ3QgbWVhc3VyZWQuICopXG4gIGxldCBfID0gU3RvcFBvaW50TGlzdC4oYWRkIGVtcHR5ICgwLiwgMC4sIDAuLCAwLiwgMC4pIHw+IHRvX2xpc3QpXG5cbiAgKCogV2hlbiB3ZSBkcm9wIHN1cHBvcnQgb2YgT0NhbWwgNC4wMiwgd2UgY2FuIHVzZSBbaW5saW5lIHJlY29yZHNdKGh0dHBzOi8vY2FtbC5pbnJpYS5mci9wdWIvZG9jcy9tYW51YWwtb2NhbWwtNC4wNi9leHRuLmh0bWwjcyUzQWlubGluZS1yZWNvcmRzKSAqKVxuICB0eXBlIGxpbmVhcl9ncmFkaWVudCA9IHtcbiAgICBwb2ludHM6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0OyAoKiAoeDAsIHkwLCB4MSwgeTEpICopXG4gICAgc3RvcF9wb2ludHM6IFN0b3BQb2ludExpc3QudDtcbiAgfVxuXG4gIHR5cGUgcmFkaWFsX2dyYWRpZW50ID0ge1xuICAgIGNpcmNsZXM6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgKiBmbG9hdDsgKCogKHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpICopXG4gICAgc3RvcF9wb2ludHM6IFN0b3BQb2ludExpc3QudDtcbiAgfVxuXG4gIHR5cGUgc291cmNlID1cbiAgICB8IFJnYmEgb2YgKGZsb2F0ICogZmxvYXQgKiBmbG9hdCAqIGZsb2F0KSAoKiAociwgZywgYiwgYSkgKilcbiAgICB8IExpbmVhckdyYWRpZW50IG9mIGxpbmVhcl9ncmFkaWVudFxuICAgIHwgUmFkaWFsR3JhZGllbnQgb2YgcmFkaWFsX2dyYWRpZW50XG4gICAgfCBUeXBlTWlzbWF0Y2hcblxuICB0eXBlICdhIHQgPSBzb3VyY2UgcmVmIGNvbnN0cmFpbnQgJ2EgPSBbPGBTb2xpZCB8IGBTdXJmYWNlIHwgYEdyYWRpZW50IHwgYExpbmVhciB8IGBSYWRpYWxdXG5cbiAgdHlwZSBhbnkgPSBbYFNvbGlkIHwgYFN1cmZhY2UgfCBgR3JhZGllbnQgfCBgTGluZWFyIHwgYFJhZGlhbF0gdFxuXG4gIGxldCBjcmVhdGVfcmdiYSByIGcgYiBhID1cbiAgICByZWYgKFJnYmEgKHIsIGcsIGIsIGEpKVxuXG4gIGxldCBjcmVhdGVfcmdiIHIgZyBiID1cbiAgICBjcmVhdGVfcmdiYSByIGcgYiAxLlxuXG4gIGxldCBnZXRfcmdiYSBwYXR0ZXJuID1cbiAgICBtYXRjaCAhcGF0dGVybiB3aXRoXG4gICAgICB8IFJnYmEgY29sb3IgLT4gY29sb3JcbiAgICAgIHwgTGluZWFyR3JhZGllbnQgX1xuICAgICAgfCBSYWRpYWxHcmFkaWVudCBfXG4gICAgICB8IFR5cGVNaXNtYXRjaCAtPiByYWlzZSAoRXJyb3IgUEFUVEVSTl9UWVBFX01JU01BVENIKVxuXG4gIGxldCBjcmVhdGVfbGluZWFyIH54MCB+eTAgfngxIH55MSA9XG4gICAgcmVmIChMaW5lYXJHcmFkaWVudCB7cG9pbnRzPSh4MCwgeTAsIHgxLCB5MSk7IHN0b3BfcG9pbnRzPVN0b3BQb2ludExpc3QuZW1wdHl9KVxuXG4gIGxldCBnZXRfbGluZWFyX3BvaW50cyBwYXR0ZXJuID1cbiAgICBtYXRjaCAhcGF0dGVybiB3aXRoXG4gICAgICB8IExpbmVhckdyYWRpZW50IHtwb2ludHM7IF99IC0+IHBvaW50c1xuICAgICAgfCBSZ2JhIF9cbiAgICAgIHwgUmFkaWFsR3JhZGllbnQgX1xuICAgICAgfCBUeXBlTWlzbWF0Y2ggLT4gcmFpc2UgKEVycm9yIFBBVFRFUk5fVFlQRV9NSVNNQVRDSClcblxuICBsZXQgY3JlYXRlX3JhZGlhbCB+eDAgfnkwIH5yMCB+eDEgfnkxIH5yMSA9XG4gICAgcmVmIChSYWRpYWxHcmFkaWVudCB7Y2lyY2xlcz0oeDAsIHkwLCByMCwgeDEsIHkxLCByMSk7IHN0b3BfcG9pbnRzPVN0b3BQb2ludExpc3QuZW1wdHl9KVxuXG4gIGxldCBnZXRfcmFkaWFsX2NpcmNsZXMgcGF0dGVybiA9XG4gICAgbWF0Y2ggIXBhdHRlcm4gd2l0aFxuICAgICAgfCBSYWRpYWxHcmFkaWVudCB7Y2lyY2xlczsgX30gLT4gY2lyY2xlc1xuICAgICAgfCBMaW5lYXJHcmFkaWVudCBfXG4gICAgICB8IFJnYmEgX1xuICAgICAgfCBUeXBlTWlzbWF0Y2ggLT4gcmFpc2UgKEVycm9yIFBBVFRFUk5fVFlQRV9NSVNNQVRDSClcblxuICBsZXQgYWRkX2NvbG9yX3N0b3BfcmdiYSBwYXR0ZXJuID8ob2ZzPTAuKSByIGcgYiBhID1cbiAgICBsZXQgc3RvcF9wb2ludCA9IChvZnMsIHIsIGcsIGIsIGEpIGluXG4gICAgbWF0Y2ggIXBhdHRlcm4gd2l0aFxuICAgICAgfCBMaW5lYXJHcmFkaWVudCBncmFkaWVudCAtPlxuICAgICAgICBwYXR0ZXJuIDo9IExpbmVhckdyYWRpZW50IHtncmFkaWVudCB3aXRoIHN0b3BfcG9pbnRzPShTdG9wUG9pbnRMaXN0LmFkZCBncmFkaWVudC5zdG9wX3BvaW50cyBzdG9wX3BvaW50KX1cbiAgICAgIHwgUmFkaWFsR3JhZGllbnQgZ3JhZGllbnQgLT5cbiAgICAgICAgcGF0dGVybiA6PSBSYWRpYWxHcmFkaWVudCB7Z3JhZGllbnQgd2l0aCBzdG9wX3BvaW50cz0oU3RvcFBvaW50TGlzdC5hZGQgZ3JhZGllbnQuc3RvcF9wb2ludHMgc3RvcF9wb2ludCl9XG4gICAgICB8IFJnYmEgXyAtPiBwYXR0ZXJuIDo9IFR5cGVNaXNtYXRjaFxuICAgICAgfCBUeXBlTWlzbWF0Y2ggLT4gKClcblxuICBsZXQgYWRkX2NvbG9yX3N0b3BfcmdiIHBhdHRlcm4gP29mcyByIGcgYiA9XG4gICAgYWRkX2NvbG9yX3N0b3BfcmdiYSBwYXR0ZXJuID9vZnMgciBnIGIgMS5cblxuICBsZXQgZ2V0X2NvbG9yX3N0b3BfY291bnQgcGF0dGVybiA9XG4gICAgbWF0Y2ggIXBhdHRlcm4gd2l0aFxuICAgICAgfCBMaW5lYXJHcmFkaWVudCB7c3RvcF9wb2ludHM7IF99IHwgUmFkaWFsR3JhZGllbnQge3N0b3BfcG9pbnRzOyBffSAtPiBTdG9wUG9pbnRMaXN0LnNpemUgc3RvcF9wb2ludHNcbiAgICAgIHwgUmdiYSBfXG4gICAgICB8IFR5cGVNaXNtYXRjaCAtPiByYWlzZSAoRXJyb3IgUEFUVEVSTl9UWVBFX01JU01BVENIKVxuXG4gIGxldCBnZXRfY29sb3Jfc3RvcF9yZ2JhIHBhdHRlcm4gfmlkeCA9XG4gICAgbWF0Y2ggIXBhdHRlcm4gd2l0aFxuICAgICAgfCBMaW5lYXJHcmFkaWVudCB7c3RvcF9wb2ludHM7IF99IHwgUmFkaWFsR3JhZGllbnQge3N0b3BfcG9pbnRzOyBffSAtPiBTdG9wUG9pbnRMaXN0LmdldCBzdG9wX3BvaW50cyB+aTppZHhcbiAgICAgIHwgUmdiYSBfXG4gICAgICB8IFR5cGVNaXNtYXRjaCAtPiByYWlzZSAoRXJyb3IgUEFUVEVSTl9UWVBFX01JU01BVENIKVxuZW5kXG5cbnR5cGUgZmlsbF9ydWxlID1cbiAgfCBXSU5ESU5HXG4gIHwgRVZFTl9PRERcblxudHlwZSBsaW5lX2NhcCA9XG4gIHwgQlVUVFxuICB8IFJPVU5EXG4gIHwgU1FVQVJFXG5cbnR5cGUgbGluZV9qb2luID1cbiAgfCBKT0lOX01JVEVSXG4gIHwgSk9JTl9ST1VORFxuICB8IEpPSU5fQkVWRUxcblxudHlwZSBmb250X2V4dGVudHMgPSB7XG4gIGFzY2VudDogZmxvYXQ7XG4gIGRlc2NlbnQ6IGZsb2F0O1xuICBiYXNlbGluZTogZmxvYXQ7XG4gIG1heF94X2FkdmFuY2U6IGZsb2F0O1xuICBtYXhfeV9hZHZhbmNlOiBmbG9hdDtcbn1cblxudHlwZSB0ZXh0X2V4dGVudHMgPSB7XG4gIHhfYmVhcmluZzogZmxvYXQ7XG4gIHlfYmVhcmluZzogZmxvYXQ7XG4gIHdpZHRoOiBmbG9hdDtcbiAgaGVpZ2h0OiBmbG9hdDtcbiAgeF9hZHZhbmNlOiBmbG9hdDtcbiAgeV9hZHZhbmNlOiBmbG9hdDtcbn1cblxudHlwZSBvcGVyYXRvciA9XG4gIHwgQ0xFQVJcbiAgfCBTT1VSQ0VcbiAgfCBPVkVSXG4gIHwgSU5cbiAgfCBPVVRcbiAgfCBBVE9QXG4gIHwgREVTVFxuICB8IERFU1RfT1ZFUlxuICB8IERFU1RfSU5cbiAgfCBERVNUX09VVFxuICB8IERFU1RfQVRPUFxuICB8IFhPUlxuICB8IEFERFxuICB8IFNBVFVSQVRFXG5cbm1vZHVsZSBQb2ludHM6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgY3JlYXRlOiB1bml0IC0+IHRcblxuICB2YWwgc2V0X3N0YXJ0OiB0IC0+IHRyYW5zZm9ybWF0aW9uOk1hdHJpeC50IC0+IHg6ZmxvYXQgLT4geTpmbG9hdCAtPiB1bml0XG4gIHZhbCBzZXRfc3RhcnRfaWZfbm9uZTogdCAtPiB0cmFuc2Zvcm1hdGlvbjpNYXRyaXgudCAtPiB4OmZsb2F0IC0+IHk6ZmxvYXQgLT4gdW5pdFxuICB2YWwgcmVzZXRfc3RhcnQ6IHQgLT4gdW5pdFxuXG4gIHZhbCBzZXRfY3VycmVudDogdCAtPiB0cmFuc2Zvcm1hdGlvbjpNYXRyaXgudCAtPiB4OmZsb2F0IC0+IHk6ZmxvYXQgLT4gdW5pdFxuICB2YWwgc2V0X2N1cnJlbnRfZnJvbV9zdGFydDogdCAtPiB1bml0XG4gIHZhbCByZXNldF9jdXJyZW50OiB0IC0+IHVuaXRcbiAgdmFsIGN1cnJlbnQ6IHQgLT4gdHJhbnNmb3JtYXRpb246TWF0cml4LnQgLT4gKGZsb2F0ICogZmxvYXQpIG9wdGlvblxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IHtcbiAgICBtdXRhYmxlIHN0YXJ0OiAoZmxvYXQgKiBmbG9hdCkgb3B0aW9uO1xuICAgIG11dGFibGUgY3VycmVudDogKGZsb2F0ICogZmxvYXQpIG9wdGlvbjtcbiAgfVxuXG4gIGxldCBjcmVhdGUgKCkgPSB7XG4gICAgc3RhcnQgPSBOb25lO1xuICAgIGN1cnJlbnQgPSBOb25lO1xuICB9XG5cbiAgbGV0IHNldF9zdGFydCBwb2ludHMgfnRyYW5zZm9ybWF0aW9uIH54IH55ID1cbiAgICBwb2ludHMuc3RhcnQgPC0gU29tZSAoTWF0cml4LnRyYW5zZm9ybV9wb2ludCB0cmFuc2Zvcm1hdGlvbiB4IHkpXG5cbiAgbGV0IHNldF9zdGFydF9pZl9ub25lIHBvaW50cyB+dHJhbnNmb3JtYXRpb24gfnggfnkgPVxuICAgIGlmIHBvaW50cy5zdGFydCA9IE5vbmUgdGhlblxuICAgIHBvaW50cy5zdGFydCA8LSBTb21lIChNYXRyaXgudHJhbnNmb3JtX3BvaW50IHRyYW5zZm9ybWF0aW9uIHggeSlcblxuICBsZXQgcmVzZXRfc3RhcnQgcG9pbnRzID1cbiAgICBwb2ludHMuc3RhcnQgPC0gTm9uZVxuXG4gIGxldCBzZXRfY3VycmVudCBwb2ludHMgfnRyYW5zZm9ybWF0aW9uIH54IH55ID1cbiAgICBwb2ludHMuY3VycmVudCA8LSBTb21lIChNYXRyaXgudHJhbnNmb3JtX3BvaW50IHRyYW5zZm9ybWF0aW9uIHggeSlcblxuICBsZXQgc2V0X2N1cnJlbnRfZnJvbV9zdGFydCBwb2ludHMgPVxuICAgIHBvaW50cy5jdXJyZW50IDwtIHBvaW50cy5zdGFydFxuXG4gIGxldCByZXNldF9jdXJyZW50IHBvaW50cyA9XG4gICAgcG9pbnRzLmN1cnJlbnQgPC0gTm9uZVxuXG4gIGxldCBjdXJyZW50IHBvaW50cyB+dHJhbnNmb3JtYXRpb24gPVxuICAgIG1hdGNoIHBvaW50cy5jdXJyZW50IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgKHgsIHkpIC0+IFNvbWUgKE1hdHJpeC50cmFuc2Zvcm1fcG9pbnQgKE1hdHJpeC5pbml0X2ludmVyc2UgdHJhbnNmb3JtYXRpb24pIHggeSlcbmVuZFxuIiwiKCogQ29weXJpZ2h0IDIwMTctMjAxOCBWaW5jZW50IEphY3F1ZXMgPHZpbmNlbnRAdmluY2VudC1qYWNxdWVzLm5ldD4gKilcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAjaW5jbHVkZSBcIlMuaW5jbC5tbGlcIlxuZW5kXG5cbm1vZHVsZSBNb2NrID0gc3RydWN0XG4gICNpbmNsdWRlIFwiQmFja2VuZC5pbmNsLm1sXCJcblxuICBsZXQgKCkgPSBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIChmdW5jdGlvblxuICAgIHwgRXJyb3Igc3RhdHVzIC0+IFNvbWUgKFByaW50Zi5zcHJpbnRmIFwiQ2Fpcm9Nb2NrLkVycm9yKCVzKVwiIChzdGF0dXNfcmVwciBzdGF0dXMpKVxuICAgIHwgXyAtPiBOb25lXG4gIClcblxuICBtb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSB7XG4gICAgICBkYXNoZXM6IGZsb2F0IGFycmF5O1xuICAgICAgZmlsbF9ydWxlOiBmaWxsX3J1bGU7XG4gICAgICBmb250OiBmb250O1xuICAgICAgbGluZV9jYXA6IGxpbmVfY2FwO1xuICAgICAgbGluZV9qb2luOiBsaW5lX2pvaW47XG4gICAgICBsaW5lX3dpZHRoOiBmbG9hdDtcbiAgICAgIG1pdGVyX2xpbWl0OiBmbG9hdDtcbiAgICAgIG9mczogZmxvYXQ7XG4gICAgICBvcGVyYXRvcjogb3BlcmF0b3I7XG4gICAgICBzb3VyY2U6IFBhdHRlcm4uc291cmNlO1xuICAgICAgdHJhbnNmb3JtYXRpb246IE1hdHJpeC50O1xuICAgIH1cbiAgZW5kXG5cbiAgdHlwZSBjb250ZXh0ID0ge1xuICAgIG11dGFibGUgc3RhdGVzOiBTdGF0ZS50IGxpc3Q7XG4gICAgcG9pbnRzOiBQb2ludHMudDtcbiAgfVxuXG4gIGxldCBjcmVhdGUgKCkgPSB7XG4gICAgc3RhdGVzID0gW1xuICAgICAge1xuICAgICAgICBkYXNoZXMgPSBbfHxdO1xuICAgICAgICBmaWxsX3J1bGUgPSBXSU5ESU5HO1xuICAgICAgICBmb250ID0ge1xuICAgICAgICAgIHNsYW50ID0gVXByaWdodDtcbiAgICAgICAgICB3ZWlnaHQgPSBOb3JtYWw7XG4gICAgICAgICAgc2l6ZSA9IDEwLjtcbiAgICAgICAgICBmYW1pbHkgPSBcInNhbnMtc2VyaWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgbGluZV9jYXAgPSBCVVRUO1xuICAgICAgICBsaW5lX2pvaW4gPSBKT0lOX01JVEVSO1xuICAgICAgICBsaW5lX3dpZHRoID0gMi47XG4gICAgICAgIG1pdGVyX2xpbWl0ID0gMTAuO1xuICAgICAgICBvZnMgPSAwLjtcbiAgICAgICAgb3BlcmF0b3IgPSBPVkVSO1xuICAgICAgICBzb3VyY2UgPSAhKFBhdHRlcm4uY3JlYXRlX3JnYiAwLiAwLiAwLik7XG4gICAgICAgIHRyYW5zZm9ybWF0aW9uID0gTWF0cml4LmluaXRfaWRlbnRpdHkgKCk7XG4gICAgICB9O1xuICAgIF07XG4gICAgcG9pbnRzID0gUG9pbnRzLmNyZWF0ZSAoKTtcbiAgfVxuXG4gIGxldCBzdGF0ZSB7c3RhdGVzOyBffSA9XG4gICAgTGlzdC5oZCBzdGF0ZXNcblxuICBsZXQgbXV0YXRlX3N0YXRlIGNvbnRleHQgZiA9XG4gICAgbGV0IHN0YXRlID0gZiAoc3RhdGUgY29udGV4dCkgaW5cbiAgICBjb250ZXh0LnN0YXRlcyA8LSBzdGF0ZTo6KExpc3QudGwgY29udGV4dC5zdGF0ZXMpXG5cblxuICBsZXQgc2F2ZSBjb250ZXh0ID1cbiAgICBjb250ZXh0LnN0YXRlcyA8LSAoc3RhdGUgY29udGV4dCk6OmNvbnRleHQuc3RhdGVzXG5cbiAgbGV0IHJlc3RvcmUgY29udGV4dCA9XG4gICAgbGV0IHN0YXRlcyA9XG4gICAgICBtYXRjaCBjb250ZXh0LnN0YXRlcyB3aXRoXG4gICAgICAgIHwgW10gKCpCSVNFQ1QtSUdOT1JFKikgKCogVGhpcyBjYW5ub3QgaGFwcGVuOiByZXN0b3JlIGlzIHRoZSBvbmx5IGZ1bmN0aW9uIHJlbW92aW5nIHN0YXRlcyBhbmQgaXQgcmVmdXNlcyB0byByZW1vdmUgdGhlIGxhc3Qgb25lLiAqKVxuICAgICAgICB8IFtfXSAtPiByYWlzZSAoRXJyb3IgSU5WQUxJRF9SRVNUT1JFKVxuICAgICAgICB8IF86OnN0YXRlcyAtPiBzdGF0ZXNcbiAgICBpblxuICAgIGNvbnRleHQuc3RhdGVzIDwtIHN0YXRlc1xuXG5cbiAgbGV0IHNldF9tYXRyaXggY29udGV4dCB0cmFuc2Zvcm1hdGlvbiA9XG4gICAgbXV0YXRlX3N0YXRlIGNvbnRleHQgKGZ1biBzIC0+IHtzIHdpdGggdHJhbnNmb3JtYXRpb259KVxuXG4gIGxldCBnZXRfbWF0cml4IGNvbnRleHQgPVxuICAgIChzdGF0ZSBjb250ZXh0KS50cmFuc2Zvcm1hdGlvblxuXG4gIGxldCB0cmFuc2Zvcm1fIG0gcyA9XG4gICAge3Mgd2l0aCBTdGF0ZS50cmFuc2Zvcm1hdGlvbj1NYXRyaXgubXVsdGlwbHkgcy5TdGF0ZS50cmFuc2Zvcm1hdGlvbiBtfVxuXG4gIGxldCB0cmFuc2Zvcm0gY29udGV4dCBtID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAodHJhbnNmb3JtXyBtKVxuXG4gIGxldCBzY2FsZSBjb250ZXh0IHggeSA9XG4gICAgbXV0YXRlX3N0YXRlIGNvbnRleHQgKHRyYW5zZm9ybV8gKE1hdHJpeC5pbml0X3NjYWxlIHggeSkpXG5cbiAgbGV0IHRyYW5zbGF0ZSBjb250ZXh0IHggeSA9XG4gICAgbXV0YXRlX3N0YXRlIGNvbnRleHQgKHRyYW5zZm9ybV8gKE1hdHJpeC5pbml0X3RyYW5zbGF0ZSB4IHkpKVxuXG4gIGxldCByb3RhdGUgY29udGV4dCBhbmdsZSA9XG4gICAgbXV0YXRlX3N0YXRlIGNvbnRleHQgKHRyYW5zZm9ybV8gKE1hdHJpeC5pbml0X3JvdGF0ZSBhbmdsZSkpXG5cbiAgbGV0IGlkZW50aXR5X21hdHJpeCBjb250ZXh0ID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAoZnVuIHMgLT4ge3Mgd2l0aCB0cmFuc2Zvcm1hdGlvbj1NYXRyaXguaW5pdF9pZGVudGl0eSAoKX0pXG5cbiAgbGV0IGRldmljZV90b191c2VyIGNvbnRleHQgeCB5ID1cbiAgICBNYXRyaXgudHJhbnNmb3JtX3BvaW50IChNYXRyaXguaW5pdF9pbnZlcnNlIChzdGF0ZSBjb250ZXh0KS50cmFuc2Zvcm1hdGlvbikgeCB5XG5cbiAgbGV0IGRldmljZV90b191c2VyX2Rpc3RhbmNlIGNvbnRleHQgZHggZHkgPVxuICAgIE1hdHJpeC50cmFuc2Zvcm1fZGlzdGFuY2UgKE1hdHJpeC5pbml0X2ludmVyc2UgKHN0YXRlIGNvbnRleHQpLnRyYW5zZm9ybWF0aW9uKSB+ZHggfmR5XG5cbiAgbGV0IHVzZXJfdG9fZGV2aWNlIGNvbnRleHQgeCB5ID1cbiAgICBNYXRyaXgudHJhbnNmb3JtX3BvaW50IChzdGF0ZSBjb250ZXh0KS50cmFuc2Zvcm1hdGlvbiB4IHlcblxuICBsZXQgdXNlcl90b19kZXZpY2VfZGlzdGFuY2UgY29udGV4dCBkeCBkeSA9XG4gICAgTWF0cml4LnRyYW5zZm9ybV9kaXN0YW5jZSAoc3RhdGUgY29udGV4dCkudHJhbnNmb3JtYXRpb24gfmR4IH5keVxuXG5cbiAgbGV0IG11dGF0ZV9wb2ludHMgY29udGV4dCB+c3RhcnQgfmN1cnJlbnQgPVxuICAgIGxldCB0cmFuc2Zvcm1hdGlvbiA9IChzdGF0ZSBjb250ZXh0KS50cmFuc2Zvcm1hdGlvbiBpblxuICAgIGxldCBtYWtlX3JlbGF0aXZlIH5keCB+ZHkgPVxuICAgICAgbGV0ICh4LCB5KSA9XG4gICAgICAgIG1hdGNoIFBvaW50cy5jdXJyZW50IGNvbnRleHQucG9pbnRzIH50cmFuc2Zvcm1hdGlvbiB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChFcnJvciBOT19DVVJSRU5UX1BPSU5UKVxuICAgICAgICAgIHwgU29tZSAoeCwgeSkgLT4gKHgsIHkpXG4gICAgICBpblxuICAgICAgKHggKy4gZHgsIHkgKy4gZHkpXG4gICAgaW5cbiAgICBiZWdpbiBtYXRjaCBzdGFydCB3aXRoXG4gICAgICB8IGBOb25lIC0+ICgpXG4gICAgICB8IGBSZXNldCAtPiBQb2ludHMucmVzZXRfc3RhcnQgY29udGV4dC5wb2ludHNcbiAgICAgIHwgYElmTm9uZSAoeCwgeSkgLT4gUG9pbnRzLnNldF9zdGFydF9pZl9ub25lIGNvbnRleHQucG9pbnRzIH50cmFuc2Zvcm1hdGlvbiB+eCB+eVxuICAgICAgfCBgU2V0ICh4LCB5KSAtPiBQb2ludHMuc2V0X3N0YXJ0IGNvbnRleHQucG9pbnRzIH50cmFuc2Zvcm1hdGlvbiB+eCB+eVxuICAgICAgfCBgUmVsYXRpdmUgKGR4LCBkeSkgLT5cbiAgICAgICAgbGV0ICh4LCB5KSA9IG1ha2VfcmVsYXRpdmUgfmR4IH5keSBpblxuICAgICAgICBQb2ludHMuc2V0X3N0YXJ0IGNvbnRleHQucG9pbnRzIH50cmFuc2Zvcm1hdGlvbiB+eCB+eVxuICAgIGVuZDtcbiAgICBiZWdpbiBtYXRjaCBjdXJyZW50IHdpdGhcbiAgICAgIHwgYFJlc2V0IC0+IFBvaW50cy5yZXNldF9jdXJyZW50IGNvbnRleHQucG9pbnRzXG4gICAgICB8IGBGcm9tU3RhcnQgLT4gUG9pbnRzLnNldF9jdXJyZW50X2Zyb21fc3RhcnQgY29udGV4dC5wb2ludHNcbiAgICAgIHwgYFNldCAoeCwgeSkgLT4gUG9pbnRzLnNldF9jdXJyZW50IGNvbnRleHQucG9pbnRzIH50cmFuc2Zvcm1hdGlvbiB+eCB+eVxuICAgICAgfCBgUmVsYXRpdmUgKGR4LCBkeSkgLT5cbiAgICAgICAgbGV0ICh4LCB5KSA9IG1ha2VfcmVsYXRpdmUgfmR4IH5keSBpblxuICAgICAgICBQb2ludHMuc2V0X2N1cnJlbnQgY29udGV4dC5wb2ludHMgfnRyYW5zZm9ybWF0aW9uIH54IH55XG4gICAgZW5kXG5cblxuICBsZXQgbW92ZV90byBjb250ZXh0IHggeSA9XG4gICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDooYFNldCAoeCwgeSkpIH5jdXJyZW50OmBGcm9tU3RhcnRcblxuICBsZXQgcmVsX21vdmVfdG8gY29udGV4dCB4IHkgPVxuICAgIG11dGF0ZV9wb2ludHMgY29udGV4dCB+c3RhcnQ6KGBSZWxhdGl2ZSAoeCwgeSkpIH5jdXJyZW50OmBGcm9tU3RhcnRcblxuICBsZXQgbGluZV90byBjb250ZXh0IHggeSA9XG4gICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDooYElmTm9uZSAoeCwgeSkpIH5jdXJyZW50OihgU2V0ICh4LCB5KSlcblxuICBsZXQgcmVsX2xpbmVfdG8gY29udGV4dCB4IHkgPVxuICAgIG11dGF0ZV9wb2ludHMgY29udGV4dCB+c3RhcnQ6KGBJZk5vbmUgKHgsIHkpKSB+Y3VycmVudDooYFJlbGF0aXZlICh4LCB5KSlcblxuICBsZXQgY3VydmVfdG8gY29udGV4dCB4MSB5MSBfIF8geDMgeTMgPVxuICAgIG11dGF0ZV9wb2ludHMgY29udGV4dCB+c3RhcnQ6KGBJZk5vbmUgKHgxLCB5MSkpIH5jdXJyZW50OihgU2V0ICh4MywgeTMpKVxuXG4gIGxldCByZWxfY3VydmVfdG8gY29udGV4dCB4MSB5MSBfIF8geDMgeTMgPVxuICAgIG11dGF0ZV9wb2ludHMgY29udGV4dCB+c3RhcnQ6KGBJZk5vbmUgKHgxLCB5MSkpIH5jdXJyZW50OihgUmVsYXRpdmUgKHgzLCB5MykpXG5cbiAgbGV0IHJlY3RhbmdsZSBjb250ZXh0IHggeSB+dzpfIH5oOl8gPVxuICAgIG11dGF0ZV9wb2ludHMgY29udGV4dCB+c3RhcnQ6YE5vbmUgfmN1cnJlbnQ6KGBTZXQgKHgsIHkpKVxuXG4gIGxldCBhcmMgY29udGV4dCB4IHkgfnIgfmExIH5hMiA9XG4gICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDooYElmTm9uZSAoeCArLiByICouIChjb3MgYTEpLCB5ICsuIHIgKi4gKHNpbiBhMSkpKSB+Y3VycmVudDooYFNldCAoeCArLiByICouIChjb3MgYTIpLCB5ICsuIHIgKi4gKHNpbiBhMikpKVxuXG4gIGxldCBhcmNfbmVnYXRpdmUgY29udGV4dCB4IHkgfnIgfmExIH5hMiA9XG4gICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDooYElmTm9uZSAoeCArLiByICouIChjb3MgYTEpLCB5ICsuIHIgKi4gKHNpbiBhMSkpKSB+Y3VycmVudDooYFNldCAoeCArLiByICouIChjb3MgYTIpLCB5ICsuIHIgKi4gKHNpbiBhMikpKVxuXG4gIG1vZHVsZSBQYXRoID0gc3RydWN0XG4gICAgbGV0IGdldF9jdXJyZW50X3BvaW50IGNvbnRleHQgPVxuICAgICAgbGV0IHRyYW5zZm9ybWF0aW9uID0gKHN0YXRlIGNvbnRleHQpLnRyYW5zZm9ybWF0aW9uIGluXG4gICAgICBtYXRjaCBQb2ludHMuY3VycmVudCB+dHJhbnNmb3JtYXRpb24gY29udGV4dC5wb2ludHMgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKDAuLCAwLilcbiAgICAgICAgfCBTb21lICh4LCB5KSAtPiAoeCwgeSlcblxuICAgIGxldCBjbGVhciBjb250ZXh0ID1cbiAgICAgIG11dGF0ZV9wb2ludHMgY29udGV4dCB+c3RhcnQ6YFJlc2V0IH5jdXJyZW50OmBSZXNldFxuXG4gICAgbGV0IGNsb3NlIGNvbnRleHQgPVxuICAgICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDpgTm9uZSB+Y3VycmVudDpgRnJvbVN0YXJ0XG4gIGVuZFxuXG4gIGxldCBzdHJva2VfcHJlc2VydmUgXyA9XG4gICAgKClcblxuICBsZXQgc3Ryb2tlIGNvbnRleHQgPVxuICAgIG11dGF0ZV9wb2ludHMgY29udGV4dCB+c3RhcnQ6YFJlc2V0IH5jdXJyZW50OmBSZXNldFxuXG4gIGxldCBmaWxsX3ByZXNlcnZlIF8gPVxuICAgICgpXG5cbiAgbGV0IGZpbGwgY29udGV4dCA9XG4gICAgbXV0YXRlX3BvaW50cyBjb250ZXh0IH5zdGFydDpgUmVzZXQgfmN1cnJlbnQ6YFJlc2V0XG5cbiAgbGV0IGNsaXBfcHJlc2VydmUgXyA9XG4gICAgKClcblxuICBsZXQgY2xpcCBjb250ZXh0ID1cbiAgICBtdXRhdGVfcG9pbnRzIGNvbnRleHQgfnN0YXJ0OmBSZXNldCB+Y3VycmVudDpgUmVzZXRcblxuICBsZXQgcGFpbnQgP2FscGhhOl8gXyA9XG4gICAgKClcblxuXG4gIGxldCBzZXRfbGluZV93aWR0aCBjb250ZXh0IGxpbmVfd2lkdGggPVxuICAgIG11dGF0ZV9zdGF0ZSBjb250ZXh0IChmdW4gcyAtPiB7cyB3aXRoIGxpbmVfd2lkdGh9KVxuXG4gIGxldCBnZXRfbGluZV93aWR0aCBjb250ZXh0ID1cbiAgICAoc3RhdGUgY29udGV4dCkubGluZV93aWR0aFxuXG4gIGxldCBzZXRfZGFzaCBjb250ZXh0ID8ob2ZzPTAuKSBkYXNoZXMgPVxuICAgIG11dGF0ZV9zdGF0ZSBjb250ZXh0IChmdW4gcyAtPiB7cyB3aXRoIGRhc2hlczsgb2ZzfSlcblxuICBsZXQgZ2V0X2Rhc2ggY29udGV4dCA9XG4gICAgbGV0IHN0YXRlID0gc3RhdGUgY29udGV4dCBpblxuICAgIChzdGF0ZS5kYXNoZXMsIHN0YXRlLm9mcylcblxuICBsZXQgc2V0X2ZpbGxfcnVsZSBjb250ZXh0IGZpbGxfcnVsZSA9XG4gICAgbXV0YXRlX3N0YXRlIGNvbnRleHQgKGZ1biBzIC0+IHtzIHdpdGggZmlsbF9ydWxlfSlcblxuICBsZXQgZ2V0X2ZpbGxfcnVsZSBjb250ZXh0ID1cbiAgICAoc3RhdGUgY29udGV4dCkuZmlsbF9ydWxlXG5cbiAgbGV0IHNldF9saW5lX2NhcCBjb250ZXh0IGxpbmVfY2FwID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAoZnVuIHMgLT4ge3Mgd2l0aCBsaW5lX2NhcH0pXG5cbiAgbGV0IGdldF9saW5lX2NhcCBjb250ZXh0ID1cbiAgICAoc3RhdGUgY29udGV4dCkubGluZV9jYXBcblxuICBsZXQgc2V0X2xpbmVfam9pbiBjb250ZXh0IGxpbmVfam9pbiA9XG4gICAgbXV0YXRlX3N0YXRlIGNvbnRleHQgKGZ1biBzIC0+IHtzIHdpdGggbGluZV9qb2lufSlcblxuICBsZXQgZ2V0X2xpbmVfam9pbiBjb250ZXh0ID1cbiAgICAoc3RhdGUgY29udGV4dCkubGluZV9qb2luXG5cbiAgbGV0IHNldF9taXRlcl9saW1pdCBjb250ZXh0IG1pdGVyX2xpbWl0ID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAoZnVuIHMgLT4ge3Mgd2l0aCBtaXRlcl9saW1pdH0pXG5cbiAgbGV0IGdldF9taXRlcl9saW1pdCBjb250ZXh0ID1cbiAgICAoc3RhdGUgY29udGV4dCkubWl0ZXJfbGltaXRcblxuICBsZXQgc2V0X29wZXJhdG9yIGNvbnRleHQgb3BlcmF0b3IgPVxuICAgIG11dGF0ZV9zdGF0ZSBjb250ZXh0IChmdW4gcyAtPiB7cyB3aXRoIG9wZXJhdG9yfSlcblxuICBsZXQgZ2V0X29wZXJhdG9yIGNvbnRleHQgPVxuICAgIChzdGF0ZSBjb250ZXh0KS5vcGVyYXRvclxuXG5cbiAgbGV0IHNldF9zb3VyY2UgY29udGV4dCBwYXR0ZXJuID1cbiAgICBsZXQgc291cmNlID0gIXBhdHRlcm4gaW5cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAoZnVuIHMgLT4ge3Mgd2l0aCBzb3VyY2V9KVxuXG4gIGxldCBnZXRfc291cmNlIGNvbnRleHQgPVxuICAgIHJlZiAoc3RhdGUgY29udGV4dCkuc291cmNlXG5cbiAgbGV0IHNldF9zb3VyY2VfcmdiIGNvbnRleHQgciBnIGIgPVxuICAgIGxldCBzb3VyY2UgPSAhKFBhdHRlcm4uY3JlYXRlX3JnYiByIGcgYikgaW5cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAoZnVuIHMgLT4ge3Mgd2l0aCBzb3VyY2V9KVxuXG4gIGxldCBzZXRfc291cmNlX3JnYmEgY29udGV4dCByIGcgYiBhID1cbiAgICBsZXQgc291cmNlID0gIShQYXR0ZXJuLmNyZWF0ZV9yZ2JhIHIgZyBiIGEpIGluXG4gICAgbXV0YXRlX3N0YXRlIGNvbnRleHQgKGZ1biBzIC0+IHtzIHdpdGggc291cmNlfSlcblxuXG4gIGxldCBzZWxlY3RfZm9udF9mYWNlIGNvbnRleHQgPyhzbGFudD1VcHJpZ2h0KSA/KHdlaWdodD1Ob3JtYWwpIGZhbWlseSA9XG4gICAgbXV0YXRlX3N0YXRlIGNvbnRleHQgKGZ1biBzIC0+IHtzIHdpdGggZm9udD17cy5mb250IHdpdGggc2xhbnQ7IHdlaWdodDsgZmFtaWx5fX0pXG5cbiAgbGV0IHNldF9mb250X3NpemUgY29udGV4dCBzaXplID1cbiAgICBtdXRhdGVfc3RhdGUgY29udGV4dCAoZnVuIHMgLT4ge3Mgd2l0aCBmb250PXtzLmZvbnQgd2l0aCBzaXplfX0pXG5cbiAgbGV0IHNob3dfdGV4dCBjb250ZXh0IHMgPVxuICAgIGxldCAoeCwgeSkgPVxuICAgICAgUGF0aC5nZXRfY3VycmVudF9wb2ludCBjb250ZXh0XG4gICAgYW5kIHdpZHRoID1cbiAgICAgIChzdGF0ZSBjb250ZXh0KS5mb250LnNpemUgKi4gMC44ICouIChmbG9hdF9vZl9pbnQgKFN0cmluZy5sZW5ndGggcykpXG4gICAgaW5cbiAgICBtdXRhdGVfcG9pbnRzIGNvbnRleHQgfnN0YXJ0OmBOb25lIH5jdXJyZW50OihgU2V0ICh4ICsuIHdpZHRoLCB5KSlcblxuICBsZXQgZm9udF9leHRlbnRzIGNvbnRleHQgPVxuICAgIGxldCBhc2NlbnQgPSAoc3RhdGUgY29udGV4dCkuZm9udC5zaXplIGluXG4gICAge1xuICAgICAgYXNjZW50O1xuICAgICAgZGVzY2VudD1hc2NlbnQgLy4gNC47XG4gICAgICBiYXNlbGluZT0wLjtcbiAgICAgIG1heF94X2FkdmFuY2U9Mi4gKi4gYXNjZW50O1xuICAgICAgbWF4X3lfYWR2YW5jZT0wLjtcbiAgICB9XG5cbiAgbGV0IHRleHRfZXh0ZW50cyBjb250ZXh0IHMgPVxuICAgIGxldCB3aWR0aCA9XG4gICAgICAoc3RhdGUgY29udGV4dCkuZm9udC5zaXplICouIDAuOCAqLiAoZmxvYXRfb2ZfaW50IChTdHJpbmcubGVuZ3RoIHMpKVxuICAgIGFuZCBoZWlnaHQgPVxuICAgICAgKHN0YXRlIGNvbnRleHQpLmZvbnQuc2l6ZVxuICAgIGluXG4gICAge3hfYmVhcmluZz0wLjsgeV9iZWFyaW5nPTAuOyB3aWR0aDsgaGVpZ2h0OyB4X2FkdmFuY2U9d2lkdGg7IHlfYWR2YW5jZT0wLn1cbmVuZFxuXG5tb2R1bGUgRGVjb3JhdGUoQzogUykgPSBzdHJ1Y3RcbiAgb3BlbiBTdGRMYWJlbHNcblxuICB0eXBlIGZpbGxfcnVsZSA9IEMuZmlsbF9ydWxlID1cbiAgICB8IFdJTkRJTkdcbiAgICB8IEVWRU5fT0REXG5cbiAgdHlwZSBsaW5lX2NhcCA9IEMubGluZV9jYXAgPVxuICAgIHwgQlVUVFxuICAgIHwgUk9VTkRcbiAgICB8IFNRVUFSRVxuXG4gIHR5cGUgbGluZV9qb2luID0gQy5saW5lX2pvaW4gPVxuICAgIHwgSk9JTl9NSVRFUlxuICAgIHwgSk9JTl9ST1VORFxuICAgIHwgSk9JTl9CRVZFTFxuXG4gIHR5cGUgbWF0cml4ID0gQy5tYXRyaXg9IHtcbiAgICBtdXRhYmxlIHh4OiBmbG9hdDtcbiAgICBtdXRhYmxlIHl4OiBmbG9hdDtcbiAgICBtdXRhYmxlIHh5OiBmbG9hdDtcbiAgICBtdXRhYmxlIHl5OiBmbG9hdDtcbiAgICBtdXRhYmxlIHgwOiBmbG9hdDtcbiAgICBtdXRhYmxlIHkwOiBmbG9hdDtcbiAgfVxuXG4gIHR5cGUgdGV4dF9leHRlbnRzID0gQy50ZXh0X2V4dGVudHMgPSB7XG4gICAgeF9iZWFyaW5nIDogZmxvYXQ7XG4gICAgeV9iZWFyaW5nIDogZmxvYXQ7XG4gICAgd2lkdGggOiBmbG9hdDtcbiAgICBoZWlnaHQgOiBmbG9hdDtcbiAgICB4X2FkdmFuY2UgOiBmbG9hdDtcbiAgICB5X2FkdmFuY2UgOiBmbG9hdDtcbiAgfVxuXG4gIHR5cGUgZm9udF9leHRlbnRzID0gQy5mb250X2V4dGVudHMgPSB7XG4gICAgYXNjZW50OiBmbG9hdDtcbiAgICBkZXNjZW50OiBmbG9hdDtcbiAgICBiYXNlbGluZTogZmxvYXQ7XG4gICAgbWF4X3hfYWR2YW5jZTogZmxvYXQ7XG4gICAgbWF4X3lfYWR2YW5jZTogZmxvYXQ7XG4gIH1cblxuICB0eXBlIG9wZXJhdG9yID0gQy5vcGVyYXRvciA9XG4gICAgfCBDTEVBUlxuICAgIHwgU09VUkNFXG4gICAgfCBPVkVSXG4gICAgfCBJTlxuICAgIHwgT1VUXG4gICAgfCBBVE9QXG4gICAgfCBERVNUXG4gICAgfCBERVNUX09WRVJcbiAgICB8IERFU1RfSU5cbiAgICB8IERFU1RfT1VUXG4gICAgfCBERVNUX0FUT1BcbiAgICB8IFhPUlxuICAgIHwgQUREXG4gICAgfCBTQVRVUkFURVxuXG4gIHR5cGUgd2VpZ2h0ID0gQy53ZWlnaHQgPVxuICAgIHwgTm9ybWFsXG4gICAgfCBCb2xkXG5cbiAgdHlwZSBzbGFudCA9IEMuc2xhbnQgPVxuICAgIHwgVXByaWdodFxuICAgIHwgSXRhbGljXG4gICAgfCBPYmxpcXVlXG5cbiAgdHlwZSBzdGF0dXMgPSBDLnN0YXR1cyA9XG4gICAgfCBJTlZBTElEX1JFU1RPUkVcbiAgICB8IElOVkFMSURfUE9QX0dST1VQXG4gICAgfCBOT19DVVJSRU5UX1BPSU5UXG4gICAgfCBJTlZBTElEX01BVFJJWFxuICAgIHwgSU5WQUxJRF9TVEFUVVNcbiAgICB8IE5VTExfUE9JTlRFUlxuICAgIHwgSU5WQUxJRF9TVFJJTkdcbiAgICB8IElOVkFMSURfUEFUSF9EQVRBXG4gICAgfCBSRUFEX0VSUk9SXG4gICAgfCBXUklURV9FUlJPUlxuICAgIHwgU1VSRkFDRV9GSU5JU0hFRFxuICAgIHwgU1VSRkFDRV9UWVBFX01JU01BVENIXG4gICAgfCBQQVRURVJOX1RZUEVfTUlTTUFUQ0hcbiAgICB8IElOVkFMSURfQ09OVEVOVFxuICAgIHwgSU5WQUxJRF9GT1JNQVRcbiAgICB8IElOVkFMSURfVklTVUFMXG4gICAgfCBGSUxFX05PVF9GT1VORFxuICAgIHwgSU5WQUxJRF9EQVNIXG4gICAgfCBJTlZBTElEX0RTQ19DT01NRU5UXG4gICAgfCBJTlZBTElEX0lOREVYXG4gICAgfCBDTElQX05PVF9SRVBSRVNFTlRBQkxFXG4gICAgfCBURU1QX0ZJTEVfRVJST1JcbiAgICB8IElOVkFMSURfU1RSSURFXG4gICAgfCBGT05UX1RZUEVfTUlTTUFUQ0hcbiAgICB8IFVTRVJfRk9OVF9JTU1VVEFCTEVcbiAgICB8IFVTRVJfRk9OVF9FUlJPUlxuICAgIHwgTkVHQVRJVkVfQ09VTlRcbiAgICB8IElOVkFMSURfQ0xVU1RFUlNcbiAgICB8IElOVkFMSURfU0xBTlRcbiAgICB8IElOVkFMSURfV0VJR0hUXG4gICAgfCBJTlZBTElEX1NJWkVcbiAgICB8IFVTRVJfRk9OVF9OT1RfSU1QTEVNRU5URURcbiAgICB8IERFVklDRV9UWVBFX01JU01BVENIXG4gICAgfCBERVZJQ0VfRVJST1JcbiAgICB8IElOVkFMSURfTUVTSF9DT05TVFJVQ1RJT05cbiAgICB8IERFVklDRV9GSU5JU0hFRFxuICAgIHwgSkJJRzJfR0xPQkFMX01JU1NJTkdcblxuICBtb2R1bGUgUGF0dGVybiA9IEMuUGF0dGVyblxuXG4gIG1vZHVsZSBNYXRyaXggPSBDLk1hdHJpeFxuXG4gIGV4Y2VwdGlvbiBFcnJvciA9IEMuRXJyb3JcblxuICBleGNlcHRpb24gVW5hdmFpbGFibGUgPSBDLlVuYXZhaWxhYmxlXG5cbiAgbGV0IHN0YXR1c190b19zdHJpbmcgPSBDLnN0YXR1c190b19zdHJpbmdcblxuICBtb2R1bGUgUCA9IHN0cnVjdFxuICAgIG9wZW4gQ1xuXG4gICAgbGV0IHVuaXQgKCkgPVxuICAgICAgXCJcIlxuXG4gICAgbGV0IGZsb2F0IHggPVxuICAgICAgUHJpbnRmLnNwcmludGYgXCIlLjJmXCIgeFxuXG4gICAgbGV0IG1hdHJpeCB7eHg7IHh5OyB5eDsgeXk7IHgwOyB5MH0gPVxuICAgICAgUHJpbnRmLnNwcmludGYgXCJ7eHg9JS4yZjsgeHk9JS4yZjsgeXg9JS4yZjsgeXk9JS4yZjsgeDA9JS4yZjsgeTA9JS4yZn1cIiB4eCB4eSB5eCB5eSB4MCB5MFxuXG4gICAgbGV0IGNvb3JkcyAoeCwgeSkgPVxuICAgICAgUHJpbnRmLnNwcmludGYgXCIoJS4yZiwgJS4yZilcIiB4IHlcblxuICAgIGxldCBkYXNoZXMgZGFzaGVzID1cbiAgICAgIGRhc2hlc1xuICAgICAgfD4gQXJyYXkudG9fbGlzdFxuICAgICAgfD4gTGlzdC5tYXAgfmY6KFByaW50Zi5zcHJpbnRmIFwiJS4yZlwiKVxuICAgICAgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiOyBcIlxuICAgICAgfD4gUHJpbnRmLnNwcmludGYgXCJbfCVzfF1cIlxuXG4gICAgbGV0IGRhc2hlc19vZnMgKGRzLCBvZnMpID1cbiAgICAgIFByaW50Zi5zcHJpbnRmIFwiKCVzLCAlLjJmKVwiIChkYXNoZXMgZHMpIG9mc1xuXG4gICAgbGV0IGZpbGxfcnVsZSA9IGZ1bmN0aW9uXG4gICAgICB8IFdJTkRJTkcgLT4gXCJXSU5ESU5HXCJcbiAgICAgIHwgRVZFTl9PREQgLT4gXCJFVkVOX09ERFwiXG5cbiAgICBsZXQgbGluZV9jYXAgPSBmdW5jdGlvblxuICAgICAgfCBCVVRUIC0+IFwiQlVUVFwiXG4gICAgICB8IFJPVU5EIC0+IFwiUk9VTkRcIlxuICAgICAgfCBTUVVBUkUgLT4gXCJTUVVBUkVcIlxuXG4gICAgbGV0IGxpbmVfam9pbiA9IGZ1bmN0aW9uXG4gICAgICB8IEpPSU5fTUlURVIgLT4gXCJKT0lOX01JVEVSXCJcbiAgICAgIHwgSk9JTl9ST1VORCAtPiBcIkpPSU5fUk9VTkRcIlxuICAgICAgfCBKT0lOX0JFVkVMIC0+IFwiSk9JTl9CRVZFTFwiXG5cbiAgICBsZXQgb3BlcmF0b3IgPSBmdW5jdGlvblxuICAgICAgfCBDTEVBUiAtPiBcIkNMRUFSXCJcbiAgICAgIHwgU09VUkNFIC0+IFwiU09VUkNFXCJcbiAgICAgIHwgT1ZFUiAtPiBcIk9WRVJcIlxuICAgICAgfCBJTiAtPiBcIklOXCJcbiAgICAgIHwgT1VUIC0+IFwiT1VUXCJcbiAgICAgIHwgQVRPUCAtPiBcIkFUT1BcIlxuICAgICAgfCBERVNUIC0+IFwiREVTVFwiXG4gICAgICB8IERFU1RfT1ZFUiAtPiBcIkRFU1RfT1ZFUlwiXG4gICAgICB8IERFU1RfSU4gLT4gXCJERVNUX0lOXCJcbiAgICAgIHwgREVTVF9PVVQgLT4gXCJERVNUX09VVFwiXG4gICAgICB8IERFU1RfQVRPUCAtPiBcIkRFU1RfQVRPUFwiXG4gICAgICB8IFhPUiAtPiBcIlhPUlwiXG4gICAgICB8IEFERCAtPiBcIkFERFwiXG4gICAgICB8IFNBVFVSQVRFIC0+IFwiU0FUVVJBVEVcIlxuXG4gICAgbGV0IHNvdXJjZSBzb3VyY2UgPSBQYXR0ZXJuLihcbiAgICAgIGxldCBnZXQgZ2V0ID1cbiAgICAgICAgdHJ5IFNvbWUgKGdldCBzb3VyY2UpIHdpdGggRXJyb3IgUEFUVEVSTl9UWVBFX01JU01BVENIIC0+IE5vbmVcbiAgICAgIGFuZCBzdG9wX3BvaW50cyAoKSA9XG4gICAgICAgIGxldCBjb3VudCA9IGdldF9jb2xvcl9zdG9wX2NvdW50IHNvdXJjZSBpblxuICAgICAgICBsZXQgc3RvcF9wb2ludHMgPSBBcnJheS5tYWtlIGNvdW50ICgwLiwgMC4sIDAuLCAwLiwgMC4pIGluXG4gICAgICAgIGZvciBpZHggPSAwIHRvIGNvdW50IC0gMSBkb1xuICAgICAgICAgIHN0b3BfcG9pbnRzLihpZHgpIDwtIGdldF9jb2xvcl9zdG9wX3JnYmEgc291cmNlIH5pZHhcbiAgICAgICAgZG9uZTtcbiAgICAgICAgc3RvcF9wb2ludHNcbiAgICAgICAgfD4gQXJyYXkudG9fbGlzdFxuICAgICAgICB8PiBMaXN0Lm1hcCB+ZjooZnVuIChwb3NpdGlvbiwgciwgZywgYiwgYSkgLT4gUHJpbnRmLnNwcmludGYgXCJ7cG9zaXRpb249JS4yZjsgcj0lLjJmOyBnPSUuMmY7IGI9JS4yZjsgYT0lLjJmfVwiIHBvc2l0aW9uIHIgZyBiIGEpXG4gICAgICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIjsgXCJcbiAgICAgICAgfD4gUHJpbnRmLnNwcmludGYgXCJbJXNdXCJcbiAgICAgIGluXG4gICAgICBtYXRjaCBnZXQgZ2V0X3JnYmEgd2l0aFxuICAgICAgICB8IFNvbWUgKHIsIGcsIGIsIGEpIC0+XG4gICAgICAgICAgUHJpbnRmLnNwcmludGYgXCIoUmdiYSB7cj0lLjJmOyBnPSUuMmY7IGI9JS4yZjsgYT0lLjJmfSlcIiByIGcgYiBhXG4gICAgICAgIHwgTm9uZSAtPiBtYXRjaCBnZXQgZ2V0X2xpbmVhcl9wb2ludHMgd2l0aFxuICAgICAgICAgIHwgU29tZSAoeDEsIHkxLCB4MiwgeTIpIC0+XG4gICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIihMaW5lYXJHcmFkaWVudCB7eDA9JS4yZjsgeTA9JS4yZjsgeDE9JS4yZjsgeTE9JS4yZjsgc3RvcF9wb2ludHM9JXN9KVwiIHgxIHkxIHgyIHkyIChzdG9wX3BvaW50cyAoKSlcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgIGxldCAoeDEsIHkxLCByMSwgeDIsIHkyLCByMikgPSBnZXRfcmFkaWFsX2NpcmNsZXMgc291cmNlIGluXG4gICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIihSYWRpYWxHcmFkaWVudCB7eDA9JS4yZjsgeTA9JS4yZjsgcjA9JS4yZjsgeDE9JS4yZjsgeTE9JS4yZjsgcjElLjJmOyBzdG9wX3BvaW50cz0lc30pXCIgeDEgeTEgcjEgeDIgeTIgcjIgKHN0b3BfcG9pbnRzICgpKVxuICAgIClcblxuICAgIGxldCBmb250X2V4dGVudHMge2FzY2VudDsgZGVzY2VudDsgYmFzZWxpbmU7IG1heF94X2FkdmFuY2U7IG1heF95X2FkdmFuY2V9ID1cbiAgICAgIFByaW50Zi5zcHJpbnRmIFwie2FzY2VudD0lLjJmOyBkZXNjZW50PSUuMmY7IGJhc2VsaW5lPSUuMmY7IG1heF94X2FkdmFuY2U9JS4yZjsgbWF4X3lfYWR2YW5jZT0lLjJmfVwiIGFzY2VudCBkZXNjZW50IGJhc2VsaW5lIG1heF94X2FkdmFuY2UgbWF4X3lfYWR2YW5jZVxuXG4gICAgbGV0IHRleHRfZXh0ZW50cyB7eF9iZWFyaW5nOyB5X2JlYXJpbmc7IHdpZHRoOyBoZWlnaHQ7IHhfYWR2YW5jZTsgeV9hZHZhbmNlfSA9XG4gICAgICBQcmludGYuc3ByaW50ZiBcInt4X2JlYXJpbmc9JS4yZjsgeV9iZWFyaW5nPSUuMmY7IHdpZHRoPSUuMmY7IGhlaWdodD0lLjJmOyB4X2FkdmFuY2U9JS4yZjsgeV9hZHZhbmNlPSUuMmZ9XCIgeF9iZWFyaW5nIHlfYmVhcmluZyB3aWR0aCBoZWlnaHQgeF9hZHZhbmNlIHlfYWR2YW5jZVxuXG4gICAgbGV0IHNsYW50ID0gZnVuY3Rpb25cbiAgICAgIHwgVXByaWdodCAtPiBcIlVwcmlnaHRcIlxuICAgICAgfCBJdGFsaWMgLT4gXCJJdGFsaWNcIlxuICAgICAgfCBPYmxpcXVlIC0+IFwiT2JsaXF1ZVwiXG5cbiAgICBsZXQgd2VpZ2h0ID0gZnVuY3Rpb25cbiAgICAgIHwgTm9ybWFsIC0+IFwiTm9ybWFsXCJcbiAgICAgIHwgQm9sZCAtPiBcIkJvbGRcIlxuICBlbmRcblxuICBtb2R1bGUgQSA9IHN0cnVjdFxuICAgIGxldCBtYXRyaXggKCkgPVxuICAgICAgUC5tYXRyaXhcblxuICAgIGxldCBvcGVyYXRvciAoKSA9XG4gICAgICBQLm9wZXJhdG9yXG5cbiAgICBsZXQgZmlsbF9ydWxlICgpID1cbiAgICAgIFAuZmlsbF9ydWxlXG5cbiAgICBsZXQgbGluZV9jYXAgKCkgPVxuICAgICAgUC5saW5lX2NhcFxuXG4gICAgbGV0IGxpbmVfam9pbiAoKSA9XG4gICAgICBQLmxpbmVfam9pblxuXG4gICAgbGV0IHNvdXJjZSAoKSA9XG4gICAgICBQLnNvdXJjZVxuXG4gICAgbGV0IGRhc2hlcyAoKSA9XG4gICAgICBQLmRhc2hlc1xuXG4gICAgbGV0IG9wdGlvbiBuYW1lIHAgKCkgPSBmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IFwiXCJcbiAgICAgIHwgU29tZSB4IC0+IFByaW50Zi5zcHJpbnRmIFwiIH4lczolc1wiIG5hbWUgKHAgeClcbiAgZW5kXG5cbiAgbW9kdWxlIENvbnRleHQ6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGNyZWF0ZTogQy5jb250ZXh0IC0+IHRcbiAgICB2YWwgY2FsbDogdCAtPiAoJ2EsIHVuaXQsIHN0cmluZywgKCdiIC0+IHN0cmluZykgLT4gKEMuY29udGV4dCAtPiAnYikgLT4gJ2IpIGZvcm1hdDQgLT4gJ2FcbiAgICB2YWwgY2FsbHM6IHQgLT4gc3RyaW5nIGxpc3RcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSB0ID0ge1xuICAgICAgYzogQy5jb250ZXh0O1xuICAgICAgbXV0YWJsZSBjYWxsczogc3RyaW5nIGxpc3Q7XG4gICAgfVxuXG4gICAgbGV0IGNyZWF0ZSBjID1cbiAgICAgIHtjOyBjYWxscz1bXX1cblxuICAgIGxldCBjYWxscyB7Y2FsbHM7IF99ID1cbiAgICAgIExpc3QucmV2IGNhbGxzXG5cbiAgICBsZXQgY2FsbCBjb250ZXh0IGZvcm1hdCA9XG4gICAgICBQcmludGYua3NwcmludGYgKGZ1biBjYWxsIHByaW50X3JldCBmIC0+XG4gICAgICAgIHRyeSBiZWdpblxuICAgICAgICAgIGxldCByZXQgPSBmIGNvbnRleHQuYyBpblxuICAgICAgICAgIGxldCBwcmludGVkX3JldCA9IHByaW50X3JldCByZXQgaW5cbiAgICAgICAgICBsZXQgY2FsbCA9XG4gICAgICAgICAgICBpZiBwcmludGVkX3JldCA8PiBcIlwiIHRoZW5cbiAgICAgICAgICAgICAgUHJpbnRmLnNwcmludGYgXCIlcyAtPiAlc1wiIGNhbGwgcHJpbnRlZF9yZXRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgY2FsbFxuICAgICAgICAgIGluXG4gICAgICAgICAgY29udGV4dC5jYWxscyA8LSBjYWxsOjpjb250ZXh0LmNhbGxzO1xuICAgICAgICAgIHJldFxuICAgICAgICBlbmQgd2l0aFxuICAgICAgICAgIHwgZXggLT4gYmVnaW5cbiAgICAgICAgICAgIGxldCBjYWxsID0gUHJpbnRmLnNwcmludGYgXCIlcyAtPiByYWlzZSAoJXMpXCIgY2FsbCAoUHJpbnRleGMudG9fc3RyaW5nIGV4KSBpblxuICAgICAgICAgICAgY29udGV4dC5jYWxscyA8LSBjYWxsOjpjb250ZXh0LmNhbGxzO1xuICAgICAgICAgICAgcmFpc2UgZXhcbiAgICAgICAgICBlbmRcbiAgICAgICkgZm9ybWF0XG4gIGVuZFxuXG4gIHR5cGUgY29udGV4dCA9IENvbnRleHQudFxuXG4gIGxldCBjcmVhdGUgPSBDb250ZXh0LmNyZWF0ZVxuXG4gIGxldCBjYWxscyA9IENvbnRleHQuY2FsbHNcblxuICAjZGVmaW5lIENDIENvbnRleHQuY2FsbCBjb250ZXh0XG5cblxuICBsZXQgc2F2ZSBjb250ZXh0ID1cbiAgICBDQyBcInNhdmVcIiBQLnVuaXQgQy5zYXZlXG5cbiAgbGV0IHJlc3RvcmUgY29udGV4dCA9XG4gICAgQ0MgXCJyZXN0b3JlXCIgUC51bml0IEMucmVzdG9yZVxuXG5cbiAgbGV0IHNldF9tYXRyaXggY29udGV4dCBtID1cbiAgICBDQyBcInNldF9tYXRyaXggJWFcIiBBLm1hdHJpeCBtIFAudW5pdCAoZnVuIGMgLT4gQy5zZXRfbWF0cml4IGMgbSlcblxuICBsZXQgZ2V0X21hdHJpeCBjb250ZXh0ID1cbiAgICBDQyBcImdldF9tYXRyaXhcIiBQLm1hdHJpeCBDLmdldF9tYXRyaXhcblxuICBsZXQgdHJhbnNmb3JtIGNvbnRleHQgbSA9XG4gICAgQ0MgXCJ0cmFuc2Zvcm0gJWFcIiBBLm1hdHJpeCBtIFAudW5pdCAoZnVuIGMgLT4gQy50cmFuc2Zvcm0gYyBtKVxuXG4gIGxldCBzY2FsZSBjb250ZXh0IHggeSA9XG4gICAgQ0MgXCJzY2FsZSAlLjJmICUuMmZcIiB4IHkgUC51bml0IChmdW4gYyAtPiBDLnNjYWxlIGMgeCB5KVxuXG4gIGxldCB0cmFuc2xhdGUgY29udGV4dCB4IHkgPVxuICAgIENDIFwidHJhbnNsYXRlICUuMmYgJS4yZlwiIHggeSBQLnVuaXQgKGZ1biBjIC0+IEMudHJhbnNsYXRlIGMgeCB5KVxuXG4gIGxldCByb3RhdGUgY29udGV4dCBhbmdsZSA9XG4gICAgQ0MgXCJyb3RhdGUgJS4yZlwiIGFuZ2xlIFAudW5pdCAoZnVuIGMgLT4gQy5yb3RhdGUgYyBhbmdsZSlcblxuICBsZXQgaWRlbnRpdHlfbWF0cml4IGNvbnRleHQgPVxuICAgIENDIFwiaWRlbnRpdHlfbWF0cml4XCIgUC51bml0IEMuaWRlbnRpdHlfbWF0cml4XG5cbiAgbGV0IGRldmljZV90b191c2VyIGNvbnRleHQgeCB5ID1cbiAgICBDQyBcImRldmljZV90b191c2VyICUuMmYgJS4yZlwiIHggeSBQLmNvb3JkcyAoZnVuIGMgLT4gQy5kZXZpY2VfdG9fdXNlciBjIHggeSlcblxuICBsZXQgZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2UgY29udGV4dCB4IHkgPVxuICAgIENDIFwiZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2UgJS4yZiAlLjJmXCIgeCB5IFAuY29vcmRzIChmdW4gYyAtPiBDLmRldmljZV90b191c2VyX2Rpc3RhbmNlIGMgeCB5KVxuXG4gIGxldCB1c2VyX3RvX2RldmljZSBjb250ZXh0IHggeSA9XG4gICAgQ0MgXCJ1c2VyX3RvX2RldmljZSAlLjJmICUuMmZcIiB4IHkgUC5jb29yZHMgKGZ1biBjIC0+IEMudXNlcl90b19kZXZpY2UgYyB4IHkpXG5cbiAgbGV0IHVzZXJfdG9fZGV2aWNlX2Rpc3RhbmNlIGNvbnRleHQgeCB5ID1cbiAgICBDQyBcInVzZXJfdG9fZGV2aWNlX2Rpc3RhbmNlICUuMmYgJS4yZlwiIHggeSBQLmNvb3JkcyAoZnVuIGMgLT4gQy51c2VyX3RvX2RldmljZV9kaXN0YW5jZSBjIHggeSlcblxuXG4gIGxldCBtb3ZlX3RvIGNvbnRleHQgeCB5ID1cbiAgICBDQyBcIm1vdmVfdG8gJS4yZiAlLjJmXCIgeCB5IFAudW5pdCAoZnVuIGMgLT4gQy5tb3ZlX3RvIGMgeCB5KVxuXG4gIGxldCByZWxfbW92ZV90byBjb250ZXh0IHggeSA9XG4gICAgQ0MgXCJyZWxfbW92ZV90byAlLjJmICUuMmZcIiB4IHkgUC51bml0IChmdW4gYyAtPiBDLnJlbF9tb3ZlX3RvIGMgeCB5KVxuXG4gIGxldCBsaW5lX3RvIGNvbnRleHQgeCB5ID1cbiAgICBDQyBcImxpbmVfdG8gJS4yZiAlLjJmXCIgeCB5IFAudW5pdCAoZnVuIGMgLT4gQy5saW5lX3RvIGMgeCB5KVxuXG4gIGxldCByZWxfbGluZV90byBjb250ZXh0IHggeSA9XG4gICAgQ0MgXCJyZWxfbGluZV90byAlLjJmICUuMmZcIiB4IHkgUC51bml0IChmdW4gYyAtPiBDLnJlbF9saW5lX3RvIGMgeCB5KVxuXG4gIGxldCBjdXJ2ZV90byBjb250ZXh0IHgxIHkxIHgyIHkyIHgzIHkzID1cbiAgICBDQyBcImN1cnZlX3RvICUuMmYgJS4yZiAlLjJmICUuMmYgJS4yZiAlLjJmXCIgeDEgeTEgeDIgeTIgeDMgeTMgUC51bml0IChmdW4gYyAtPiBDLmN1cnZlX3RvIGMgeDEgeTEgeDIgeTIgeDMgeTMpXG5cbiAgbGV0IHJlbF9jdXJ2ZV90byBjb250ZXh0IHgxIHkxIHgyIHkyIHgzIHkzID1cbiAgICBDQyBcInJlbF9jdXJ2ZV90byAlLjJmICUuMmYgJS4yZiAlLjJmICUuMmYgJS4yZlwiIHgxIHkxIHgyIHkyIHgzIHkzIFAudW5pdCAoZnVuIGMgLT4gQy5yZWxfY3VydmVfdG8gYyB4MSB5MSB4MiB5MiB4MyB5MylcblxuICBsZXQgcmVjdGFuZ2xlIGNvbnRleHQgeCB5IH53IH5oID1cbiAgICBDQyBcInJlY3RhbmdsZSAlLjJmICUuMmYgfnc6JS4yZiB+aDolLjJmXCIgeCB5IHcgaCBQLnVuaXQgKGZ1biBjIC0+IEMucmVjdGFuZ2xlIGMgeCB5IH53IH5oKVxuXG4gIGxldCBhcmMgY29udGV4dCB4IHkgfnIgfmExIH5hMiA9XG4gICAgQ0MgXCJhcmMgJS4yZiAlLjJmIH5yOiUuMmYgfmExOiUuMmYgfmEyOiUuMmZcIiB4IHkgciBhMSBhMiBQLnVuaXQgKGZ1biBjIC0+IEMuYXJjIGMgeCB5IH5yIH5hMSB+YTIpXG5cbiAgbGV0IGFyY19uZWdhdGl2ZSBjb250ZXh0IHggeSB+ciB+YTEgfmEyID1cbiAgICBDQyBcImFyY19uZWdhdGl2ZSAlLjJmICUuMmYgfnI6JS4yZiB+YTE6JS4yZiB+YTI6JS4yZlwiIHggeSByIGExIGEyIFAudW5pdCAoZnVuIGMgLT4gQy5hcmNfbmVnYXRpdmUgYyB4IHkgfnIgfmExIH5hMilcblxuICBtb2R1bGUgUGF0aCA9IHN0cnVjdFxuICAgIGxldCBnZXRfY3VycmVudF9wb2ludCBjb250ZXh0ID1cbiAgICAgIENDIFwiUGF0aC5nZXRfY3VycmVudF9wb2ludFwiIFAuY29vcmRzIEMuUGF0aC5nZXRfY3VycmVudF9wb2ludFxuXG4gICAgbGV0IGNsZWFyIGNvbnRleHQgPVxuICAgICAgQ0MgXCJQYXRoLmNsZWFyXCIgUC51bml0IEMuUGF0aC5jbGVhclxuXG4gICAgbGV0IGNsb3NlIGNvbnRleHQgPVxuICAgICAgQ0MgXCJQYXRoLmNsb3NlXCIgUC51bml0IEMuUGF0aC5jbG9zZVxuICBlbmRcblxuICBsZXQgc3Ryb2tlX3ByZXNlcnZlIGNvbnRleHQgPVxuICAgIENDIFwic3Ryb2tlX3ByZXNlcnZlXCIgUC51bml0IEMuc3Ryb2tlX3ByZXNlcnZlXG5cbiAgbGV0IHN0cm9rZSBjb250ZXh0ID1cbiAgICBDQyBcInN0cm9rZVwiIFAudW5pdCBDLnN0cm9rZVxuXG4gIGxldCBmaWxsX3ByZXNlcnZlIGNvbnRleHQgPVxuICAgIENDIFwiZmlsbF9wcmVzZXJ2ZVwiIFAudW5pdCBDLmZpbGxfcHJlc2VydmVcblxuICBsZXQgZmlsbCBjb250ZXh0ID1cbiAgICBDQyBcImZpbGxcIiBQLnVuaXQgQy5maWxsXG5cbiAgbGV0IGNsaXBfcHJlc2VydmUgY29udGV4dCA9XG4gICAgQ0MgXCJjbGlwX3ByZXNlcnZlXCIgUC51bml0IEMuY2xpcF9wcmVzZXJ2ZVxuXG4gIGxldCBjbGlwIGNvbnRleHQgPVxuICAgIENDIFwiY2xpcFwiIFAudW5pdCBDLmNsaXBcblxuICBsZXQgcGFpbnQgP2FscGhhIGNvbnRleHQgPVxuICAgIENDIFwicGFpbnQlYVwiIChBLm9wdGlvbiBcImFscGhhXCIgUC5mbG9hdCkgYWxwaGEgUC51bml0IChDLnBhaW50ID9hbHBoYSlcblxuXG4gIGxldCBzZXRfbGluZV93aWR0aCBjb250ZXh0IGxpbmVfd2lkdGggPVxuICAgIENDIFwic2V0X2xpbmVfd2lkdGggJS4yZlwiIGxpbmVfd2lkdGggUC51bml0IChmdW4gYyAtPiBDLnNldF9saW5lX3dpZHRoIGMgbGluZV93aWR0aClcblxuICBsZXQgZ2V0X2xpbmVfd2lkdGggY29udGV4dCA9XG4gICAgQ0MgXCJnZXRfbGluZV93aWR0aFwiIFAuZmxvYXQgQy5nZXRfbGluZV93aWR0aFxuXG4gIGxldCBzZXRfZGFzaCBjb250ZXh0ID9vZnMgZGFzaGVzID1cbiAgICBDQyBcInNldF9kYXNoJWEgJWFcIiAoQS5vcHRpb24gXCJvZnNcIiBQLmZsb2F0KSBvZnMgQS5kYXNoZXMgZGFzaGVzIFAudW5pdCAoZnVuIGMgLT4gQy5zZXRfZGFzaCBjID9vZnMgZGFzaGVzKVxuXG4gIGxldCBnZXRfZGFzaCBjb250ZXh0ID1cbiAgICBDQyBcImdldF9kYXNoXCIgUC5kYXNoZXNfb2ZzIEMuZ2V0X2Rhc2hcblxuICBsZXQgc2V0X2ZpbGxfcnVsZSBjb250ZXh0IGZpbGxfcnVsZSA9XG4gICAgQ0MgXCJzZXRfZmlsbF9ydWxlICVhXCIgQS5maWxsX3J1bGUgZmlsbF9ydWxlIFAudW5pdCAoZnVuIGMgLT4gQy5zZXRfZmlsbF9ydWxlIGMgZmlsbF9ydWxlKVxuXG4gIGxldCBnZXRfZmlsbF9ydWxlIGNvbnRleHQgPVxuICAgIENDIFwiZ2V0X2ZpbGxfcnVsZVwiIFAuZmlsbF9ydWxlIEMuZ2V0X2ZpbGxfcnVsZVxuXG4gIGxldCBzZXRfbGluZV9jYXAgY29udGV4dCBsaW5lX2NhcCA9XG4gICAgQ0MgXCJzZXRfbGluZV9jYXAgJWFcIiBBLmxpbmVfY2FwIGxpbmVfY2FwIFAudW5pdCAoZnVuIGMgLT4gQy5zZXRfbGluZV9jYXAgYyBsaW5lX2NhcClcblxuICBsZXQgZ2V0X2xpbmVfY2FwIGNvbnRleHQgPVxuICAgIENDIFwiZ2V0X2xpbmVfY2FwXCIgUC5saW5lX2NhcCBDLmdldF9saW5lX2NhcFxuXG4gIGxldCBzZXRfbGluZV9qb2luIGNvbnRleHQgbGluZV9qb2luID1cbiAgICBDQyBcInNldF9saW5lX2pvaW4gJWFcIiBBLmxpbmVfam9pbiBsaW5lX2pvaW4gUC51bml0IChmdW4gYyAtPiBDLnNldF9saW5lX2pvaW4gYyBsaW5lX2pvaW4pXG5cbiAgbGV0IGdldF9saW5lX2pvaW4gY29udGV4dCA9XG4gICAgQ0MgXCJnZXRfbGluZV9qb2luXCIgUC5saW5lX2pvaW4gQy5nZXRfbGluZV9qb2luXG5cbiAgbGV0IHNldF9taXRlcl9saW1pdCBjb250ZXh0IG1pdGVyX2xpbWl0ID1cbiAgICBDQyBcInNldF9taXRlcl9saW1pdCAlLjJmXCIgbWl0ZXJfbGltaXQgUC51bml0IChmdW4gYyAtPiBDLnNldF9taXRlcl9saW1pdCBjIG1pdGVyX2xpbWl0KVxuXG4gIGxldCBnZXRfbWl0ZXJfbGltaXQgY29udGV4dCA9XG4gICAgQ0MgXCJnZXRfbWl0ZXJfbGltaXRcIiBQLmZsb2F0IEMuZ2V0X21pdGVyX2xpbWl0XG5cbiAgbGV0IHNldF9vcGVyYXRvciBjb250ZXh0IG9wZXJhdG9yID1cbiAgICBDQyBcInNldF9vcGVyYXRvciAlYVwiIEEub3BlcmF0b3Igb3BlcmF0b3IgUC51bml0IChmdW4gYyAtPiBDLnNldF9vcGVyYXRvciBjIG9wZXJhdG9yKVxuXG4gIGxldCBnZXRfb3BlcmF0b3IgY29udGV4dCA9XG4gICAgQ0MgXCJnZXRfb3BlcmF0b3JcIiBQLm9wZXJhdG9yIEMuZ2V0X29wZXJhdG9yXG5cblxuICBsZXQgc2V0X3NvdXJjZSBjb250ZXh0IHNvdXJjZSA9XG4gICAgQ0MgXCJzZXRfc291cmNlICVhXCIgQS5zb3VyY2UgKE9iai5tYWdpYyBzb3VyY2UpIFAudW5pdCAoZnVuIGMgLT4gQy5zZXRfc291cmNlIGMgc291cmNlKVxuXG4gIGxldCBnZXRfc291cmNlIGNvbnRleHQgPVxuICAgIENDIFwiZ2V0X3NvdXJjZVwiIFAuc291cmNlIEMuZ2V0X3NvdXJjZVxuXG4gIGxldCBzZXRfc291cmNlX3JnYiBjb250ZXh0IHIgZyBiID1cbiAgICBDQyBcInNldF9zb3VyY2VfcmdiICUuMmYgJS4yZiAlLjJmXCIgciBnIGIgUC51bml0IChmdW4gYyAtPiBDLnNldF9zb3VyY2VfcmdiIGMgciBnIGIpXG5cbiAgbGV0IHNldF9zb3VyY2VfcmdiYSBjb250ZXh0IHIgZyBiIGEgPVxuICAgIENDIFwic2V0X3NvdXJjZV9yZ2JhICUuMmYgJS4yZiAlLjJmICUuMmZcIiByIGcgYiBhIFAudW5pdCAoZnVuIGMgLT4gQy5zZXRfc291cmNlX3JnYmEgYyByIGcgYiBhKVxuXG5cbiAgbGV0IHNlbGVjdF9mb250X2ZhY2UgY29udGV4dCA/c2xhbnQgP3dlaWdodCBmYW1pbHkgPVxuICAgIENDIFwic2VsZWN0X2ZvbnRfZmFjZSVhJWEgJVNcIiAoQS5vcHRpb24gXCJzbGFudFwiIFAuc2xhbnQpIHNsYW50IChBLm9wdGlvbiBcIndlaWdodFwiIFAud2VpZ2h0KSB3ZWlnaHQgZmFtaWx5IFAudW5pdCAoZnVuIGMgLT4gQy5zZWxlY3RfZm9udF9mYWNlIGMgP3NsYW50ID93ZWlnaHQgZmFtaWx5KVxuXG4gIGxldCBzZXRfZm9udF9zaXplIGNvbnRleHQgZm9udF9zaXplID1cbiAgICBDQyBcInNldF9mb250X3NpemUgJS4yZlwiIGZvbnRfc2l6ZSBQLnVuaXQgKGZ1biBjIC0+IEMuc2V0X2ZvbnRfc2l6ZSBjIGZvbnRfc2l6ZSlcblxuICBsZXQgc2hvd190ZXh0IGNvbnRleHQgcyA9XG4gICAgQ0MgXCJzaG93X3RleHQgJVNcIiBzIFAudW5pdCAoZnVuIGMgLT4gQy5zaG93X3RleHQgYyBzKVxuXG4gIGxldCBmb250X2V4dGVudHMgY29udGV4dCA9XG4gICAgQ0MgXCJmb250X2V4dGVudHNcIiBQLmZvbnRfZXh0ZW50cyBDLmZvbnRfZXh0ZW50c1xuXG4gIGxldCB0ZXh0X2V4dGVudHMgY29udGV4dCBzID1cbiAgICBDQyBcInRleHRfZXh0ZW50cyAlU1wiIHMgUC50ZXh0X2V4dGVudHMgKGZ1biBjIC0+IEMudGV4dF9leHRlbnRzIGMgcylcbmVuZFxuXG5pbmNsdWRlIERlY29yYXRlKE1vY2spXG5cbmxldCBjcmVhdGUgKCkgPVxuICBDb250ZXh0LmNyZWF0ZSAoTW9jay5jcmVhdGUgKCkpXG4iLCIoKiBDb3B5cmlnaHQgMjAxNy0yMDE4IFZpbmNlbnQgSmFjcXVlcyA8dmluY2VudEB2aW5jZW50LWphY3F1ZXMubmV0PiAqKVxuXG5tb2R1bGUgdHlwZSBTID0gQ2Fpcm9Nb2NrLlNcblxuKCpcbkNhbnZhczpcbi0gaHR0cDovL3d3dy53M3NjaG9vbHMuY29tL3RhZ3MvcmVmX2NhbnZhcy5hc3Bcbi0gaHR0cHM6Ly9vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC8yLjguNC9hcGkvRG9tX2h0bWwuY2FudmFzUmVuZGVyaW5nQ29udGV4dDJELWNcblxuQ2Fpcm86XG4tIGh0dHA6Ly9jYWlyby5mb3JnZS5vY2FtbGNvcmUub3JnL3R1dG9yaWFsL0NhaXJvLmh0bWxcbi0gaHR0cHM6Ly9naXRodWIuY29tL0NocmlzMDAvb2NhbWwtY2Fpcm9cbi0gdXRvcCAtcmVxdWlyZSBjYWlybzJcbiopXG5cbiNpbmNsdWRlIFwiQmFja2VuZC5pbmNsLm1sXCJcblxubGV0ICgpID0gUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciAoZnVuY3Rpb25cbiAgfCBFcnJvciBzdGF0dXMgLT4gU29tZSAoUHJpbnRmLnNwcmludGYgXCJKc09mT0NhaXJvLkVycm9yKCVzKVwiIChzdGF0dXNfcmVwciBzdGF0dXMpKVxuICB8IF8gLT4gTm9uZVxuKVxuXG5tb2R1bGUgSHRtbCA9IHN0cnVjdFxuICB0eXBlIHQgPSBEb21faHRtbC5jYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgSnMudFxuZW5kXG5cbm1vZHVsZSBMb2NhbDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBjcmVhdGU6IHVuaXQgLT4gdFxuXG4gIHZhbCBzYXZlOiB0IC0+IHVuaXRcbiAgdmFsIHJlc3RvcmU6IHQgLT4gdW5pdFxuXG4gIHZhbCB0cmFuc2Zvcm1hdGlvbjogdCAtPiBNYXRyaXgudFxuICB2YWwgc2V0X3RyYW5zZm9ybWF0aW9uOiB0IC0+IHRyYW5zZm9ybWF0aW9uOk1hdHJpeC50IC0+IHVuaXRcblxuICB2YWwgZm9udDogdCAtPiBmb250XG4gIHZhbCBzZXRfZm9udDogdCAtPiBmb250OmZvbnQgLT4gdW5pdFxuXG4gIHZhbCBzb3VyY2U6IHQgLT4gUGF0dGVybi5zb3VyY2VcbiAgdmFsIHNldF9zb3VyY2U6IHQgLT4gc291cmNlOlBhdHRlcm4uc291cmNlIC0+IHVuaXRcblxuICB2YWwgZmlsbF9ydWxlOiB0IC0+IGZpbGxfcnVsZVxuICB2YWwgc2V0X2ZpbGxfcnVsZTogdCAtPiBmaWxsX3J1bGU6ZmlsbF9ydWxlIC0+IHVuaXRcblxuICB2YWwgc2V0X3N0YXJ0X3BvaW50OiB0IC0+IGZsb2F0ICogZmxvYXQgLT4gdW5pdFxuICB2YWwgc2V0X3N0YXJ0X3BvaW50X2lmX25vbmU6IHQgLT4gZmxvYXQgKiBmbG9hdCAtPiB1bml0XG4gIHZhbCByZXNldF9zdGFydF9wb2ludDogdCAtPiB1bml0XG4gIHZhbCBzZXRfc3RhcnRfcG9pbnRfYXNfY3VycmVudF9wb2ludDogdCAtPiB1bml0XG5cbiAgdmFsIGN1cnJlbnRfcG9pbnQ6IHQgLT4gKGZsb2F0ICogZmxvYXQpIG9wdGlvblxuICB2YWwgc2V0X2N1cnJlbnRfcG9pbnQ6IHQgLT4gZmxvYXQgKiBmbG9hdCAtPiB1bml0XG4gIHZhbCByZXNldF9jdXJyZW50X3BvaW50OiB0IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICBtb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSB7XG4gICAgICB0cmFuc2Zvcm1hdGlvbjogTWF0cml4LnQ7XG4gICAgICBmb250OiBmb250O1xuICAgICAgc291cmNlOiBQYXR0ZXJuLnNvdXJjZTtcbiAgICAgIGZpbGxfcnVsZTogZmlsbF9ydWxlO1xuICAgIH1cbiAgZW5kXG5cbiAgdHlwZSB0ID0ge1xuICAgIHBvaW50czogUG9pbnRzLnQ7XG4gICAgbXV0YWJsZSBzdGF0ZXM6IFN0YXRlLnQgbGlzdDtcbiAgfVxuXG4gIGxldCBjcmVhdGUgKCkgPSB7XG4gICAgcG9pbnRzID0gUG9pbnRzLmNyZWF0ZSAoKTtcbiAgICBzdGF0ZXMgPSBbXG4gICAgICB7XG4gICAgICAgIHRyYW5zZm9ybWF0aW9uID0gTWF0cml4LmluaXRfaWRlbnRpdHkgKCk7XG4gICAgICAgIGZvbnQgPSB7XG4gICAgICAgICAgc2xhbnQgPSBVcHJpZ2h0O1xuICAgICAgICAgIHdlaWdodCA9IE5vcm1hbDtcbiAgICAgICAgICBzaXplID0gMTAuO1xuICAgICAgICAgIGZhbWlseSA9IFwic2Fucy1zZXJpZlwiO1xuICAgICAgICB9O1xuICAgICAgICBzb3VyY2UgPSAhKFBhdHRlcm4uY3JlYXRlX3JnYiAwLiAwLiAwLik7XG4gICAgICAgIGZpbGxfcnVsZSA9IFdJTkRJTkc7XG4gICAgICB9O1xuICAgIF07XG4gIH1cblxuICBsZXQgc3RhdGUgY29udGV4dCA9XG4gICAgTGlzdC5oZCBjb250ZXh0LnN0YXRlc1xuXG4gIGxldCBzZXRfc3RhdGUgY29udGV4dCBzdGF0ZSA9XG4gICAgY29udGV4dC5zdGF0ZXMgPC0gc3RhdGU6OihMaXN0LnRsIGNvbnRleHQuc3RhdGVzKVxuXG4gIGxldCBzYXZlIGNvbnRleHQgPVxuICAgIGNvbnRleHQuc3RhdGVzIDwtIChzdGF0ZSBjb250ZXh0KTo6Y29udGV4dC5zdGF0ZXNcblxuICBsZXQgcmVzdG9yZSBjb250ZXh0ID1cbiAgICBsZXQgc3RhdGVzID1cbiAgICAgIG1hdGNoIGNvbnRleHQuc3RhdGVzIHdpdGhcbiAgICAgICAgfCBbXSB8IFtfXSAtPiByYWlzZSAoRXJyb3IgSU5WQUxJRF9SRVNUT1JFKVxuICAgICAgICB8IF86OnN0YXRlcyAtPiBzdGF0ZXNcbiAgICBpblxuICAgIGNvbnRleHQuc3RhdGVzIDwtIHN0YXRlc1xuXG4gIGxldCB0cmFuc2Zvcm1hdGlvbiBjb250ZXh0ID1cbiAgICAoc3RhdGUgY29udGV4dCkudHJhbnNmb3JtYXRpb25cblxuICBsZXQgc2V0X3RyYW5zZm9ybWF0aW9uIGNvbnRleHQgfnRyYW5zZm9ybWF0aW9uID1cbiAgICBzZXRfc3RhdGUgY29udGV4dCAoeyhzdGF0ZSBjb250ZXh0KSB3aXRoIHRyYW5zZm9ybWF0aW9ufSlcblxuICBsZXQgZm9udCBjb250ZXh0ID1cbiAgICAoc3RhdGUgY29udGV4dCkuZm9udFxuXG4gIGxldCBzZXRfZm9udCBjb250ZXh0IH5mb250ID1cbiAgICBzZXRfc3RhdGUgY29udGV4dCAoeyhzdGF0ZSBjb250ZXh0KSB3aXRoIGZvbnR9KVxuXG4gIGxldCBzb3VyY2UgY29udGV4dCA9XG4gICAgKHN0YXRlIGNvbnRleHQpLnNvdXJjZVxuXG4gIGxldCBzZXRfc291cmNlIGNvbnRleHQgfnNvdXJjZSA9XG4gICAgc2V0X3N0YXRlIGNvbnRleHQgKHsoc3RhdGUgY29udGV4dCkgd2l0aCBzb3VyY2V9KVxuXG4gIGxldCBmaWxsX3J1bGUgY29udGV4dCA9XG4gICAgKHN0YXRlIGNvbnRleHQpLmZpbGxfcnVsZVxuXG4gIGxldCBzZXRfZmlsbF9ydWxlIGNvbnRleHQgfmZpbGxfcnVsZSA9XG4gICAgc2V0X3N0YXRlIGNvbnRleHQgKHsoc3RhdGUgY29udGV4dCkgd2l0aCBmaWxsX3J1bGV9KVxuXG4gIGxldCBzZXRfc3RhcnRfcG9pbnQgY29udGV4dCAoeCwgeSkgPVxuICAgIGxldCB0cmFuc2Zvcm1hdGlvbiA9IHRyYW5zZm9ybWF0aW9uIGNvbnRleHQgaW5cbiAgICBQb2ludHMuc2V0X3N0YXJ0IGNvbnRleHQucG9pbnRzIH50cmFuc2Zvcm1hdGlvbiB+eCB+eVxuXG4gIGxldCByZXNldF9zdGFydF9wb2ludCBjb250ZXh0ID1cbiAgICBQb2ludHMucmVzZXRfc3RhcnQgY29udGV4dC5wb2ludHNcblxuICBsZXQgc2V0X3N0YXJ0X3BvaW50X2lmX25vbmUgY29udGV4dCAoeCwgeSkgPVxuICAgIGxldCB0cmFuc2Zvcm1hdGlvbiA9IHRyYW5zZm9ybWF0aW9uIGNvbnRleHQgaW5cbiAgICBQb2ludHMuc2V0X3N0YXJ0X2lmX25vbmUgY29udGV4dC5wb2ludHMgfnRyYW5zZm9ybWF0aW9uIH54IH55XG5cbiAgbGV0IHNldF9zdGFydF9wb2ludF9hc19jdXJyZW50X3BvaW50IGNvbnRleHQgPVxuICAgIFBvaW50cy5zZXRfY3VycmVudF9mcm9tX3N0YXJ0IGNvbnRleHQucG9pbnRzXG5cbiAgbGV0IGN1cnJlbnRfcG9pbnQgY29udGV4dCA9XG4gICAgbGV0IHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb24gY29udGV4dCBpblxuICAgIFBvaW50cy5jdXJyZW50IGNvbnRleHQucG9pbnRzIH50cmFuc2Zvcm1hdGlvblxuXG4gIGxldCBzZXRfY3VycmVudF9wb2ludCBjb250ZXh0ICh4LCB5KSA9XG4gICAgbGV0IHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb24gY29udGV4dCBpblxuICAgIFBvaW50cy5zZXRfY3VycmVudCBjb250ZXh0LnBvaW50cyB+dHJhbnNmb3JtYXRpb24gfnggfnlcblxuICBsZXQgcmVzZXRfY3VycmVudF9wb2ludCBjb250ZXh0ID1cbiAgICBQb2ludHMucmVzZXRfY3VycmVudCBjb250ZXh0LnBvaW50c1xuZW5kXG5cbnR5cGUgY29udGV4dCA9IHtcbiAgaHRtbDogSHRtbC50O1xuICBsb2NhbDogTG9jYWwudDtcbn1cblxuXG5sZXQgc2F2ZSBjb250ZXh0ID1cbiAgY29udGV4dC5odG1sIyNzYXZlO1xuICBMb2NhbC5zYXZlIGNvbnRleHQubG9jYWxcblxubGV0IHJlc3RvcmUgY29udGV4dCA9XG4gIGNvbnRleHQuaHRtbCMjcmVzdG9yZTtcbiAgTG9jYWwucmVzdG9yZSBjb250ZXh0LmxvY2FsXG5cblxubGV0IHNldF9tYXRyaXggY29udGV4dCAoe3h4OyB4eTsgeXg7IHl5OyB4MDsgeTB9IGFzIHRyYW5zZm9ybWF0aW9uKSA9XG4gIGNvbnRleHQuaHRtbCMjc2V0VHJhbnNmb3JtIHh4IHl4IHh5IHl5IHgwIHkwO1xuICBMb2NhbC5zZXRfdHJhbnNmb3JtYXRpb24gY29udGV4dC5sb2NhbCB+dHJhbnNmb3JtYXRpb25cblxubGV0IGdldF9tYXRyaXggY29udGV4dCA9XG4gIExvY2FsLnRyYW5zZm9ybWF0aW9uIGNvbnRleHQubG9jYWxcblxubGV0IHRyYW5zZm9ybSBjb250ZXh0IG0gPVxuICBzZXRfbWF0cml4IGNvbnRleHQgKE1hdHJpeC5tdWx0aXBseSAoTG9jYWwudHJhbnNmb3JtYXRpb24gY29udGV4dC5sb2NhbCkgbSlcblxubGV0IHNjYWxlIGNvbnRleHQgeCB5ID1cbiAgdHJhbnNmb3JtIGNvbnRleHQgKE1hdHJpeC5pbml0X3NjYWxlIHggeSlcblxubGV0IHRyYW5zbGF0ZSBjb250ZXh0IHggeSA9XG4gIHRyYW5zZm9ybSBjb250ZXh0IChNYXRyaXguaW5pdF90cmFuc2xhdGUgeCB5KVxuXG5sZXQgcm90YXRlIGNvbnRleHQgYW5nbGUgPVxuICB0cmFuc2Zvcm0gY29udGV4dCAoTWF0cml4LmluaXRfcm90YXRlIGFuZ2xlKVxuXG5sZXQgaWRlbnRpdHlfbWF0cml4IGNvbnRleHQgPVxuICBzZXRfbWF0cml4IGNvbnRleHQgKE1hdHJpeC5pbml0X2lkZW50aXR5ICgpKVxuXG5sZXQgZGV2aWNlX3RvX3VzZXIgY29udGV4dCB4IHkgPVxuICBNYXRyaXgudHJhbnNmb3JtX3BvaW50IChNYXRyaXguaW5pdF9pbnZlcnNlIChMb2NhbC50cmFuc2Zvcm1hdGlvbiBjb250ZXh0LmxvY2FsKSkgeCB5XG5cbmxldCBkZXZpY2VfdG9fdXNlcl9kaXN0YW5jZSBjb250ZXh0IGR4IGR5ID1cbiAgTWF0cml4LnRyYW5zZm9ybV9kaXN0YW5jZSAoTWF0cml4LmluaXRfaW52ZXJzZSAoTG9jYWwudHJhbnNmb3JtYXRpb24gY29udGV4dC5sb2NhbCkpIH5keCB+ZHlcblxubGV0IHVzZXJfdG9fZGV2aWNlIGNvbnRleHQgeCB5ID1cbiAgTWF0cml4LnRyYW5zZm9ybV9wb2ludCAoTG9jYWwudHJhbnNmb3JtYXRpb24gY29udGV4dC5sb2NhbCkgeCB5XG5cbmxldCB1c2VyX3RvX2RldmljZV9kaXN0YW5jZSBjb250ZXh0IGR4IGR5ID1cbiAgTWF0cml4LnRyYW5zZm9ybV9kaXN0YW5jZSAoTG9jYWwudHJhbnNmb3JtYXRpb24gY29udGV4dC5sb2NhbCkgfmR4IH5keVxuXG5cbmxldCBtYWtlX3JlbCBjb250ZXh0IH54OmR4IH55OmR5ID1cbiAgbWF0Y2ggTG9jYWwuY3VycmVudF9wb2ludCBjb250ZXh0LmxvY2FsIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgKEVycm9yIE5PX0NVUlJFTlRfUE9JTlQpXG4gICAgfCBTb21lICh4LCB5KSAtPiAoeCArLiBkeCwgeSArLiBkeSlcblxubGV0IG1vdmVfdG8gY29udGV4dCB4IHkgPVxuICBjb250ZXh0Lmh0bWwjI21vdmVUbyB4IHk7XG4gIExvY2FsLnNldF9zdGFydF9wb2ludCBjb250ZXh0LmxvY2FsICh4LCB5KTtcbiAgTG9jYWwuc2V0X3N0YXJ0X3BvaW50X2FzX2N1cnJlbnRfcG9pbnQgY29udGV4dC5sb2NhbFxuXG5sZXQgcmVsX21vdmVfdG8gY29udGV4dCB4IHkgPVxuICBsZXQgKHgsIHkpID0gbWFrZV9yZWwgY29udGV4dCB+eCB+eSBpblxuICBtb3ZlX3RvIGNvbnRleHQgeCB5XG5cbmxldCBsaW5lX3RvIGNvbnRleHQgeCB5ID1cbiAgY29udGV4dC5odG1sIyNsaW5lVG8geCB5O1xuICBMb2NhbC5zZXRfc3RhcnRfcG9pbnRfaWZfbm9uZSBjb250ZXh0LmxvY2FsICh4LCB5KTtcbiAgTG9jYWwuc2V0X2N1cnJlbnRfcG9pbnQgY29udGV4dC5sb2NhbCAoeCwgeSlcblxubGV0IHJlbF9saW5lX3RvIGNvbnRleHQgeCB5ID1cbiAgbGV0ICh4LCB5KSA9IG1ha2VfcmVsIGNvbnRleHQgfnggfnkgaW5cbiAgbGluZV90byBjb250ZXh0IHggeVxuXG5sZXQgY3VydmVfdG8gY29udGV4dCB4MSB5MSB4MiB5MiB4MyB5MyA9XG4gIGNvbnRleHQuaHRtbCMjYmV6aWVyQ3VydmVUbyB4MSB5MSB4MiB5MiB4MyB5MztcbiAgTG9jYWwuc2V0X3N0YXJ0X3BvaW50X2lmX25vbmUgY29udGV4dC5sb2NhbCAoeDEsIHkxKTtcbiAgTG9jYWwuc2V0X2N1cnJlbnRfcG9pbnQgY29udGV4dC5sb2NhbCAoeDMsIHkzKVxuXG5sZXQgcmVsX2N1cnZlX3RvIGNvbnRleHQgeDEgeTEgeDIgeTIgeDMgeTMgPVxuICBsZXQgKHgxLCB5MSkgPSBtYWtlX3JlbCBjb250ZXh0IH54OngxIH55OnkxXG4gIGFuZCAoeDIsIHkyKSA9IG1ha2VfcmVsIGNvbnRleHQgfng6eDIgfnk6eTJcbiAgYW5kICh4MywgeTMpID0gbWFrZV9yZWwgY29udGV4dCB+eDp4MyB+eTp5MyBpblxuICBjdXJ2ZV90byBjb250ZXh0IHgxIHkxIHgyIHkyIHgzIHkzXG5cbmxldCByZWN0YW5nbGUgY29udGV4dCB4IHkgfncgfmggPVxuICBMb2NhbC5zZXRfY3VycmVudF9wb2ludCBjb250ZXh0LmxvY2FsICh4LCB5KTtcbiAgY29udGV4dC5odG1sIyNyZWN0IHggeSB3IGhcblxubGV0IGFyY18gfmRpciBjb250ZXh0IHggeSB+ciB+YTEgfmEyID1cbiAgY29udGV4dC5odG1sIyNhcmMgeCB5IHIgYTEgYTIgZGlyO1xuICBMb2NhbC5zZXRfc3RhcnRfcG9pbnRfaWZfbm9uZSBjb250ZXh0LmxvY2FsICh4ICsuIHIgKi4gKGNvcyBhMSksIHkgKy4gciAqLiAoc2luIGExKSk7XG4gIExvY2FsLnNldF9jdXJyZW50X3BvaW50IGNvbnRleHQubG9jYWwgKHggKy4gciAqLiAoY29zIGEyKSwgeSArLiByICouIChzaW4gYTIpKVxuXG5sZXQgYXJjID0gYXJjXyB+ZGlyOkpzLl9mYWxzZVxuXG5sZXQgYXJjX25lZ2F0aXZlID0gYXJjXyB+ZGlyOkpzLl90cnVlXG5cbm1vZHVsZSBQYXRoID0gc3RydWN0XG4gIGxldCBnZXRfY3VycmVudF9wb2ludCBjb250ZXh0ID1cbiAgICBtYXRjaCBMb2NhbC5jdXJyZW50X3BvaW50IGNvbnRleHQubG9jYWwgd2l0aFxuICAgICAgfCBOb25lIC0+ICgwLiwgMC4pXG4gICAgICB8IFNvbWUgKHgsIHkpIC0+ICh4LCB5KVxuXG4gIGxldCBjbGVhciBjb250ZXh0ID1cbiAgICBjb250ZXh0Lmh0bWwjI2JlZ2luUGF0aDtcbiAgICBMb2NhbC5yZXNldF9zdGFydF9wb2ludCBjb250ZXh0LmxvY2FsO1xuICAgIExvY2FsLnJlc2V0X2N1cnJlbnRfcG9pbnQgY29udGV4dC5sb2NhbFxuXG4gIGxldCBjbG9zZSBjb250ZXh0ID1cbiAgICBjb250ZXh0Lmh0bWwjI2Nsb3NlUGF0aDtcbiAgICBMb2NhbC5zZXRfc3RhcnRfcG9pbnRfYXNfY3VycmVudF9wb2ludCBjb250ZXh0LmxvY2FsXG5lbmRcblxubGV0IHN0cm9rZV9wcmVzZXJ2ZSBjb250ZXh0ID1cbiAgY29udGV4dC5odG1sIyNzdHJva2VcblxubGV0IHN0cm9rZSBjb250ZXh0ID1cbiAgc3Ryb2tlX3ByZXNlcnZlIGNvbnRleHQ7XG4gIFBhdGguY2xlYXIgY29udGV4dFxuXG5sZXQgZmlsbF9wcmVzZXJ2ZSBjb250ZXh0ID1cbiAgbWF0Y2ggTG9jYWwuZmlsbF9ydWxlIGNvbnRleHQubG9jYWwgd2l0aFxuICAgIHwgV0lORElORyAtPiBjb250ZXh0Lmh0bWwjI2ZpbGxcbiAgICB8IEVWRU5fT0REIC0+IChKcy5VbnNhZmUuY29lcmNlIGNvbnRleHQuaHRtbCkjI2ZpbGwgKEpzLnN0cmluZyBcImV2ZW5vZGRcIilcblxubGV0IGZpbGwgY29udGV4dCA9XG4gIGZpbGxfcHJlc2VydmUgY29udGV4dDtcbiAgUGF0aC5jbGVhciBjb250ZXh0XG5cbmxldCBjbGlwX3ByZXNlcnZlIGNvbnRleHQgPVxuICBjb250ZXh0Lmh0bWwjI2NsaXBcblxubGV0IGNsaXAgY29udGV4dCA9XG4gIGNsaXBfcHJlc2VydmUgY29udGV4dDtcbiAgUGF0aC5jbGVhciBjb250ZXh0XG5cbmxldCBwYWludCA/KGFscGhhPTEuKSBjb250ZXh0ID1cbiAgc2F2ZSBjb250ZXh0O1xuICBjb250ZXh0Lmh0bWwjIy5nbG9iYWxBbHBoYSA6PSBhbHBoYTtcbiAgaWRlbnRpdHlfbWF0cml4IGNvbnRleHQ7XG4gIGxldCB3aWR0aCA9IChmbG9hdF9vZl9pbnQgY29udGV4dC5odG1sIyMuY2FudmFzIyMud2lkdGgpXG4gIGFuZCBoZWlnaHQgPSAoZmxvYXRfb2ZfaW50IGNvbnRleHQuaHRtbCMjLmNhbnZhcyMjLmhlaWdodCkgaW5cbiAgY29udGV4dC5odG1sIyNmaWxsUmVjdCAwLiAwLiB3aWR0aCBoZWlnaHQ7XG4gIHJlc3RvcmUgY29udGV4dFxuXG5cbmxldCBzZXRfbGluZV93aWR0aCBjb250ZXh0IHdpZHRoID1cbiAgY29udGV4dC5odG1sIyMubGluZVdpZHRoIDo9IHdpZHRoXG5cbmxldCBnZXRfbGluZV93aWR0aCBjb250ZXh0ID1cbiAgY29udGV4dC5odG1sIyMubGluZVdpZHRoXG5cbmxldCBzZXRfZGFzaCBjb250ZXh0ID8ob2ZzPTAuKSBkYXNoZXMgPVxuICBsZXQgaHRtbCA9IEpzLlVuc2FmZS5jb2VyY2UgY29udGV4dC5odG1sIGluXG4gIGh0bWwjIy5saW5lRGFzaE9mZnNldCA6PSBvZnM7XG4gIGh0bWwjI3NldExpbmVEYXNoIChKcy5hcnJheSBkYXNoZXMpXG5cbmxldCBnZXRfZGFzaCBjb250ZXh0ID1cbiAgbGV0IGh0bWwgPSBKcy5VbnNhZmUuY29lcmNlIGNvbnRleHQuaHRtbCBpblxuICAoSnMudG9fYXJyYXkgKGh0bWwjI2dldExpbmVEYXNoKSwgaHRtbCMjLmxpbmVEYXNoT2Zmc2V0KVxuXG5sZXQgc2V0X2ZpbGxfcnVsZSBjb250ZXh0IGZpbGxfcnVsZSA9XG4gIExvY2FsLnNldF9maWxsX3J1bGUgY29udGV4dC5sb2NhbCB+ZmlsbF9ydWxlXG5cbmxldCBnZXRfZmlsbF9ydWxlIGNvbnRleHQgPVxuICBMb2NhbC5maWxsX3J1bGUgY29udGV4dC5sb2NhbFxuXG5sZXQgc2V0X2xpbmVfY2FwIGNvbnRleHQgY2FwID1cbiAgbGV0IGNhcCA9IG1hdGNoIGNhcCB3aXRoXG4gICAgfCBCVVRUIC0+IFwiYnV0dFwiXG4gICAgfCBST1VORCAtPiBcInJvdW5kXCJcbiAgICB8IFNRVUFSRSAtPiBcInNxdWFyZVwiXG4gIGluXG4gIGNvbnRleHQuaHRtbCMjLmxpbmVDYXAgOj0gSnMuc3RyaW5nIGNhcFxuXG5sZXQgZ2V0X2xpbmVfY2FwIGNvbnRleHQgPVxuICBtYXRjaCBKcy50b19zdHJpbmcgY29udGV4dC5odG1sIyMubGluZUNhcCB3aXRoXG4gICAgfCBcInJvdW5kXCIgLT4gUk9VTkRcbiAgICB8IFwic3F1YXJlXCIgLT4gU1FVQVJFXG4gICAgfCBfIC0+IEJVVFRcblxubGV0IHNldF9saW5lX2pvaW4gY29udGV4dCBqb2luID1cbiAgbGV0IGpvaW4gPSBtYXRjaCBqb2luIHdpdGhcbiAgICB8IEpPSU5fTUlURVIgLT4gIFwibWl0ZXJcIlxuICAgIHwgSk9JTl9ST1VORCAtPiBcInJvdW5kXCJcbiAgICB8IEpPSU5fQkVWRUwgLT4gXCJiZXZlbFwiXG4gIGluXG4gIGNvbnRleHQuaHRtbCMjLmxpbmVKb2luIDo9IEpzLnN0cmluZyBqb2luXG5cbmxldCBnZXRfbGluZV9qb2luIGNvbnRleHQgPVxuICBtYXRjaCBKcy50b19zdHJpbmcgY29udGV4dC5odG1sIyMubGluZUpvaW4gd2l0aFxuICAgIHwgXCJyb3VuZFwiIC0+IEpPSU5fUk9VTkRcbiAgICB8IFwiYmV2ZWxcIiAtPiBKT0lOX0JFVkVMXG4gICAgfCBfIC0+IEpPSU5fTUlURVJcblxubGV0IHNldF9taXRlcl9saW1pdCBjb250ZXh0IGwgPVxuICBjb250ZXh0Lmh0bWwjIy5taXRlckxpbWl0IDo9IGxcblxubGV0IGdldF9taXRlcl9saW1pdCBjb250ZXh0ID1cbiAgY29udGV4dC5odG1sIyMubWl0ZXJMaW1pdFxuXG5sZXQgc2V0X29wZXJhdG9yIGNvbnRleHQgb3BlcmF0b3IgPVxuICBsZXQgb3BlcmF0b3IgPSBtYXRjaCBvcGVyYXRvciB3aXRoXG4gICAgfCBDTEVBUiAtPiBmYWlsd2l0aCBcIlVuc3VwcG9ydGVkIG9wZXJhdG9yIENMRUFSXCJcbiAgICB8IFNPVVJDRSAtPiBmYWlsd2l0aCBcIlVuc3VwcG9ydGVkIG9wZXJhdG9yIFNPVVJDRVwiXG4gICAgfCBPVkVSIC0+IFwic291cmNlLW92ZXJcIlxuICAgIHwgQVRPUCAtPiBcInNvdXJjZS1hdG9wXCJcbiAgICB8IElOIC0+IFwic291cmNlLWluXCJcbiAgICB8IE9VVCAtPiBcInNvdXJjZS1vdXRcIlxuICAgIHwgREVTVF9PVkVSIC0+IFwiZGVzdGluYXRpb24tb3ZlclwiXG4gICAgfCBERVNUX0FUT1AgLT4gXCJkZXN0aW5hdGlvbi1hdG9wXCJcbiAgICB8IERFU1RfSU4gLT4gXCJkZXN0aW5hdGlvbi1pblwiXG4gICAgfCBERVNUX09VVCAtPiBcImRlc3RpbmF0aW9uLW91dFwiXG4gICAgfCBBREQgLT4gXCJsaWdodGVyXCJcbiAgICB8IFhPUiAtPiBcInhvclwiXG4gICAgfCBERVNUIC0+IGZhaWx3aXRoIFwiVW5zdXBwb3J0ZWQgb3BlcmF0b3IgREVTVFwiXG4gICAgfCBTQVRVUkFURSAtPiBmYWlsd2l0aCBcIlVuc3VwcG9ydGVkIG9wZXJhdG9yIFNBVFVSQVRFXCJcbiAgaW5cbiAgY29udGV4dC5odG1sIyMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIDo9IEpzLnN0cmluZyBvcGVyYXRvclxuXG5sZXQgZ2V0X29wZXJhdG9yIGNvbnRleHQgPVxuICBtYXRjaCBKcy50b19zdHJpbmcgY29udGV4dC5odG1sIyMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHdpdGhcbiAgICB8IFwib3ZlclwiIC0+IE9WRVIgKCogU3BlY2lhbCBjYXNlIGZvciBub2RlLWNhbnZhcyB3aGljaCBzZWVtcyB0byBoYXZlIGEgd3JvbmcgZGVmYXVsdCB2YWx1ZSAqKVxuICAgIHwgXCJhZGRcIiAtPiBBREQgKCogU3BlY2lhbCBjYXNlIGZvciBub2RlLWNhbnZhcyAqKVxuICAgIHwgXCJzb3VyY2Utb3ZlclwiIC0+IE9WRVJcbiAgICB8IFwic291cmNlLWF0b3BcIiAtPiBBVE9QXG4gICAgfCBcInNvdXJjZS1pblwiIC0+IElOXG4gICAgfCBcInNvdXJjZS1vdXRcIiAtPiBPVVRcbiAgICB8IFwiZGVzdGluYXRpb24tb3ZlclwiIC0+IERFU1RfT1ZFUlxuICAgIHwgXCJkZXN0aW5hdGlvbi1hdG9wXCIgLT4gREVTVF9BVE9QXG4gICAgfCBcImRlc3RpbmF0aW9uLWluXCIgLT4gREVTVF9JTlxuICAgIHwgXCJkZXN0aW5hdGlvbi1vdXRcIiAtPiBERVNUX09VVFxuICAgIHwgXCJsaWdodGVyXCIgLT4gQUREXG4gICAgfCBcInhvclwiIC0+IFhPUlxuICAgIHwgb3AgLT4gZmFpbHdpdGggKFByaW50Zi5zcHJpbnRmIFwiVW5leHBlY3RlZCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gJVNcIiBvcClcblxuXG5sZXQgc2V0X3NvdXJjZSBjb250ZXh0IHBhdHRlcm4gPVxuICBsZXQgY29udmVydCB4ID0gc3RyaW5nX29mX2ludCAoaW50X29mX2Zsb2F0ICgyNTUuMCAqLiB4KSkgaW5cbiAgbGV0IGNvbnZlcnRfcmdiYSByIGcgYiBhID0gSnMuc3RyaW5nIChQcmludGYuc3ByaW50ZiBcInJnYmEoJXMsICVzLCAlcywgJWYpXCIgKGNvbnZlcnQgcikgKGNvbnZlcnQgZykgKGNvbnZlcnQgYikgYSkgaW5cbiAgbGV0IHNvdXJjZSA9ICFwYXR0ZXJuIGluXG4gIExvY2FsLnNldF9zb3VyY2UgY29udGV4dC5sb2NhbCB+c291cmNlO1xuICBtYXRjaCBzb3VyY2Ugd2l0aFxuICAgIHwgUGF0dGVybi5SZ2JhIChyLCBnLCBiLCBhKSAtPlxuICAgICAgbGV0IGNvbG9yID0gY29udmVydF9yZ2JhIHIgZyBiIGEgaW5cbiAgICAgIGNvbnRleHQuaHRtbCMjLmZpbGxTdHlsZSA6PSBjb2xvcjtcbiAgICAgIGNvbnRleHQuaHRtbCMjLnN0cm9rZVN0eWxlIDo9IGNvbG9yXG4gICAgfCBQYXR0ZXJuLkxpbmVhckdyYWRpZW50IHtwb2ludHM9KHgwLCB5MCwgeDEsIHkxKTsgc3RvcF9wb2ludHN9IC0+XG4gICAgICBsZXQgZ3JhZGllbnQgPSBjb250ZXh0Lmh0bWwjI2NyZWF0ZUxpbmVhckdyYWRpZW50IHgwIHkwIHgxIHkxIGluXG4gICAgICBzdG9wX3BvaW50c1xuICAgICAgfD4gUGF0dGVybi5TdG9wUG9pbnRMaXN0LnRvX2xpc3RcbiAgICAgIHw+IExpc3QuaXRlciB+ZjooZnVuIChwb3NpdGlvbiwgciwgZywgYiwgYSkgLT5cbiAgICAgICAgZ3JhZGllbnQjI2FkZENvbG9yU3RvcCBwb3NpdGlvbiAoY29udmVydF9yZ2JhIHIgZyBiIGEpXG4gICAgICApO1xuICAgICAgY29udGV4dC5odG1sIyMuZmlsbFN0eWxlX2dyYWRpZW50IDo9IGdyYWRpZW50O1xuICAgICAgY29udGV4dC5odG1sIyMuc3Ryb2tlU3R5bGVfZ3JhZGllbnQgOj0gZ3JhZGllbnRcbiAgICB8IFBhdHRlcm4uUmFkaWFsR3JhZGllbnQge2NpcmNsZXM9KHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpOyBzdG9wX3BvaW50c30gLT5cbiAgICAgIGxldCBncmFkaWVudCA9IGNvbnRleHQuaHRtbCMjY3JlYXRlUmFkaWFsR3JhZGllbnQgeDAgeTAgcjAgeDEgeTEgcjEgaW5cbiAgICAgIHN0b3BfcG9pbnRzXG4gICAgICB8PiBQYXR0ZXJuLlN0b3BQb2ludExpc3QudG9fbGlzdFxuICAgICAgfD4gTGlzdC5pdGVyIH5mOihmdW4gKHBvc2l0aW9uLCByLCBnLCBiLCBhKSAtPlxuICAgICAgICBncmFkaWVudCMjYWRkQ29sb3JTdG9wIHBvc2l0aW9uIChjb252ZXJ0X3JnYmEgciBnIGIgYSlcbiAgICAgICk7XG4gICAgICBjb250ZXh0Lmh0bWwjIy5maWxsU3R5bGVfZ3JhZGllbnQgOj0gZ3JhZGllbnQ7XG4gICAgICBjb250ZXh0Lmh0bWwjIy5zdHJva2VTdHlsZV9ncmFkaWVudCA6PSBncmFkaWVudFxuICAgIHwgUGF0dGVybi5UeXBlTWlzbWF0Y2ggLT5cbiAgICAgICgpXG5cbmxldCBnZXRfc291cmNlIGNvbnRleHQgPVxuICByZWYgKExvY2FsLnNvdXJjZSBjb250ZXh0LmxvY2FsKVxuXG5sZXQgc2V0X3NvdXJjZV9yZ2IgY29udGV4dCByIGcgYiA9XG4gIHNldF9zb3VyY2UgY29udGV4dCAoUGF0dGVybi5jcmVhdGVfcmdiIHIgZyBiKVxuXG5sZXQgc2V0X3NvdXJjZV9yZ2JhIGNvbnRleHQgciBnIGIgYSA9XG4gIHNldF9zb3VyY2UgY29udGV4dCAoUGF0dGVybi5jcmVhdGVfcmdiYSByIGcgYiBhKVxuXG5cbmxldCBfc2V0X2ZvbnQgY29udGV4dCAoe3NsYW50OyB3ZWlnaHQ7IHNpemU7IGZhbWlseX0gYXMgZm9udCkgPVxuICBMb2NhbC5zZXRfZm9udCBjb250ZXh0LmxvY2FsIH5mb250O1xuICBsZXQgZm9udF9zdHlsZSA9IG1hdGNoIHNsYW50IHdpdGhcbiAgICB8IFVwcmlnaHQgLT4gXCJub3JtYWxcIlxuICAgIHwgSXRhbGljIC0+IFwiaXRhbGljXCJcbiAgICB8IE9ibGlxdWUgLT4gXCJvYmxpcXVlXCJcbiAgYW5kIGZvbnRfd2VpZ2h0ID0gbWF0Y2ggd2VpZ2h0IHdpdGhcbiAgICB8IE5vcm1hbCAtPiBcIm5vcm1hbFwiXG4gICAgfCBCb2xkIC0+IFwiYm9sZFwiXG4gIGluXG4gIGxldCBmb250ID0gUHJpbnRmLnNwcmludGYgXCIlcyAlcyAlbnB4ICVzXCIgZm9udF9zdHlsZSBmb250X3dlaWdodCAoaW50X29mX2Zsb2F0IHNpemUpIGZhbWlseSBpblxuICBjb250ZXh0Lmh0bWwjIy5mb250IDo9IEpzLnN0cmluZyBmb250XG5cbmxldCBzZWxlY3RfZm9udF9mYWNlIGNvbnRleHQgPyhzbGFudD1VcHJpZ2h0KSA/KHdlaWdodD1Ob3JtYWwpIGZhbWlseSA9XG4gIF9zZXRfZm9udCBjb250ZXh0IHsoTG9jYWwuZm9udCBjb250ZXh0LmxvY2FsKSB3aXRoIHNsYW50OyB3ZWlnaHQ7IGZhbWlseX1cblxubGV0IHNldF9mb250X3NpemUgY29udGV4dCBzaXplID1cbiAgX3NldF9mb250IGNvbnRleHQgeyhMb2NhbC5mb250IGNvbnRleHQubG9jYWwpIHdpdGggc2l6ZX1cblxubGV0IHNob3dfdGV4dCBjb250ZXh0IHMgPVxuICBsZXQgKHgsIHkpID0gUGF0aC5nZXRfY3VycmVudF9wb2ludCBjb250ZXh0XG4gIGFuZCB3ID0gKGNvbnRleHQuaHRtbCMjbWVhc3VyZVRleHQgKEpzLnN0cmluZyBzKSkjIy53aWR0aCBpblxuICBMb2NhbC5zZXRfY3VycmVudF9wb2ludCBjb250ZXh0LmxvY2FsICh4ICsuIHcsIHkpO1xuICBjb250ZXh0Lmh0bWwjI2ZpbGxUZXh0IChKcy5zdHJpbmcgcykgeCB5XG5cbmxldCBmb250X2V4dGVudHMgY29udGV4dCA9XG4gIGxldCB7c2l6ZTsgX30gPSAoTG9jYWwuZm9udCBjb250ZXh0LmxvY2FsKSBpblxuICB7XG4gICAgYXNjZW50ID0gc2l6ZTtcbiAgICBkZXNjZW50ID0gc2l6ZSAvLiA0LjtcbiAgICBiYXNlbGluZSA9IDAuO1xuICAgIG1heF94X2FkdmFuY2UgPSAyLiAqLiBzaXplO1xuICAgIG1heF95X2FkdmFuY2UgPSAwLjtcbiAgfVxuXG5sZXQgdGV4dF9leHRlbnRzIGNvbnRleHQgcyA9XG4gIGxldCB7c2l6ZTsgX30gPSAoTG9jYWwuZm9udCBjb250ZXh0LmxvY2FsKVxuICBhbmQgdyA9IChjb250ZXh0Lmh0bWwjI21lYXN1cmVUZXh0IChKcy5zdHJpbmcgcykpIyMud2lkdGggaW5cbiAge1xuICAgIHhfYmVhcmluZyA9IDAuO1xuICAgIHlfYmVhcmluZyA9IDAuO1xuICAgIHdpZHRoID0gdztcbiAgICBoZWlnaHQgPSBzaXplO1xuICAgIHhfYWR2YW5jZSA9IHc7XG4gICAgeV9hZHZhbmNlID0gMC47XG4gIH1cblxubGV0IGNyZWF0ZSBjYW52YXMgPVxuICBsZXQgaHRtbCA9IGNhbnZhcyMjZ2V0Q29udGV4dCBEb21faHRtbC5fMmRfXG4gIGFuZCBsb2NhbCA9IExvY2FsLmNyZWF0ZSAoKSBpblxuICBsZXQgY29udGV4dCA9IHtcbiAgICBodG1sO1xuICAgIGxvY2FsO1xuICB9IGluXG4gIHNldF9saW5lX3dpZHRoIGNvbnRleHQgMi4wO1xuICBjb250ZXh0XG4iLCIoKiBDb3B5cmlnaHQgMjAxNy0yMDE4IFZpbmNlbnQgSmFjcXVlcyA8dmluY2VudEB2aW5jZW50LWphY3F1ZXMubmV0PiAqKVxuXG5vcGVuIEdlbmVyYWwuQWJiclxub3BlbiBUc3RcblxubW9kdWxlIE1ha2UoQzogQ2Fpcm9Nb2NrLlMpKE46IHNpZ1xuICB2YWwgbmFtZTogc3RyaW5nXG4gIHZhbCBjcmVhdGU6IHVuaXQgLT4gQy5jb250ZXh0XG4gIHZhbCBiYWNrZW5kOiBbYENhaXJvIHwgYE5vZGUgfCBgQnJvd3NlciB8IGBDYWlyb01vY2sgXVxuZW5kKSA9IHN0cnVjdFxuICBvcGVuIENcblxuICBsZXQgYmFja2VuZF9uYW1lID0gbWF0Y2ggTi5iYWNrZW5kIHdpdGhcbiAgICB8IGBDYWlybyAtPiBcIkNhaXJvXCJcbiAgICB8IGBOb2RlIHwgYEJyb3dzZXIgLT4gXCJKc09mT0NhaXJvXCIgKCpCSVNFQ1QtSUdOT1JFKikgKCogVGVzdCBjb2RlICopXG4gICAgfCBgQ2Fpcm9Nb2NrIC0+IFwiQ2Fpcm9Nb2NrXCJcblxuICBsZXQgY2hlY2tfbWF0cml4ID1cbiAgICBsZXQgZXF1YWwge3h4OyB4eTsgeXg7IHl5OyB4MDsgeTB9IG0gPVxuICAgICAgKFxuICAgICAgICBGbC5hcHByb3hfZXF1YWwgbS54eCB4eFxuICAgICAgICAmJiBGbC5hcHByb3hfZXF1YWwgbS54eSB4eVxuICAgICAgICAmJiBGbC5hcHByb3hfZXF1YWwgbS55eCB5eFxuICAgICAgICAmJiBGbC5hcHByb3hfZXF1YWwgbS55eSB5eVxuICAgICAgICAmJiBGbC5hcHByb3hfZXF1YWwgbS54MCB4MFxuICAgICAgICAmJiBGbC5hcHByb3hfZXF1YWwgbS55MCB5MFxuICAgICAgKVxuICAgIGFuZCByZXByIHt4eDsgeHk7IHl4OyB5eTsgeDA7IHkwfSA9XG4gICAgICBGcm10LmFwcGx5IFwie3h4PSVmOyB4eT0lZjsgeXg9JWY7IHl5PSVmOyB4MD0lZjsgeTA9JWZ9XCIgeHggeHkgeXggeXkgeDAgeTAgKCpCSVNFQ1QtSUdOT1JFKikgKCogVGVzdCBjb2RlICopXG4gICAgaW5cbiAgICBjaGVjayB+ZXF1YWwgfnJlcHJcblxuICBsZXQgY2hlY2tfY29vcmRzID9wcmVjaXNpb24gPVxuICAgIGxldCBlcXVhbCAoeDAsIHkwKSAoeDEsIHkxKSA9XG4gICAgICAoRmwuYXBwcm94X2VxdWFsID9wcmVjaXNpb24geDAgeDEgJiYgRmwuYXBwcm94X2VxdWFsID9wcmVjaXNpb24geTAgeTEpXG4gICAgYW5kIHJlcHIgKHgsIHkpID1cbiAgICAgIEZybXQuYXBwbHkgXCIoJWYsICVmKVwiIHggeSAoKkJJU0VDVC1JR05PUkUqKSAoKiBUZXN0IGNvZGUgKilcbiAgICBpblxuICAgIGNoZWNrIH5lcXVhbCB+cmVwclxuXG4gIGxldCBjaGVja19mbG9hdF90dXBsZV80ID1cbiAgICBsZXQgcmVwciAoYSwgYiwgYywgZCkgPVxuICAgICAgRnJtdC5hcHBseSBcIiglZiwgJWYsICVmLCAlZilcIiBhIGIgYyBkICgqQklTRUNULUlHTk9SRSopICgqIFRlc3QgY29kZSAqKVxuICAgIGluXG4gICAgY2hlY2tfcG9seSB+cmVwclxuXG4gIGxldCBjaGVja19mbG9hdF90dXBsZV81ID1cbiAgICBsZXQgcmVwciAoYSwgYiwgYywgZCwgZSkgPVxuICAgICAgRnJtdC5hcHBseSBcIiglZiwgJWYsICVmLCAlZiwgJWYpXCIgYSBiIGMgZCBlICgqQklTRUNULUlHTk9SRSopICgqIFRlc3QgY29kZSAqKVxuICAgIGluXG4gICAgY2hlY2tfcG9seSB+cmVwclxuXG4gIGxldCBjaGVja19mbG9hdF90dXBsZV82ID1cbiAgICBsZXQgcmVwciAoYSwgYiwgYywgZCwgZSwgZikgPVxuICAgICAgRnJtdC5hcHBseSBcIiglZiwgJWYsICVmLCAlZiwgJWYsICVmKVwiIGEgYiBjIGQgZSBmICgqQklTRUNULUlHTk9SRSopICgqIFRlc3QgY29kZSAqKVxuICAgIGluXG4gICAgY2hlY2tfcG9seSB+cmVwclxuXG4gIGxldCB0ZXN0ID0gfjo6IFwiVW5pdmVyc2FsIHRlc3RzIG9uICVzXCIgTi5uYW1lIFtcbiAgICBcInNhdmVkLWFuZC1yZXN0b3JlZCBzZXR0aW5nc1wiID46OiAoXG4gICAgICBsZXQgbWFrZSBuYW1lIHNldHRlciBnZXR0ZXIgY2hlY2sgaW5pdGlhbF92YWx1ZSBvdGhlcl92YWx1ZSBvdGhlcl92YWx1ZXMgPVxuICAgICAgICBuYW1lID46IChsYXp5IChcbiAgICAgICAgICBsZXQgY3R4ID0gTi5jcmVhdGUgKCkgaW5cbiAgICAgICAgICBjaGVjayB+ZXhwZWN0ZWQ6aW5pdGlhbF92YWx1ZSAoZ2V0dGVyIGN0eCk7XG4gICAgICAgICAgKGluaXRpYWxfdmFsdWU6Om90aGVyX3ZhbHVlOjpvdGhlcl92YWx1ZXMpXG4gICAgICAgICAgfD4gTGkuaXRlciB+ZjooZnVuIHZhbHVlIC0+XG4gICAgICAgICAgICBzZXR0ZXIgY3R4IHZhbHVlO1xuICAgICAgICAgICAgY2hlY2sgfmV4cGVjdGVkOnZhbHVlIChnZXR0ZXIgY3R4KTtcbiAgICAgICAgICAgIHNhdmUgY3R4O1xuICAgICAgICAgICAgY2hlY2sgfmV4cGVjdGVkOnZhbHVlIChnZXR0ZXIgY3R4KTtcbiAgICAgICAgICAgIHNldHRlciBjdHggb3RoZXJfdmFsdWU7XG4gICAgICAgICAgICBjaGVjayB+ZXhwZWN0ZWQ6b3RoZXJfdmFsdWUgKGdldHRlciBjdHgpO1xuICAgICAgICAgICAgcmVzdG9yZSBjdHg7XG4gICAgICAgICAgICBjaGVjayB+ZXhwZWN0ZWQ6dmFsdWUgKGdldHRlciBjdHgpO1xuICAgICAgICAgIClcbiAgICAgICAgKSlcbiAgICAgIGluXG4gICAgICBbXG4gICAgICAgIG1ha2UgXCJsaW5lX3dpZHRoXCIgc2V0X2xpbmVfd2lkdGggZ2V0X2xpbmVfd2lkdGggY2hlY2tfZmxvYXRfZXhhY3QgMi4gMS4gWzQuXTtcbiAgICAgICAgbWFrZSBcIm1pdGVyX2xpbWl0XCIgc2V0X21pdGVyX2xpbWl0IGdldF9taXRlcl9saW1pdCBjaGVja19mbG9hdF9leGFjdCAxMC4gNS4gWzIwLl07XG4gICAgICAgIChsZXQgcmVwciA9IGZ1bmN0aW9uXG4gICAgICAgICAgKCpCSVNFQ1QtSUdOT1JFLUJFR0lOKilcbiAgICAgICAgICB8IFdJTkRJTkcgLT4gXCJXSU5ESU5HXCJcbiAgICAgICAgICB8IEVWRU5fT0REIC0+IFwiRVZFTl9PRERcIlxuICAgICAgICAgICgqQklTRUNULUlHTk9SRS1FTkQqKVxuICAgICAgICBpblxuICAgICAgICBtYWtlIFwiZmlsbF9ydWxlXCIgc2V0X2ZpbGxfcnVsZSBnZXRfZmlsbF9ydWxlIChjaGVja19wb2x5IH5yZXByKSBXSU5ESU5HIEVWRU5fT0REIFtdKTtcbiAgICAgICAgKGxldCByZXByID0gZnVuY3Rpb25cbiAgICAgICAgICAoKkJJU0VDVC1JR05PUkUtQkVHSU4qKVxuICAgICAgICAgIHwgQlVUVCAtPiBcIkJVVFRcIlxuICAgICAgICAgIHwgUk9VTkQgLT4gXCJST1VORFwiXG4gICAgICAgICAgfCBTUVVBUkUgLT4gXCJTUVVBUkVcIlxuICAgICAgICAgICgqQklTRUNULUlHTk9SRS1FTkQqKVxuICAgICAgICBpblxuICAgICAgICBtYWtlIFwibGluZV9jYXBcIiBzZXRfbGluZV9jYXAgZ2V0X2xpbmVfY2FwIChjaGVja19wb2x5IH5yZXByKSBCVVRUIFJPVU5EIFtTUVVBUkVdKTtcbiAgICAgICAgKGxldCByZXByID0gZnVuY3Rpb25cbiAgICAgICAgICAoKkJJU0VDVC1JR05PUkUtQkVHSU4qKVxuICAgICAgICAgIHwgSk9JTl9NSVRFUiAtPiBcIkpPSU5fTUlURVJcIlxuICAgICAgICAgIHwgSk9JTl9ST1VORCAtPiBcIkpPSU5fUk9VTkRcIlxuICAgICAgICAgIHwgSk9JTl9CRVZFTCAtPiBcIkpPSU5fQkVWRUxcIlxuICAgICAgICAgICgqQklTRUNULUlHTk9SRS1FTkQqKVxuICAgICAgICBpblxuICAgICAgICBtYWtlIFwibGluZV9qb2luXCIgc2V0X2xpbmVfam9pbiBnZXRfbGluZV9qb2luIChjaGVja19wb2x5IH5yZXByKSBKT0lOX01JVEVSIEpPSU5fUk9VTkQgW0pPSU5fQkVWRUxdKTtcbiAgICAgICAgKGxldCByZXByID0gZnVuY3Rpb25cbiAgICAgICAgICAoKkJJU0VDVC1JR05PUkUtQkVHSU4qKVxuICAgICAgICAgIHwgQ0xFQVIgLT4gXCJDTEVBUlwiXG4gICAgICAgICAgfCBTT1VSQ0UgLT4gXCJTT1VSQ0VcIlxuICAgICAgICAgIHwgT1ZFUiAtPiBcIk9WRVJcIlxuICAgICAgICAgIHwgSU4gLT4gXCJJTlwiXG4gICAgICAgICAgfCBPVVQgLT4gXCJPVVRcIlxuICAgICAgICAgIHwgQVRPUCAtPiBcIkFUT1BcIlxuICAgICAgICAgIHwgREVTVCAtPiBcIkRFU1RcIlxuICAgICAgICAgIHwgREVTVF9PVkVSIC0+IFwiREVTVF9PVkVSXCJcbiAgICAgICAgICB8IERFU1RfSU4gLT4gXCJERVNUX0lOXCJcbiAgICAgICAgICB8IERFU1RfT1VUIC0+IFwiREVTVF9PVVRcIlxuICAgICAgICAgIHwgREVTVF9BVE9QIC0+IFwiREVTVF9BVE9QXCJcbiAgICAgICAgICB8IFhPUiAtPiBcIlhPUlwiXG4gICAgICAgICAgfCBBREQgLT4gXCJBRERcIlxuICAgICAgICAgIHwgU0FUVVJBVEUgLT4gXCJTQVRVUkFURVwiXG4gICAgICAgICAgKCpCSVNFQ1QtSUdOT1JFLUVORCopXG4gICAgICAgIGluXG4gICAgICAgIG1ha2UgXCJvcGVyYXRvclwiIHNldF9vcGVyYXRvciBnZXRfb3BlcmF0b3IgKGNoZWNrX3BvbHkgfnJlcHIpIE9WRVIgSU4gKFtPVVQ7IEFUT1A7IERFU1RfT1ZFUjsgREVTVF9JTjsgREVTVF9PVVQ7IERFU1RfQVRPUDsgWE9SOyBBRERdIEAgKGlmIE4uYmFja2VuZCA9IGBOb2RlIHx8IE4uYmFja2VuZCA9IGBCcm93c2VyIHRoZW4gW10gZWxzZSBbQ0xFQVI7IFNPVVJDRTsgREVTVDsgU0FUVVJBVEVdKSkpOyAoKkJJU0VDVC1JR05PUkUqKSAoKiBUZXN0IGNvZGUgKilcbiAgICAgICAgXCJkYXNoXCIgPjo6IFtcbiAgICAgICAgICAobGV0IHJlcHIgZGFzaGVzID1cbiAgICAgICAgICAgICgqQklTRUNULUlHTk9SRS1CRUdJTiopXG4gICAgICAgICAgICBkYXNoZXNcbiAgICAgICAgICAgIHw+IExpLm9mX2FycmF5XG4gICAgICAgICAgICB8PiBMaS5tYXAgfmY6RmwucmVwclxuICAgICAgICAgICAgfD4gU3RyTGkuam9pbiB+c2VwOlwiOyBcIlxuICAgICAgICAgICAgfD4gRnJtdC5hcHBseSBcIlt8JXN8XVwiXG4gICAgICAgICAgICAoKkJJU0VDVC1JR05PUkUtRU5EKilcbiAgICAgICAgICBpblxuICAgICAgICAgIG1ha2UgXCJkYXNoZXNcIiAoZnVuIGMgZGFzaGVzIC0+IHNldF9kYXNoIGMgZGFzaGVzKSAoZnVuIGMgLT4gZ2V0X2Rhc2ggYyB8PiBUdTIuZ2V0XzApIChjaGVja19wb2x5IH5yZXByKSBbfHxdIFt8MS47IDIufF0gKFtbfDMuOyA0LjsgNS47IDYufF07IFt8Ny47IDguOyA5LjsgMTAuOyAxMS47IDEyLnxdXSBAIChpZiBOLmJhY2tlbmQgPSBgTm9kZSB8fCBOLmJhY2tlbmQgPSBgQnJvd3NlciB0aGVuIFtdIGVsc2UgW1t8My58XTsgW3w0LjsgNS47IDYufF1dKSkpOyAoKkJJU0VDVC1JR05PUkUqKSAoKiBUZXN0IGNvZGUgKilcbiAgICAgICAgICBtYWtlIFwib2Zmc2V0XCIgKGZ1biBjIG9mcyAtPiBzZXRfZGFzaCBjIH5vZnMgW3wxMC47IDEwLnxdKSAoZnVuIGMgLT4gZ2V0X2Rhc2ggYyB8PiBUdTIuZ2V0XzEpIGNoZWNrX2Zsb2F0X2V4YWN0IDAuIDIuIFszLl07XG4gICAgICAgIF07XG4gICAgICAgIG1ha2VcbiAgICAgICAgICBcInNvdXJjZVwiXG4gICAgICAgICAgKGZ1biBjIChyLCBnLCBiLCBhKSAtPiBzZXRfc291cmNlX3JnYmEgYyByIGcgYiBhKVxuICAgICAgICAgIChmdW4gYyAtPiBnZXRfc291cmNlIGMgfD4gUGF0dGVybi5nZXRfcmdiYSlcbiAgICAgICAgICAoY2hlY2tfZmxvYXRfdHVwbGVfNClcbiAgICAgICAgICAoMC4sIDAuLCAwLiwgMS4pXG4gICAgICAgICAgKDEuLCAwLiwgMC4sIDAuNSlcbiAgICAgICAgICBbKDAuLCAwLiwgMS4sIDAuNyldXG4gICAgICAgIDtcbiAgICAgIF1cbiAgICApO1xuICAgIFwic3RhdHVzX3RvX3N0cmluZ1wiID46OiAoXG4gICAgICBsZXQgbWFrZSBuYW1lIHN0YXR1cyBleHBlY3RlZCA9XG4gICAgICAgIG5hbWUgPjogKGxhenkgKFxuICAgICAgICAgIGNoZWNrX3N0cmluZyB+ZXhwZWN0ZWQgKHN0YXR1c190b19zdHJpbmcgc3RhdHVzKVxuICAgICAgICApKVxuICAgICAgaW5cbiAgICAgIFtcbiAgICAgICAgbWFrZSBcIklOVkFMSURfUkVTVE9SRVwiIElOVkFMSURfUkVTVE9SRSBcImNhaXJvX3Jlc3RvcmUoKSB3aXRob3V0IG1hdGNoaW5nIGNhaXJvX3NhdmUoKVwiO1xuICAgICAgICBtYWtlIFwiSU5WQUxJRF9QT1BfR1JPVVBcIiBJTlZBTElEX1BPUF9HUk9VUCBcIm5vIHNhdmVkIGdyb3VwIHRvIHBvcCwgaS5lLiBjYWlyb19wb3BfZ3JvdXAoKSB3aXRob3V0IG1hdGNoaW5nIGNhaXJvX3B1c2hfZ3JvdXAoKVwiO1xuICAgICAgICBtYWtlIFwiTk9fQ1VSUkVOVF9QT0lOVFwiIE5PX0NVUlJFTlRfUE9JTlQgXCJubyBjdXJyZW50IHBvaW50IGRlZmluZWRcIjtcbiAgICAgICAgbWFrZSBcIklOVkFMSURfTUFUUklYXCIgSU5WQUxJRF9NQVRSSVggXCJpbnZhbGlkIG1hdHJpeCAobm90IGludmVydGlibGUpXCI7XG4gICAgICAgIG1ha2UgXCJJTlZBTElEX1NUQVRVU1wiIElOVkFMSURfU1RBVFVTIFwiaW52YWxpZCB2YWx1ZSBmb3IgYW4gaW5wdXQgY2Fpcm9fc3RhdHVzX3RcIjtcbiAgICAgICAgbWFrZSBcIk5VTExfUE9JTlRFUlwiIE5VTExfUE9JTlRFUiBcIk5VTEwgcG9pbnRlclwiO1xuICAgICAgICBtYWtlIFwiSU5WQUxJRF9TVFJJTkdcIiBJTlZBTElEX1NUUklORyBcImlucHV0IHN0cmluZyBub3QgdmFsaWQgVVRGLThcIjtcbiAgICAgICAgbWFrZSBcIklOVkFMSURfUEFUSF9EQVRBXCIgSU5WQUxJRF9QQVRIX0RBVEEgXCJpbnB1dCBwYXRoIGRhdGEgbm90IHZhbGlkXCI7XG4gICAgICAgIG1ha2UgXCJSRUFEX0VSUk9SXCIgUkVBRF9FUlJPUiBcImVycm9yIHdoaWxlIHJlYWRpbmcgZnJvbSBpbnB1dCBzdHJlYW1cIjtcbiAgICAgICAgbWFrZSBcIldSSVRFX0VSUk9SXCIgV1JJVEVfRVJST1IgXCJlcnJvciB3aGlsZSB3cml0aW5nIHRvIG91dHB1dCBzdHJlYW1cIjtcbiAgICAgICAgbWFrZSBcIlNVUkZBQ0VfRklOSVNIRURcIiBTVVJGQUNFX0ZJTklTSEVEIFwidGhlIHRhcmdldCBzdXJmYWNlIGhhcyBiZWVuIGZpbmlzaGVkXCI7XG4gICAgICAgIG1ha2UgXCJTVVJGQUNFX1RZUEVfTUlTTUFUQ0hcIiBTVVJGQUNFX1RZUEVfTUlTTUFUQ0ggXCJ0aGUgc3VyZmFjZSB0eXBlIGlzIG5vdCBhcHByb3ByaWF0ZSBmb3IgdGhlIG9wZXJhdGlvblwiO1xuICAgICAgICBtYWtlIFwiUEFUVEVSTl9UWVBFX01JU01BVENIXCIgUEFUVEVSTl9UWVBFX01JU01BVENIIFwidGhlIHBhdHRlcm4gdHlwZSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoZSBvcGVyYXRpb25cIjtcbiAgICAgICAgbWFrZSBcIklOVkFMSURfQ09OVEVOVFwiIElOVkFMSURfQ09OVEVOVCBcImludmFsaWQgdmFsdWUgZm9yIGFuIGlucHV0IGNhaXJvX2NvbnRlbnRfdFwiO1xuICAgICAgICBtYWtlIFwiSU5WQUxJRF9GT1JNQVRcIiBJTlZBTElEX0ZPUk1BVCBcImludmFsaWQgdmFsdWUgZm9yIGFuIGlucHV0IGNhaXJvX2Zvcm1hdF90XCI7XG4gICAgICAgIG1ha2UgXCJJTlZBTElEX1ZJU1VBTFwiIElOVkFMSURfVklTVUFMIFwiaW52YWxpZCB2YWx1ZSBmb3IgYW4gaW5wdXQgVmlzdWFsKlwiO1xuICAgICAgICBtYWtlIFwiRklMRV9OT1RfRk9VTkRcIiBGSUxFX05PVF9GT1VORCBcImZpbGUgbm90IGZvdW5kXCI7XG4gICAgICAgIG1ha2UgXCJJTlZBTElEX0RBU0hcIiBJTlZBTElEX0RBU0ggXCJpbnZhbGlkIHZhbHVlIGZvciBhIGRhc2ggc2V0dGluZ1wiO1xuICAgICAgICBtYWtlIFwiSU5WQUxJRF9EU0NfQ09NTUVOVFwiIElOVkFMSURfRFNDX0NPTU1FTlQgXCJpbnZhbGlkIHZhbHVlIGZvciBhIERTQyBjb21tZW50XCI7XG4gICAgICAgIG1ha2UgXCJJTlZBTElEX0lOREVYXCIgSU5WQUxJRF9JTkRFWCBcImludmFsaWQgaW5kZXggcGFzc2VkIHRvIGdldHRlclwiO1xuICAgICAgICBtYWtlIFwiQ0xJUF9OT1RfUkVQUkVTRU5UQUJMRVwiIENMSVBfTk9UX1JFUFJFU0VOVEFCTEUgXCJjbGlwIHJlZ2lvbiBub3QgcmVwcmVzZW50YWJsZSBpbiBkZXNpcmVkIGZvcm1hdFwiO1xuICAgICAgICBtYWtlIFwiVEVNUF9GSUxFX0VSUk9SXCIgVEVNUF9GSUxFX0VSUk9SIFwiZXJyb3IgY3JlYXRpbmcgb3Igd3JpdGluZyB0byBhIHRlbXBvcmFyeSBmaWxlXCI7XG4gICAgICAgIG1ha2UgXCJJTlZBTElEX1NUUklERVwiIElOVkFMSURfU1RSSURFIFwiaW52YWxpZCB2YWx1ZSBmb3Igc3RyaWRlXCI7XG4gICAgICAgIG1ha2UgXCJGT05UX1RZUEVfTUlTTUFUQ0hcIiBGT05UX1RZUEVfTUlTTUFUQ0ggXCJ0aGUgZm9udCB0eXBlIGlzIG5vdCBhcHByb3ByaWF0ZSBmb3IgdGhlIG9wZXJhdGlvblwiO1xuICAgICAgICBtYWtlIFwiVVNFUl9GT05UX0lNTVVUQUJMRVwiIFVTRVJfRk9OVF9JTU1VVEFCTEUgXCJ0aGUgdXNlci1mb250IGlzIGltbXV0YWJsZVwiO1xuICAgICAgICBtYWtlIFwiVVNFUl9GT05UX0VSUk9SXCIgVVNFUl9GT05UX0VSUk9SIFwiZXJyb3Igb2NjdXJyZWQgaW4gYSB1c2VyLWZvbnQgY2FsbGJhY2sgZnVuY3Rpb25cIjtcbiAgICAgICAgbWFrZSBcIk5FR0FUSVZFX0NPVU5UXCIgTkVHQVRJVkVfQ09VTlQgXCJuZWdhdGl2ZSBudW1iZXIgdXNlZCB3aGVyZSBpdCBpcyBub3QgYWxsb3dlZFwiO1xuICAgICAgICBtYWtlIFwiSU5WQUxJRF9DTFVTVEVSU1wiIElOVkFMSURfQ0xVU1RFUlMgXCJpbnB1dCBjbHVzdGVycyBkbyBub3QgcmVwcmVzZW50IHRoZSBhY2NvbXBhbnlpbmcgdGV4dCBhbmQgZ2x5cGggYXJyYXlzXCI7XG4gICAgICAgIG1ha2UgXCJJTlZBTElEX1NMQU5UXCIgSU5WQUxJRF9TTEFOVCBcImludmFsaWQgdmFsdWUgZm9yIGFuIGlucHV0IGNhaXJvX2ZvbnRfc2xhbnRfdFwiO1xuICAgICAgICBtYWtlIFwiSU5WQUxJRF9XRUlHSFRcIiBJTlZBTElEX1dFSUdIVCBcImludmFsaWQgdmFsdWUgZm9yIGFuIGlucHV0IGNhaXJvX2ZvbnRfd2VpZ2h0X3RcIjtcbiAgICAgICAgbWFrZSBcIklOVkFMSURfU0laRVwiIElOVkFMSURfU0laRSBcImludmFsaWQgdmFsdWUgKHR5cGljYWxseSB0b28gYmlnKSBmb3IgdGhlIHNpemUgb2YgdGhlIGlucHV0IChzdXJmYWNlLCBwYXR0ZXJuLCBldGMuKVwiO1xuICAgICAgICBtYWtlIFwiVVNFUl9GT05UX05PVF9JTVBMRU1FTlRFRFwiIFVTRVJfRk9OVF9OT1RfSU1QTEVNRU5URUQgXCJ1c2VyLWZvbnQgbWV0aG9kIG5vdCBpbXBsZW1lbnRlZFwiO1xuICAgICAgICBtYWtlIFwiREVWSUNFX1RZUEVfTUlTTUFUQ0hcIiBERVZJQ0VfVFlQRV9NSVNNQVRDSCBcInRoZSBkZXZpY2UgdHlwZSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoZSBvcGVyYXRpb25cIjtcbiAgICAgICAgbWFrZSBcIkRFVklDRV9FUlJPUlwiIERFVklDRV9FUlJPUiBcImFuIG9wZXJhdGlvbiB0byB0aGUgZGV2aWNlIGNhdXNlZCBhbiB1bnNwZWNpZmllZCBlcnJvclwiO1xuICAgICAgICBtYWtlIFwiSU5WQUxJRF9NRVNIX0NPTlNUUlVDVElPTlwiIElOVkFMSURfTUVTSF9DT05TVFJVQ1RJT04gXCJpbnZhbGlkIG9wZXJhdGlvbiBkdXJpbmcgbWVzaCBwYXR0ZXJuIGNvbnN0cnVjdGlvblwiO1xuICAgICAgICBtYWtlIFwiREVWSUNFX0ZJTklTSEVEXCIgREVWSUNFX0ZJTklTSEVEIFwidGhlIHRhcmdldCBkZXZpY2UgaGFzIGJlZW4gZmluaXNoZWRcIjtcbiAgICAgICAgbWFrZSBcIkpCSUcyX0dMT0JBTF9NSVNTSU5HXCIgSkJJRzJfR0xPQkFMX01JU1NJTkcgXCJDQUlST19NSU1FX1RZUEVfSkJJRzJfR0xPQkFMX0lEIHVzZWQgYnV0IG5vIENBSVJPX01JTUVfVFlQRV9KQklHMl9HTE9CQUwgZGF0YSBwcm92aWRlZFwiO1xuICAgICAgXVxuICAgICk7XG4gICAgXCJleGNlcHRpb25zXCIgPjo6IFtcbiAgICAgIFwiQ2Fpcm8gRXJyb3JcIiA+OiAobGF6eSAoXG4gICAgICAgIGNoZWNrX3N0cmluZyB+ZXhwZWN0ZWQ6KEZybXQuYXBwbHkgXCIlcy5FcnJvcihJTlZBTElEX1JFU1RPUkUpXCIgYmFja2VuZF9uYW1lKSAoRXhuLnRvX3N0cmluZyAoRXJyb3IgSU5WQUxJRF9SRVNUT1JFKSk7XG4gICAgICApKTtcbiAgICAgIFwiTm90IENhaXJvXCIgPjogKGxhenkgKFxuICAgICAgICAoKiBUaGlzIHRlc3QgY292ZXJzIHRoZSBOb25lIGNhc2UgaW4gdGhlIHJlZ2lzdGVyZWQgcHJpbnRlciAqKVxuICAgICAgICBjaGVja19zdHJpbmcgfmV4cGVjdGVkOlwiTm90X2ZvdW5kXCIgKEV4bi50b19zdHJpbmcgTm90X2ZvdW5kKTtcbiAgICAgICkpXG4gICAgXTtcbiAgICBcInRyYW5zZm9ybWF0aW9uc1wiID46OiAoXG4gICAgICBsZXQgaWRlbnRpdHkgPSB7eHg9MS47IHh5PTAuOyB5eD0wLjsgeXk9MS47IHgwPTAuOyB5MD0wLn0gaW5cbiAgICAgIGxldCBtYWtlIG5hbWUgZiBleHBlY3RlZCA9XG4gICAgICAgIG5hbWUgPjogKGxhenkgKFxuICAgICAgICAgIGxldCBjdHggPSBOLmNyZWF0ZSAoKSBpblxuICAgICAgICAgIGNoZWNrX21hdHJpeCB+ZXhwZWN0ZWQ6aWRlbnRpdHkgKGdldF9tYXRyaXggY3R4KTtcbiAgICAgICAgICBmIGN0eDtcbiAgICAgICAgICBjaGVja19tYXRyaXggfmV4cGVjdGVkIChnZXRfbWF0cml4IGN0eCk7XG4gICAgICAgICAgc2F2ZSBjdHg7XG4gICAgICAgICAgY2hlY2tfbWF0cml4IH5leHBlY3RlZCAoZ2V0X21hdHJpeCBjdHgpO1xuICAgICAgICAgIGlkZW50aXR5X21hdHJpeCBjdHg7XG4gICAgICAgICAgY2hlY2tfbWF0cml4IH5leHBlY3RlZDppZGVudGl0eSAoZ2V0X21hdHJpeCBjdHgpO1xuICAgICAgICAgIHJlc3RvcmUgY3R4O1xuICAgICAgICAgIGNoZWNrX21hdHJpeCB+ZXhwZWN0ZWQgKGdldF9tYXRyaXggY3R4KTtcbiAgICAgICAgKSlcbiAgICAgIGluXG4gICAgICBbXG4gICAgICAgIG1ha2UgXCJ0cmFuc2xhdGVcIiAoZnVuIGMgLT4gdHJhbnNsYXRlIGMgMi4gMy4pIHt4eD0xLjsgeHk9MC47IHl4PTAuOyB5eT0xLjsgeDA9Mi47IHkwPTMufTtcbiAgICAgICAgbWFrZSBcInNjYWxlXCIgKGZ1biBjIC0+IHNjYWxlIGMgMi4gMy4pIHt4eD0yLjsgeHk9MC47IHl4PTAuOyB5eT0zLjsgeDA9MC47IHkwPTAufTtcbiAgICAgICAgbWFrZSBcInJvdGF0ZVwiIChmdW4gYyAtPiByb3RhdGUgYyAoRmwucGkgLy4gNC4pKSAobGV0IHMgPSBGbC5zcXJ0KDIuKSAvLiAyLiBpbiB7eHg9czsgeHk9KC0ucyk7IHl4PXM7IHl5PXM7IHgwPTAuOyB5MD0wLn0pO1xuICAgICAgICBtYWtlIFwic2V0X21hdHJpeFwiIChmdW4gYyAtPiBzZXRfbWF0cml4IGMge3h4PTEuOyB4eT0yLjsgeXg9My47IHl5PTQuOyB4MD01LjsgeTA9Ni59KSB7eHg9MS47IHh5PTIuOyB5eD0zLjsgeXk9NC47IHgwPTUuOyB5MD02Ln07XG4gICAgICAgIG1ha2UgXCJ0cmFuc2Zvcm1cIiAoZnVuIGMgLT4gc2NhbGUgYyAyLiAzLjsgdHJhbnNmb3JtIGMge3h4PTEuOyB4eT0yLjsgeXg9My47IHl5PTQuOyB4MD01LjsgeTA9Ni59KSB7eHg9Mi47IHh5PTQuOyB5eD05LjsgeXk9MTIuOyB4MD0xMC47IHkwPTE4Ln07XG4gICAgICBdXG4gICAgKTtcbiAgICBcIm1hdHJpeFwiID46OiBbXG4gICAgICBcImluaXRfaWRlbnRpdHlcIiA+OiAobGF6eSAoXG4gICAgICAgIGNoZWNrX21hdHJpeCB+ZXhwZWN0ZWQ6e3h4PTEuOyB4eT0wLjsgeXg9MC47IHl5PTEuOyB4MD0wLjsgeTA9MC59IChNYXRyaXguaW5pdF9pZGVudGl0eSAoKSlcbiAgICAgICkpO1xuICAgICAgXCJpbml0X3RyYW5zbGF0ZVwiID46IChsYXp5IChcbiAgICAgICAgY2hlY2tfbWF0cml4IH5leHBlY3RlZDp7eHg9MS47IHh5PTAuOyB5eD0wLjsgeXk9MS47IHgwPTIuOyB5MD0zLn0gKE1hdHJpeC5pbml0X3RyYW5zbGF0ZSAyLiAzLilcbiAgICAgICkpO1xuICAgICAgXCJpbml0X3NjYWxlXCIgPjogKGxhenkgKFxuICAgICAgICBjaGVja19tYXRyaXggfmV4cGVjdGVkOnt4eD0yLjsgeHk9MC47IHl4PTAuOyB5eT0zLjsgeDA9MC47IHkwPTAufSAoTWF0cml4LmluaXRfc2NhbGUgMi4gMy4pXG4gICAgICApKTtcbiAgICAgIFwiaW5pdF9yb3RhdGVcIiA+OiAobGF6eSAoXG4gICAgICAgIGNoZWNrX21hdHJpeCB+ZXhwZWN0ZWQ6e3h4PShGbC5zcXJ0IDMuIC8uIDIuKTsgeHk9KC0wLjUpOyB5eD0wLjU7IHl5PShGbC5zcXJ0IDMuIC8uIDIuKTsgeDA9MC47IHkwPTAufSAoTWF0cml4LmluaXRfcm90YXRlIChGbC5waSAvLiA2LikpXG4gICAgICApKTtcbiAgICAgIFwiaW52ZXJ0XCIgPjo6IFtcbiAgICAgICAgXCJub24gaW52ZXJ0aWJsZVwiID46IChsYXp5IChcbiAgICAgICAgICBleHBlY3RfZXhjZXB0aW9uIH5leHBlY3RlZDooRXJyb3IgSU5WQUxJRF9NQVRSSVgpIChsYXp5IChcbiAgICAgICAgICAgIGxldCBtID0ge3h4PTEuOyB4eT0yLjsgeXg9MS47IHl5PTIuOyB4MD0zLjsgeTA9NC59IGluXG4gICAgICAgICAgICBNYXRyaXguaW52ZXJ0IG1cbiAgICAgICAgICApKVxuICAgICAgICApKTtcbiAgICAgICAgXCJpbnZlcnRpYmxlXCIgPjogKGxhenkgKFxuICAgICAgICAgIGxldCBtID0ge3h4PTEuOyB4eT0yLjsgeXg9My47IHl5PTQuOyB4MD01LjsgeTA9Ni59IGluXG4gICAgICAgICAgTWF0cml4LmludmVydCBtO1xuICAgICAgICAgIGNoZWNrX21hdHJpeCB+ZXhwZWN0ZWQ6e3h4PSgtMi4pOyB4eT0xLjsgeXg9MS41OyB5eT0oLTAuNSk7IHgwPTQuOyB5MD0oLTQuNSl9IG1cbiAgICAgICAgKSk7XG4gICAgICBdO1xuICAgICAgXCJzY2FsZVwiID46IChsYXp5IChcbiAgICAgICAgbGV0IG0gPSB7eHg9MS47IHh5PTIuOyB5eD0zLjsgeXk9NC47IHgwPTUuOyB5MD02Ln0gaW5cbiAgICAgICAgTWF0cml4LnNjYWxlIG0gNy4gOC47XG4gICAgICAgIGNoZWNrX21hdHJpeCB+ZXhwZWN0ZWQ6e3h4PTcuOyB4eT0xNi47IHl4PTIxLjsgeXk9MzIuOyB4MD01LjsgeTA9Ni59IG1cbiAgICAgICkpO1xuICAgICAgXCJ0cmFuc2xhdGVcIiA+OiAobGF6eSAoXG4gICAgICAgIGxldCBtID0ge3h4PTEuOyB4eT0yLjsgeXg9My47IHl5PTQuOyB4MD01LjsgeTA9Ni59IGluXG4gICAgICAgIE1hdHJpeC50cmFuc2xhdGUgbSA3LiA4LjtcbiAgICAgICAgY2hlY2tfbWF0cml4IH5leHBlY3RlZDp7eHg9MS47IHh5PTIuOyB5eD0zLjsgeXk9NC47IHgwPTI4LjsgeTA9NTkufSBtXG4gICAgICApKTtcbiAgICAgIFwicm90YXRlXCIgPjogKGxhenkgKFxuICAgICAgICBsZXQgbSA9IHt4eD0xLjsgeHk9Mi47IHl4PTMuOyB5eT00LjsgeDA9NS47IHkwPTYufSBpblxuICAgICAgICBNYXRyaXgucm90YXRlIG0gKEZsLnBpIC8uIDYuKTtcbiAgICAgICAgbGV0IHMgPSBGbC5zcXJ0IDMuIC8uIDIuIGluXG4gICAgICAgIGNoZWNrX21hdHJpeCB+ZXhwZWN0ZWQ6e3h4PShzICsuIDEuKTsgeHk9KDIuICouIHMgLS4gMC41KTsgeXg9KDMuICouIHMgKy4gMi4pOyB5eT0oNC4gKi4gcyAtLiAxLjUpOyB4MD01LjsgeTA9Ni59IG1cbiAgICAgICkpO1xuICAgIF07XG4gICAgXCJjb29yZGluYXRlcyB0cmFuc2Zvcm1hdGlvblwiID46IChsYXp5IChcbiAgICAgIGxldCBjdHggPSBOLmNyZWF0ZSAoKVxuICAgICAgYW5kIG0gPSB7eHg9MS47IHh5PTIuOyB5eD0zLjsgeXk9NC47IHgwPTUuOyB5MD02Ln0gaW5cbiAgICAgIHNldF9tYXRyaXggY3R4IG07XG4gICAgICBjaGVja19jb29yZHMgfmV4cGVjdGVkOigtMi4sIDIuKSAoZGV2aWNlX3RvX3VzZXIgY3R4IDcuIDguKTtcbiAgICAgIGNoZWNrX2Nvb3JkcyB+ZXhwZWN0ZWQ6KC02LiwgNi41KSAoZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2UgY3R4IDcuIDguKTtcbiAgICAgIGNoZWNrX2Nvb3JkcyB+ZXhwZWN0ZWQ6KDI4LiwgNTkuKSAodXNlcl90b19kZXZpY2UgY3R4IDcuIDguKTtcbiAgICAgIGNoZWNrX2Nvb3JkcyB+ZXhwZWN0ZWQ6KDIzLiwgNTMuKSAodXNlcl90b19kZXZpY2VfZGlzdGFuY2UgY3R4IDcuIDguKTtcbiAgICAgIGNoZWNrX2Nvb3JkcyB+ZXhwZWN0ZWQ6KDI4LiwgNTkuKSAoTWF0cml4LnRyYW5zZm9ybV9wb2ludCBtIDcuIDguKTtcbiAgICAgIGNoZWNrX2Nvb3JkcyB+ZXhwZWN0ZWQ6KDIzLiwgNTMuKSAoTWF0cml4LnRyYW5zZm9ybV9kaXN0YW5jZSBtIH5keDo3LiB+ZHk6OC4pO1xuICAgICkpO1xuICAgIFwiaW52YWxpZCByZXN0b3JlXCIgPjogKGxhenkgKFxuICAgICAgbGV0IGN0eCA9IE4uY3JlYXRlICgpIGluXG4gICAgICBleHBlY3RfZXhjZXB0aW9uIH5leHBlY3RlZDooRXJyb3IgSU5WQUxJRF9SRVNUT1JFKSAobGF6eSAocmVzdG9yZSBjdHgpKVxuICAgICkpO1xuICAgIFwibm8gY3VycmVudCBwb2ludFwiID46OiAoXG4gICAgICBsZXQgbWFrZSBuYW1lIGYgPVxuICAgICAgICBuYW1lID46IChsYXp5IChcbiAgICAgICAgICBsZXQgY3R4ID0gTi5jcmVhdGUgKCkgaW5cbiAgICAgICAgICBleHBlY3RfZXhjZXB0aW9uIH5leHBlY3RlZDooRXJyb3IgTk9fQ1VSUkVOVF9QT0lOVCkgKGxhenkgKGYgY3R4KSlcbiAgICAgICAgKSlcbiAgICAgIGluXG4gICAgICBbXG4gICAgICAgIG1ha2UgXCJyZWxfbW92ZV90b1wiIChmdW4gYyAtPiByZWxfbW92ZV90byBjIDEuIDIuKTtcbiAgICAgICAgbWFrZSBcInJlbF9saW5lX3RvXCIgKGZ1biBjIC0+IHJlbF9saW5lX3RvIGMgMS4gMi4pO1xuICAgICAgICBtYWtlIFwicmVsX2N1cnZlX3RvXCIgKGZ1biBjIC0+IHJlbF9jdXJ2ZV90byBjIDEuIDIuIDMuIDQuIDUuIDYuKTtcbiAgICAgICAgbWFrZSBcIlBhdGguY2xlYXJcIiAoZnVuIGMgLT4gbW92ZV90byBjIDEuIDIuOyBQYXRoLmNsZWFyIGM7IHJlbF9tb3ZlX3RvIGMgMy4gNC4pO1xuICAgICAgICBtYWtlIFwic3Ryb2tlXCIgKGZ1biBjIC0+IG1vdmVfdG8gYyAxLiAyLjsgbGluZV90byBjIDMuIDQuOyBzdHJva2UgYzsgcmVsX21vdmVfdG8gYyAzLiA0Lik7XG4gICAgICAgIG1ha2UgXCJmaWxsXCIgKGZ1biBjIC0+IG1vdmVfdG8gYyAxLiAyLjsgbGluZV90byBjIDMuIDQuOyBmaWxsIGM7IHJlbF9tb3ZlX3RvIGMgMy4gNC4pO1xuICAgICAgICBtYWtlIFwiY2xpcFwiIChmdW4gYyAtPiBtb3ZlX3RvIGMgMS4gMi47IGxpbmVfdG8gYyAzLiA0LjsgY2xpcCBjOyByZWxfbW92ZV90byBjIDMuIDQuKTtcbiAgICAgIF1cbiAgICApO1xuICAgIFwiY3VycmVudCBwb2ludFwiID46OiAoXG4gICAgICBsZXQgbWFrZScgbmFtZSBmIGNoZWNrID1cbiAgICAgICAgbmFtZSA+OiAobGF6eSAoXG4gICAgICAgICAgbGV0IGN0eCA9IE4uY3JlYXRlICgpIGluXG4gICAgICAgICAgZiBjdHg7XG4gICAgICAgICAgY2hlY2sgKFBhdGguZ2V0X2N1cnJlbnRfcG9pbnQgY3R4KVxuICAgICAgICApKVxuICAgICAgaW5cbiAgICAgIGxldCBtYWtlIG5hbWUgZiBleHBlY3RlZCA9XG4gICAgICAgICgqIExvdyBwcmVjaXNpb24gYmVjYXVzZSBDYWlybyBtYWtlcyBhcHByb3hpbWF0aW9ucyBvbiBhcmNzICopXG4gICAgICAgIG1ha2UnIG5hbWUgZiAoY2hlY2tfY29vcmRzIH5wcmVjaXNpb246MWUtMyB+ZXhwZWN0ZWQpXG4gICAgICBpblxuICAgICAgW1xuICAgICAgICBtYWtlIFwibm8tb3BcIiAoZnVuIF8gLT4gKCkpICgwLiwgMC4pO1xuICAgICAgICBtYWtlIFwibW92ZV90b1wiIChmdW4gYyAtPiBtb3ZlX3RvIGMgMS4gMi4pICgxLiwgMi4pO1xuICAgICAgICBtYWtlIFwicGFpbnRcIiBwYWludCAoMC4sIDAuKTtcbiAgICAgICAgbWFrZSBcIm1vdmVfdG8sIHBhaW50XCIgKGZ1biBjIC0+IG1vdmVfdG8gYyAxLiAyLjsgcGFpbnQgYykgKDEuLCAyLik7XG4gICAgICAgIG1ha2UgXCJzYXZlLCBtb3ZlX3RvLCByZXN0b3JlXCJcbiAgICAgICAgICAoZnVuIGMgLT5cbiAgICAgICAgICAgIHNhdmUgYztcbiAgICAgICAgICAgIG1vdmVfdG8gYyAxLiAyLjtcbiAgICAgICAgICAgIHJlc3RvcmUgYztcbiAgICAgICAgICApXG4gICAgICAgICAgKDEuLCAyLik7XG4gICAgICAgIG1ha2UgXCJzYXZlLCBzY2FsZSwgbW92ZV90bywgcmVzdG9yZVwiXG4gICAgICAgICAgKGZ1biBjIC0+XG4gICAgICAgICAgICBzYXZlIGM7XG4gICAgICAgICAgICBzY2FsZSBjIDMuIDQuO1xuICAgICAgICAgICAgbW92ZV90byBjIDEuIDIuO1xuICAgICAgICAgICAgcmVzdG9yZSBjO1xuICAgICAgICAgIClcbiAgICAgICAgICAoMy4sIDguKTtcbiAgICAgICAgbWFrZSBcInJlbF9tb3ZlX3RvXCIgKGZ1biBjIC0+IG1vdmVfdG8gYyAxLiAyLjsgcmVsX21vdmVfdG8gYyAzLiA0LikgKDQuLCA2Lik7XG4gICAgICAgIG1ha2UgXCJsaW5lX3RvXCIgKGZ1biBjIC0+IGxpbmVfdG8gYyAxLiAyLikgKDEuLCAyLik7XG4gICAgICAgIG1ha2UgXCJyZWxfbGluZV90b1wiIChmdW4gYyAtPiBtb3ZlX3RvIGMgMS4gMi47IHJlbF9saW5lX3RvIGMgMy4gNC4pICg0LiwgNi4pO1xuICAgICAgICBtYWtlIFwicmVjdGFuZ2xlXCIgKGZ1biBjIC0+IHJlY3RhbmdsZSBjIDEuIDIuIH53OjMuIH5oOjQuKSAoMS4sIDIuKTtcbiAgICAgICAgXCJhcmNcIiA+OjogW1xuICAgICAgICAgIG1ha2UgXCIwXCIgKGZ1biBjIC0+IGFyYyBjIDEuIDIuIH5yOjMuIH5hMTooLTEuKSB+YTI6MC4pICg0LiwgMi4pO1xuICAgICAgICAgIG1ha2UgXCJwaSAvIDZcIiAoZnVuIGMgLT4gYXJjIGMgMS4gMi4gfnI6My4gfmExOigtMS4pIH5hMjooRmwucGkgLy4gNi4pKSAoMS4gKy4gMy4gKi4gRmwuc3FydCgzLikgLy4gMi4sIDIuICsuIDMuICouIDAuNSk7XG4gICAgICAgICAgbWFrZSBcInBpIC8gNFwiIChmdW4gYyAtPiBhcmMgYyAxLiAyLiB+cjozLiB+YTE6MC4gfmEyOihGbC5waSAvLiA0LikpICgxLiArLiAzLiAqLiBGbC5zcXJ0KDIuKSAvLiAyLiwgMi4gKy4gMy4gKi4gRmwuc3FydCgyLikgLy4gMi4pO1xuICAgICAgICAgIG1ha2UgXCJwaSAvIDJcIiAoZnVuIGMgLT4gYXJjIGMgMS4gMi4gfnI6My4gfmExOigtMS4pIH5hMjooRmwucGkgLy4gMi4pKSAoMS4sIDUuKTtcbiAgICAgICAgICBtYWtlIFwiMyBwaVwiIChmdW4gYyAtPiBhcmMgYyAxLiAyLiB+cjozLiB+YTE6KEZsLnBpIC8uIDIuKSB+YTI6KDMuICouIEZsLnBpKSkgKC0yLiwgMi4pO1xuICAgICAgICBdO1xuICAgICAgICBcImFyY19uZWdhdGl2ZVwiID46OiBbXG4gICAgICAgICAgbWFrZSBcIjBcIiAoZnVuIGMgLT4gYXJjX25lZ2F0aXZlIGMgMS4gMi4gfnI6My4gfmExOigtMS4pIH5hMjowLikgKDQuLCAyLik7XG4gICAgICAgICAgbWFrZSBcInBpIC8gNlwiIChmdW4gYyAtPiBhcmNfbmVnYXRpdmUgYyAxLiAyLiB+cjozLiB+YTE6KC0xLikgfmEyOihGbC5waSAvLiA2LikpICgxLiArLiAzLiAqLiBGbC5zcXJ0KDMuKSAvLiAyLiwgMi4gKy4gMy4gKi4gMC41KTtcbiAgICAgICAgICBtYWtlIFwicGkgLyA0XCIgKGZ1biBjIC0+IGFyY19uZWdhdGl2ZSBjIDEuIDIuIH5yOjMuIH5hMTowLiB+YTI6KEZsLnBpIC8uIDQuKSkgKDEuICsuIDMuICouIEZsLnNxcnQoMi4pIC8uIDIuLCAyLiArLiAzLiAqLiBGbC5zcXJ0KDIuKSAvLiAyLik7XG4gICAgICAgICAgbWFrZSBcInBpIC8gMlwiIChmdW4gYyAtPiBhcmNfbmVnYXRpdmUgYyAxLiAyLiB+cjozLiB+YTE6KC0xLikgfmEyOihGbC5waSAvLiAyLikpICgxLiwgNS4pO1xuICAgICAgICBdO1xuICAgICAgICBtYWtlIFwiY3VydmVfdG9cIiAoZnVuIGMgLT4gY3VydmVfdG8gYyAxLiAyLiAzLiA0LiA1LiA2LikgKDUuLCA2Lik7XG4gICAgICAgIG1ha2UgXCJyZWxfbGluZV90b1wiIChmdW4gYyAtPiBtb3ZlX3RvIGMgMS4gMi47IHJlbF9jdXJ2ZV90byBjIDEuIDIuIDMuIDQuIDUuIDYuKSAoNi4sIDguKTtcbiAgICAgICAgbWFrZSBcIlBhdGguY2xvc2VcIiAoZnVuIGMgLT4gbW92ZV90byBjIDEuIDIuOyBsaW5lX3RvIGMgMy4gNC47IGxpbmVfdG8gYyA1LiA2LjsgUGF0aC5jbG9zZSBjKSAoMS4sIDIuKTtcbiAgICAgICAgbWFrZSBcInN0cm9rZV9wcmVzZXJ2ZVwiIChmdW4gYyAtPiBtb3ZlX3RvIGMgMS4gMi47IGxpbmVfdG8gYyAzLiA0Ljsgc3Ryb2tlX3ByZXNlcnZlIGMpICgzLiwgNC4pO1xuICAgICAgICBtYWtlIFwiZmlsbF9wcmVzZXJ2ZVwiIChmdW4gYyAtPiBtb3ZlX3RvIGMgMS4gMi47IGxpbmVfdG8gYyAzLiA0LjsgZmlsbF9wcmVzZXJ2ZSBjKSAoMy4sIDQuKTtcbiAgICAgICAgbWFrZSBcImNsaXBfcHJlc2VydmVcIiAoZnVuIGMgLT4gbW92ZV90byBjIDEuIDIuOyBsaW5lX3RvIGMgMy4gNC47IGNsaXBfcHJlc2VydmUgYykgKDMuLCA0Lik7XG4gICAgICAgIG1ha2UnIFwic2hvd190ZXh0XCIgKGZ1biBjIC0+IG1vdmVfdG8gYyAxLiAyLjsgc2hvd190ZXh0IGMgXCJIZWxsb1wiKSAoZnVuICh4LCB5KSAtPlxuICAgICAgICAgIGNoZWNrX2Zsb2F0X2luIH5sb3c6MTAuIH5oaWdoOjUwLiB4O1xuICAgICAgICAgIGNoZWNrX2Zsb2F0IH5leHBlY3RlZDoyLiB5XG4gICAgICAgICk7XG4gICAgICBdXG4gICAgKTtcbiAgICBcInBhdHRlcm5zXCIgPjo6IFBhdHRlcm4uW1xuICAgICAgXCJjcmVhdGVfcmdiLCBnZXRfcmdiYVwiID46IChsYXp5IChcbiAgICAgICAgbGV0IHAgPSBjcmVhdGVfcmdiIDAuMSAwLjIgMC4zIGluXG4gICAgICAgIGNoZWNrX2Zsb2F0X3R1cGxlXzQgfmV4cGVjdGVkOigwLjEsIDAuMiwgMC4zLCAxLikgKGdldF9yZ2JhIHApXG4gICAgICApKTtcbiAgICAgIFwic2V0X3NvdXJjZV9yZ2IsIGdldF9yZ2JhXCIgPjogKGxhenkgKFxuICAgICAgICBsZXQgY3R4ID0gTi5jcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X3NvdXJjZV9yZ2IgY3R4IDAuMSAwLjIgMC4zO1xuICAgICAgICBsZXQgcCA9IGdldF9zb3VyY2UgY3R4IGluXG4gICAgICAgIGNoZWNrX2Zsb2F0X3R1cGxlXzQgfmV4cGVjdGVkOigwLjEsIDAuMiwgMC4zLCAxLikgKGdldF9yZ2JhIHApXG4gICAgICApKTtcbiAgICAgIFwiY3JlYXRlX3JnYmEsIGdldF9yZ2JhXCIgPjogKGxhenkgKFxuICAgICAgICBsZXQgcCA9IGNyZWF0ZV9yZ2JhIDAuMSAwLjIgMC4zIDAuNCBpblxuICAgICAgICBjaGVja19mbG9hdF90dXBsZV80IH5leHBlY3RlZDooMC4xLCAwLjIsIDAuMywgMC40KSAoZ2V0X3JnYmEgcClcbiAgICAgICkpO1xuICAgICAgXCJzZXRfc291cmNlX3JnYmEsIGdldF9yZ2JhXCIgPjogKGxhenkgKFxuICAgICAgICBsZXQgY3R4ID0gTi5jcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X3NvdXJjZV9yZ2JhIGN0eCAwLjEgMC4yIDAuMyAwLjQ7XG4gICAgICAgIGxldCBwID0gZ2V0X3NvdXJjZSBjdHggaW5cbiAgICAgICAgY2hlY2tfZmxvYXRfdHVwbGVfNCB+ZXhwZWN0ZWQ6KDAuMSwgMC4yLCAwLjMsIDAuNCkgKGdldF9yZ2JhIHApXG4gICAgICApKTtcbiAgICAgIFwiY3JlYXRlX2xpbmVhciwgZ2V0X2xpbmVhcl9wb2ludHNcIiA+OiAobGF6eSAoXG4gICAgICAgIGxldCBwID0gY3JlYXRlX2xpbmVhciB+eDA6MS4gfnkwOjIuIH54MTozLiB+eTE6NC4gaW5cbiAgICAgICAgY2hlY2tfZmxvYXRfdHVwbGVfNCB+ZXhwZWN0ZWQ6KDEuLCAyLiwgMy4sIDQuKSAoZ2V0X2xpbmVhcl9wb2ludHMgcClcbiAgICAgICkpO1xuICAgICAgXCJjcmVhdGVfcmFkaWFsLCBnZXRfcmFkaWFsX2NpcmNsZXNcIiA+OiAobGF6eSAoXG4gICAgICAgIGxldCBwID0gY3JlYXRlX3JhZGlhbCB+eDA6MS4gfnkwOjIuIH5yMDozLiB+eDE6NC4gfnkxOjUuIH5yMTo2LiBpblxuICAgICAgICBjaGVja19mbG9hdF90dXBsZV82IH5leHBlY3RlZDooMS4sIDIuLCAzLiwgNC4sIDUuLCA2LikgKGdldF9yYWRpYWxfY2lyY2xlcyBwKVxuICAgICAgKSk7XG4gICAgICBcImNyZWF0ZV9saW5lYXIsIGFkZF9jb2xvcl9zdG9wX3JnYmEsIGdldF9jb2xvcl9zdG9wX2NvdW50LCBnZXRfY29sb3Jfc3RvcF9yZ2JhXCIgPjogKGxhenkgKFxuICAgICAgICBsZXQgcCA9IGNyZWF0ZV9saW5lYXIgfngwOjEuIH55MDoyLiB+eDE6My4gfnkxOjQuIGluXG4gICAgICAgIGFkZF9jb2xvcl9zdG9wX3JnYmEgcCB+b2ZzOjAuMSAwLjIgMC4zIDAuNCAwLjU7XG4gICAgICAgIGNoZWNrX2ludCB+ZXhwZWN0ZWQ6MSAoZ2V0X2NvbG9yX3N0b3BfY291bnQgcCk7XG4gICAgICAgIGNoZWNrX2Zsb2F0X3R1cGxlXzUgfmV4cGVjdGVkOigwLjEsIDAuMiwgMC4zLCAwLjQsIDAuNSkgKGdldF9jb2xvcl9zdG9wX3JnYmEgcCB+aWR4OjApXG4gICAgICApKTtcbiAgICAgIFwiY3JlYXRlX3JhZGlhbCwgYWRkX2NvbG9yX3N0b3BfcmdiLCBnZXRfY29sb3Jfc3RvcF9jb3VudCwgZ2V0X2NvbG9yX3N0b3BfcmdiYVwiID46IChsYXp5IChcbiAgICAgICAgbGV0IHAgPSBjcmVhdGVfcmFkaWFsIH54MDoxLiB+eTA6Mi4gfnIwOjMuIH54MTo0LiB+eTE6NS4gfnIxOjYuIGluXG4gICAgICAgIGFkZF9jb2xvcl9zdG9wX3JnYiBwIDAuMiAwLjMgMC40O1xuICAgICAgICBjaGVja19pbnQgfmV4cGVjdGVkOjEgKGdldF9jb2xvcl9zdG9wX2NvdW50IHApO1xuICAgICAgICBjaGVja19mbG9hdF90dXBsZV81IH5leHBlY3RlZDooMC4sIDAuMiwgMC4zLCAwLjQsIDEuKSAoZ2V0X2NvbG9yX3N0b3BfcmdiYSBwIH5pZHg6MClcbiAgICAgICkpO1xuICAgICAgXCJtdWx0aXBsZSBjb2xvciBzdG9wc1wiID46IChsYXp5IChcbiAgICAgICAgbGV0IHAgPSBjcmVhdGVfbGluZWFyIH54MDoxLiB+eTA6Mi4gfngxOjMuIH55MTo0LiBpblxuICAgICAgICBhZGRfY29sb3Jfc3RvcF9yZ2IgcCB+b2ZzOjAuMiAwLjIgMC4yIDAuMjtcbiAgICAgICAgYWRkX2NvbG9yX3N0b3BfcmdiIHAgfm9mczowLjEgMC4xIDAuMSAwLjE7XG4gICAgICAgIGFkZF9jb2xvcl9zdG9wX3JnYiBwIH5vZnM6MC4yIDAuMjEgMC4yMSAwLjIxO1xuICAgICAgICBhZGRfY29sb3Jfc3RvcF9yZ2IgcCB+b2ZzOjAuMyAwLjMgMC4zIDAuMztcbiAgICAgICAgY2hlY2tfaW50IH5leHBlY3RlZDo0IChnZXRfY29sb3Jfc3RvcF9jb3VudCBwKTtcbiAgICAgICAgY2hlY2tfZmxvYXRfdHVwbGVfNSB+ZXhwZWN0ZWQ6KDAuMSwgMC4xLCAwLjEsIDAuMSwgMS4pIChnZXRfY29sb3Jfc3RvcF9yZ2JhIHAgfmlkeDowKTtcbiAgICAgICAgY2hlY2tfZmxvYXRfdHVwbGVfNSB+ZXhwZWN0ZWQ6KDAuMiwgMC4yLCAwLjIsIDAuMiwgMS4pIChnZXRfY29sb3Jfc3RvcF9yZ2JhIHAgfmlkeDoxKTtcbiAgICAgICAgY2hlY2tfZmxvYXRfdHVwbGVfNSB+ZXhwZWN0ZWQ6KDAuMiwgMC4yMSwgMC4yMSwgMC4yMSwgMS4pIChnZXRfY29sb3Jfc3RvcF9yZ2JhIHAgfmlkeDoyKTtcbiAgICAgICAgY2hlY2tfZmxvYXRfdHVwbGVfNSB+ZXhwZWN0ZWQ6KDAuMywgMC4zLCAwLjMsIDAuMywgMS4pIChnZXRfY29sb3Jfc3RvcF9yZ2JhIHAgfmlkeDozKVxuICAgICAgKSk7XG4gICAgICBcImNyZWF0ZV9yZ2IsIGFkZF9jb2xvcl9zdG9wX3JnYlwiID46IChsYXp5IChcbiAgICAgICAgbGV0IGN0eCA9IE4uY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9zb3VyY2UgY3R4IChjcmVhdGVfcmdiIDAuMSAwLjIgMC4zKTtcbiAgICAgICAgbGV0IHAgPSBnZXRfc291cmNlIGN0eCBpblxuICAgICAgICAoKiBUaGlzIGlzIGEgYml0IHdlaXJkOiBhZGRfY29sb3Jfc3RvcF9yZ2IgcmV0dXJucyBzaWxlbnRseSwgYnV0IHB1dHMgdGhlIHBhdHRlcm4gaW4gYSBzdGF0ZSB3aGVyZSBhbGwgZ2V0dGVycyBmYWlsLiAqKVxuICAgICAgICBhZGRfY29sb3Jfc3RvcF9yZ2IgcCB+b2ZzOjAuMSAwLjEgMC4xIDAuMTtcbiAgICAgICAgYWRkX2NvbG9yX3N0b3BfcmdiIHAgfm9mczowLjIgMC4yIDAuMiAwLjI7XG4gICAgICAgIGV4cGVjdF9leGNlcHRpb24gfmV4cGVjdGVkOihFcnJvciBQQVRURVJOX1RZUEVfTUlTTUFUQ0gpIChsYXp5IChnZXRfcmdiYSBwKSk7XG4gICAgICAgIGV4cGVjdF9leGNlcHRpb24gfmV4cGVjdGVkOihFcnJvciBQQVRURVJOX1RZUEVfTUlTTUFUQ0gpIChsYXp5IChnZXRfY29sb3Jfc3RvcF9jb3VudCBwKSk7XG4gICAgICAgIGV4cGVjdF9leGNlcHRpb24gfmV4cGVjdGVkOihFcnJvciBQQVRURVJOX1RZUEVfTUlTTUFUQ0gpIChsYXp5IChnZXRfbGluZWFyX3BvaW50cyBwKSk7XG4gICAgICAgIGV4cGVjdF9leGNlcHRpb24gfmV4cGVjdGVkOihFcnJvciBQQVRURVJOX1RZUEVfTUlTTUFUQ0gpIChsYXp5IChnZXRfcmFkaWFsX2NpcmNsZXMgcCkpO1xuICAgICAgICBleHBlY3RfZXhjZXB0aW9uIH5leHBlY3RlZDooRXJyb3IgUEFUVEVSTl9UWVBFX01JU01BVENIKSAobGF6eSAoZ2V0X2NvbG9yX3N0b3BfcmdiYSB+aWR4OjAgcCkpO1xuICAgICAgKSk7XG4gICAgICBcIm1pc21hdGNoXCIgPjo6IChcbiAgICAgICAgbGV0IG1ha2UgbmFtZSBwIGYgPVxuICAgICAgICAgIG5hbWUgPjogKGxhenkgKFxuICAgICAgICAgICAgbGV0IGN0eCA9IE4uY3JlYXRlICgpIGluXG4gICAgICAgICAgICAoKiBGb3JnZXQgdHlwZSAqKVxuICAgICAgICAgICAgc2V0X3NvdXJjZSBjdHggcDtcbiAgICAgICAgICAgIGxldCBwID0gZ2V0X3NvdXJjZSBjdHggaW5cbiAgICAgICAgICAgIGV4cGVjdF9leGNlcHRpb24gfmV4cGVjdGVkOihFcnJvciBQQVRURVJOX1RZUEVfTUlTTUFUQ0gpIChsYXp5IChmIHApKVxuICAgICAgICAgICkpXG4gICAgICAgIGluXG4gICAgICAgIFtcbiAgICAgICAgICBtYWtlIFwiY3JlYXRlX3JnYiwgZ2V0X2xpbmVhcl9wb2ludHNcIiAoY3JlYXRlX3JnYiAwLjEgMC4yIDAuMykgZ2V0X2xpbmVhcl9wb2ludHM7XG4gICAgICAgICAgbWFrZSBcImNyZWF0ZV9yZ2IsIGdldF9yYWRpYWxfY2lyY2xlc1wiIChjcmVhdGVfcmdiIDAuMSAwLjIgMC4zKSBnZXRfcmFkaWFsX2NpcmNsZXM7XG4gICAgICAgICAgbWFrZSBcImNyZWF0ZV9yZ2IsIGdldF9jb2xvcl9zdG9wX2NvdW50XCIgKGNyZWF0ZV9yZ2IgMC4xIDAuMiAwLjMpIGdldF9jb2xvcl9zdG9wX2NvdW50O1xuICAgICAgICAgIG1ha2UgXCJjcmVhdGVfcmdiLCBnZXRfY29sb3Jfc3RvcF9yZ2JhXCIgKGNyZWF0ZV9yZ2IgMC4xIDAuMiAwLjMpIChnZXRfY29sb3Jfc3RvcF9yZ2JhIH5pZHg6MCk7XG4gICAgICAgICAgbWFrZSBcImNyZWF0ZV9saW5lYXIsIGdldF9yZ2JhXCIgKGNyZWF0ZV9saW5lYXIgfngwOjEuIH55MDoyLiB+eDE6My4gfnkxOjQuKSBnZXRfcmdiYTtcbiAgICAgICAgICBtYWtlIFwiY3JlYXRlX2xpbmVhciwgZ2V0X3JhZGlhbF9jaXJjbGVzXCIgKGNyZWF0ZV9saW5lYXIgfngwOjEuIH55MDoyLiB+eDE6My4gfnkxOjQuKSBnZXRfcmFkaWFsX2NpcmNsZXM7XG4gICAgICAgICAgbWFrZSBcImNyZWF0ZV9yYWRpYWwsIGdldF9yZ2JhXCIgKGNyZWF0ZV9yYWRpYWwgfngwOjEuIH55MDoyLiB+cjA6My4gfngxOjQuIH55MTo1LiB+cjE6Ni4pIGdldF9yZ2JhO1xuICAgICAgICAgIG1ha2UgXCJjcmVhdGVfcmFkaWFsLCBnZXRfbGluZWFyX3BvaW50c1wiIChjcmVhdGVfcmFkaWFsIH54MDoxLiB+eTA6Mi4gfnIwOjMuIH54MTo0LiB+eTE6NS4gfnIxOjYuKSBnZXRfbGluZWFyX3BvaW50cztcbiAgICAgICAgXVxuICAgICAgKTtcbiAgICBdO1xuICAgICgqIEZ1bmN0aW9ucyBhYm91dCB0ZXh0IGFuZCBmb250cyBhcmUgbm90IGNvdmVyZWQgYnkgdGhlc2UgdGVzdHMgYmVjYXVzZSB0aGV5IGRvbid0IGJlaGF2ZSB0aGUgc2FtZSBhY2Nyb3NzIGFsbCBpbXBsZW1lbnRhdGlvbnMuICopXG4gIF1cbmVuZFxuIiwiKCogQ29weXJpZ2h0IDIwMTctMjAxOCBWaW5jZW50IEphY3F1ZXMgPHZpbmNlbnRAdmluY2VudC1qYWNxdWVzLm5ldD4gKilcblxub3BlbiBHZW5lcmFsLkFiYnJcbm9wZW4gVHN0XG5cbm1vZHVsZSBNYWtlKEM6IENhaXJvTW9jay5TKShOOiBzaWdcbiAgdmFsIG5hbWU6IHN0cmluZ1xuICB2YWwgY3JlYXRlOiB1bml0IC0+IEMuY29udGV4dFxuICB2YWwgYmFja2VuZDogW2BDYWlybyB8IGBOb2RlIHwgYEJyb3dzZXIgfCBgQ2Fpcm9Nb2NrIF1cbmVuZCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIERlY29yYXRlZEMgPSBDYWlyb01vY2suRGVjb3JhdGUoQylcbiAgb3BlbiBEZWNvcmF0ZWRDXG5cbiAgbGV0IGJhY2tlbmRfbmFtZSA9IG1hdGNoIE4uYmFja2VuZCB3aXRoXG4gICAgfCBgQ2Fpcm8gLT4gXCJDYWlyb1wiXG4gICAgfCBgTm9kZSB8IGBCcm93c2VyIC0+IFwiSnNPZk9DYWlyb1wiICgqQklTRUNULUlHTk9SRSopICgqIFRlc3QgY29kZSAqKVxuICAgIHwgYENhaXJvTW9jayAtPiBcIkNhaXJvTW9ja1wiXG5cbiAgbGV0IG1ha2VfbicgbmFtZSBmcyBjaGVja3MgPVxuICAgIG5hbWUgPjogKGxhenkgKFxuICAgICAgbGV0IGMgPSBjcmVhdGUgKE4uY3JlYXRlICgpKSBpblxuICAgICAgTGkuaXRlciB+ZjooZnVuIGYgLT4gaWdub3JlIChmIGMpKSBmcztcbiAgICAgIExpLlR3by50b19wYWlyX2xpc3QgY2hlY2tzIChjYWxscyBjKVxuICAgICAgfD4gTGkuaXRlciB+ZjooZnVuIChjaGVjaywgYWN0dWFsKSAtPlxuICAgICAgICBjaGVjayBhY3R1YWxcbiAgICAgIClcbiAgICApKVxuXG4gIGxldCBtYWtlJyBuYW1lIGYgY2hlY2sgPVxuICAgIG1ha2VfbicgbmFtZSBbZl0gW2NoZWNrXVxuXG4gIGxldCBtYWtlX24gbmFtZSBmcyBleHBlY3RlZCA9XG4gICAgbWFrZV9uJyBuYW1lIGZzIChMaS5tYXAgfmY6KGZ1biBleHBlY3RlZCAtPiBjaGVja19zdHJpbmcgfmV4cGVjdGVkKSBleHBlY3RlZClcblxuICBsZXQgbWFrZSBuYW1lIGYgZXhwZWN0ZWQgPVxuICAgIEZybXQud2l0aF9yZXN1bHQgfmY6KGZ1biBleHBlY3RlZCAtPlxuICAgICAgbWFrZV9uIG5hbWUgW2ZdIFtleHBlY3RlZF1cbiAgICApIGV4cGVjdGVkXG5cbiAgbGV0IGNhdGNoIGVycm9yIGYgY3R4ID1cbiAgICBleHBlY3RfZXhjZXB0aW9uIH5leHBlY3RlZDooRXJyb3IgZXJyb3IpIChsYXp5IChmIGN0eCkpXG5cbiAgbGV0IHRlc3QgPSB+OjogXCJEZWNvcmF0aW9uIHRlc3RzIG9uIENhaXJvTW9jay5EZWNvcmF0ZSglcylcIiBOLm5hbWUgKFtcbiAgICBtYWtlX24gXCJzYXZlLCByZXN0b3JlXCIgW3NhdmU7IHJlc3RvcmVdIFtcInNhdmVcIjsgXCJyZXN0b3JlXCJdO1xuICAgIG1ha2UgXCJpbnZhbGlkIHJlc3RvcmVcIiAoY2F0Y2ggSU5WQUxJRF9SRVNUT1JFIHJlc3RvcmUpIFwicmVzdG9yZSAtPiByYWlzZSAoJXMuRXJyb3IoSU5WQUxJRF9SRVNUT1JFKSlcIiBiYWNrZW5kX25hbWU7XG5cbiAgICBtYWtlIFwic2NhbGVcIiAoZnVuIGMgLT4gc2NhbGUgYyAzLiAyLikgXCJzY2FsZSAzLjAwIDIuMDBcIjtcbiAgICBtYWtlIFwidHJhbnNsYXRlXCIgKGZ1biBjIC0+IHRyYW5zbGF0ZSBjIDMuIDIuKSBcInRyYW5zbGF0ZSAzLjAwIDIuMDBcIjtcbiAgICBtYWtlIFwicm90YXRlXCIgKGZ1biBjIC0+IHJvdGF0ZSBjIDMuKSBcInJvdGF0ZSAzLjAwXCI7XG4gICAgbWFrZSBcInRyYW5zZm9ybVwiIChmdW4gYyAtPiB0cmFuc2Zvcm0gYyB7eHg9MS47IHh5PTIuOyB5eD0zLjsgeXk9NC47IHgwPTUuOyB5MD02Ln0pIFwidHJhbnNmb3JtIHt4eD0xLjAwOyB4eT0yLjAwOyB5eD0zLjAwOyB5eT00LjAwOyB4MD01LjAwOyB5MD02LjAwfVwiO1xuICAgIG1ha2UgXCJzZXRfbWF0cml4XCIgKGZ1biBjIC0+IHNldF9tYXRyaXggYyB7eHg9MS47IHh5PTIuOyB5eD0zLjsgeXk9NC47IHgwPTUuOyB5MD02Ln0pIFwic2V0X21hdHJpeCB7eHg9MS4wMDsgeHk9Mi4wMDsgeXg9My4wMDsgeXk9NC4wMDsgeDA9NS4wMDsgeTA9Ni4wMH1cIjtcbiAgICBtYWtlIFwiaWRlbnRpdHlfbWF0cml4XCIgaWRlbnRpdHlfbWF0cml4IFwiaWRlbnRpdHlfbWF0cml4XCI7XG4gICAgbWFrZSBcImdldF9tYXRyaXhcIiBnZXRfbWF0cml4IFwiZ2V0X21hdHJpeCAtPiB7eHg9MS4wMDsgeHk9MC4wMDsgeXg9MC4wMDsgeXk9MS4wMDsgeDA9MC4wMDsgeTA9MC4wMH1cIjtcbiAgICBtYWtlIFwidXNlcl90b19kZXZpY2VcIiAoZnVuIGMgLT4gdXNlcl90b19kZXZpY2UgYyAyLiAzLikgXCJ1c2VyX3RvX2RldmljZSAyLjAwIDMuMDAgLT4gKDIuMDAsIDMuMDApXCI7XG4gICAgbWFrZSBcInVzZXJfdG9fZGV2aWNlX2Rpc3RhbmNlXCIgKGZ1biBjIC0+IHVzZXJfdG9fZGV2aWNlX2Rpc3RhbmNlIGMgMi4gMy4pIFwidXNlcl90b19kZXZpY2VfZGlzdGFuY2UgMi4wMCAzLjAwIC0+ICgyLjAwLCAzLjAwKVwiO1xuICAgIG1ha2UgXCJkZXZpY2VfdG9fdXNlclwiIChmdW4gYyAtPiBkZXZpY2VfdG9fdXNlciBjIDIuIDMuKSBcImRldmljZV90b191c2VyIDIuMDAgMy4wMCAtPiAoMi4wMCwgMy4wMClcIjtcbiAgICBtYWtlIFwiZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2VcIiAoZnVuIGMgLT4gZGV2aWNlX3RvX3VzZXJfZGlzdGFuY2UgYyAyLiAzLikgXCJkZXZpY2VfdG9fdXNlcl9kaXN0YW5jZSAyLjAwIDMuMDAgLT4gKDIuMDAsIDMuMDApXCI7XG5cbiAgICBtYWtlIFwibW92ZV90b1wiIChmdW4gYyAtPiBtb3ZlX3RvIGMgNC4wNSAyLjk1NykgXCJtb3ZlX3RvIDQuMDUgMi45NlwiO1xuICAgIG1ha2UgXCJpbnZhbGlkIHJlbF9tb3ZlX3RvXCIgKGNhdGNoIE5PX0NVUlJFTlRfUE9JTlQgKGZ1biBjIC0+IHJlbF9tb3ZlX3RvIGMgNC4wNSAyLjk1NykpIFwicmVsX21vdmVfdG8gNC4wNSAyLjk2IC0+IHJhaXNlICglcy5FcnJvcihOT19DVVJSRU5UX1BPSU5UKSlcIiBiYWNrZW5kX25hbWU7XG4gICAgbWFrZV9uIFwicmVsX21vdmVfdG9cIiBbKGZ1biBjIC0+IG1vdmVfdG8gYyAxLiAyLik7IGZ1biBjIC0+IHJlbF9tb3ZlX3RvIGMgMy4gNC5dIFtcIm1vdmVfdG8gMS4wMCAyLjAwXCI7IFwicmVsX21vdmVfdG8gMy4wMCA0LjAwXCJdO1xuICAgIG1ha2UgXCJsaW5lX3RvXCIgKGZ1biBjIC0+IGxpbmVfdG8gYyA0LjA1IDIuOTU3KSBcImxpbmVfdG8gNC4wNSAyLjk2XCI7XG4gICAgbWFrZSBcImludmFsaWQgcmVsX2xpbmVfdG9cIiAoY2F0Y2ggTk9fQ1VSUkVOVF9QT0lOVCAoZnVuIGMgLT4gcmVsX2xpbmVfdG8gYyA0LjA1IDIuOTU3KSkgXCJyZWxfbGluZV90byA0LjA1IDIuOTYgLT4gcmFpc2UgKCVzLkVycm9yKE5PX0NVUlJFTlRfUE9JTlQpKVwiIGJhY2tlbmRfbmFtZTtcbiAgICBtYWtlX24gXCJyZWxfbGluZV90b1wiIFsoZnVuIGMgLT4gbW92ZV90byBjIDEuIDIuKTsgZnVuIGMgLT4gcmVsX2xpbmVfdG8gYyAzLiA0Ll0gW1wibW92ZV90byAxLjAwIDIuMDBcIjsgXCJyZWxfbGluZV90byAzLjAwIDQuMDBcIl07XG4gICAgbWFrZSBcImN1cnZlX3RvXCIgKGZ1biBjIC0+IGN1cnZlX3RvIGMgMS4gMi4gMy4gNC4gNS4gNi4pIFwiY3VydmVfdG8gMS4wMCAyLjAwIDMuMDAgNC4wMCA1LjAwIDYuMDBcIjtcbiAgICBtYWtlIFwiaW52YWxpZCByZWxfY3VydmVfdG9cIiAoY2F0Y2ggTk9fQ1VSUkVOVF9QT0lOVCAoZnVuIGMgLT4gcmVsX2N1cnZlX3RvIGMgMS4gMi4gMy4gNC4gNS4gNi4pKSBcInJlbF9jdXJ2ZV90byAxLjAwIDIuMDAgMy4wMCA0LjAwIDUuMDAgNi4wMCAtPiByYWlzZSAoJXMuRXJyb3IoTk9fQ1VSUkVOVF9QT0lOVCkpXCIgYmFja2VuZF9uYW1lO1xuICAgIG1ha2VfbiBcInJlbF9jdXJ2ZV90b1wiIFsoZnVuIGMgLT4gbW92ZV90byBjIDEuIDIuKTsgZnVuIGMgLT4gcmVsX2N1cnZlX3RvIGMgMS4gMi4gMy4gNC4gNS4gNi5dIFtcIm1vdmVfdG8gMS4wMCAyLjAwXCI7IFwicmVsX2N1cnZlX3RvIDEuMDAgMi4wMCAzLjAwIDQuMDAgNS4wMCA2LjAwXCJdO1xuICAgIG1ha2UgXCJyZWN0YW5nbGVcIiAoZnVuIGMgLT4gcmVjdGFuZ2xlIGMgMi4gMy4gfnc6NC4gfmg6NS4pIFwicmVjdGFuZ2xlIDIuMDAgMy4wMCB+dzo0LjAwIH5oOjUuMDBcIjtcbiAgICBtYWtlIFwiYXJjXCIgKGZ1biBjIC0+IGFyYyBjIDEuIDIuIH5yOjMuIH5hMTo0LiB+YTI6NS4pIFwiYXJjIDEuMDAgMi4wMCB+cjozLjAwIH5hMTo0LjAwIH5hMjo1LjAwXCI7XG4gICAgbWFrZSBcImFyY19uZWdhdGl2ZVwiIChmdW4gYyAtPiBhcmNfbmVnYXRpdmUgYyAxLiAyLiB+cjozLiB+YTE6NC4gfmEyOjUuKSBcImFyY19uZWdhdGl2ZSAxLjAwIDIuMDAgfnI6My4wMCB+YTE6NC4wMCB+YTI6NS4wMFwiO1xuICAgIG1ha2UgXCJQYXRoLmNsb3NlXCIgUGF0aC5jbG9zZSBcIlBhdGguY2xvc2VcIjtcbiAgICBtYWtlIFwiUGF0aC5jbGVhclwiIFBhdGguY2xlYXIgXCJQYXRoLmNsZWFyXCI7XG4gICAgbWFrZSBcIlBhdGguZ2V0X2N1cnJlbnRfcG9pbnRcIiBQYXRoLmdldF9jdXJyZW50X3BvaW50IFwiUGF0aC5nZXRfY3VycmVudF9wb2ludCAtPiAoMC4wMCwgMC4wMClcIjtcbiAgICBtYWtlX24gXCJtb3ZlX3RvLCBQYXRoLmdldF9jdXJyZW50X3BvaW50XCIgWyhmdW4gYyAtPiBtb3ZlX3RvIGMgMS4gMi4pOyBpZ25vcmUgJSBQYXRoLmdldF9jdXJyZW50X3BvaW50XSBbXCJtb3ZlX3RvIDEuMDAgMi4wMFwiOyBcIlBhdGguZ2V0X2N1cnJlbnRfcG9pbnQgLT4gKDEuMDAsIDIuMDApXCJdO1xuXG4gICAgbWFrZSBcInN0cm9rZVwiIHN0cm9rZSBcInN0cm9rZVwiO1xuICAgIG1ha2UgXCJzdHJva2VfcHJlc2VydmVcIiBzdHJva2VfcHJlc2VydmUgXCJzdHJva2VfcHJlc2VydmVcIjtcbiAgICBtYWtlIFwiZmlsbFwiIGZpbGwgXCJmaWxsXCI7XG4gICAgbWFrZSBcImZpbGxfcHJlc2VydmVcIiBmaWxsX3ByZXNlcnZlIFwiZmlsbF9wcmVzZXJ2ZVwiO1xuICAgIG1ha2UgXCJjbGlwXCIgY2xpcCBcImNsaXBcIjtcbiAgICBtYWtlIFwiY2xpcF9wcmVzZXJ2ZVwiIGNsaXBfcHJlc2VydmUgXCJjbGlwX3ByZXNlcnZlXCI7XG4gICAgbWFrZSBcInBhaW50XCIgcGFpbnQgXCJwYWludFwiO1xuICAgIG1ha2UgXCJwYWludCB3aXRoIGFscGhhXCIgKHBhaW50IH5hbHBoYTowLjUpIFwicGFpbnQgfmFscGhhOjAuNTBcIjtcblxuICAgIG1ha2UgXCJzZXRfbGluZV93aWR0aFwiIChmdW4gYyAtPiBzZXRfbGluZV93aWR0aCBjIDMuKSBcInNldF9saW5lX3dpZHRoIDMuMDBcIjtcbiAgICBtYWtlIFwiZ2V0X2xpbmVfd2lkdGhcIiBnZXRfbGluZV93aWR0aCBcImdldF9saW5lX3dpZHRoIC0+IDIuMDBcIjtcbiAgICBtYWtlIFwic2V0X2Rhc2hcIiAoZnVuIGMgLT4gc2V0X2Rhc2ggYyBbfDIuOyAzLnxdKSBcInNldF9kYXNoIFt8Mi4wMDsgMy4wMHxdXCI7XG4gICAgbWFrZSBcInNldF9kYXNoIHdpdGggb2ZzXCIgKGZ1biBjIC0+IHNldF9kYXNoIGMgfm9mczoyLiBbfDMuOyA0LnxdKSBcInNldF9kYXNoIH5vZnM6Mi4wMCBbfDMuMDA7IDQuMDB8XVwiO1xuICAgIG1ha2UgXCJnZXRfZGFzaFwiIGdldF9kYXNoIFwiZ2V0X2Rhc2ggLT4gKFt8fF0sIDAuMDApXCI7XG4gICAgbWFrZSBcInNldF9maWxsX3J1bGVcIiAoZnVuIGMgLT4gc2V0X2ZpbGxfcnVsZSBjIEVWRU5fT0REKSBcInNldF9maWxsX3J1bGUgRVZFTl9PRERcIjtcbiAgICBtYWtlIFwiZ2V0X2ZpbGxfcnVsZVwiIGdldF9maWxsX3J1bGUgXCJnZXRfZmlsbF9ydWxlIC0+IFdJTkRJTkdcIjtcbiAgICBtYWtlIFwic2V0X2xpbmVfY2FwIFJPVU5EXCIgKGZ1biBjIC0+IHNldF9saW5lX2NhcCBjIFJPVU5EKSBcInNldF9saW5lX2NhcCBST1VORFwiO1xuICAgIG1ha2UgXCJzZXRfbGluZV9jYXAgU1FVQVJFXCIgKGZ1biBjIC0+IHNldF9saW5lX2NhcCBjIFNRVUFSRSkgXCJzZXRfbGluZV9jYXAgU1FVQVJFXCI7XG4gICAgbWFrZSBcImdldF9saW5lX2NhcFwiIGdldF9saW5lX2NhcCBcImdldF9saW5lX2NhcCAtPiBCVVRUXCI7XG4gICAgbWFrZSBcInNldF9saW5lX2pvaW4gSk9JTl9ST1VORFwiIChmdW4gYyAtPiBzZXRfbGluZV9qb2luIGMgSk9JTl9ST1VORCkgXCJzZXRfbGluZV9qb2luIEpPSU5fUk9VTkRcIjtcbiAgICBtYWtlIFwic2V0X2xpbmVfam9pbiBKT0lOX0JFVkVMXCIgKGZ1biBjIC0+IHNldF9saW5lX2pvaW4gYyBKT0lOX0JFVkVMKSBcInNldF9saW5lX2pvaW4gSk9JTl9CRVZFTFwiO1xuICAgIG1ha2UgXCJnZXRfbGluZV9qb2luXCIgZ2V0X2xpbmVfam9pbiBcImdldF9saW5lX2pvaW4gLT4gSk9JTl9NSVRFUlwiO1xuICAgIG1ha2UgXCJzZXRfbWl0ZXJfbGltaXRcIiAoZnVuIGMgLT4gc2V0X21pdGVyX2xpbWl0IGMgMy4pIFwic2V0X21pdGVyX2xpbWl0IDMuMDBcIjtcbiAgICBtYWtlIFwiZ2V0X21pdGVyX2xpbWl0XCIgZ2V0X21pdGVyX2xpbWl0IFwiZ2V0X21pdGVyX2xpbWl0IC0+IDEwLjAwXCI7XG4gICAgbWFrZSBcInNldF9vcGVyYXRvciBJTlwiIChmdW4gYyAtPiBzZXRfb3BlcmF0b3IgYyBJTikgXCJzZXRfb3BlcmF0b3IgSU5cIjtcbiAgICBtYWtlIFwic2V0X29wZXJhdG9yIE9VVFwiIChmdW4gYyAtPiBzZXRfb3BlcmF0b3IgYyBPVVQpIFwic2V0X29wZXJhdG9yIE9VVFwiO1xuICAgIG1ha2UgXCJzZXRfb3BlcmF0b3IgQVRPUFwiIChmdW4gYyAtPiBzZXRfb3BlcmF0b3IgYyBBVE9QKSBcInNldF9vcGVyYXRvciBBVE9QXCI7XG4gICAgbWFrZSBcInNldF9vcGVyYXRvciBERVNUX09WRVJcIiAoZnVuIGMgLT4gc2V0X29wZXJhdG9yIGMgREVTVF9PVkVSKSBcInNldF9vcGVyYXRvciBERVNUX09WRVJcIjtcbiAgICBtYWtlIFwic2V0X29wZXJhdG9yIERFU1RfSU5cIiAoZnVuIGMgLT4gc2V0X29wZXJhdG9yIGMgREVTVF9JTikgXCJzZXRfb3BlcmF0b3IgREVTVF9JTlwiO1xuICAgIG1ha2UgXCJzZXRfb3BlcmF0b3IgREVTVF9PVVRcIiAoZnVuIGMgLT4gc2V0X29wZXJhdG9yIGMgREVTVF9PVVQpIFwic2V0X29wZXJhdG9yIERFU1RfT1VUXCI7XG4gICAgbWFrZSBcInNldF9vcGVyYXRvciBERVNUX0FUT1BcIiAoZnVuIGMgLT4gc2V0X29wZXJhdG9yIGMgREVTVF9BVE9QKSBcInNldF9vcGVyYXRvciBERVNUX0FUT1BcIjtcbiAgICBtYWtlIFwic2V0X29wZXJhdG9yIFhPUlwiIChmdW4gYyAtPiBzZXRfb3BlcmF0b3IgYyBYT1IpIFwic2V0X29wZXJhdG9yIFhPUlwiO1xuICAgIG1ha2UgXCJzZXRfb3BlcmF0b3IgQUREXCIgKGZ1biBjIC0+IHNldF9vcGVyYXRvciBjIEFERCkgXCJzZXRfb3BlcmF0b3IgQUREXCI7XG4gIF0gQCAoaWYgTi5iYWNrZW5kID0gYE5vZGUgfHwgTi5iYWNrZW5kID0gYEJyb3dzZXIgdGhlbiBbXSBlbHNlIFsgKCpCSVNFQ1QtSUdOT1JFKikgKCogVGVzdCBjb2RlICopXG4gICAgbWFrZSBcInNldF9vcGVyYXRvciBERVNUXCIgKGZ1biBjIC0+IHNldF9vcGVyYXRvciBjIERFU1QpIFwic2V0X29wZXJhdG9yIERFU1RcIjtcbiAgICBtYWtlIFwic2V0X29wZXJhdG9yIENMRUFSXCIgKGZ1biBjIC0+IHNldF9vcGVyYXRvciBjIENMRUFSKSBcInNldF9vcGVyYXRvciBDTEVBUlwiO1xuICAgIG1ha2UgXCJzZXRfb3BlcmF0b3IgU09VUkNFXCIgKGZ1biBjIC0+IHNldF9vcGVyYXRvciBjIFNPVVJDRSkgXCJzZXRfb3BlcmF0b3IgU09VUkNFXCI7XG4gICAgbWFrZSBcInNldF9vcGVyYXRvciBTQVRVUkFURVwiIChmdW4gYyAtPiBzZXRfb3BlcmF0b3IgYyBTQVRVUkFURSkgXCJzZXRfb3BlcmF0b3IgU0FUVVJBVEVcIjtcbiAgXSkgQCBbXG4gICAgbWFrZSBcImdldF9vcGVyYXRvclwiIGdldF9vcGVyYXRvciBcImdldF9vcGVyYXRvciAtPiBPVkVSXCI7XG5cbiAgICBtYWtlIFwic2V0X3NvdXJjZV9yZ2JcIiAoZnVuIGMgLT4gc2V0X3NvdXJjZV9yZ2IgYyAwLjUgMC42IDAuNykgXCJzZXRfc291cmNlX3JnYiAwLjUwIDAuNjAgMC43MFwiO1xuICAgIG1ha2UgXCJzZXRfc291cmNlX3JnYmFcIiAoZnVuIGMgLT4gc2V0X3NvdXJjZV9yZ2JhIGMgMC41IDAuNiAwLjcgMC44KSBcInNldF9zb3VyY2VfcmdiYSAwLjUwIDAuNjAgMC43MCAwLjgwXCI7XG4gICAgbWFrZSBcInNldF9zb3VyY2UgUmdiYVwiIChmdW4gYyAtPiBzZXRfc291cmNlIGMgKFBhdHRlcm4uY3JlYXRlX3JnYiAwLjUgMC42IDAuNykpIFwic2V0X3NvdXJjZSAoUmdiYSB7cj0wLjUwOyBnPTAuNjA7IGI9MC43MDsgYT0xLjAwfSlcIjtcbiAgICBtYWtlXG4gICAgICBcInNldF9zb3VyY2UgTGluZWFyR3JhZGllbnRcIlxuICAgICAgKGZ1biBjIC0+XG4gICAgICAgIGxldCBwID0gUGF0dGVybi5jcmVhdGVfbGluZWFyIH54MDoxLiB+eTA6Mi4gfngxOjMuIH55MTo0LiBpblxuICAgICAgICBQYXR0ZXJuLmFkZF9jb2xvcl9zdG9wX3JnYiBwIDAuMSAwLjIgMC4zO1xuICAgICAgICBzZXRfc291cmNlIGMgcFxuICAgICAgKVxuICAgICAgXCJzZXRfc291cmNlIChMaW5lYXJHcmFkaWVudCB7eDA9MS4wMDsgeTA9Mi4wMDsgeDE9My4wMDsgeTE9NC4wMDsgc3RvcF9wb2ludHM9W3twb3NpdGlvbj0wLjAwOyByPTAuMTA7IGc9MC4yMDsgYj0wLjMwOyBhPTEuMDB9XX0pXCJcbiAgICA7XG4gICAgbWFrZSBcInNldF9zb3VyY2UgUmFkaWFsR3JhZGllbnRcIiAoZnVuIGMgLT4gc2V0X3NvdXJjZSBjIChQYXR0ZXJuLmNyZWF0ZV9yYWRpYWwgfngwOjEuIH55MDoyLiB+cjA6NS4gfngxOjMuIH55MTo0LiB+cjE6Ni4pKSBcInNldF9zb3VyY2UgKFJhZGlhbEdyYWRpZW50IHt4MD0xLjAwOyB5MD0yLjAwOyByMD01LjAwOyB4MT0zLjAwOyB5MT00LjAwOyByMTYuMDA7IHN0b3BfcG9pbnRzPVtdfSlcIjtcbiAgICBtYWtlIFwiZ2V0X3NvdXJjZVwiIGdldF9zb3VyY2UgXCJnZXRfc291cmNlIC0+IChSZ2JhIHtyPTAuMDA7IGc9MC4wMDsgYj0wLjAwOyBhPTEuMDB9KVwiO1xuXG4gICAgbWFrZSBcInNldF9mb250X3NpemVcIiAoZnVuIGMgLT4gc2V0X2ZvbnRfc2l6ZSBjIDMuKSBcInNldF9mb250X3NpemUgMy4wMFwiO1xuICAgIG1ha2UgXCJzZWxlY3RfZm9udF9mYWNlXCIgKGZ1biBjIC0+IHNlbGVjdF9mb250X2ZhY2UgYyBcImZvby1iYXJcIikgXCJzZWxlY3RfZm9udF9mYWNlIFxcXCJmb28tYmFyXFxcIlwiO1xuICAgIG1ha2UgXCJzZWxlY3RfZm9udF9mYWNlIFVwcmlnaHRcIiAoZnVuIGMgLT4gc2VsZWN0X2ZvbnRfZmFjZSBjIH5zbGFudDpVcHJpZ2h0IFwiZm9vLWJhclwiKSBcInNlbGVjdF9mb250X2ZhY2UgfnNsYW50OlVwcmlnaHQgXFxcImZvby1iYXJcXFwiXCI7XG4gICAgbWFrZSBcInNlbGVjdF9mb250X2ZhY2UgT2JsaXF1ZVwiIChmdW4gYyAtPiBzZWxlY3RfZm9udF9mYWNlIGMgfnNsYW50Ok9ibGlxdWUgXCJmb28tYmFyXCIpIFwic2VsZWN0X2ZvbnRfZmFjZSB+c2xhbnQ6T2JsaXF1ZSBcXFwiZm9vLWJhclxcXCJcIjtcbiAgICBtYWtlIFwic2VsZWN0X2ZvbnRfZmFjZSBOb3JtYWxcIiAoZnVuIGMgLT4gc2VsZWN0X2ZvbnRfZmFjZSBjIH53ZWlnaHQ6Tm9ybWFsIFwiZm9vLWJhclwiKSBcInNlbGVjdF9mb250X2ZhY2UgfndlaWdodDpOb3JtYWwgXFxcImZvby1iYXJcXFwiXCI7XG4gICAgbWFrZSBcInNlbGVjdF9mb250X2ZhY2UgSXRhbGljIEJvbGRcIiAoZnVuIGMgLT4gc2VsZWN0X2ZvbnRfZmFjZSBjIH5zbGFudDpJdGFsaWMgfndlaWdodDpCb2xkIFwiZm9vLWJhclwiKSBcInNlbGVjdF9mb250X2ZhY2UgfnNsYW50Okl0YWxpYyB+d2VpZ2h0OkJvbGQgXFxcImZvby1iYXJcXFwiXCI7XG4gICAgbWFrZSBcInNob3dfdGV4dFwiIChmdW4gYyAtPiBzaG93X3RleHQgYyBcImZsaWJpZGlib29cIikgXCJzaG93X3RleHQgXFxcImZsaWJpZGlib29cXFwiXCI7XG4gICAgbWFrZScgXCJ0ZXh0X2V4dGVudHNcIlxuICAgICAgKGZ1biBjIC0+IHRleHRfZXh0ZW50cyBjIFwiYWJjZFwiKVxuICAgICAgKEZybXQud2l0aF9zY2FuX3Jlc3VsdFxuICAgICAgICBcInRleHRfZXh0ZW50cyBcXFwiYWJjZFxcXCIgLT4ge3hfYmVhcmluZz0lZjsgeV9iZWFyaW5nPSVmOyB3aWR0aD0lZjsgaGVpZ2h0PSVmOyB4X2FkdmFuY2U9JWY7IHlfYWR2YW5jZT0lZn1cIlxuICAgICAgICB+ZjooZnVuIF8gXyB3aWR0aCBfIF8gXyAtPiBjaGVja19mbG9hdF9pbiB+bG93OjEwLiB+aGlnaDo1MC4gd2lkdGgpXG4gICAgICApXG4gICAgO1xuICAgIG1ha2UnIFwiZm9udF9leHRlbnRzXCJcbiAgICAgIGZvbnRfZXh0ZW50c1xuICAgICAgKEZybXQud2l0aF9zY2FuX3Jlc3VsdFxuICAgICAgICBcImZvbnRfZXh0ZW50cyAtPiB7YXNjZW50PSVmOyBkZXNjZW50PSVmOyBiYXNlbGluZT0lZjsgbWF4X3hfYWR2YW5jZT0lZjsgbWF4X3lfYWR2YW5jZT0lZn1cIlxuICAgICAgICB+ZjooZnVuIGFzY2VudCBkZXNjZW50IF8gXyBfIC0+XG4gICAgICAgICAgY2hlY2tfZmxvYXRfaW4gfmxvdzo1LiB+aGlnaDoxNS4gYXNjZW50O1xuICAgICAgICAgIGNoZWNrX2Zsb2F0X2luIH5sb3c6MS4gfmhpZ2g6Ny4gZGVzY2VudFxuICAgICAgICApXG4gICAgICApXG4gICAgO1xuICBdKVxuZW5kXG4iLCIoKiBDb3B5cmlnaHQgMjAxNy0yMDE4IFZpbmNlbnQgSmFjcXVlcyA8dmluY2VudEB2aW5jZW50LWphY3F1ZXMubmV0PiAqKVxuXG5vcGVuIEdlbmVyYWwuQWJiclxuXG5tb2R1bGUgTWFrZShDOiBDYWlyb01vY2suUykgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0ge25hbWU6IHN0cmluZzsgd2lkdGg6IGludDsgaGVpZ2h0OiBpbnQ7IGRyYXc6IEMuY29udGV4dCAtPiB1bml0fVxuXG4gIGxldCBtYWtlX3NpbXBsZSBuYW1lIHdpZHRoIGhlaWdodCBkcmF3ID1cbiAgICB7bmFtZTsgd2lkdGg7IGhlaWdodDsgZHJhd31cblxuICBsZXQgbWFrZV9saXN0IG5hbWUgd2lkdGggaGVpZ2h0IHZhbHVlcyBkcmF3ID1cbiAgICBtYWtlX3NpbXBsZSBuYW1lIHdpZHRoIChoZWlnaHQgKiBMaS5zaXplIHZhbHVlcykgKGZ1biBjdHggLT5cbiAgICAgIHZhbHVlc1xuICAgICAgfD4gTGkuaXRlciB+ZjooZnVuIHZhbHVlIC0+XG4gICAgICAgIEMuc2F2ZSBjdHg7XG4gICAgICAgIEMucmVjdGFuZ2xlIGN0eCAwLiAwLiB+dzooRmwub2ZfaW50IHdpZHRoKSB+aDooRmwub2ZfaW50IGhlaWdodCk7XG4gICAgICAgIEMuY2xpcCBjdHg7XG5cbiAgICAgICAgZHJhdyB2YWx1ZSBjdHg7XG5cbiAgICAgICAgQy5yZXN0b3JlIGN0eDtcblxuICAgICAgICBDLnRyYW5zbGF0ZSBjdHggMC4gKEZsLm9mX2ludCBoZWlnaHQpO1xuICAgICAgKVxuICAgIClcblxuICBsZXQgdGVzdHMgPSAoW1xuICAgIG1ha2VfbGlzdCBcInNldF9saW5lX3dpZHRoXCIgNTAgMjAgWzUuOyAxMC5dIChmdW4gbGluZV93aWR0aCBjdHggLT5cbiAgICAgIEMuc2V0X2xpbmVfd2lkdGggY3R4IGxpbmVfd2lkdGg7XG4gICAgICBDLm1vdmVfdG8gY3R4IDEwLiAxMC47XG4gICAgICBDLmxpbmVfdG8gY3R4IDQwLiAxMC47XG4gICAgICBDLnN0cm9rZSBjdHg7XG4gICAgKTtcbiAgICBtYWtlX2xpc3QgXCJzZXRfbWl0ZXJfbGltaXRcIiAxMjAgNTAgWzguOyA5LjsgMTAuXSAoZnVuIG1pdGVyX2xpbWl0IGN0eCAtPlxuICAgICAgQy5zZXRfbWl0ZXJfbGltaXQgY3R4IG1pdGVyX2xpbWl0O1xuICAgICAgQy5zZXRfbGluZV9qb2luIGN0eCBDLkpPSU5fTUlURVI7XG4gICAgICBDLnNldF9saW5lX3dpZHRoIGN0eCA1LjtcbiAgICAgIEMubW92ZV90byBjdHggMTAuIDEwLjtcbiAgICAgIEMubGluZV90byBjdHggNTAuIDEwLjtcbiAgICAgIEMubGluZV90byBjdHggMTAuIDIwLjtcbiAgICAgIEMubW92ZV90byBjdHggMTAuIDMwLjtcbiAgICAgIEMubGluZV90byBjdHggNTAuIDMwLjtcbiAgICAgIEMubGluZV90byBjdHggMTAuIDM5LjtcbiAgICAgIEMuc3Ryb2tlIGN0eDtcbiAgICApO1xuICAgIG1ha2VfbGlzdCBcInNldF9maWxsX3J1bGVcIiA2MCA2MCBDLltFVkVOX09ERDsgV0lORElOR10gKGZ1biBmaWxsX3J1bGUgY3R4IC0+XG4gICAgICBDLnNldF9maWxsX3J1bGUgY3R4IGZpbGxfcnVsZTtcbiAgICAgIEMubW92ZV90byBjdHggMTAuIDEwLjtcbiAgICAgIEMubGluZV90byBjdHggNDAuIDEwLjtcbiAgICAgIEMubGluZV90byBjdHggNDAuIDUwLjtcbiAgICAgIEMubGluZV90byBjdHggMzAuIDUwLjtcbiAgICAgIEMubGluZV90byBjdHggMzAuIDIwLjtcbiAgICAgIEMubGluZV90byBjdHggMjAuIDIwLjtcbiAgICAgIEMubGluZV90byBjdHggMjAuIDMwLjtcbiAgICAgIEMubGluZV90byBjdHggNTAuIDMwLjtcbiAgICAgIEMubGluZV90byBjdHggNTAuIDQwLjtcbiAgICAgIEMubGluZV90byBjdHggMTAuIDQwLjtcbiAgICAgIEMuZmlsbCBjdHg7XG4gICAgKTtcbiAgICBtYWtlX2xpc3QgXCJzZXRfbGluZV9jYXBcIiA1MCAyMCBDLltST1VORDsgU1FVQVJFOyBCVVRUXSAoZnVuIGxpbmVfY2FwIGN0eCAtPlxuICAgICAgQy5zZXRfbGluZV9jYXAgY3R4IGxpbmVfY2FwO1xuICAgICAgQy5zZXRfbGluZV93aWR0aCBjdHggMTAuO1xuICAgICAgQy5tb3ZlX3RvIGN0eCAxMC4gMTAuO1xuICAgICAgQy5saW5lX3RvIGN0eCA0MC4gMTAuO1xuICAgICAgQy5zdHJva2UgY3R4O1xuICAgICk7XG4gICAgbWFrZV9saXN0IFwic2V0X2xpbmVfam9pblwiIDUwIDUwIEMuW0pPSU5fUk9VTkQ7IEpPSU5fQkVWRUw7IEpPSU5fTUlURVJdIChmdW4gbGluZV9qb2luIGN0eCAtPlxuICAgICAgQy5zZXRfbGluZV9qb2luIGN0eCBsaW5lX2pvaW47XG4gICAgICBDLnNldF9saW5lX3dpZHRoIGN0eCAxMC47XG4gICAgICBDLm1vdmVfdG8gY3R4IDEwLiAxMC47XG4gICAgICBDLmxpbmVfdG8gY3R4IDQwLiAxMC47XG4gICAgICBDLmxpbmVfdG8gY3R4IDQwLiA0MC47XG4gICAgICBDLnN0cm9rZSBjdHg7XG4gICAgKTtcbiAgICBtYWtlX2xpc3QgXCJzZXRfb3BlcmF0b3JcIiA5MCA5MCBDLltPVkVSOyBJTjsgT1VUOyBBVE9QOyBERVNUX09WRVI7IERFU1RfSU47IERFU1RfT1VUOyBERVNUX0FUT1A7IFhPUjsgQUREXSAoZnVuIG9wZXJhdG9yIGN0eCAtPlxuICAgICAgQy5zZXRfc291cmNlX3JnYmEgY3R4IDAuIDAuIDAuOCAwLjg7XG4gICAgICBDLnJlY3RhbmdsZSBjdHggMTAuIDEwLiB+dzo1MC4gfmg6NTAuO1xuICAgICAgQy5maWxsIGN0eDtcblxuICAgICAgQy5zZXRfb3BlcmF0b3IgY3R4IG9wZXJhdG9yO1xuICAgICAgQy5zZXRfc291cmNlX3JnYmEgY3R4IDAuOCAwLiAwLiAwLjg7XG4gICAgICBDLmFyYyBjdHggNTAuIDUwLiB+cjozMC4gfmExOjAuIH5hMjooRmwucGkgKi4gMi4pO1xuICAgICAgQy5maWxsIGN0eDtcbiAgICApO1xuICAgIG1ha2VfbGlzdCBcInNldF9kYXNoXCIgMTAwIDIwIFsoMC4sIFt8NS47IDcuOyA5LjsgMTEufF0pOyAoMC4sIFt8MTAuOyAyLnxdKTsgKDMuLCBbfDEwLjsgMi58XSldIChmdW4gKG9mcywgZGFzaGVzKSBjdHggLT5cbiAgICAgIEMuc2V0X2Rhc2ggY3R4IH5vZnMgZGFzaGVzO1xuICAgICAgQy5zZXRfbGluZV93aWR0aCBjdHggMTAuO1xuICAgICAgQy5tb3ZlX3RvIGN0eCAxMC4gMTAuO1xuICAgICAgQy5saW5lX3RvIGN0eCA5MC4gMTAuO1xuICAgICAgQy5zdHJva2UgY3R4O1xuICAgICk7XG4gICAgbWFrZV9zaW1wbGUgXCJzY2FsZSByb3RhdGUgdHJhbnNsYXRlIHNhdmUgcmVzdG9yZVwiIDQwMCAyMDAgKGZ1biBjdHggLT5cbiAgICAgIGxldCByZWMgYXV4ID0gZnVuY3Rpb25cbiAgICAgICAgfCAwIC0+XG4gICAgICAgICAgQy5saW5lX3RvIGN0eCAxLiAwLjtcbiAgICAgICAgICBDLnRyYW5zbGF0ZSBjdHggMS4gMC47XG4gICAgICAgIHwgbiAtPlxuICAgICAgICAgIEMuc2F2ZSBjdHg7XG4gICAgICAgICAgQy5zY2FsZSBjdHggKDEuIC8uIDMuKSAoMS4gLy4gMy4pO1xuICAgICAgICAgIGF1eCAobiAtIDEpO1xuICAgICAgICAgIEMucm90YXRlIGN0eCAoLS5GbC5waSAvLiAzLik7XG4gICAgICAgICAgYXV4IChuIC0gMSk7XG4gICAgICAgICAgQy5yb3RhdGUgY3R4ICgyLiAqLiBGbC5waSAvLiAzLik7XG4gICAgICAgICAgYXV4IChuIC0gMSk7XG4gICAgICAgICAgQy5yb3RhdGUgY3R4ICgtLkZsLnBpIC8uIDMuKTtcbiAgICAgICAgICBhdXggKG4gLSAxKTtcbiAgICAgICAgICBDLnJlc3RvcmUgY3R4O1xuICAgICAgICAgIEMudHJhbnNsYXRlIGN0eCAxLiAwLjtcbiAgICAgIGluXG4gICAgICBDLnRyYW5zbGF0ZSBjdHggMC4gMTUwLjtcbiAgICAgIEMuc2NhbGUgY3R4IDQwMC4gNDAwLjtcbiAgICAgIEMubW92ZV90byBjdHggMC4gMC47XG4gICAgICBhdXggMztcbiAgICAgIEMuaWRlbnRpdHlfbWF0cml4IGN0eDtcbiAgICAgIEMuc3Ryb2tlIGN0eDtcbiAgICApO1xuICAgIG1ha2Vfc2ltcGxlIFwic2NhbGUgaWRlbnRpdHlfbWF0cml4XCIgMTAwIDEwMCAoZnVuIGN0eCAtPlxuICAgICAgQy5tb3ZlX3RvIGN0eCAxMC4gMTAuO1xuICAgICAgQy5saW5lX3RvIGN0eCA1MC4gMzAuO1xuICAgICAgQy5zY2FsZSBjdHggMy4gMC41O1xuICAgICAgQy5saW5lX3RvIGN0eCAzMC4gMTgwLjtcbiAgICAgIEMuaWRlbnRpdHlfbWF0cml4IGN0eDtcbiAgICAgIEMuc3Ryb2tlIGN0eDtcbiAgICApO1xuICAgIG1ha2VfbGlzdCBcImRyYXdpbmcgZnVuY3Rpb25zXCIgMTAwIDEwMCBDLltcbiAgICAgIChmaWxsX3ByZXNlcnZlLCBzdHJva2UpO1xuICAgICAgKHN0cm9rZV9wcmVzZXJ2ZSwgZmlsbCk7XG4gICAgICAoY2xpcF9wcmVzZXJ2ZSwgZmlsbCk7XG4gICAgICAoY2xpcF9wcmVzZXJ2ZSwgc3Ryb2tlKTtcbiAgICBdIChmdW4gKGYxLCBmMikgY3R4IC0+XG4gICAgICBDLm1vdmVfdG8gY3R4IDEwLiAxMC47XG4gICAgICBDLmxpbmVfdG8gY3R4IDUwLiAyMC47XG4gICAgICBDLmFyYyBjdHggNTAuIDEwLiB+cjo0MC4gfmExOjAuIH5hMjoxLjtcbiAgICAgIEMucmVsX2xpbmVfdG8gY3R4IDEwLiAzMC47XG4gICAgICBDLmFyY19uZWdhdGl2ZSBjdHggMzAuIDkwLiB+cjo0MC4gfmExOjAuIH5hMjooLTEuKTtcbiAgICAgIEMubGluZV90byBjdHggNTAuIDkwLjtcbiAgICAgIEMuY3VydmVfdG8gY3R4IDMwLiA5MC4gMTAuIDgwLiAyMC4gMzAuO1xuICAgICAgQy5QYXRoLmNsb3NlIGN0eDtcbiAgICAgIEMucmVjdGFuZ2xlIGN0eCA0MC4gNTAuIH53OjMwLiB+aDoyMC47XG4gICAgICBDLnJlbF9tb3ZlX3RvIGN0eCAxMC4gKC0xMC4pO1xuICAgICAgQy5yZWxfY3VydmVfdG8gY3R4ICgtMTAuKSAwLiAyMC4gMC4gMjAuICgtMjAuKTtcbiAgICAgIEMuc2V0X2xpbmVfd2lkdGggY3R4IDQuO1xuICAgICAgQy5zZXRfc291cmNlX3JnYiBjdHggMC4yIDEuIDAuMjtcbiAgICAgIGYxIGN0eDtcbiAgICAgIEMuc2V0X3NvdXJjZV9yZ2IgY3R4IDAuMiAwLjIgMS47XG4gICAgICBmMiBjdHg7XG4gICAgKTtcbiAgICBtYWtlX3NpbXBsZSBcImNsaXAgcGFpbnRcIiA1MCA1MCAoZnVuIGN0eCAtPlxuICAgICAgQy5hcmMgY3R4IDI1LiAyNS4gfnI6MjAuIH5hMToxLiB+YTI6KC0xLik7XG4gICAgICBDLmNsaXAgY3R4O1xuICAgICAgQy5wYWludCBjdHg7XG4gICAgKTtcbiAgICBtYWtlX2xpc3RcbiAgICAgIFwic2V0X3NvdXJjZV9yZ2JcIlxuICAgICAgNTAgNTBcbiAgICAgIFtcbiAgICAgICAgKDAuLCAwLiwgMC4pOyAoMC41LCAwLjUsIDAuNSk7ICgxLiwgMS4sIDEuKTtcbiAgICAgICAgKDAuNSwgMC4sIDAuKTsgKDAuLCAwLjUsIDAuKTsgKDAuLCAwLiwgMC41KTtcbiAgICAgICAgKDEuLCAwLiwgMC4pOyAoMC4sIDEuLCAwLik7ICgwLiwgMC4sIDEuKTtcbiAgICAgICAgKDAuNSwgMC41LCAwLik7ICgwLiwgMC41LCAwLjUpOyAoMC41LCAwLiwgMC41KTtcbiAgICAgICAgKDEuLCAxLiwgMC4pOyAoMC4sIDEuLCAxLik7ICgxLiwgMC4sIDEuKTtcbiAgICAgIF1cbiAgICAgIChmdW4gKHIsIGcsIGIpIGN0eCAtPlxuICAgICAgICBDLnNldF9zb3VyY2VfcmdiIGN0eCByIGcgYjtcbiAgICAgICAgQy5yZWN0YW5nbGUgY3R4IDUuIDUuIH53OjQwLiB+aDo0MC47XG4gICAgICAgIEMuZmlsbCBjdHg7XG4gICAgICApXG4gICAgO1xuICAgIG1ha2VfbGlzdFxuICAgICAgXCJzZXRfc291cmNlX3JnYmFcIlxuICAgICAgNTAgNTBcbiAgICAgIFtcbiAgICAgICAgKDAuLCAwLiwgMC4sIDAuNyk7ICgwLjUsIDAuNSwgMC41LCAwLjcpOyAoMS4sIDEuLCAxLiwgMC43KTtcbiAgICAgICAgKDAuNSwgMC4sIDAuLCAwLjcpOyAoMC4sIDAuNSwgMC4sIDAuNyk7ICgwLiwgMC4sIDAuNSwgMC43KTtcbiAgICAgICAgKDEuLCAwLiwgMC4sIDAuNyk7ICgwLiwgMS4sIDAuLCAwLjcpOyAoMC4sIDAuLCAxLiwgMC43KTtcbiAgICAgICAgKDAuNSwgMC41LCAwLiwgMC43KTsgKDAuLCAwLjUsIDAuNSwgMC43KTsgKDAuNSwgMC4sIDAuNSwgMC43KTtcbiAgICAgICAgKDEuLCAxLiwgMC4sIDAuNyk7ICgwLiwgMS4sIDEuLCAwLjcpOyAoMS4sIDAuLCAxLiwgMC43KTtcbiAgICAgICAgKDAuLCAwLiwgMC4sIDAuMyk7ICgwLjUsIDAuNSwgMC41LCAwLjMpOyAoMS4sIDEuLCAxLiwgMC4zKTtcbiAgICAgICAgKDAuNSwgMC4sIDAuLCAwLjMpOyAoMC4sIDAuNSwgMC4sIDAuMyk7ICgwLiwgMC4sIDAuNSwgMC4zKTtcbiAgICAgICAgKDEuLCAwLiwgMC4sIDAuMyk7ICgwLiwgMS4sIDAuLCAwLjMpOyAoMC4sIDAuLCAxLiwgMC4zKTtcbiAgICAgICAgKDAuNSwgMC41LCAwLiwgMC4zKTsgKDAuLCAwLjUsIDAuNSwgMC4zKTsgKDAuNSwgMC4sIDAuNSwgMC4zKTtcbiAgICAgICAgKDEuLCAxLiwgMC4sIDAuMyk7ICgwLiwgMS4sIDEuLCAwLjMpOyAoMS4sIDAuLCAxLiwgMC4zKTtcbiAgICAgIF1cbiAgICAgIChmdW4gKHIsIGcsIGIsIGEpIGN0eCAtPlxuICAgICAgICBDLnNldF9zb3VyY2VfcmdiIGN0eCAwLjYgMC42IDAuOTtcbiAgICAgICAgQy5wYWludCBjdHg7XG4gICAgICAgIEMuc2V0X3NvdXJjZV9yZ2JhIGN0eCByIGcgYiBhO1xuICAgICAgICBDLnJlY3RhbmdsZSBjdHggNS4gNS4gfnc6NDAuIH5oOjQwLjtcbiAgICAgICAgQy5maWxsIGN0eDtcbiAgICAgIClcbiAgICA7XG4gICAgbWFrZV9zaW1wbGUgXCJzZXRfc291cmNlIGxpbmVhciBncmFkaWVudFwiIDEwMCA0MCAoZnVuIGN0eCAtPlxuICAgICAgQy5zZXRfc291cmNlX3JnYiBjdHggMS4gMC4gMC47XG4gICAgICBDLnBhaW50IGN0eDtcbiAgICAgIGxldCBwID0gQy5QYXR0ZXJuLmNyZWF0ZV9saW5lYXIgfngwOjEwLiB+eTA6MjAuIH54MTo5MC4gfnkxOjMwLiBpblxuICAgICAgQy5QYXR0ZXJuLmFkZF9jb2xvcl9zdG9wX3JnYiBwIH5vZnM6MC4gMS4gMC4gMC47XG4gICAgICBDLlBhdHRlcm4uYWRkX2NvbG9yX3N0b3BfcmdiYSBwIH5vZnM6MS4gMC4gMC4gMS4gMC4yO1xuICAgICAgQy5QYXR0ZXJuLmFkZF9jb2xvcl9zdG9wX3JnYiBwIH5vZnM6MC40IDAuIDEuIDAuO1xuICAgICAgQy5zZXRfc291cmNlIGN0eCBwO1xuICAgICAgQy5yZWN0YW5nbGUgY3R4IDUuIDUuIH53OjkwLiB+aDozMC47XG4gICAgICBDLmZpbGwgY3R4O1xuICAgICk7XG4gICAgbWFrZV9zaW1wbGUgXCJzZXRfc291cmNlIHJhZGlhbCBncmFkaWVudFwiIDIwMCAyMDAgKGZ1biBjdHggLT5cbiAgICAgIGxldCAoeDAsIHkwLCByMCwgeDEsIHkxLCByMSkgPSAoNTAuLCA0MC4sIDMwLiwgMTEwLiwgMTQwLiwgNTAuKSBpblxuICAgICAgbGV0IHAgPSBDLlBhdHRlcm4uY3JlYXRlX3JhZGlhbCB+eDAgfnkwIH5yMCB+eDEgfnkxIH5yMSBpblxuICAgICAgQy5QYXR0ZXJuLmFkZF9jb2xvcl9zdG9wX3JnYiBwIH5vZnM6MC4gMS4gMC4gMC47XG4gICAgICBDLlBhdHRlcm4uYWRkX2NvbG9yX3N0b3BfcmdiIHAgfm9mczoxLiAwLiAwLiAxLjtcbiAgICAgIEMuc2V0X3NvdXJjZSBjdHggcDtcbiAgICAgIEMucGFpbnQgY3R4O1xuICAgICAgQy5zZXRfc291cmNlX3JnYiBjdHggMC4gMC4gMC47XG4gICAgICBDLmFyYyBjdHggeDAgeTAgfnI6cjAgfmExOjAuIH5hMjo2LjI4O1xuICAgICAgQy5zdHJva2UgY3R4O1xuICAgICAgQy5hcmMgY3R4IHgxIHkxIH5yOnIxIH5hMTowLiB+YTI6Ni4yODtcbiAgICAgIEMuc3Ryb2tlIGN0eDtcbiAgICApO1xuICAgIG1ha2Vfc2ltcGxlIFwicGFpbnQgd2l0aCBhbHBoYSAxXCIgMTAwIDEwMCAoZnVuIGN0eCAtPlxuICAgICAgQy5hcmMgY3R4IDUwLiA1MC4gfnI6NDAuIH5hMTowLiB+YTI6Ni4yODtcbiAgICAgIEMuZmlsbCBjdHg7XG4gICAgICBDLnNldF9zb3VyY2VfcmdiIGN0eCAwLiAxLiAxLjtcbiAgICAgIEMucGFpbnQgY3R4IH5hbHBoYTowLjU7XG4gICAgKTtcbiAgICBtYWtlX3NpbXBsZSBcInBhaW50IHdpdGggYWxwaGEgMlwiIDEwMCAxMDAgKGZ1biBjdHggLT5cbiAgICAgIEMuYXJjIGN0eCA1MC4gNTAuIH5yOjQwLiB+YTE6MC4gfmEyOjYuMjg7XG4gICAgICBDLmZpbGwgY3R4O1xuICAgICAgQy5zZXRfc291cmNlX3JnYmEgY3R4IDAuIDEuIDEuIDAuNTtcbiAgICAgIEMucGFpbnQgY3R4IH5hbHBoYTowLjU7XG4gICAgKTtcbiAgICBtYWtlX3NpbXBsZSBcInBhaW50IHdpdGggYWxwaGEgM1wiIDEwMCAxMDAgKGZ1biBjdHggLT5cbiAgICAgIEMuYXJjIGN0eCA1MC4gNTAuIH5yOjQwLiB+YTE6MC4gfmEyOjYuMjg7XG4gICAgICBDLmZpbGwgY3R4O1xuICAgICAgbGV0IHAgPSBDLlBhdHRlcm4uY3JlYXRlX2xpbmVhciB+eDA6MC4gfnkwOjAuIH54MToxMDAuIH55MToxMDAuIGluXG4gICAgICBDLlBhdHRlcm4uYWRkX2NvbG9yX3N0b3BfcmdiIHAgfm9mczowLiAwLiAxLiAwLjtcbiAgICAgIEMuUGF0dGVybi5hZGRfY29sb3Jfc3RvcF9yZ2IgcCB+b2ZzOjEuIDAuIDAuIDEuO1xuICAgICAgQy5zZXRfc291cmNlIGN0eCBwO1xuICAgICAgQy5wYWludCBjdHggfmFscGhhOjAuNTtcbiAgICApO1xuICAgIG1ha2Vfc2ltcGxlIFwicGFpbnQgd2l0aCBhbHBoYSA0XCIgMTAwIDEwMCAoZnVuIGN0eCAtPlxuICAgICAgQy5hcmMgY3R4IDUwLiA1MC4gfnI6NDAuIH5hMTowLiB+YTI6Ni4yODtcbiAgICAgIEMuZmlsbCBjdHg7XG4gICAgICBsZXQgcCA9IEMuUGF0dGVybi5jcmVhdGVfbGluZWFyIH54MDowLiB+eTA6MC4gfngxOjEwMC4gfnkxOjEwMC4gaW5cbiAgICAgIEMuUGF0dGVybi5hZGRfY29sb3Jfc3RvcF9yZ2JhIHAgfm9mczowLiAwLiAxLiAwLiAwLjU7XG4gICAgICBDLlBhdHRlcm4uYWRkX2NvbG9yX3N0b3BfcmdiYSBwIH5vZnM6MS4gMC4gMC4gMS4gMC41O1xuICAgICAgQy5zZXRfc291cmNlIGN0eCBwO1xuICAgICAgQy5wYWludCBjdHggfmFscGhhOjAuNTtcbiAgICApO1xuICBdKVxuZW5kXG4iLCIoKiBDb3B5cmlnaHQgMjAxNy0yMDE4IFZpbmNlbnQgSmFjcXVlcyA8dmluY2VudEB2aW5jZW50LWphY3F1ZXMubmV0PiAqKVxuXG5vcGVuIEdlbmVyYWwuQWJiclxuXG5tb2R1bGUgTWFrZShDOiBDYWlyb01vY2suUykgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0ge25hbWU6IHN0cmluZzsgd2lkdGg6IGludDsgaGVpZ2h0OiBpbnQ7IGRyYXdzOiAoQy5jb250ZXh0IC0+IHN0cmluZyBsaXN0KSBsaXN0fVxuXG4gIG1vZHVsZSBEZWNvcmF0ZWRDID0gQ2Fpcm9Nb2NrLkRlY29yYXRlKEMpXG5cbiAgbGV0IG1ha2UgbmFtZSB3aWR0aCBoZWlnaHQgZHJhd3MgPVxuICAgIGxldCBkcmF3cyA9XG4gICAgICBkcmF3c1xuICAgICAgfD4gTGkubWFwIH5mOihmdW4gZHJhdyAtPlxuICAgICAgICBmdW4gY3R4IC0+XG4gICAgICAgICAgbGV0IGN0eCA9IERlY29yYXRlZEMuY3JlYXRlIGN0eCBpblxuICAgICAgICAgIGRyYXcgY3R4O1xuICAgICAgICAgIERlY29yYXRlZEMuY2FsbHMgY3R4XG4gICAgICApXG4gICAgaW5cbiAgICB7bmFtZTsgd2lkdGg7IGhlaWdodDsgZHJhd3N9XG5cbiAgbGV0IGxpbWl0YXRpb25zID0gRGVjb3JhdGVkQy4oW1xuICAgIG1ha2UgXCJhcmNfbW9yZV90aGFuXzJwaVwiIDEwMCAxMDAgW2Z1biBjdHggLT5cbiAgICAgIGFyYyBjdHggNTAuIDUwLiB+cjo0MC4gfmExOjAuIH5hMjo3LjtcbiAgICAgIGlnbm9yZSAoUGF0aC5nZXRfY3VycmVudF9wb2ludCBjdHgpO1xuICAgICAgbGluZV90byBjdHggNTAuIDUwLjtcbiAgICAgIHN0cm9rZSBjdHhcbiAgICBdO1xuICAgIG1ha2UgXCJmb250X2V4dGVudHNcIiAxMDAgMTAgW2Z1biBjdHggLT5cbiAgICAgIGlnbm9yZSAoZm9udF9leHRlbnRzIGN0eClcbiAgICBdO1xuICAgIG1ha2UgXCJ0ZXh0X2V4dGVudHNcIiAxMDAgMTAgW2Z1biBjdHggLT5cbiAgICAgIGlnbm9yZSAodGV4dF9leHRlbnRzIGN0eCBcIkhlbGxvXCIpXG4gICAgXTtcbiAgICBtYWtlIFwic2hvd190ZXh0XCIgMTAwIDI0MCBbZnVuIGN0eCAtPlxuICAgICAgc2V0X2ZvbnRfc2l6ZSBjdHggMjAuO1xuICAgICAgW1xuICAgICAgICAoVXByaWdodCwgTm9ybWFsLCBcInNhbnMtc2VyaWZcIik7XG4gICAgICAgIChJdGFsaWMsIE5vcm1hbCwgXCJzYW5zLXNlcmlmXCIpO1xuICAgICAgICAoT2JsaXF1ZSwgTm9ybWFsLCBcInNhbnMtc2VyaWZcIik7XG4gICAgICAgIChVcHJpZ2h0LCBCb2xkLCBcInNhbnMtc2VyaWZcIik7XG4gICAgICAgIChJdGFsaWMsIEJvbGQsIFwic2Fucy1zZXJpZlwiKTtcbiAgICAgICAgKE9ibGlxdWUsIEJvbGQsIFwic2Fucy1zZXJpZlwiKTtcbiAgICAgICAgKFVwcmlnaHQsIE5vcm1hbCwgXCJzZXJpZlwiKTtcbiAgICAgICAgKFVwcmlnaHQsIE5vcm1hbCwgXCJtb25vc3BhY2VcIik7XG4gICAgICBdXG4gICAgICB8PiBMaS5pdGVyIH5mOihmdW4gKHNsYW50LCB3ZWlnaHQsIGZhbWlseSkgLT5cbiAgICAgICAgbW92ZV90byBjdHggMTAuIDIwLjtcbiAgICAgICAgc2VsZWN0X2ZvbnRfZmFjZSBjdHggfnNsYW50IH53ZWlnaHQgZmFtaWx5O1xuICAgICAgICBzaG93X3RleHQgY3R4IFwiSGVcIjtcbiAgICAgICAgc2hvd190ZXh0IGN0eCBcImxsb1wiO1xuICAgICAgICB0cmFuc2xhdGUgY3R4IDAuIDMwLjtcbiAgICAgIClcbiAgICBdO1xuICAgIG1ha2UgXCJyZXVzZV9jYW52YXNfdHJhbnNmb3JtYXRpb25cIiAxMDAgNjAgW1xuICAgICAgKGZ1biBjdHggLT4gc2NhbGUgY3R4IDIuIDMuKTtcbiAgICAgIChmdW4gY3R4IC0+XG4gICAgICAgIG1vdmVfdG8gY3R4IDEwLiAxMC47XG4gICAgICAgIGxpbmVfdG8gY3R4IDQwLiAxMC47XG4gICAgICAgIHN0cm9rZSBjdHgpO1xuICAgIF07XG4gICAgbWFrZSBcInJldXNlX2NhbnZhc19saW5lX2NhcFwiIDEwMCA2MCBbXG4gICAgICAoZnVuIGN0eCAtPiBzZXRfbGluZV9jYXAgY3R4IFJPVU5EKTtcbiAgICAgIChmdW4gY3R4IC0+XG4gICAgICAgIHNldF9saW5lX3dpZHRoIGN0eCAyMC47XG4gICAgICAgIG1vdmVfdG8gY3R4IDMwLiAzMC47XG4gICAgICAgIGxpbmVfdG8gY3R4IDcwLiAzMC47XG4gICAgICAgIHN0cm9rZSBjdHgpO1xuICAgIF07XG4gIF0pXG5lbmRcbiIsIigqIENvcHlyaWdodCAyMDE3LTIwMTggVmluY2VudCBKYWNxdWVzIDx2aW5jZW50QHZpbmNlbnQtamFjcXVlcy5uZXQ+ICopXG5cbm9wZW4gR2VuZXJhbC5BYmJyXG5vcGVuIFRzdFxuXG5sZXQgZHJhd2luZ190ZXN0cyA9XG4gIGxldCBtb2R1bGUgVCA9IERyYXdpbmcuTWFrZShDYWlyb01vY2spIGluXG4gIExpLm1hcCB+ZjooZnVuIHtULm5hbWU7IF99IC0+IG5hbWUpIFQudGVzdHNcblxubW9kdWxlIE1ha2UoWDogc2lnXG4gIHZhbCB0aXRsZTogc3RyaW5nXG5cbiAgbW9kdWxlIEM6IENhaXJvTW9jay5TXG5cbiAgbW9kdWxlIE46IHNpZ1xuICAgIHZhbCBuYW1lOiBzdHJpbmdcbiAgICB2YWwgY3JlYXRlOiB1bml0IC0+IEMuY29udGV4dFxuICAgIHZhbCBiYWNrZW5kOiBbYENhaXJvIHwgYE5vZGUgfCBgQnJvd3NlciB8IGBDYWlyb01vY2sgXVxuICBlbmRcblxuICBtb2R1bGUgRHJhd2luZ1Rlc3QoVDogc2lnXG4gICAgdHlwZSB0ID0ge25hbWU6IHN0cmluZzsgd2lkdGg6IGludDsgaGVpZ2h0OiBpbnQ7IGRyYXc6IEMuY29udGV4dCAtPiB1bml0fVxuICBlbmQpOiBzaWdcbiAgICB2YWwgcnVuOiBULnQgLT4gdW5pdFxuICBlbmRcblxuICBtb2R1bGUgTGltaXRhdGlvbihMOiBzaWdcbiAgICB0eXBlIHQgPSB7bmFtZTogc3RyaW5nOyB3aWR0aDogaW50OyBoZWlnaHQ6IGludDsgZHJhd3M6IChDLmNvbnRleHQgLT4gc3RyaW5nIGxpc3QpIGxpc3R9XG4gIGVuZCk6IHNpZ1xuICAgIHZhbCBydW46IEwudCAtPiB1bml0XG4gIGVuZFxuZW5kKSA9IHN0cnVjdFxuICBvcGVuIFhcblxuICBtb2R1bGUgTGltaXRhdGlvbnMgPSBMaW1pdGF0aW9ucy5NYWtlKEMpXG4gIG1vZHVsZSBMaW1pdGF0aW9uID0gTGltaXRhdGlvbihMaW1pdGF0aW9ucylcblxuICBsZXQgKCkgPSBMaS5pdGVyIH5mOkxpbWl0YXRpb24ucnVuIExpbWl0YXRpb25zLmxpbWl0YXRpb25zXG5cbiAgbGV0IHRlc3QgPSB0aXRsZSA+OjogW1xuICAgIChcbiAgICAgIGxldCBtb2R1bGUgVCA9IERlY29yYXRpb24uTWFrZShDYWlyb01vY2suTW9jaykoc3RydWN0XG4gICAgICAgIGxldCBuYW1lID0gXCJDYWlyb01vY2suTW9ja1wiXG4gICAgICAgIGxldCBjcmVhdGUgPSBDYWlyb01vY2suTW9jay5jcmVhdGVcbiAgICAgICAgbGV0IGJhY2tlbmQgPSBgQ2Fpcm9Nb2NrXG4gICAgICBlbmQpIGluXG4gICAgICBULnRlc3RcbiAgICApO1xuICAgIChcbiAgICAgIGxldCBtb2R1bGUgVCA9IERlY29yYXRpb24uTWFrZShDKShOKSBpblxuICAgICAgVC50ZXN0XG4gICAgKTtcbiAgICAoXG4gICAgICBsZXQgbW9kdWxlIFQgPSBVbml2ZXJzYWwuTWFrZShDYWlyb01vY2suTW9jaykoc3RydWN0XG4gICAgICAgIGxldCBuYW1lID0gXCJDYWlyb01vY2suTW9ja1wiXG4gICAgICAgIGxldCBjcmVhdGUgPSBDYWlyb01vY2suTW9jay5jcmVhdGVcbiAgICAgICAgbGV0IGJhY2tlbmQgPSBgQ2Fpcm9Nb2NrXG4gICAgICBlbmQpIGluXG4gICAgICBULnRlc3RcbiAgICApO1xuICAgIChcbiAgICAgIGxldCBtb2R1bGUgVCA9IFVuaXZlcnNhbC5NYWtlKENhaXJvTW9jaykoc3RydWN0XG4gICAgICAgIGxldCBuYW1lID0gXCJDYWlyb01vY2tcIlxuICAgICAgICBsZXQgY3JlYXRlID0gQ2Fpcm9Nb2NrLmNyZWF0ZVxuICAgICAgICBsZXQgYmFja2VuZCA9IGBDYWlyb01vY2tcbiAgICAgIGVuZCkgaW5cbiAgICAgIFQudGVzdFxuICAgICk7XG4gICAgKFxuICAgICAgbGV0IG1vZHVsZSBUID0gVW5pdmVyc2FsLk1ha2UoQykoTikgaW5cbiAgICAgIFQudGVzdFxuICAgICk7XG4gICAgKFxuICAgICAgbGV0IG1vZHVsZSBEZWNvcmF0ZWRDID0gQ2Fpcm9Nb2NrLkRlY29yYXRlKEMpIGluXG4gICAgICBsZXQgbW9kdWxlIFQgPSBVbml2ZXJzYWwuTWFrZShEZWNvcmF0ZWRDKShzdHJ1Y3RcbiAgICAgICAgbGV0IG5hbWUgPSBGcm10LmFwcGx5IFwiQ2Fpcm9Nb2NrLkRlY29yYXRlKCVzKVwiIE4ubmFtZVxuICAgICAgICBsZXQgY3JlYXRlICgpID0gRGVjb3JhdGVkQy5jcmVhdGUgKE4uY3JlYXRlICgpKVxuICAgICAgICBsZXQgYmFja2VuZCA9IE4uYmFja2VuZFxuICAgICAgZW5kKSBpblxuICAgICAgVC50ZXN0XG4gICAgKTtcbiAgICB+OjogXCJEcmF3aW5nIHRlc3RzIG9uICVzXCIgTi5uYW1lIChcbiAgICAgIGxldCBtb2R1bGUgVCA9IERyYXdpbmcuTWFrZShDKSBpblxuICAgICAgbGV0IG1vZHVsZSBEVCA9IERyYXdpbmdUZXN0KFQpIGluXG4gICAgICBULnRlc3RzXG4gICAgICB8PiBMaS5tYXAgfmY6KGZ1biB0ZXN0IC0+XG4gICAgICAgIHRlc3QuVC5uYW1lID46IChsYXp5IChEVC5ydW4gdGVzdCkpXG4gICAgICApXG4gICAgKTtcbiAgXVxuZW5kXG4iXX0=